From 410934a762a048fbff8d35927a70ce55f97a9d63 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 22 May 2020 16:25:51 -0500
Subject: [PATCH] amstream: Simplify flush_receive_queue() a bit.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 68b8b84f505..4e82d76da0d 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -95,13 +95,10 @@ static void remove_queued_update(IAudioStreamSampleImpl *sample)
 
 static void flush_receive_queue(struct audio_stream *stream)
 {
-    while (!list_empty(&stream->receive_queue))
-    {
-        struct queued_receive *receive =
-            LIST_ENTRY(list_head(&stream->receive_queue), struct queued_receive, entry);
+    struct list *entry;
 
-        remove_queued_receive(receive);
-    }
+    while ((entry = list_head(&stream->receive_queue)))
+        remove_queued_receive(LIST_ENTRY(entry, struct queued_receive, entry));
 }
 
 static void process_update(IAudioStreamSampleImpl *sample, struct queued_receive *receive)
From f5aaca10affba65460206f6869fdf7fb10197468 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 25 May 2020 14:17:32 -0500
Subject: [PATCH] amstream: Don't duplicate IMediaStream method
 implementations.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c | 61 +++++++++-------------------------
 dlls/amstream/ddrawstream.c | 65 ++++++++++---------------------------
 2 files changed, 32 insertions(+), 94 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 4e82d76da0d..d620abc6ecf 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -605,76 +605,45 @@ static ULONG WINAPI audio_IAudioMediaStream_Release(IAudioMediaStream *iface)
     return IAMMediaStream_Release(&This->IAMMediaStream_iface);
 }
 
-/*** IMediaStream methods ***/
 static HRESULT WINAPI audio_IAudioMediaStream_GetMultiMediaStream(IAudioMediaStream *iface,
-        IMultiMediaStream **multi_media_stream)
+        IMultiMediaStream **mmstream)
 {
-    struct audio_stream *This = impl_from_IAudioMediaStream(iface);
-
-    TRACE("(%p/%p)->(%p)\n", iface, This, multi_media_stream);
-
-    if (!multi_media_stream)
-        return E_POINTER;
-
-    IMultiMediaStream_AddRef(This->parent);
-    *multi_media_stream = This->parent;
-
-    return S_OK;
+    struct audio_stream *stream = impl_from_IAudioMediaStream(iface);
+    return IAMMediaStream_GetMultiMediaStream(&stream->IAMMediaStream_iface, mmstream);
 }
 
 static HRESULT WINAPI audio_IAudioMediaStream_GetInformation(IAudioMediaStream *iface,
         MSPID *purpose_id, STREAM_TYPE *type)
 {
-    struct audio_stream *This = impl_from_IAudioMediaStream(iface);
-
-    TRACE("(%p/%p)->(%p,%p)\n", iface, This, purpose_id, type);
-
-    if (purpose_id)
-        *purpose_id = This->purpose_id;
-    if (type)
-        *type = This->stream_type;
-
-    return S_OK;
+    struct audio_stream *stream = impl_from_IAudioMediaStream(iface);
+    return IAMMediaStream_GetInformation(&stream->IAMMediaStream_iface, purpose_id, type);
 }
 
 static HRESULT WINAPI audio_IAudioMediaStream_SetSameFormat(IAudioMediaStream *iface,
-        IMediaStream *stream_format, DWORD flags)
+        IMediaStream *other, DWORD flags)
 {
-    struct audio_stream *This = impl_from_IAudioMediaStream(iface);
-
-    FIXME("(%p/%p)->(%p,%x) stub!\n", iface, This, stream_format, flags);
-
-    return S_FALSE;
+    struct audio_stream *stream = impl_from_IAudioMediaStream(iface);
+    return IAMMediaStream_SetSameFormat(&stream->IAMMediaStream_iface, other, flags);
 }
 
 static HRESULT WINAPI audio_IAudioMediaStream_AllocateSample(IAudioMediaStream *iface,
         DWORD flags, IStreamSample **sample)
 {
-    struct audio_stream *This = impl_from_IAudioMediaStream(iface);
-
-    FIXME("(%p/%p)->(%x,%p) stub!\n", iface, This, flags, sample);
-
-    return S_FALSE;
+    struct audio_stream *stream = impl_from_IAudioMediaStream(iface);
+    return IAMMediaStream_AllocateSample(&stream->IAMMediaStream_iface, flags, sample);
 }
 
 static HRESULT WINAPI audio_IAudioMediaStream_CreateSharedSample(IAudioMediaStream *iface,
         IStreamSample *existing_sample, DWORD flags, IStreamSample **sample)
 {
-    struct audio_stream *This = impl_from_IAudioMediaStream(iface);
-
-    FIXME("(%p/%p)->(%p,%x,%p) stub!\n", iface, This, existing_sample, flags, sample);
-
-    return S_FALSE;
+    struct audio_stream *stream = impl_from_IAudioMediaStream(iface);
+    return IAMMediaStream_CreateSharedSample(&stream->IAMMediaStream_iface, existing_sample, flags, sample);
 }
 
-static HRESULT WINAPI audio_IAudioMediaStream_SendEndOfStream(IAudioMediaStream *iface,
-        DWORD flags)
+static HRESULT WINAPI audio_IAudioMediaStream_SendEndOfStream(IAudioMediaStream *iface, DWORD flags)
 {
-    struct audio_stream *This = impl_from_IAudioMediaStream(iface);
-
-    FIXME("(%p/%p)->(%x) stub!\n", iface, This, flags);
-
-    return S_FALSE;
+    struct audio_stream *stream = impl_from_IAudioMediaStream(iface);
+    return IAMMediaStream_SendEndOfStream(&stream->IAMMediaStream_iface, flags);
 }
 
 /*** IAudioMediaStream methods ***/
diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 9c552f1a03f..6ef74eb7de0 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -292,76 +292,45 @@ static ULONG WINAPI ddraw_IDirectDrawMediaStream_Release(IDirectDrawMediaStream
     return IAMMediaStream_Release(&This->IAMMediaStream_iface);
 }
 
-/*** IMediaStream methods ***/
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetMultiMediaStream(IDirectDrawMediaStream *iface,
-        IMultiMediaStream **multi_media_stream)
+        IMultiMediaStream **mmstream)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
-
-    TRACE("(%p/%p)->(%p)\n", This, iface, multi_media_stream);
-
-    if (!multi_media_stream)
-        return E_POINTER;
-
-    IMultiMediaStream_AddRef(This->parent);
-    *multi_media_stream = This->parent;
-
-    return S_OK;
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    return IAMMediaStream_GetMultiMediaStream(&stream->IAMMediaStream_iface, mmstream);
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetInformation(IDirectDrawMediaStream *iface,
         MSPID *purpose_id, STREAM_TYPE *type)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
-
-    TRACE("(%p/%p)->(%p,%p)\n", This, iface, purpose_id, type);
-
-    if (purpose_id)
-        *purpose_id = This->purpose_id;
-    if (type)
-        *type = This->stream_type;
-
-    return S_OK;
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    return IAMMediaStream_GetInformation(&stream->IAMMediaStream_iface, purpose_id, type);
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SetSameFormat(IDirectDrawMediaStream *iface,
-        IMediaStream *pStreamThatHasDesiredFormat, DWORD dwFlags)
+        IMediaStream *other, DWORD flags)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
-
-    FIXME("(%p/%p)->(%p,%x) stub!\n", This, iface, pStreamThatHasDesiredFormat, dwFlags);
-
-    return S_FALSE;
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    return IAMMediaStream_SetSameFormat(&stream->IAMMediaStream_iface, other, flags);
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_AllocateSample(IDirectDrawMediaStream *iface,
-        DWORD dwFlags, IStreamSample **ppSample)
+        DWORD flags, IStreamSample **sample)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
-
-    FIXME("(%p/%p)->(%x,%p) stub!\n", This, iface, dwFlags, ppSample);
-
-    return S_FALSE;
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    return IAMMediaStream_AllocateSample(&stream->IAMMediaStream_iface, flags, sample);
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_CreateSharedSample(IDirectDrawMediaStream *iface,
-        IStreamSample *pExistingSample, DWORD dwFlags, IStreamSample **ppSample)
+        IStreamSample *existing_sample, DWORD flags, IStreamSample **sample)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
-
-    FIXME("(%p/%p)->(%p,%x,%p) stub!\n", This, iface, pExistingSample, dwFlags, ppSample);
-
-    return S_FALSE;
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    return IAMMediaStream_CreateSharedSample(&stream->IAMMediaStream_iface, existing_sample, flags, sample);
 }
 
-static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SendEndOfStream(IDirectDrawMediaStream *iface,
-        DWORD dwFlags)
+static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SendEndOfStream(IDirectDrawMediaStream *iface, DWORD flags)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
-
-    FIXME("(%p/%p)->(%x) stub!\n", This, iface, dwFlags);
-
-    return S_FALSE;
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    return IAMMediaStream_SendEndOfStream(&stream->IAMMediaStream_iface, flags);
 }
 
 /*** IDirectDrawMediaStream methods ***/
From 4300981d6b997c0b4c70c3415d4bbcd694d1a7f1 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Mon, 25 May 2020 14:17:33 -0500
Subject: [PATCH] amstream: Don't crash if parent is NULL in AMAudioStream::
 and AMDirectDrawStream::GetMultiMediaStream.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c | 14 +++++++-------
 dlls/amstream/ddrawstream.c | 14 +++++++-------
 2 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index d620abc6ecf..265c3bf9f20 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -429,18 +429,18 @@ static ULONG WINAPI audio_IAMMediaStream_Release(IAMMediaStream *iface)
 
 /*** IMediaStream methods ***/
 static HRESULT WINAPI audio_IAMMediaStream_GetMultiMediaStream(IAMMediaStream *iface,
-        IMultiMediaStream** multi_media_stream)
+        IMultiMediaStream **mmstream)
 {
-    struct audio_stream *This = impl_from_IAMMediaStream(iface);
+    struct audio_stream *stream = impl_from_IAMMediaStream(iface);
 
-    TRACE("(%p/%p)->(%p)\n", This, iface, multi_media_stream);
+    TRACE("stream %p, mmstream %p.\n", stream, mmstream);
 
-    if (!multi_media_stream)
+    if (!mmstream)
         return E_POINTER;
 
-    IMultiMediaStream_AddRef(This->parent);
-    *multi_media_stream = This->parent;
-
+    if (stream->parent)
+        IMultiMediaStream_AddRef(stream->parent);
+    *mmstream = stream->parent;
     return S_OK;
 }
 
diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 6ef74eb7de0..a4bfe948d2d 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -125,18 +125,18 @@ static ULONG WINAPI ddraw_IAMMediaStream_Release(IAMMediaStream *iface)
 
 /*** IMediaStream methods ***/
 static HRESULT WINAPI ddraw_IAMMediaStream_GetMultiMediaStream(IAMMediaStream *iface,
-        IMultiMediaStream** multi_media_stream)
+        IMultiMediaStream **mmstream)
 {
-    struct ddraw_stream *This = impl_from_IAMMediaStream(iface);
+    struct ddraw_stream *stream = impl_from_IAMMediaStream(iface);
 
-    TRACE("(%p/%p)->(%p)\n", This, iface, multi_media_stream);
+    TRACE("stream %p, mmstream %p.\n", stream, mmstream);
 
-    if (!multi_media_stream)
+    if (!mmstream)
         return E_POINTER;
 
-    IMultiMediaStream_AddRef(This->parent);
-    *multi_media_stream = This->parent;
-
+    if (stream->parent)
+        IMultiMediaStream_AddRef(stream->parent);
+    *mmstream = stream->parent;
     return S_OK;
 }
 
From dc93d5f856cd14eddc2db688248a700c256d17ee Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 27 May 2020 14:26:22 -0500
Subject: [PATCH] quartz/vmr9: Fake success from
 IVMRMixerConrol9::SetMixingPrefs().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr9.c | 33 +++++++++++++++++++++++++++++++++
 dlls/quartz/vmr9.c       | 14 +++++++++++---
 2 files changed, 44 insertions(+), 3 deletions(-)

diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index dfa9dae73e5..0a8ae371a6b 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -3876,6 +3876,38 @@ static void test_windowless_size(void)
     DestroyWindow(window);
 }
 
+static void test_mixing_prefs(void)
+{
+    IBaseFilter *filter = create_vmr9(VMR9Mode_Windowed);
+    IVMRMixerControl9 *mixer_control;
+    DWORD flags;
+    HRESULT hr;
+    ULONG ref;
+
+    set_mixing_mode(filter, 1);
+
+    hr = IBaseFilter_QueryInterface(filter, &IID_IVMRMixerControl9, (void **)&mixer_control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IVMRMixerControl9_GetMixingPrefs(mixer_control, &flags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(flags == (MixerPref9_NoDecimation | MixerPref9_ARAdjustXorY | MixerPref9_BiLinearFiltering
+            | MixerPref9_RenderTargetRGB), "Got flags %#x.\n", flags);
+
+    hr = IVMRMixerControl9_SetMixingPrefs(mixer_control, MixerPref9_NoDecimation
+            | MixerPref9_ARAdjustXorY | MixerPref9_PointFiltering | MixerPref9_RenderTargetRGB);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IVMRMixerControl9_GetMixingPrefs(mixer_control, &flags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(flags == (MixerPref9_NoDecimation | MixerPref9_ARAdjustXorY | MixerPref9_PointFiltering
+            | MixerPref9_RenderTargetRGB), "Got flags %#x.\n", flags);
+
+    IVMRMixerControl9_Release(mixer_control);
+    ref = IBaseFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(vmr9)
 {
     IBaseFilter *filter;
@@ -3910,6 +3942,7 @@ START_TEST(vmr9)
     test_surface_allocator_notify_refcount();
     test_basic_video();
     test_windowless_size();
+    test_mixing_prefs();
 
     CoUninitialize();
 }
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 81e265f104a..a716a6e7128 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -84,6 +84,7 @@ struct quartz_vmr
     BOOL allocator_is_ex;
 
     DWORD stream_count;
+    DWORD mixing_prefs;
 
     /*
      * The Video Mixing Renderer supports 3 modes, renderless, windowless and windowed
@@ -2227,7 +2228,10 @@ static HRESULT WINAPI mixer_control9_SetMixingPrefs(IVMRMixerControl9 *iface, DW
 
     FIXME("filter %p, flags %#x, stub!\n", filter, flags);
 
-    return E_NOTIMPL;
+    EnterCriticalSection(&filter->renderer.filter.csFilter);
+    filter->mixing_prefs = flags;
+    LeaveCriticalSection(&filter->renderer.filter.csFilter);
+    return S_OK;
 }
 
 static HRESULT WINAPI mixer_control9_GetMixingPrefs(IVMRMixerControl9 *iface, DWORD *flags)
@@ -2236,8 +2240,9 @@ static HRESULT WINAPI mixer_control9_GetMixingPrefs(IVMRMixerControl9 *iface, DW
 
     FIXME("filter %p, flags %p, stub!\n", filter, flags);
 
-    *flags = MixerPref9_NoDecimation | MixerPref9_ARAdjustXorY | MixerPref9_BiLinearFiltering | MixerPref9_RenderTargetRGB;
-
+    EnterCriticalSection(&filter->renderer.filter.csFilter);
+    *flags = filter->mixing_prefs;
+    LeaveCriticalSection(&filter->renderer.filter.csFilter);
     return S_OK;
 }
 
@@ -2500,6 +2505,9 @@ static HRESULT vmr_create(IUnknown *outer, IUnknown **out, const CLSID *clsid)
 
     object->run_event = CreateEventW(NULL, TRUE, FALSE, NULL);
 
+    object->mixing_prefs = MixerPref9_NoDecimation | MixerPref9_ARAdjustXorY
+            | MixerPref9_BiLinearFiltering | MixerPref9_RenderTargetRGB;
+
     TRACE("Created VMR %p.\n", object);
     *out = &object->renderer.filter.IUnknown_inner;
     return S_OK;
From f020fe051b02d7bda90a1fdb028a60e2ab7400f0 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 May 2020 11:47:33 -0500
Subject: [PATCH] quartz/vmr9: Use TRACE for some implemented methods.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 59 +++++++++++++++++++++++++---------------------
 1 file changed, 32 insertions(+), 27 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index a716a6e7128..7fca3550d1b 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -1699,17 +1699,18 @@ static HRESULT WINAPI VMR9WindowlessControl_SetVideoPosition(IVMRWindowlessContr
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9WindowlessControl_GetVideoPosition(IVMRWindowlessControl9 *iface, RECT *source, RECT *dest)
+static HRESULT WINAPI VMR9WindowlessControl_GetVideoPosition(IVMRWindowlessControl9 *iface, RECT *src, RECT *dst)
 {
-    struct quartz_vmr *This = impl_from_IVMRWindowlessControl9(iface);
+    struct quartz_vmr *filter = impl_from_IVMRWindowlessControl9(iface);
 
-    if (source)
-        *source = This->window.src;
+    TRACE("filter %p, src %p, dst %p.\n", filter, src, dst);
 
-    if (dest)
-        *dest = This->window.dst;
+    if (src)
+        *src = filter->window.src;
+
+    if (dst)
+        *dst = filter->window.dst;
 
-    FIXME("(%p/%p)->(%p/%p) stub\n", iface, This, source, dest);
     return S_OK;
 }
 
@@ -1955,42 +1956,46 @@ static ULONG WINAPI VMR9SurfaceAllocatorNotify_Release(IVMRSurfaceAllocatorNotif
     return refcount;
 }
 
-static HRESULT WINAPI VMR9SurfaceAllocatorNotify_AdviseSurfaceAllocator(IVMRSurfaceAllocatorNotify9 *iface, DWORD_PTR id, IVMRSurfaceAllocator9 *alloc)
+static HRESULT WINAPI VMR9SurfaceAllocatorNotify_AdviseSurfaceAllocator(
+        IVMRSurfaceAllocatorNotify9 *iface, DWORD_PTR cookie, IVMRSurfaceAllocator9 *allocator)
 {
-    struct quartz_vmr *This = impl_from_IVMRSurfaceAllocatorNotify9(iface);
+    struct quartz_vmr *filter = impl_from_IVMRSurfaceAllocatorNotify9(iface);
 
-    /* FIXME: This code is not tested!!! */
-    FIXME("(%p/%p)->(...) stub\n", iface, This);
-    This->cookie = id;
+    TRACE("filter %p, cookie %#Ix, allocator %p.\n", filter, cookie, allocator);
 
-    if (This->presenter)
+    filter->cookie = cookie;
+
+    if (filter->presenter)
         return VFW_E_WRONG_STATE;
 
-    if (FAILED(IVMRSurfaceAllocator9_QueryInterface(alloc, &IID_IVMRImagePresenter9, (void **)&This->presenter)))
+    if (FAILED(IVMRSurfaceAllocator9_QueryInterface(allocator, &IID_IVMRImagePresenter9, (void **)&filter->presenter)))
         return E_NOINTERFACE;
 
-    if (SUCCEEDED(IVMRSurfaceAllocator9_QueryInterface(alloc, &IID_IVMRSurfaceAllocatorEx9, (void **)&This->allocator)))
-        This->allocator_is_ex = 1;
+    if (SUCCEEDED(IVMRSurfaceAllocator9_QueryInterface(allocator,
+            &IID_IVMRSurfaceAllocatorEx9, (void **)&filter->allocator)))
+        filter->allocator_is_ex = 1;
     else
     {
-        This->allocator = (IVMRSurfaceAllocatorEx9 *)alloc;
-        IVMRSurfaceAllocator9_AddRef(alloc);
-        This->allocator_is_ex = 0;
+        filter->allocator = (IVMRSurfaceAllocatorEx9 *)allocator;
+        IVMRSurfaceAllocator9_AddRef(allocator);
+        filter->allocator_is_ex = 0;
     }
 
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9SurfaceAllocatorNotify_SetD3DDevice(IVMRSurfaceAllocatorNotify9 *iface, IDirect3DDevice9 *device, HMONITOR monitor)
+static HRESULT WINAPI VMR9SurfaceAllocatorNotify_SetD3DDevice(IVMRSurfaceAllocatorNotify9 *iface,
+        IDirect3DDevice9 *device, HMONITOR monitor)
 {
-    struct quartz_vmr *This = impl_from_IVMRSurfaceAllocatorNotify9(iface);
+    struct quartz_vmr *filter = impl_from_IVMRSurfaceAllocatorNotify9(iface);
 
-    FIXME("(%p/%p)->(...) semi-stub\n", iface, This);
-    if (This->allocator_d3d9_dev)
-        IDirect3DDevice9_Release(This->allocator_d3d9_dev);
-    This->allocator_d3d9_dev = device;
-    IDirect3DDevice9_AddRef(This->allocator_d3d9_dev);
-    This->allocator_mon = monitor;
+    TRACE("filter %p, device %p, monitor %p.\n", filter, device, monitor);
+
+    if (filter->allocator_d3d9_dev)
+        IDirect3DDevice9_Release(filter->allocator_d3d9_dev);
+    filter->allocator_d3d9_dev = device;
+    IDirect3DDevice9_AddRef(device);
+    filter->allocator_mon = monitor;
 
     return S_OK;
 }
From 39489e4d01ace78e90943c066e7e43105cf208a2 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 May 2020 11:47:34 -0500
Subject: [PATCH] quartz/vmr9: Don't query for IVMRSurfaceAllocatorEx9.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr9.c |  1 +
 dlls/quartz/vmr9.c       | 33 ++++++++++++---------------------
 2 files changed, 13 insertions(+), 21 deletions(-)

diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 0a8ae371a6b..2921d1aed02 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -2852,6 +2852,7 @@ static HRESULT WINAPI allocator_QueryInterface(IVMRSurfaceAllocator9 *iface, REF
         IVMRImagePresenter9_AddRef(&presenter_iface);
         return S_OK;
     }
+    ok(!IsEqualGUID(iid, &IID_IVMRSurfaceAllocatorEx9), "Unexpected query for IVMRSurfaceAllocatorEx9.\n");
     *out = NULL;
     return E_NOTIMPL;
 }
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 7fca3550d1b..e02b642dbc1 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -79,9 +79,8 @@ struct quartz_vmr
 
     IOverlay IOverlay_iface;
 
-    IVMRSurfaceAllocatorEx9 *allocator;
+    IVMRSurfaceAllocator9 *allocator;
     IVMRImagePresenter9 *presenter;
-    BOOL allocator_is_ex;
 
     DWORD stream_count;
     DWORD mixing_prefs;
@@ -345,7 +344,7 @@ static HRESULT initialize_device(struct quartz_vmr *filter, VMR9AllocationInfo *
     HRESULT hr;
     DWORD i;
 
-    if (FAILED(hr = IVMRSurfaceAllocatorEx9_InitializeDevice(filter->allocator,
+    if (FAILED(hr = IVMRSurfaceAllocator9_InitializeDevice(filter->allocator,
             filter->cookie, info, &count)))
     {
         WARN("Failed to initialize device (flags %#x), hr %#x.\n", info->dwFlags, hr);
@@ -354,13 +353,13 @@ static HRESULT initialize_device(struct quartz_vmr *filter, VMR9AllocationInfo *
 
     for (i = 0; i < count; ++i)
     {
-        if (FAILED(hr = IVMRSurfaceAllocatorEx9_GetSurface(filter->allocator,
+        if (FAILED(hr = IVMRSurfaceAllocator9_GetSurface(filter->allocator,
                 filter->cookie, i, 0, &filter->surfaces[i])))
         {
             ERR("Failed to get surface %u, hr %#x.\n", i, hr);
             while (i--)
                 IDirect3DSurface9_Release(filter->surfaces[i]);
-            IVMRSurfaceAllocatorEx9_TerminateDevice(filter->allocator, filter->cookie);
+            IVMRSurfaceAllocator9_TerminateDevice(filter->allocator, filter->cookie);
             return hr;
         }
     }
@@ -533,7 +532,7 @@ static HRESULT WINAPI VMR9_BreakConnect(struct strmbase_renderer *This)
         for (i = 0; i < pVMR9->num_surfaces; ++i)
             IDirect3DSurface9_Release(pVMR9->surfaces[i]);
         free(pVMR9->surfaces);
-        IVMRSurfaceAllocatorEx9_TerminateDevice(pVMR9->allocator, pVMR9->cookie);
+        IVMRSurfaceAllocator9_TerminateDevice(pVMR9->allocator, pVMR9->cookie);
         pVMR9->num_surfaces = 0;
     }
     return hr;
@@ -558,8 +557,8 @@ static void vmr_destroy(struct strmbase_renderer *iface)
 
     if (filter->allocator)
     {
-        IVMRSurfaceAllocatorEx9_TerminateDevice(filter->allocator, filter->cookie);
-        IVMRSurfaceAllocatorEx9_Release(filter->allocator);
+        IVMRSurfaceAllocator9_TerminateDevice(filter->allocator, filter->cookie);
+        IVMRSurfaceAllocator9_Release(filter->allocator);
     }
     if (filter->presenter)
         IVMRImagePresenter9_Release(filter->presenter);
@@ -1353,7 +1352,7 @@ static HRESULT WINAPI VMR9FilterConfig_SetRenderingMode(IVMRFilterConfig9 *iface
     }
 
     if (This->allocator)
-        IVMRSurfaceAllocatorEx9_Release(This->allocator);
+        IVMRSurfaceAllocator9_Release(This->allocator);
     if (This->presenter)
         IVMRImagePresenter9_Release(This->presenter);
 
@@ -1364,7 +1363,6 @@ static HRESULT WINAPI VMR9FilterConfig_SetRenderingMode(IVMRFilterConfig9 *iface
     {
     case VMR9Mode_Windowed:
     case VMR9Mode_Windowless:
-        This->allocator_is_ex = 0;
         This->cookie = ~0;
 
         hr = VMR9DefaultAllocatorPresenterImpl_create(This, (LPVOID*)&This->presenter);
@@ -1378,7 +1376,7 @@ static HRESULT WINAPI VMR9FilterConfig_SetRenderingMode(IVMRFilterConfig9 *iface
             This->presenter = NULL;
         }
         else
-            hr = IVMRSurfaceAllocatorEx9_AdviseNotify(This->allocator, &This->IVMRSurfaceAllocatorNotify9_iface);
+            hr = IVMRSurfaceAllocator9_AdviseNotify(This->allocator, &This->IVMRSurfaceAllocatorNotify9_iface);
         break;
     case VMR9Mode_Renderless:
         break;
@@ -1971,15 +1969,8 @@ static HRESULT WINAPI VMR9SurfaceAllocatorNotify_AdviseSurfaceAllocator(
     if (FAILED(IVMRSurfaceAllocator9_QueryInterface(allocator, &IID_IVMRImagePresenter9, (void **)&filter->presenter)))
         return E_NOINTERFACE;
 
-    if (SUCCEEDED(IVMRSurfaceAllocator9_QueryInterface(allocator,
-            &IID_IVMRSurfaceAllocatorEx9, (void **)&filter->allocator)))
-        filter->allocator_is_ex = 1;
-    else
-    {
-        filter->allocator = (IVMRSurfaceAllocatorEx9 *)allocator;
-        IVMRSurfaceAllocator9_AddRef(allocator);
-        filter->allocator_is_ex = 0;
-    }
+    filter->allocator = allocator;
+    IVMRSurfaceAllocator9_AddRef(allocator);
 
     return S_OK;
 }
@@ -2827,7 +2818,7 @@ static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9Allocation
 
     if (FAILED(hr))
     {
-        IVMRSurfaceAllocatorEx9_TerminateDevice(This->pVMR9->allocator, This->pVMR9->cookie);
+        IVMRSurfaceAllocator9_TerminateDevice(This->pVMR9->allocator, This->pVMR9->cookie);
         return FALSE;
     }
 
From aa44879a09b29997e68f416c0c6e77d0a0ea82bf Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 May 2020 11:47:35 -0500
Subject: [PATCH] quartz/vmr9: Don't expose IVMRSurfaceAllocatorEx9 from the
 default presenter.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 58 +++++++++++++++++++++++-----------------------
 1 file changed, 29 insertions(+), 29 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index e02b642dbc1..bc03326599f 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -174,7 +174,7 @@ static inline struct quartz_vmr *impl_from_IVMRWindowlessControl9(IVMRWindowless
 struct default_presenter
 {
     IVMRImagePresenter9 IVMRImagePresenter9_iface;
-    IVMRSurfaceAllocatorEx9 IVMRSurfaceAllocatorEx9_iface;
+    IVMRSurfaceAllocator9 IVMRSurfaceAllocator9_iface;
 
     LONG refCount;
 
@@ -195,9 +195,9 @@ static inline struct default_presenter *impl_from_IVMRImagePresenter9(IVMRImageP
     return CONTAINING_RECORD(iface, struct default_presenter, IVMRImagePresenter9_iface);
 }
 
-static inline struct default_presenter *impl_from_IVMRSurfaceAllocatorEx9(IVMRSurfaceAllocatorEx9 *iface)
+static inline struct default_presenter *impl_from_IVMRSurfaceAllocator9(IVMRSurfaceAllocator9 *iface)
 {
-    return CONTAINING_RECORD(iface, struct default_presenter, IVMRSurfaceAllocatorEx9_iface);
+    return CONTAINING_RECORD(iface, struct default_presenter, IVMRSurfaceAllocator9_iface);
 }
 
 static HRESULT VMR9DefaultAllocatorPresenterImpl_create(struct quartz_vmr *parent, LPVOID * ppv);
@@ -1367,7 +1367,8 @@ static HRESULT WINAPI VMR9FilterConfig_SetRenderingMode(IVMRFilterConfig9 *iface
 
         hr = VMR9DefaultAllocatorPresenterImpl_create(This, (LPVOID*)&This->presenter);
         if (SUCCEEDED(hr))
-            hr = IVMRImagePresenter9_QueryInterface(This->presenter, &IID_IVMRSurfaceAllocatorEx9, (LPVOID*)&This->allocator);
+            hr = IVMRImagePresenter9_QueryInterface(This->presenter,
+                    &IID_IVMRSurfaceAllocator9, (void **)&This->allocator);
         if (FAILED(hr))
         {
             ERR("Unable to find Presenter interface\n");
@@ -2530,8 +2531,8 @@ static HRESULT WINAPI VMR9_ImagePresenter_QueryInterface(IVMRImagePresenter9 *if
 
     if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IVMRImagePresenter9))
         *ppv = &This->IVMRImagePresenter9_iface;
-    else if (IsEqualIID(riid, &IID_IVMRSurfaceAllocatorEx9))
-        *ppv = &This->IVMRSurfaceAllocatorEx9_iface;
+    else if (IsEqualIID(riid, &IID_IVMRSurfaceAllocator9))
+        *ppv = &This->IVMRSurfaceAllocator9_iface;
 
     if (*ppv)
     {
@@ -2667,25 +2668,22 @@ static const IVMRImagePresenter9Vtbl VMR9_ImagePresenter =
     VMR9_ImagePresenter_PresentImage
 };
 
-static HRESULT WINAPI VMR9_SurfaceAllocator_QueryInterface(IVMRSurfaceAllocatorEx9 *iface, REFIID riid, LPVOID * ppv)
+static HRESULT WINAPI VMR9_SurfaceAllocator_QueryInterface(IVMRSurfaceAllocator9 *iface, REFIID iid, void **out)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocatorEx9(iface);
-
-    return VMR9_ImagePresenter_QueryInterface(&This->IVMRImagePresenter9_iface, riid, ppv);
+    struct default_presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
+    return IVMRImagePresenter9_QueryInterface(&presenter->IVMRImagePresenter9_iface, iid, out);
 }
 
-static ULONG WINAPI VMR9_SurfaceAllocator_AddRef(IVMRSurfaceAllocatorEx9 *iface)
+static ULONG WINAPI VMR9_SurfaceAllocator_AddRef(IVMRSurfaceAllocator9 *iface)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocatorEx9(iface);
-
-    return VMR9_ImagePresenter_AddRef(&This->IVMRImagePresenter9_iface);
+    struct default_presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
+    return IVMRImagePresenter9_AddRef(&presenter->IVMRImagePresenter9_iface);
 }
 
-static ULONG WINAPI VMR9_SurfaceAllocator_Release(IVMRSurfaceAllocatorEx9 *iface)
+static ULONG WINAPI VMR9_SurfaceAllocator_Release(IVMRSurfaceAllocator9 *iface)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocatorEx9(iface);
-
-    return VMR9_ImagePresenter_Release(&This->IVMRImagePresenter9_iface);
+    struct default_presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
+    return IVMRImagePresenter9_Release(&presenter->IVMRImagePresenter9_iface);
 }
 
 static HRESULT VMR9_SurfaceAllocator_SetAllocationSettings(struct default_presenter *This, VMR9AllocationInfo *allocinfo)
@@ -2827,9 +2825,10 @@ static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9Allocation
     return TRUE;
 }
 
-static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocatorEx9 *iface, DWORD_PTR id, VMR9AllocationInfo *allocinfo, DWORD *numbuffers)
+static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocator9 *iface,
+        DWORD_PTR cookie, VMR9AllocationInfo *allocinfo, DWORD *numbuffers)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocatorEx9(iface);
+    struct default_presenter *This = impl_from_IVMRSurfaceAllocator9(iface);
 
     This->info = *allocinfo;
 
@@ -2842,16 +2841,17 @@ static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocato
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9_SurfaceAllocator_TerminateDevice(IVMRSurfaceAllocatorEx9 *iface, DWORD_PTR id)
+static HRESULT WINAPI VMR9_SurfaceAllocator_TerminateDevice(IVMRSurfaceAllocator9 *iface, DWORD_PTR cookie)
 {
-    TRACE("iface %p, id %#lx.\n", iface, id);
+    TRACE("iface %p, cookie %#lx.\n", iface, cookie);
 
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9_SurfaceAllocator_GetSurface(IVMRSurfaceAllocatorEx9 *iface, DWORD_PTR id, DWORD surfaceindex, DWORD flags, IDirect3DSurface9 **surface)
+static HRESULT WINAPI VMR9_SurfaceAllocator_GetSurface(IVMRSurfaceAllocator9 *iface,
+        DWORD_PTR cookie, DWORD surfaceindex, DWORD flags, IDirect3DSurface9 **surface)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocatorEx9(iface);
+    struct default_presenter *This = impl_from_IVMRSurfaceAllocator9(iface);
 
     /* Update everything first, this is needed because the surface might be destroyed in the reset */
     if (!This->d3d9_dev)
@@ -2871,9 +2871,10 @@ static HRESULT WINAPI VMR9_SurfaceAllocator_GetSurface(IVMRSurfaceAllocatorEx9 *
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9_SurfaceAllocator_AdviseNotify(IVMRSurfaceAllocatorEx9 *iface, IVMRSurfaceAllocatorNotify9 *allocnotify)
+static HRESULT WINAPI VMR9_SurfaceAllocator_AdviseNotify(IVMRSurfaceAllocator9 *iface,
+        IVMRSurfaceAllocatorNotify9 *allocnotify)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocatorEx9(iface);
+    struct default_presenter *This = impl_from_IVMRSurfaceAllocator9(iface);
 
     TRACE("(%p/%p)->(...)\n", iface, This);
 
@@ -2882,7 +2883,7 @@ static HRESULT WINAPI VMR9_SurfaceAllocator_AdviseNotify(IVMRSurfaceAllocatorEx9
     return S_OK;
 }
 
-static const IVMRSurfaceAllocatorEx9Vtbl VMR9_SurfaceAllocator =
+static const IVMRSurfaceAllocator9Vtbl VMR9_SurfaceAllocator =
 {
     VMR9_SurfaceAllocator_QueryInterface,
     VMR9_SurfaceAllocator_AddRef,
@@ -2891,7 +2892,6 @@ static const IVMRSurfaceAllocatorEx9Vtbl VMR9_SurfaceAllocator =
     VMR9_SurfaceAllocator_TerminateDevice,
     VMR9_SurfaceAllocator_GetSurface,
     VMR9_SurfaceAllocator_AdviseNotify,
-    NULL /* This isn't the SurfaceAllocatorEx type yet, working on it */
 };
 
 static IDirect3D9 *init_d3d9(HMODULE d3d9_handle)
@@ -2940,7 +2940,7 @@ static HRESULT VMR9DefaultAllocatorPresenterImpl_create(struct quartz_vmr *paren
     }
 
     object->IVMRImagePresenter9_iface.lpVtbl = &VMR9_ImagePresenter;
-    object->IVMRSurfaceAllocatorEx9_iface.lpVtbl = &VMR9_SurfaceAllocator;
+    object->IVMRSurfaceAllocator9_iface.lpVtbl = &VMR9_SurfaceAllocator;
 
     object->refCount = 1;
     object->pVMR9 = parent;
From 6ccbc0579d7b3857687e2611ca586a4cbb9d99a3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 May 2020 11:47:36 -0500
Subject: [PATCH] quartz/vmr9: Remove the unused "allocator_mon" field.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index bc03326599f..6f699ce70fb 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -97,7 +97,6 @@ struct quartz_vmr
 
     /* Presentation related members */
     IDirect3DDevice9 *allocator_d3d9_dev;
-    HMONITOR allocator_mon;
     IDirect3DSurface9 **surfaces;
     DWORD num_surfaces;
     DWORD cur_surface;
@@ -1987,7 +1986,6 @@ static HRESULT WINAPI VMR9SurfaceAllocatorNotify_SetD3DDevice(IVMRSurfaceAllocat
         IDirect3DDevice9_Release(filter->allocator_d3d9_dev);
     filter->allocator_d3d9_dev = device;
     IDirect3DDevice9_AddRef(device);
-    filter->allocator_mon = monitor;
 
     return S_OK;
 }
@@ -2001,7 +1999,6 @@ static HRESULT WINAPI VMR9SurfaceAllocatorNotify_ChangeD3DDevice(IVMRSurfaceAllo
         IDirect3DDevice9_Release(This->allocator_d3d9_dev);
     This->allocator_d3d9_dev = device;
     IDirect3DDevice9_AddRef(This->allocator_d3d9_dev);
-    This->allocator_mon = monitor;
 
     return S_OK;
 }
From c6abb3b241b67934b1bebebac70293ea3e0cdf3c Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 May 2020 11:47:37 -0500
Subject: [PATCH] quartz/vmr9: Get rid of CreateRenderingWindow().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 32 ++++++++++----------------------
 1 file changed, 10 insertions(+), 22 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 6f699ce70fb..8ba82e8259c 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -2751,8 +2751,10 @@ static UINT d3d9_adapter_from_hwnd(IDirect3D9 *d3d9, HWND hwnd, HMONITOR *mon_ou
     return d3d9_adapter;
 }
 
-static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9AllocationInfo *info, DWORD *numbuffers)
+static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocator9 *iface,
+        DWORD_PTR cookie, VMR9AllocationInfo *info, DWORD *numbuffers)
 {
+    struct default_presenter *This = impl_from_IVMRSurfaceAllocator9(iface);
     D3DPRESENT_PARAMETERS d3dpp;
     IDirect3DDevice9 *device;
     DWORD d3d9_adapter;
@@ -2760,7 +2762,9 @@ static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9Allocation
     HWND window;
     HRESULT hr;
 
-    TRACE("(%p)->()\n", This);
+    TRACE("presenter %p, cookie %#Ix, info %p, numbuffers %p.\n", This, cookie, info, numbuffers);
+
+    This->info = *info;
 
     if (This->pVMR9->mode == VMR9Mode_Windowed)
         window = This->pVMR9->window.hwnd;
@@ -2783,7 +2787,7 @@ static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9Allocation
     if (FAILED(hr))
     {
         ERR("Could not create device: %08x\n", hr);
-        return FALSE;
+        return hr;
     }
 
     IDirect3DDevice9_GetDeviceCaps(device, &caps);
@@ -2791,14 +2795,14 @@ static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9Allocation
     {
         WARN("Device does not support blitting from textures.\n");
         IDirect3DDevice9_Release(device);
-        return FALSE;
+        return VFW_E_DDRAW_CAPS_NOT_SUITABLE;
     }
 
     This->d3d9_dev = device;
     IVMRSurfaceAllocatorNotify9_SetD3DDevice(This->SurfaceAllocatorNotify, This->d3d9_dev, This->hMon);
 
     if (!(This->d3d9_surfaces = calloc(*numbuffers, sizeof(IDirect3DSurface9 *))))
-        return FALSE;
+        return E_OUTOFMEMORY;
 
     hr = VMR9_SurfaceAllocator_SetAllocationSettings(This, info);
     if (FAILED(hr))
@@ -2814,27 +2818,11 @@ static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9Allocation
     if (FAILED(hr))
     {
         IVMRSurfaceAllocator9_TerminateDevice(This->pVMR9->allocator, This->pVMR9->cookie);
-        return FALSE;
+        return hr;
     }
 
     This->num_surfaces = *numbuffers;
 
-    return TRUE;
-}
-
-static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocator9 *iface,
-        DWORD_PTR cookie, VMR9AllocationInfo *allocinfo, DWORD *numbuffers)
-{
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocator9(iface);
-
-    This->info = *allocinfo;
-
-    if (!CreateRenderingWindow(This, allocinfo, numbuffers))
-    {
-        ERR("Failed to create rendering window, expect no output!\n");
-        return VFW_E_WRONG_STATE;
-    }
-
     return S_OK;
 }
 
From e48fabff525061c8eea9558084a97308cebe6b7b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 May 2020 11:47:38 -0500
Subject: [PATCH] quartz/vmr9: Trace argument values instead of omitting them.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 27 +++++++++++++++------------
 1 file changed, 15 insertions(+), 12 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 8ba82e8259c..4ea3b483a75 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -2583,19 +2583,21 @@ static ULONG WINAPI VMR9_ImagePresenter_Release(IVMRImagePresenter9 *iface)
     return refCount;
 }
 
-static HRESULT WINAPI VMR9_ImagePresenter_StartPresenting(IVMRImagePresenter9 *iface, DWORD_PTR id)
+static HRESULT WINAPI VMR9_ImagePresenter_StartPresenting(IVMRImagePresenter9 *iface, DWORD_PTR cookie)
 {
-    struct default_presenter *This = impl_from_IVMRImagePresenter9(iface);
+    struct default_presenter *presenter = impl_from_IVMRImagePresenter9(iface);
+
+    TRACE("presenter %p, cookie %#Ix.\n", presenter, cookie);
 
-    TRACE("(%p/%p/%p)->(...) stub\n", iface, This,This->pVMR9);
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9_ImagePresenter_StopPresenting(IVMRImagePresenter9 *iface, DWORD_PTR id)
+static HRESULT WINAPI VMR9_ImagePresenter_StopPresenting(IVMRImagePresenter9 *iface, DWORD_PTR cookie)
 {
-    struct default_presenter *This = impl_from_IVMRImagePresenter9(iface);
+    struct default_presenter *presenter = impl_from_IVMRImagePresenter9(iface);
+
+    TRACE("presenter %p, cookie %#Ix.\n", presenter, cookie);
 
-    TRACE("(%p/%p/%p)->(...) stub\n", iface, This,This->pVMR9);
     return S_OK;
 }
 
@@ -2619,13 +2621,14 @@ static HRESULT VMR9_ImagePresenter_PresentOffscreenSurface(struct default_presen
     return hr;
 }
 
-static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *iface, DWORD_PTR id, VMR9PresentationInfo *info)
+static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *iface,
+        DWORD_PTR cookie, VMR9PresentationInfo *info)
 {
     struct default_presenter *This = impl_from_IVMRImagePresenter9(iface);
     HRESULT hr;
     BOOL render = FALSE;
 
-    TRACE("(%p/%p/%p)->(...) stub\n", iface, This, This->pVMR9);
+    TRACE("presenter %p, cookie %#Ix, info %p.\n", This, cookie, info);
 
     /* This might happen if we don't have active focus (eg on a different virtual desktop) */
     if (!This->d3d9_dev)
@@ -2857,14 +2860,14 @@ static HRESULT WINAPI VMR9_SurfaceAllocator_GetSurface(IVMRSurfaceAllocator9 *if
 }
 
 static HRESULT WINAPI VMR9_SurfaceAllocator_AdviseNotify(IVMRSurfaceAllocator9 *iface,
-        IVMRSurfaceAllocatorNotify9 *allocnotify)
+        IVMRSurfaceAllocatorNotify9 *notify)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocator9(iface);
+    struct default_presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
 
-    TRACE("(%p/%p)->(...)\n", iface, This);
+    TRACE("presenter %p, notify %p.\n", presenter, notify);
 
     /* No AddRef taken here or the base VMR9 filter would never be destroyed */
-    This->SurfaceAllocatorNotify = allocnotify;
+    presenter->SurfaceAllocatorNotify = notify;
     return S_OK;
 }
 
From 8b5f9145f7cf889513a2226197086a39bf17deb0 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 28 May 2020 02:05:48 +0700
Subject: [PATCH] amstream: Move initialization code from audio_stream_create
 into AMAudioStream::Initialize and ::JoinAMMultiMediaStream.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c | 50 +++++++++++++++++++++++++++----------
 1 file changed, 37 insertions(+), 13 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 265c3bf9f20..a38cbc5f639 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -502,11 +502,24 @@ static HRESULT WINAPI audio_IAMMediaStream_SendEndOfStream(IAMMediaStream *iface
 static HRESULT WINAPI audio_IAMMediaStream_Initialize(IAMMediaStream *iface, IUnknown *source_object, DWORD flags,
                                                     REFMSPID purpose_id, const STREAM_TYPE stream_type)
 {
-    struct audio_stream *This = impl_from_IAMMediaStream(iface);
+    struct audio_stream *stream = impl_from_IAMMediaStream(iface);
 
-    FIXME("(%p/%p)->(%p,%x,%p,%u) stub!\n", This, iface, source_object, flags, purpose_id, stream_type);
+    TRACE("stream %p, source_object %p, flags %x, purpose_id %s, stream_type %u.\n", stream, source_object, flags,
+            debugstr_guid(purpose_id), stream_type);
 
-    return S_FALSE;
+    if (!purpose_id)
+        return E_POINTER;
+
+    if (source_object)
+        FIXME("Specifying a stream object is not yet supported.\n");
+
+    if (flags & AMMSF_CREATEPEER)
+        FIXME("AMMSF_CREATEPEER is not yet supported.\n");
+
+    stream->purpose_id = *purpose_id;
+    stream->stream_type = stream_type;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_IAMMediaStream_SetState(IAMMediaStream *iface, FILTER_STATE state)
@@ -530,13 +543,15 @@ static HRESULT WINAPI audio_IAMMediaStream_SetState(IAMMediaStream *iface, FILTE
 }
 
 static HRESULT WINAPI audio_IAMMediaStream_JoinAMMultiMediaStream(IAMMediaStream *iface,
-        IAMMultiMediaStream *am_multi_media_stream)
+        IAMMultiMediaStream *mmstream)
 {
-    struct audio_stream *This = impl_from_IAMMediaStream(iface);
+    struct audio_stream *stream = impl_from_IAMMediaStream(iface);
 
-    FIXME("(%p/%p)->(%p) stub!\n", This, iface, am_multi_media_stream);
+    TRACE("stream %p, mmstream %p.\n", stream, mmstream);
 
-    return S_FALSE;
+    stream->parent = (IMultiMediaStream *)mmstream;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_IAMMediaStream_JoinFilter(IAMMediaStream *iface, IMediaStreamFilter *filter)
@@ -1262,12 +1277,10 @@ HRESULT audio_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
         IUnknown *stream_object, STREAM_TYPE stream_type, IAMMediaStream **media_stream)
 {
     struct audio_stream *object;
+    HRESULT hr;
 
     TRACE("(%p,%s,%p,%p)\n", parent, debugstr_guid(purpose_id), stream_object, media_stream);
 
-    if (stream_object)
-        FIXME("Specifying a stream object is not yet supported.\n");
-
     object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
     if (!object)
         return E_OUTOFMEMORY;
@@ -1279,12 +1292,23 @@ HRESULT audio_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
     object->ref = 1;
 
     InitializeCriticalSection(&object->cs);
-    object->parent = parent;
-    object->purpose_id = *purpose_id;
-    object->stream_type = stream_type;
     list_init(&object->receive_queue);
     list_init(&object->update_queue);
 
+    hr = IAMMediaStream_Initialize(&object->IAMMediaStream_iface, stream_object, 0, purpose_id, stream_type);
+    if (FAILED(hr))
+    {
+        IAMMediaStream_Release(&object->IAMMediaStream_iface);
+        return hr;
+    }
+
+    hr = IAMMediaStream_JoinAMMultiMediaStream(&object->IAMMediaStream_iface, (IAMMultiMediaStream *)parent);
+    if (FAILED(hr))
+    {
+        IAMMediaStream_Release(&object->IAMMediaStream_iface);
+        return hr;
+    }
+
     *media_stream = &object->IAMMediaStream_iface;
 
     return S_OK;
From f568c47a470c7a567dfdc3c64d186f935501d47c Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 28 May 2020 02:05:49 +0700
Subject: [PATCH] amstream: Move initialization code from ddraw_stream_create
 into AMDirectDrawStream::Initialize and ::JoinAMMultiMediaStream.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c | 49 +++++++++++++++++++++++++++----------
 1 file changed, 36 insertions(+), 13 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index a4bfe948d2d..8e99ea3bf55 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -198,11 +198,26 @@ static HRESULT WINAPI ddraw_IAMMediaStream_SendEndOfStream(IAMMediaStream *iface
 static HRESULT WINAPI ddraw_IAMMediaStream_Initialize(IAMMediaStream *iface, IUnknown *source_object, DWORD flags,
                                                     REFMSPID purpose_id, const STREAM_TYPE stream_type)
 {
-    struct ddraw_stream *This = impl_from_IAMMediaStream(iface);
+    struct ddraw_stream *stream = impl_from_IAMMediaStream(iface);
+    HRESULT hr;
 
-    FIXME("(%p/%p)->(%p,%x,%p,%u) stub!\n", This, iface, source_object, flags, purpose_id, stream_type);
+    TRACE("stream %p, source_object %p, flags %x, purpose_id %s, stream_type %u.\n", stream, source_object, flags,
+            debugstr_guid(purpose_id), stream_type);
 
-    return S_FALSE;
+    if (!purpose_id)
+        return E_POINTER;
+
+    if (flags & AMMSF_CREATEPEER)
+        FIXME("AMMSF_CREATEPEER is not yet supported.\n");
+
+    stream->purpose_id = *purpose_id;
+    stream->stream_type = stream_type;
+
+    if (source_object
+            && FAILED(hr = IUnknown_QueryInterface(source_object, &IID_IDirectDraw7, (void **)&stream->ddraw)))
+        FIXME("Stream object doesn't implement IDirectDraw7 interface, hr %#x.\n", hr);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI ddraw_IAMMediaStream_SetState(IAMMediaStream *iface, FILTER_STATE state)
@@ -214,13 +229,15 @@ static HRESULT WINAPI ddraw_IAMMediaStream_SetState(IAMMediaStream *iface, FILTE
     return S_FALSE;
 }
 
-static HRESULT WINAPI ddraw_IAMMediaStream_JoinAMMultiMediaStream(IAMMediaStream *iface, IAMMultiMediaStream *am_multi_media_stream)
+static HRESULT WINAPI ddraw_IAMMediaStream_JoinAMMultiMediaStream(IAMMediaStream *iface, IAMMultiMediaStream *mmstream)
 {
-    struct ddraw_stream *This = impl_from_IAMMediaStream(iface);
+    struct ddraw_stream *stream = impl_from_IAMMediaStream(iface);
+
+    TRACE("stream %p, mmstream %p.\n", stream, mmstream);
 
-    FIXME("(%p/%p)->(%p) stub!\n", This, iface, am_multi_media_stream);
+    stream->parent = (IMultiMediaStream *)mmstream;
 
-    return S_FALSE;
+    return S_OK;
 }
 
 static HRESULT WINAPI ddraw_IAMMediaStream_JoinFilter(IAMMediaStream *iface, IMediaStreamFilter *filter)
@@ -929,13 +946,19 @@ HRESULT ddraw_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
 
     InitializeCriticalSection(&object->cs);
 
-    object->parent = parent;
-    object->purpose_id = *purpose_id;
-    object->stream_type = stream_type;
+    hr = IAMMediaStream_Initialize(&object->IAMMediaStream_iface, stream_object, 0, purpose_id, stream_type);
+    if (FAILED(hr))
+    {
+        IAMMediaStream_Release(&object->IAMMediaStream_iface);
+        return hr;
+    }
 
-    if (stream_object
-            && FAILED(hr = IUnknown_QueryInterface(stream_object, &IID_IDirectDraw7, (void **)&object->ddraw)))
-        FIXME("Stream object doesn't implement IDirectDraw7 interface, hr %#x.\n", hr);
+    hr = IAMMediaStream_JoinAMMultiMediaStream(&object->IAMMediaStream_iface, (IAMMultiMediaStream *)parent);
+    if (FAILED(hr))
+    {
+        IAMMediaStream_Release(&object->IAMMediaStream_iface);
+        return hr;
+    }
 
     *media_stream = &object->IAMMediaStream_iface;
 
From 5eb568354cc6eddc6653cbf7ed53606ae8b488fb Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 28 May 2020 02:05:50 +0700
Subject: [PATCH] amstream: Move initialization calls from *_stream_create into
 AMMultiMediaStream::AddMediaStream.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/amstream_private.h |  6 ++----
 dlls/amstream/audiostream.c      | 23 +++++------------------
 dlls/amstream/ddrawstream.c      | 23 +++++------------------
 dlls/amstream/multimedia.c       | 18 +++++++++++++-----
 dlls/amstream/tests/amstream.c   |  2 +-
 5 files changed, 26 insertions(+), 46 deletions(-)

diff --git a/dlls/amstream/amstream_private.h b/dlls/amstream/amstream_private.h
index bec107f819b..e71563cb115 100644
--- a/dlls/amstream/amstream_private.h
+++ b/dlls/amstream/amstream_private.h
@@ -37,9 +37,7 @@
 HRESULT multimedia_stream_create(IUnknown *outer, void **out) DECLSPEC_HIDDEN;
 HRESULT AMAudioData_create(IUnknown *pUnkOuter, LPVOID *ppObj) DECLSPEC_HIDDEN;
 HRESULT filter_create(IUnknown *outer, void **out) DECLSPEC_HIDDEN;
-HRESULT ddraw_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
-        IUnknown *stream_object, STREAM_TYPE type, IAMMediaStream **stream) DECLSPEC_HIDDEN;
-HRESULT audio_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
-        IUnknown *stream_object, STREAM_TYPE stream_type, IAMMediaStream **media_stream) DECLSPEC_HIDDEN;
+HRESULT ddraw_stream_create(IUnknown *outer, void **out) DECLSPEC_HIDDEN;
+HRESULT audio_stream_create(IUnknown *outer, void **out) DECLSPEC_HIDDEN;
 
 #endif /* __AMSTREAM_PRIVATE_INCLUDED__ */
diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index a38cbc5f639..f9470fa5f90 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -1273,13 +1273,12 @@ static const IMemInputPinVtbl audio_meminput_vtbl =
     audio_meminput_ReceiveCanBlock,
 };
 
-HRESULT audio_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
-        IUnknown *stream_object, STREAM_TYPE stream_type, IAMMediaStream **media_stream)
+HRESULT audio_stream_create(IUnknown *outer, void **out)
 {
     struct audio_stream *object;
-    HRESULT hr;
 
-    TRACE("(%p,%s,%p,%p)\n", parent, debugstr_guid(purpose_id), stream_object, media_stream);
+    if (outer)
+        return CLASS_E_NOAGGREGATION;
 
     object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
     if (!object)
@@ -1295,21 +1294,9 @@ HRESULT audio_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
     list_init(&object->receive_queue);
     list_init(&object->update_queue);
 
-    hr = IAMMediaStream_Initialize(&object->IAMMediaStream_iface, stream_object, 0, purpose_id, stream_type);
-    if (FAILED(hr))
-    {
-        IAMMediaStream_Release(&object->IAMMediaStream_iface);
-        return hr;
-    }
-
-    hr = IAMMediaStream_JoinAMMultiMediaStream(&object->IAMMediaStream_iface, (IAMMultiMediaStream *)parent);
-    if (FAILED(hr))
-    {
-        IAMMediaStream_Release(&object->IAMMediaStream_iface);
-        return hr;
-    }
+    TRACE("Created audio stream %p.\n", object);
 
-    *media_stream = &object->IAMMediaStream_iface;
+    *out = &object->IAMMediaStream_iface;
 
     return S_OK;
 }
diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 8e99ea3bf55..1c924e40a20 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -926,13 +926,12 @@ static const IMemInputPinVtbl ddraw_meminput_vtbl =
     ddraw_meminput_ReceiveCanBlock,
 };
 
-HRESULT ddraw_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
-        IUnknown *stream_object, STREAM_TYPE stream_type, IAMMediaStream **media_stream)
+HRESULT ddraw_stream_create(IUnknown *outer, void **out)
 {
     struct ddraw_stream *object;
-    HRESULT hr;
 
-    TRACE("(%p,%s,%p,%p)\n", parent, debugstr_guid(purpose_id), stream_object, media_stream);
+    if (outer)
+        return CLASS_E_NOAGGREGATION;
 
     object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
     if (!object)
@@ -946,21 +945,9 @@ HRESULT ddraw_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
 
     InitializeCriticalSection(&object->cs);
 
-    hr = IAMMediaStream_Initialize(&object->IAMMediaStream_iface, stream_object, 0, purpose_id, stream_type);
-    if (FAILED(hr))
-    {
-        IAMMediaStream_Release(&object->IAMMediaStream_iface);
-        return hr;
-    }
-
-    hr = IAMMediaStream_JoinAMMultiMediaStream(&object->IAMMediaStream_iface, (IAMMultiMediaStream *)parent);
-    if (FAILED(hr))
-    {
-        IAMMediaStream_Release(&object->IAMMediaStream_iface);
-        return hr;
-    }
+    TRACE("Created ddraw stream %p.\n", object);
 
-    *media_stream = &object->IAMMediaStream_iface;
+    *out = &object->IAMMediaStream_iface;
 
     return S_OK;
 }
diff --git a/dlls/amstream/multimedia.c b/dlls/amstream/multimedia.c
index be8fd4ecbfc..e77392e483a 100644
--- a/dlls/amstream/multimedia.c
+++ b/dlls/amstream/multimedia.c
@@ -301,6 +301,7 @@ static HRESULT WINAPI multimedia_stream_GetFilter(IAMMultiMediaStream *iface,
 static void add_stream(struct multimedia_stream *mmstream, IAMMediaStream *stream, IMediaStream **ret_stream)
 {
     IMediaStreamFilter_AddMediaStream(mmstream->filter, stream);
+    IAMMediaStream_JoinAMMultiMediaStream(stream, &mmstream->IAMMultiMediaStream_iface);
     if (ret_stream)
     {
         *ret_stream = (IMediaStream *)stream;
@@ -377,19 +378,26 @@ static HRESULT WINAPI multimedia_stream_AddMediaStream(IAMMultiMediaStream *ifac
     }
 
     if (IsEqualGUID(PurposeId, &MSPID_PrimaryVideo))
-        hr = ddraw_stream_create((IMultiMediaStream*)iface, PurposeId, stream_object, This->type, &pStream);
+        hr = ddraw_stream_create(NULL, (void **)&pStream);
     else if (IsEqualGUID(PurposeId, &MSPID_PrimaryAudio))
-        hr = audio_stream_create((IMultiMediaStream*)iface, PurposeId, stream_object, This->type, &pStream);
+        hr = audio_stream_create(NULL, (void **)&pStream);
     else
         return MS_E_PURPOSEID;
 
-    if (SUCCEEDED(hr))
+    if (FAILED(hr))
+        return hr;
+
+    hr = IAMMediaStream_Initialize(pStream, stream_object, dwFlags, PurposeId, This->type);
+    if (FAILED(hr))
     {
-        add_stream(This, pStream, ret_stream);
         IAMMediaStream_Release(pStream);
+        return hr;
     }
 
-    return hr;
+    add_stream(This, pStream, ret_stream);
+    IAMMediaStream_Release(pStream);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI multimedia_stream_OpenFile(IAMMultiMediaStream *iface,
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 073e372c94f..13c00aac25a 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -730,7 +730,7 @@ static void test_add_stream(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(stream == (IMediaStream *)&teststream, "Streams didn't match.\n");
     if (hr == S_OK) IMediaStream_Release(stream);
-    todo_wine ok(teststream.mmstream == mmstream, "IAMMultiMediaStream objects didn't match.\n");
+    ok(teststream.mmstream == mmstream, "IAMMultiMediaStream objects didn't match.\n");
     ok(teststream.filter == stream_filter, "IMediaStreamFilter objects didn't match.\n");
     todo_wine ok(!!teststream.graph, "Expected a non-NULL graph.\n");
 
From 7d07142b1f2664ef6cd0939ddc8a40894f97d702 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 28 May 2020 02:05:51 +0700
Subject: [PATCH] amstream: Allow AMAudioStream and AMDirectDrawStream to be
 created by CoCreateInstance.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/amstream_classes.idl | 7 +++++++
 dlls/amstream/main.c               | 3 ++-
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/dlls/amstream/amstream_classes.idl b/dlls/amstream/amstream_classes.idl
index e6bda830b40..2251bf734e3 100644
--- a/dlls/amstream/amstream_classes.idl
+++ b/dlls/amstream/amstream_classes.idl
@@ -34,6 +34,13 @@ coclass MediaStreamFilter { interface IMediaStreamFilter; }
 ]
 coclass AMDirectDrawStream { interface IAMMultiMediaStream; }
 
+[
+    helpstring("AuStream Class"),
+    threading(both),
+    uuid(8496e040-af4c-11d0-8212-00c04fc32c45)
+]
+coclass AMAudioStream { interface IAMMediaStream; }
+
 [
     helpstring("MMStream Class"),
     threading(both),
diff --git a/dlls/amstream/main.c b/dlls/amstream/main.c
index c718f42448c..c581e516bd1 100644
--- a/dlls/amstream/main.c
+++ b/dlls/amstream/main.c
@@ -74,7 +74,8 @@ struct object_creation_info
 static const struct object_creation_info object_creation[] =
 {
     { &CLSID_AMMultiMediaStream, multimedia_stream_create },
-    { &CLSID_AMDirectDrawStream, multimedia_stream_create },
+    { &CLSID_AMDirectDrawStream, ddraw_stream_create },
+    { &CLSID_AMAudioStream, audio_stream_create },
     { &CLSID_AMAudioData, AMAudioData_create },
     { &CLSID_MediaStreamFilter, filter_create }
 };
From d17b009bf6fd7842bdb174b982d3435f44e0f770 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 28 May 2020 02:05:52 +0700
Subject: [PATCH] amstream: Add tests for IAMMediaStream::Initialize and
 ::JoinAMMultiMediaStream.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 143 +++++++++++++++++++++++++++++++++
 1 file changed, 143 insertions(+)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 13c00aac25a..d5b90d92574 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -3046,6 +3046,44 @@ static void test_audiostream_receive(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_audiostream_initialize(void)
+{
+    IAMMediaStream *stream;
+    STREAM_TYPE type;
+    MSPID mspid;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IAMMediaStream_Initialize(stream, NULL, 0, NULL, STREAMTYPE_WRITE);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+    }
+
+    hr = IAMMediaStream_Initialize(stream, NULL, 0, &test_mspid, STREAMTYPE_WRITE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMediaStream_GetInformation(stream, &mspid, &type);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(IsEqualGUID(&mspid, &test_mspid), "Got mspid %s.\n", wine_dbgstr_guid(&mspid));
+    ok(type == STREAMTYPE_WRITE, "Got type %u.\n", type);
+
+    hr = IAMMediaStream_Initialize(stream, NULL, 0, &MSPID_PrimaryAudio, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMediaStream_GetInformation(stream, &mspid, &type);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(IsEqualGUID(&mspid, &MSPID_PrimaryAudio), "Got mspid %s.\n", wine_dbgstr_guid(&mspid));
+    ok(type == STREAMTYPE_READ, "Got type %u.\n", type);
+
+    ref = IAMMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void CALLBACK apc_func(ULONG_PTR param)
 {
 }
@@ -3507,6 +3545,106 @@ void test_audiostreamsample_completion_status(void)
     CloseHandle(event);
 }
 
+static void test_ddrawstream_initialize(void)
+{
+    IDirectDrawMediaStream *ddraw_stream;
+    IAMMediaStream *stream;
+    IDirectDraw *ddraw2;
+    IDirectDraw *ddraw;
+    STREAM_TYPE type;
+    MSPID mspid;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = DirectDrawCreate(NULL, &ddraw, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = CoCreateInstance(&CLSID_AMDirectDrawStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (void **)&ddraw_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IAMMediaStream_Initialize(stream, NULL, 0, NULL, STREAMTYPE_WRITE);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+    }
+
+    hr = IAMMediaStream_Initialize(stream, NULL, 0, &test_mspid, STREAMTYPE_WRITE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMediaStream_GetInformation(stream, &mspid, &type);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(IsEqualGUID(&mspid, &test_mspid), "Got mspid %s.\n", wine_dbgstr_guid(&mspid));
+    ok(type == STREAMTYPE_WRITE, "Got type %u.\n", type);
+
+    hr = IAMMediaStream_Initialize(stream, (IUnknown *)ddraw, 0, &MSPID_PrimaryAudio, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMediaStream_GetInformation(stream, &mspid, &type);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(IsEqualGUID(&mspid, &MSPID_PrimaryAudio), "Got mspid %s.\n", wine_dbgstr_guid(&mspid));
+    ok(type == STREAMTYPE_READ, "Got type %u.\n", type);
+
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(ddraw2 == ddraw, "Expected ddraw %p, got %p.\n", ddraw, ddraw2);
+
+    IDirectDrawMediaStream_Release(ddraw_stream);
+    ref = IAMMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IDirectDraw_Release(ddraw2);
+    ref = IDirectDraw_Release(ddraw);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void check_ammediastream_join_am_multi_media_stream(const CLSID *clsid)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IMultiMediaStream *mmstream2;
+    IAMMediaStream *stream;
+    HRESULT hr;
+    ULONG mmstream_ref;
+    ULONG ref;
+
+    hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    mmstream_ref = get_refcount(mmstream);
+
+    hr = IAMMediaStream_JoinAMMultiMediaStream(stream, mmstream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    ref = get_refcount(mmstream);
+    ok(ref == mmstream_ref, "Expected outstanding refcount %d, got %d.\n", mmstream_ref, ref);
+
+    hr = IAMMediaStream_GetMultiMediaStream(stream, &mmstream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mmstream2 == (IMultiMediaStream *)mmstream, "Expected mmstream %p, got %p.\n", mmstream, mmstream2);
+
+    IMultiMediaStream_Release(mmstream2);
+
+    hr = IAMMediaStream_JoinAMMultiMediaStream(stream, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMediaStream_GetMultiMediaStream(stream, &mmstream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mmstream2 == NULL, "Got mmstream %p.\n", mmstream2);
+
+    ref = IAMMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_ammediastream_join_am_multi_media_stream(void)
+{
+    check_ammediastream_join_am_multi_media_stream(&CLSID_AMAudioStream);
+    check_ammediastream_join_am_multi_media_stream(&CLSID_AMDirectDrawStream);
+}
+
 void test_mediastreamfilter_get_state(void)
 {
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
@@ -3681,10 +3819,15 @@ START_TEST(amstream)
     test_audiostream_set_state();
     test_audiostream_end_of_stream();
     test_audiostream_receive();
+    test_audiostream_initialize();
 
     test_audiostreamsample_update();
     test_audiostreamsample_completion_status();
 
+    test_ddrawstream_initialize();
+
+    test_ammediastream_join_am_multi_media_stream();
+
     test_mediastreamfilter_get_state();
     test_mediastreamfilter_stop_pause_run();
 
From d1197ffaeb983abf226c27ad1a557a47644ea829 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 3 Jun 2020 14:28:12 -0500
Subject: [PATCH] amstream: Leave critical section on error in
 MediaStreamFilter::EnumPins().

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/filter.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/amstream/filter.c b/dlls/amstream/filter.c
index fb9b1d9aee5..f89fe13e625 100644
--- a/dlls/amstream/filter.c
+++ b/dlls/amstream/filter.c
@@ -361,14 +361,14 @@ static HRESULT WINAPI filter_EnumPins(IMediaStreamFilter *iface, IEnumPins **enu
 
     TRACE("iface %p, enum_pins %p.\n", iface, enum_pins);
 
-    EnterCriticalSection(&filter->cs);
-
     if (!enum_pins)
         return E_POINTER;
 
     if (!(object = heap_alloc(sizeof(*object))))
         return E_OUTOFMEMORY;
 
+    EnterCriticalSection(&filter->cs);
+
     object->IEnumPins_iface.lpVtbl = &enum_pins_vtbl;
     object->refcount = 1;
     object->count = filter->nb_streams;
@@ -376,6 +376,7 @@ static HRESULT WINAPI filter_EnumPins(IMediaStreamFilter *iface, IEnumPins **enu
     if (!(object->pins = heap_alloc(filter->nb_streams * sizeof(*object->pins))))
     {
         heap_free(object);
+        LeaveCriticalSection(&filter->cs);
         return E_OUTOFMEMORY;
     }
     for (i = 0; i < filter->nb_streams; ++i)
From ae1ca7029a4aea3e2b466dd6bc1958af38f15274 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 3 Jun 2020 14:28:13 -0500
Subject: [PATCH] amstream: Implement AMAudioStream::BeginFlush() and
 ::EndFlush().

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    |  36 ++++++++--
 dlls/amstream/tests/amstream.c | 124 +++++++++++++++++++++++++++++++++
 2 files changed, 155 insertions(+), 5 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index f9470fa5f90..8fba8777190 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -56,6 +56,7 @@ struct audio_stream
     WAVEFORMATEX format;
     FILTER_STATE state;
     BOOL eos;
+    BOOL flushing;
     struct list receive_queue;
     struct list update_queue;
 };
@@ -1084,7 +1085,7 @@ static HRESULT WINAPI audio_sink_EndOfStream(IPin *iface)
 
     EnterCriticalSection(&stream->cs);
 
-    if (stream->eos)
+    if (stream->eos || stream->flushing)
     {
         LeaveCriticalSection(&stream->cs);
         return E_FAIL;
@@ -1101,14 +1102,34 @@ static HRESULT WINAPI audio_sink_EndOfStream(IPin *iface)
 
 static HRESULT WINAPI audio_sink_BeginFlush(IPin *iface)
 {
-    FIXME("iface %p, stub!\n", iface);
-    return E_NOTIMPL;
+    struct audio_stream *stream = impl_from_IPin(iface);
+
+    TRACE("stream %p.\n", stream);
+
+    EnterCriticalSection(&stream->cs);
+
+    stream->flushing = TRUE;
+    stream->eos = FALSE;
+    flush_receive_queue(stream);
+
+    LeaveCriticalSection(&stream->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_sink_EndFlush(IPin *iface)
 {
-    FIXME("iface %p, stub!\n", iface);
-    return E_NOTIMPL;
+    struct audio_stream *stream = impl_from_IPin(iface);
+
+    TRACE("stream %p.\n", stream);
+
+    EnterCriticalSection(&stream->cs);
+
+    stream->flushing = FALSE;
+
+    LeaveCriticalSection(&stream->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_sink_NewSegment(IPin *iface, REFERENCE_TIME start, REFERENCE_TIME stop, double rate)
@@ -1219,6 +1240,11 @@ static HRESULT WINAPI audio_meminput_Receive(IMemInputPin *iface, IMediaSample *
         LeaveCriticalSection(&stream->cs);
         return VFW_E_WRONG_STATE;
     }
+    if (stream->flushing)
+    {
+        LeaveCriticalSection(&stream->cs);
+        return S_FALSE;
+    }
 
     hr = IMediaSample_GetPointer(sample, &pointer);
     if (FAILED(hr))
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index d5b90d92574..2c97a0aa90f 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -3084,6 +3084,129 @@ static void test_audiostream_initialize(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_audiostream_begin_flush_end_flush(void)
+{
+    static const WAVEFORMATEX format =
+    {
+        .wFormatTag = WAVE_FORMAT_PCM,
+        .nChannels = 1,
+        .nSamplesPerSec = 11025,
+        .wBitsPerSample = 16,
+        .nBlockAlign = 2,
+        .nAvgBytesPerSec = 2 * 11025,
+    };
+
+    const AM_MEDIA_TYPE mt =
+    {
+        .majortype = MEDIATYPE_Audio,
+        .subtype = MEDIASUBTYPE_PCM,
+        .formattype = FORMAT_WaveFormatEx,
+        .cbFormat = sizeof(WAVEFORMATEX),
+        .pbFormat = (BYTE *)&format,
+    };
+
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IAudioStreamSample *stream_sample;
+    IAudioMediaStream *audio_stream;
+    IMediaSample *media_sample;
+    struct testfilter source;
+    IAudioData *audio_data;
+    IGraphBuilder *graph;
+    IMediaStream *stream;
+    HRESULT hr;
+    ULONG ref;
+    IPin *pin;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IAudioMediaStream, (void **)&audio_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    testfilter_init(&source);
+    hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER, &IID_IAudioData, (void **)&audio_data);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAudioData_SetBuffer(audio_data, 16, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAudioMediaStream_CreateSample(audio_stream, audio_data, 0, &stream_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = BaseOutputPinImpl_GetDeliveryBuffer(&source.source, &media_sample, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(source.source.pMemInputPin, media_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ref = get_refcount(media_sample);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+
+    hr = IPin_EndOfStream(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_BeginFlush(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    ref = IMediaSample_Release(media_sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+    hr = BaseOutputPinImpl_GetDeliveryBuffer(&source.source, &media_sample, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(source.source.pMemInputPin, media_sample);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    ref = IMediaSample_Release(media_sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+    hr = IAudioStreamSample_Update(stream_sample, SSUPDATE_ASYNC, NULL, NULL, 0);
+    ok(hr == MS_S_PENDING, "Got hr %#x.\n", hr);
+
+    hr = IPin_EndOfStream(pin);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+
+    hr = IPin_EndFlush(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = BaseOutputPinImpl_GetDeliveryBuffer(&source.source, &media_sample, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(source.source.pMemInputPin, media_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ref = IMediaSample_Release(media_sample);
+    ok(ref == 1, "Got outstanding refcount %d.\n", ref);
+
+    hr = IPin_EndOfStream(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    IGraphBuilder_Disconnect(graph, pin);
+    IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
+
+    ref = IAudioStreamSample_Release(stream_sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAudioData_Release(audio_data);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin);
+    IAudioMediaStream_Release(audio_stream);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void CALLBACK apc_func(ULONG_PTR param)
 {
 }
@@ -3820,6 +3943,7 @@ START_TEST(amstream)
     test_audiostream_end_of_stream();
     test_audiostream_receive();
     test_audiostream_initialize();
+    test_audiostream_begin_flush_end_flush();
 
     test_audiostreamsample_update();
     test_audiostreamsample_completion_status();
From 77134d806d3a3c4fca3e996952a36a78c545cf72 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 3 Jun 2020 14:28:14 -0500
Subject: [PATCH] amstream: Implement MediaStreamFilter::SupportSeeking().

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/filter.c         | 270 ++++++++++++++++++++++++++--
 dlls/amstream/tests/amstream.c | 316 +++++++++++++++++++++++++++++++++
 2 files changed, 568 insertions(+), 18 deletions(-)

diff --git a/dlls/amstream/filter.c b/dlls/amstream/filter.c
index f89fe13e625..f1e0811d679 100644
--- a/dlls/amstream/filter.c
+++ b/dlls/amstream/filter.c
@@ -163,6 +163,7 @@ static const IEnumPinsVtbl enum_pins_vtbl =
 struct filter
 {
     IMediaStreamFilter IMediaStreamFilter_iface;
+    IMediaSeeking IMediaSeeking_iface;
     LONG refcount;
     CRITICAL_SECTION cs;
 
@@ -171,6 +172,7 @@ struct filter
     IFilterGraph *graph;
     ULONG nb_streams;
     IAMMediaStream **streams;
+    IAMMediaStream *seekable_stream;
     FILTER_STATE state;
 };
 
@@ -179,26 +181,27 @@ static inline struct filter *impl_from_IMediaStreamFilter(IMediaStreamFilter *if
     return CONTAINING_RECORD(iface, struct filter, IMediaStreamFilter_iface);
 }
 
-static HRESULT WINAPI filter_QueryInterface(IMediaStreamFilter *iface, REFIID riid, void **ret_iface)
+static HRESULT WINAPI filter_QueryInterface(IMediaStreamFilter *iface, REFIID iid, void **out)
 {
-    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ret_iface);
+    struct filter *filter = impl_from_IMediaStreamFilter(iface);
 
-    *ret_iface = NULL;
+    TRACE("filter %p, iid %s, out %p.\n", filter, debugstr_guid(iid), out);
 
-    if (IsEqualIID(riid, &IID_IUnknown) ||
-        IsEqualIID(riid, &IID_IPersist) ||
-        IsEqualIID(riid, &IID_IMediaFilter) ||
-        IsEqualIID(riid, &IID_IBaseFilter) ||
-        IsEqualIID(riid, &IID_IMediaStreamFilter))
-        *ret_iface = iface;
+    *out = NULL;
 
-    if (*ret_iface)
-    {
-        IMediaStreamFilter_AddRef(*ret_iface);
-        return S_OK;
-    }
+    if (IsEqualGUID(iid, &IID_IUnknown)
+            || IsEqualGUID(iid, &IID_IPersist)
+            || IsEqualGUID(iid, &IID_IMediaFilter)
+            || IsEqualGUID(iid, &IID_IBaseFilter)
+            || IsEqualGUID(iid, &IID_IMediaStreamFilter))
+        *out = iface;
+    else if (IsEqualGUID(iid, &IID_IMediaSeeking) && filter->seekable_stream)
+        *out = &filter->IMediaSeeking_iface;
+    else
+        return E_NOINTERFACE;
 
-    return E_NOINTERFACE;
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
 }
 
 static ULONG WINAPI filter_AddRef(IMediaStreamFilter *iface)
@@ -538,11 +541,70 @@ static HRESULT WINAPI filter_EnumMediaStreams(IMediaStreamFilter *iface, LONG in
     return S_OK;
 }
 
-static HRESULT WINAPI filter_SupportSeeking(IMediaStreamFilter *iface, BOOL bRenderer)
+static IMediaSeeking *get_seeking(IAMMediaStream *stream)
 {
-    FIXME("(%p)->(%d): Stub!\n", iface, bRenderer);
+    IMediaSeeking *seeking;
+    IPin *pin, *peer;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    if (FAILED(IAMMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin)))
+    {
+        WARN("Stream %p does not support IPin.\n", stream);
+        return NULL;
+    }
+
+    hr = IPin_ConnectedTo(pin, &peer);
+    IPin_Release(pin);
+    if (FAILED(hr))
+        return NULL;
+
+    hr = IPin_QueryInterface(peer, &IID_IMediaSeeking, (void **)&seeking);
+    IPin_Release(peer);
+    if (FAILED(hr))
+        return NULL;
+
+    return seeking;
+}
+
+static HRESULT WINAPI filter_SupportSeeking(IMediaStreamFilter *iface, BOOL renderer)
+{
+    struct filter *filter = impl_from_IMediaStreamFilter(iface);
+    unsigned int i;
+
+    TRACE("filter %p, renderer %d\n", iface, renderer);
+
+    if (!renderer)
+        FIXME("Non-renderer filter support is not yet implemented.\n");
+
+    EnterCriticalSection(&filter->cs);
+
+    if (filter->seekable_stream)
+    {
+        LeaveCriticalSection(&filter->cs);
+        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
+    }
+
+    for (i = 0; i < filter->nb_streams; ++i)
+    {
+        IMediaSeeking *seeking = get_seeking(filter->streams[i]);
+        LONGLONG duration;
+
+        if (!seeking)
+            continue;
+
+        if (SUCCEEDED(IMediaSeeking_GetDuration(seeking, &duration)))
+        {
+            filter->seekable_stream = filter->streams[i];
+            IMediaSeeking_Release(seeking);
+            LeaveCriticalSection(&filter->cs);
+            return S_OK;
+        }
+
+        IMediaSeeking_Release(seeking);
+    }
+
+    LeaveCriticalSection(&filter->cs);
+    return E_NOINTERFACE;
 }
 
 static HRESULT WINAPI filter_ReferenceTimeToStreamTime(IMediaStreamFilter *iface, REFERENCE_TIME *pTime)
@@ -608,6 +670,177 @@ static const IMediaStreamFilterVtbl filter_vtbl =
     filter_EndOfStream
 };
 
+static inline struct filter *impl_from_IMediaSeeking(IMediaSeeking *iface)
+{
+    return CONTAINING_RECORD(iface, struct filter, IMediaSeeking_iface);
+}
+
+static HRESULT WINAPI filter_seeking_QueryInterface(IMediaSeeking *iface, REFIID iid, void **out)
+{
+    struct filter *filter = impl_from_IMediaSeeking(iface);
+    return IMediaStreamFilter_QueryInterface(&filter->IMediaStreamFilter_iface, iid, out);
+}
+
+static ULONG WINAPI filter_seeking_AddRef(IMediaSeeking *iface)
+{
+    struct filter *filter = impl_from_IMediaSeeking(iface);
+    return IMediaStreamFilter_AddRef(&filter->IMediaStreamFilter_iface);
+}
+
+static ULONG WINAPI filter_seeking_Release(IMediaSeeking *iface)
+{
+    struct filter *filter = impl_from_IMediaSeeking(iface);
+    return IMediaStreamFilter_Release(&filter->IMediaStreamFilter_iface);
+}
+
+static HRESULT WINAPI filter_seeking_GetCapabilities(IMediaSeeking *iface, DWORD *capabilities)
+{
+    FIXME("iface %p, capabilities %p, stub!\n", iface, capabilities);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_CheckCapabilities(IMediaSeeking *iface, DWORD *capabilities)
+{
+    FIXME("iface %p, capabilities %p, stub!\n", iface, capabilities);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_IsFormatSupported(IMediaSeeking *iface, const GUID *format)
+{
+    FIXME("iface %p, format %s, stub!\n", iface, debugstr_guid(format));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_QueryPreferredFormat(IMediaSeeking *iface, GUID *format)
+{
+    FIXME("iface %p, format %p, stub!\n", iface, format);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetTimeFormat(IMediaSeeking *iface, GUID *format)
+{
+    FIXME("iface %p, format %p, stub!\n", iface, format);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_IsUsingTimeFormat(IMediaSeeking *iface, const GUID *format)
+{
+    FIXME("iface %p, format %s, stub!\n", iface, debugstr_guid(format));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_SetTimeFormat(IMediaSeeking *iface, const GUID *format)
+{
+    FIXME("iface %p, format %s, stub!\n", iface, debugstr_guid(format));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetDuration(IMediaSeeking *iface, LONGLONG *duration)
+{
+    FIXME("iface %p, duration %p, stub!\n", iface, duration);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetStopPosition(IMediaSeeking *iface, LONGLONG *stop)
+{
+    FIXME("iface %p, stop %p, stub!\n", iface, stop);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetCurrentPosition(IMediaSeeking *iface, LONGLONG *current)
+{
+    FIXME("iface %p, current %p, stub!\n", iface, current);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_ConvertTimeFormat(IMediaSeeking *iface, LONGLONG *target,
+        const GUID *target_format, LONGLONG source, const GUID *source_format)
+{
+    FIXME("iface %p, target %p, target_format %s, source 0x%s, source_format %s, stub!\n", iface, target, debugstr_guid(target_format),
+            wine_dbgstr_longlong(source), debugstr_guid(source_format));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_SetPositions(IMediaSeeking *iface, LONGLONG *current_ptr, DWORD current_flags,
+        LONGLONG *stop_ptr, DWORD stop_flags)
+{
+    FIXME("iface %p, current %s, current_flags %#x, stop %s, stop_flags %#x, stub!\n", iface,
+            current_ptr ? wine_dbgstr_longlong(*current_ptr) : "<null>", current_flags,
+            stop_ptr ? wine_dbgstr_longlong(*stop_ptr): "<null>", stop_flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetPositions(IMediaSeeking *iface, LONGLONG *current, LONGLONG *stop)
+{
+    FIXME("iface %p, current %p, stop %p, stub!\n", iface, current, stop);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetAvailable(IMediaSeeking *iface, LONGLONG *earliest, LONGLONG *latest)
+{
+    FIXME("iface %p, earliest %p, latest %p, stub!\n", iface, earliest, latest);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_SetRate(IMediaSeeking *iface, double rate)
+{
+    FIXME("iface %p, rate %f, stub!\n", iface, rate);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetRate(IMediaSeeking *iface, double *rate)
+{
+    FIXME("iface %p, rate %p, stub!\n", iface, rate);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetPreroll(IMediaSeeking *iface, LONGLONG *preroll)
+{
+    FIXME("iface %p, preroll %p, stub!\n", iface, preroll);
+
+    return E_NOTIMPL;
+}
+
+static const IMediaSeekingVtbl filter_seeking_vtbl =
+{
+    filter_seeking_QueryInterface,
+    filter_seeking_AddRef,
+    filter_seeking_Release,
+    filter_seeking_GetCapabilities,
+    filter_seeking_CheckCapabilities,
+    filter_seeking_IsFormatSupported,
+    filter_seeking_QueryPreferredFormat,
+    filter_seeking_GetTimeFormat,
+    filter_seeking_IsUsingTimeFormat,
+    filter_seeking_SetTimeFormat,
+    filter_seeking_GetDuration,
+    filter_seeking_GetStopPosition,
+    filter_seeking_GetCurrentPosition,
+    filter_seeking_ConvertTimeFormat,
+    filter_seeking_SetPositions,
+    filter_seeking_GetPositions,
+    filter_seeking_GetAvailable,
+    filter_seeking_SetRate,
+    filter_seeking_GetRate,
+    filter_seeking_GetPreroll,
+};
+
 HRESULT filter_create(IUnknown *outer, void **out)
 {
     struct filter *object;
@@ -621,6 +854,7 @@ HRESULT filter_create(IUnknown *outer, void **out)
         return E_OUTOFMEMORY;
 
     object->IMediaStreamFilter_iface.lpVtbl = &filter_vtbl;
+    object->IMediaSeeking_iface.lpVtbl = &filter_seeking_vtbl;
     object->refcount = 1;
     InitializeCriticalSection(&object->cs);
     object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": MediaStreamFilter.cs");
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 2c97a0aa90f..11813b5439f 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -2348,6 +2348,8 @@ struct testfilter
 {
     struct strmbase_filter filter;
     struct strmbase_source source;
+    IMediaSeeking IMediaSeeking_iface;
+    HRESULT get_duration_hr;
 };
 
 static inline struct testfilter *impl_from_BaseFilter(struct strmbase_filter *iface)
@@ -2394,6 +2396,25 @@ static const struct strmbase_filter_ops testfilter_ops =
     .filter_cleanup_stream = testfilter_cleanup_stream,
 };
 
+static inline struct testfilter *impl_from_base_pin(struct strmbase_pin *iface)
+{
+    return CONTAINING_RECORD(iface, struct testfilter, source.pin);
+}
+
+static HRESULT testsource_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
+{
+    struct testfilter *filter = impl_from_base_pin(iface);
+
+    if (IsEqualGUID(iid, &IID_IMediaSeeking) && filter->IMediaSeeking_iface.lpVtbl)
+        *out = &filter->IMediaSeeking_iface;
+    else
+        return E_NOINTERFACE;
+
+    IUnknown_AddRef((IUnknown *)*out);
+
+    return S_OK;
+}
+
 static HRESULT WINAPI testsource_DecideBufferSize(struct strmbase_source *iface,
         IMemAllocator *alloc, ALLOCATOR_PROPERTIES *requested)
 {
@@ -2413,6 +2434,7 @@ static HRESULT WINAPI testsource_DecideBufferSize(struct strmbase_source *iface,
 
 static const struct strmbase_source_ops testsource_ops =
 {
+    .base.pin_query_interface = testsource_query_interface,
     .pfnAttemptConnection = BaseOutputPinImpl_AttemptConnection,
     .pfnDecideBufferSize = testsource_DecideBufferSize,
     .pfnDecideAllocator = BaseOutputPinImpl_DecideAllocator,
@@ -2421,10 +2443,166 @@ static const struct strmbase_source_ops testsource_ops =
 static void testfilter_init(struct testfilter *filter)
 {
     static const GUID clsid = {0xabacab};
+    memset(filter, 0, sizeof(*filter));
     strmbase_filter_init(&filter->filter, NULL, &clsid, &testfilter_ops);
     strmbase_source_init(&filter->source, &filter->filter, L"", &testsource_ops);
 }
 
+static inline struct testfilter *impl_from_IMediaSeeking(IMediaSeeking *iface)
+{
+    return CONTAINING_RECORD(iface, struct testfilter, IMediaSeeking_iface);
+}
+
+static HRESULT WINAPI testsource_seeking_QueryInterface(IMediaSeeking *iface, REFIID iid, void **out)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+    return IBaseFilter_QueryInterface(&filter->filter.IBaseFilter_iface, iid, out);
+}
+
+static ULONG WINAPI testsource_seeking_AddRef(IMediaSeeking *iface)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+    return IBaseFilter_AddRef(&filter->filter.IBaseFilter_iface);
+}
+
+static ULONG WINAPI testsource_seeking_Release(IMediaSeeking *iface)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+    return IBaseFilter_Release(&filter->filter.IBaseFilter_iface);
+}
+
+static HRESULT WINAPI testsource_seeking_GetCapabilities(IMediaSeeking *iface, DWORD *capabilities)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_CheckCapabilities(IMediaSeeking *iface, DWORD *capabilities)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_IsFormatSupported(IMediaSeeking *iface, const GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_QueryPreferredFormat(IMediaSeeking *iface, GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetTimeFormat(IMediaSeeking *iface, GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_IsUsingTimeFormat(IMediaSeeking *iface, const GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_SetTimeFormat(IMediaSeeking *iface, const GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetDuration(IMediaSeeking *iface, LONGLONG *duration)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+
+    if (SUCCEEDED(filter->get_duration_hr))
+        *duration = 0x8000000000000000ULL;
+
+    return filter->get_duration_hr;
+}
+
+static HRESULT WINAPI testsource_seeking_GetStopPosition(IMediaSeeking *iface, LONGLONG *stop)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetCurrentPosition(IMediaSeeking *iface, LONGLONG *current)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_ConvertTimeFormat(IMediaSeeking *iface, LONGLONG *target,
+        const GUID *target_format, LONGLONG source, const GUID *source_format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_SetPositions(IMediaSeeking *iface, LONGLONG *current_ptr, DWORD current_flags,
+        LONGLONG *stop_ptr, DWORD stop_flags)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetPositions(IMediaSeeking *iface, LONGLONG *current, LONGLONG *stop)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetAvailable(IMediaSeeking *iface, LONGLONG *earliest, LONGLONG *latest)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_SetRate(IMediaSeeking *iface, double rate)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetRate(IMediaSeeking *iface, double *rate)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetPreroll(IMediaSeeking *iface, LONGLONG *preroll)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static const IMediaSeekingVtbl testsource_seeking_vtbl =
+{
+    testsource_seeking_QueryInterface,
+    testsource_seeking_AddRef,
+    testsource_seeking_Release,
+    testsource_seeking_GetCapabilities,
+    testsource_seeking_CheckCapabilities,
+    testsource_seeking_IsFormatSupported,
+    testsource_seeking_QueryPreferredFormat,
+    testsource_seeking_GetTimeFormat,
+    testsource_seeking_IsUsingTimeFormat,
+    testsource_seeking_SetTimeFormat,
+    testsource_seeking_GetDuration,
+    testsource_seeking_GetStopPosition,
+    testsource_seeking_GetCurrentPosition,
+    testsource_seeking_ConvertTimeFormat,
+    testsource_seeking_SetPositions,
+    testsource_seeking_GetPositions,
+    testsource_seeking_GetAvailable,
+    testsource_seeking_SetRate,
+    testsource_seeking_GetRate,
+    testsource_seeking_GetPreroll,
+};
+
 static void test_audiostream_get_format(void)
 {
     static const WAVEFORMATEX pin_format =
@@ -3903,6 +4081,143 @@ void test_mediastreamfilter_stop_pause_run(void)
     check_mediastreamfilter_state(State_Running, mediastreamfilter_run, mediastreamfilter_stop);
 }
 
+static void test_mediastreamfilter_support_seeking(void)
+{
+    static const WAVEFORMATEX format =
+    {
+        .wFormatTag = WAVE_FORMAT_PCM,
+        .nChannels = 1,
+        .nSamplesPerSec = 11025,
+        .wBitsPerSample = 16,
+        .nBlockAlign = 2,
+        .nAvgBytesPerSec = 2 * 11025,
+    };
+
+    const AM_MEDIA_TYPE mt =
+    {
+        .majortype = MEDIATYPE_Audio,
+        .subtype = MEDIASUBTYPE_PCM,
+        .formattype = FORMAT_WaveFormatEx,
+        .cbFormat = sizeof(WAVEFORMATEX),
+        .pbFormat = (BYTE *)&format,
+    };
+
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    static const MSPID mspid1 = {0x88888888, 1};
+    static const MSPID mspid2 = {0x88888888, 2};
+    static const MSPID mspid3 = {0x88888888, 3};
+    struct testfilter source1, source2, source3;
+    IAMMediaStream *stream1, *stream2, *stream3;
+    IMediaStreamFilter *filter;
+    IPin *pin1, *pin2, *pin3;
+    ULONG ref, seeking_ref;
+    IGraphBuilder *graph;
+    HRESULT hr;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream1);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream1, NULL, 0, &mspid1, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream2, NULL, 0, &mspid2, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream3, NULL, 0, &mspid3, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream1, &mspid1, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream2, &mspid2, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream3, &mspid3, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream1, &IID_IPin, (void **)&pin1);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream2, &IID_IPin, (void **)&pin2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream3, &IID_IPin, (void **)&pin3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    testfilter_init(&source1);
+    testfilter_init(&source2);
+    testfilter_init(&source3);
+    source2.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    source3.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    hr = IGraphBuilder_AddFilter(graph, &source1.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_AddFilter(graph, &source2.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_AddFilter(graph, &source3.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    source2.get_duration_hr = E_FAIL;
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    check_interface(filter, &IID_IMediaSeeking, FALSE);
+
+    seeking_ref = get_refcount(&source3.IMediaSeeking_iface);
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    check_interface(filter, &IID_IMediaSeeking, TRUE);
+
+    ref = get_refcount(&source3.IMediaSeeking_iface);
+    ok(ref == seeking_ref, "Expected outstanding refcount %d, got %d.\n", seeking_ref, ref);
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED), "Got hr %#x.\n", hr);
+
+    IGraphBuilder_Disconnect(graph, pin1);
+    IGraphBuilder_Disconnect(graph, &source1.source.pin.IPin_iface);
+
+    IGraphBuilder_Disconnect(graph, pin2);
+    IGraphBuilder_Disconnect(graph, &source2.source.pin.IPin_iface);
+
+    IGraphBuilder_Disconnect(graph, pin3);
+    IGraphBuilder_Disconnect(graph, &source3.source.pin.IPin_iface);
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin1);
+    ref = IAMMediaStream_Release(stream1);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin2);
+    ref = IAMMediaStream_Release(stream2);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin3);
+    ref = IAMMediaStream_Release(stream3);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(amstream)
 {
     HANDLE file;
@@ -3954,6 +4269,7 @@ START_TEST(amstream)
 
     test_mediastreamfilter_get_state();
     test_mediastreamfilter_stop_pause_run();
+    test_mediastreamfilter_support_seeking();
 
     CoUninitialize();
 }
From 1c99a8e0952f977cc5647744d806590c13f925bd Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 3 Jun 2020 14:28:15 -0500
Subject: [PATCH] amstream: Implement MediaStreamFilter::SetPositions().

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/filter.c         |  24 +++-
 dlls/amstream/tests/amstream.c | 245 ++++++++++++++++++++++++++++++++-
 2 files changed, 265 insertions(+), 4 deletions(-)

diff --git a/dlls/amstream/filter.c b/dlls/amstream/filter.c
index f1e0811d679..05a02e3f666 100644
--- a/dlls/amstream/filter.c
+++ b/dlls/amstream/filter.c
@@ -775,11 +775,31 @@ static HRESULT WINAPI filter_seeking_ConvertTimeFormat(IMediaSeeking *iface, LON
 static HRESULT WINAPI filter_seeking_SetPositions(IMediaSeeking *iface, LONGLONG *current_ptr, DWORD current_flags,
         LONGLONG *stop_ptr, DWORD stop_flags)
 {
-    FIXME("iface %p, current %s, current_flags %#x, stop %s, stop_flags %#x, stub!\n", iface,
+    struct filter *filter = impl_from_IMediaSeeking(iface);
+    IMediaSeeking *seeking;
+    HRESULT hr;
+
+    TRACE("iface %p, current %s, current_flags %#x, stop %s, stop_flags %#x.\n", iface,
             current_ptr ? wine_dbgstr_longlong(*current_ptr) : "<null>", current_flags,
             stop_ptr ? wine_dbgstr_longlong(*stop_ptr): "<null>", stop_flags);
 
-    return E_NOTIMPL;
+    EnterCriticalSection(&filter->cs);
+
+    seeking = get_seeking(filter->seekable_stream);
+
+    if (!seeking)
+    {
+        LeaveCriticalSection(&filter->cs);
+        return E_NOTIMPL;
+    }
+
+    hr = IMediaSeeking_SetPositions(seeking, current_ptr, current_flags, stop_ptr, stop_flags);
+
+    IMediaSeeking_Release(seeking);
+
+    LeaveCriticalSection(&filter->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI filter_seeking_GetPositions(IMediaSeeking *iface, LONGLONG *current, LONGLONG *stop)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 11813b5439f..a9d79e6b7a9 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -2349,7 +2349,10 @@ struct testfilter
     struct strmbase_filter filter;
     struct strmbase_source source;
     IMediaSeeking IMediaSeeking_iface;
+    LONGLONG current_position;
+    LONGLONG stop_position;
     HRESULT get_duration_hr;
+    HRESULT set_positions_hr;
 };
 
 static inline struct testfilter *impl_from_BaseFilter(struct strmbase_filter *iface)
@@ -2446,6 +2449,7 @@ static void testfilter_init(struct testfilter *filter)
     memset(filter, 0, sizeof(*filter));
     strmbase_filter_init(&filter->filter, NULL, &clsid, &testfilter_ops);
     strmbase_source_init(&filter->source, &filter->filter, L"", &testsource_ops);
+    filter->stop_position = 0x8000000000000000ULL;
 }
 
 static inline struct testfilter *impl_from_IMediaSeeking(IMediaSeeking *iface)
@@ -2545,8 +2549,18 @@ static HRESULT WINAPI testsource_seeking_ConvertTimeFormat(IMediaSeeking *iface,
 static HRESULT WINAPI testsource_seeking_SetPositions(IMediaSeeking *iface, LONGLONG *current_ptr, DWORD current_flags,
         LONGLONG *stop_ptr, DWORD stop_flags)
 {
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+
+    if (SUCCEEDED(filter->set_positions_hr))
+    {
+        if (current_ptr)
+            filter->current_position = *current_ptr;
+
+        if (stop_ptr)
+            filter->stop_position = *stop_ptr;
+    }
+
+    return filter->set_positions_hr;
 }
 
 static HRESULT WINAPI testsource_seeking_GetPositions(IMediaSeeking *iface, LONGLONG *current, LONGLONG *stop)
@@ -4218,6 +4232,232 @@ static void test_mediastreamfilter_support_seeking(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_mediastreamfilter_set_positions(void)
+{
+    static const WAVEFORMATEX format =
+    {
+        .wFormatTag = WAVE_FORMAT_PCM,
+        .nChannels = 1,
+        .nSamplesPerSec = 11025,
+        .wBitsPerSample = 16,
+        .nBlockAlign = 2,
+        .nAvgBytesPerSec = 2 * 11025,
+    };
+
+    const AM_MEDIA_TYPE mt =
+    {
+        .majortype = MEDIATYPE_Audio,
+        .subtype = MEDIASUBTYPE_PCM,
+        .formattype = FORMAT_WaveFormatEx,
+        .cbFormat = sizeof(WAVEFORMATEX),
+        .pbFormat = (BYTE *)&format,
+    };
+
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    static const MSPID mspid1 = {0x88888888, 1};
+    static const MSPID mspid2 = {0x88888888, 2};
+    static const MSPID mspid3 = {0x88888888, 3};
+    IMediaStreamFilter *filter;
+    struct testfilter source1;
+    struct testfilter source2;
+    struct testfilter source3;
+    LONGLONG current_position;
+    IAMMediaStream *stream1;
+    IAMMediaStream *stream2;
+    IAMMediaStream *stream3;
+    LONGLONG stop_position;
+    IMediaSeeking *seeking;
+    IGraphBuilder *graph;
+    IPin *pin1;
+    IPin *pin2;
+    IPin *pin3;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream1);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream1, NULL, 0, &mspid1, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream2, NULL, 0, &mspid2, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream3, NULL, 0, &mspid3, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream1, &mspid1, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream2, &mspid2, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream3, &mspid3, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream1, &IID_IPin, (void **)&pin1);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream2, &IID_IPin, (void **)&pin2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream3, &IID_IPin, (void **)&pin3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    testfilter_init(&source1);
+    testfilter_init(&source2);
+    testfilter_init(&source3);
+    source1.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    source2.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    source3.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    hr = IGraphBuilder_AddFilter(graph, &source1.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_AddFilter(graph, &source2.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_AddFilter(graph, &source3.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_QueryInterface(filter, &IID_IMediaSeeking, (void **)&seeking);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    current_position = 12345678;
+    stop_position = 87654321;
+    source1.current_position = 0xdeadbeefdeadbeefULL;
+    source1.stop_position = 0xdeadbeefdeadbeefULL;
+    source2.current_position = 0xdeadbeefdeadbeefULL;
+    source2.stop_position = 0xdeadbeefdeadbeefULL;
+    source3.current_position = 0xdeadbeefdeadbeefULL;
+    source3.stop_position = 0xdeadbeefdeadbeefULL;
+    hr = IMediaSeeking_SetPositions(seeking, &current_position, AM_SEEKING_AbsolutePositioning,
+            &stop_position, AM_SEEKING_AbsolutePositioning);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(source1.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source1.current_position));
+    ok(source1.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source1.stop_position));
+    ok(source2.current_position == 12345678, "Got current position %s.\n",
+            wine_dbgstr_longlong(source2.current_position));
+    ok(source2.stop_position == 87654321, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source2.stop_position));
+    ok(source3.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source3.current_position));
+    ok(source3.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source3.stop_position));
+
+    source2.set_positions_hr = E_FAIL;
+    source1.current_position = 0xdeadbeefdeadbeefULL;
+    source1.stop_position = 0xdeadbeefdeadbeefULL;
+    source3.current_position = 0xdeadbeefdeadbeefULL;
+    source3.stop_position = 0xdeadbeefdeadbeefULL;
+    current_position = 12345678;
+    stop_position = 87654321;
+    hr = IMediaSeeking_SetPositions(seeking, &current_position, AM_SEEKING_AbsolutePositioning,
+            &stop_position, AM_SEEKING_AbsolutePositioning);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(source1.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source1.current_position));
+    ok(source1.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source1.stop_position));
+    ok(source3.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source3.current_position));
+    ok(source3.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source3.stop_position));
+
+    source2.set_positions_hr = E_NOTIMPL;
+    source1.current_position = 0xdeadbeefdeadbeefULL;
+    source1.stop_position = 0xdeadbeefdeadbeefULL;
+    source3.current_position = 0xdeadbeefdeadbeefULL;
+    source3.stop_position = 0xdeadbeefdeadbeefULL;
+    current_position = 12345678;
+    stop_position = 87654321;
+    hr = IMediaSeeking_SetPositions(seeking, &current_position, AM_SEEKING_AbsolutePositioning,
+            &stop_position, AM_SEEKING_AbsolutePositioning);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(source1.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source1.current_position));
+    ok(source1.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source1.stop_position));
+    ok(source3.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source3.current_position));
+    ok(source3.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source3.stop_position));
+
+    source2.IMediaSeeking_iface.lpVtbl = NULL;
+    source1.current_position = 0xdeadbeefdeadbeefULL;
+    source1.stop_position = 0xdeadbeefdeadbeefULL;
+    source3.current_position = 0xdeadbeefdeadbeefULL;
+    source3.stop_position = 0xdeadbeefdeadbeefULL;
+    current_position = 12345678;
+    stop_position = 87654321;
+    hr = IMediaSeeking_SetPositions(seeking, &current_position, AM_SEEKING_AbsolutePositioning,
+            &stop_position, AM_SEEKING_AbsolutePositioning);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(source1.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source1.current_position));
+    ok(source1.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source1.stop_position));
+    ok(source3.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source3.current_position));
+    ok(source3.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source3.stop_position));
+
+    IGraphBuilder_Disconnect(graph, pin2);
+    IGraphBuilder_Disconnect(graph, &source2.source.pin.IPin_iface);
+
+    source2.IMediaSeeking_iface.lpVtbl = NULL;
+    source1.current_position = 0xdeadbeefdeadbeefULL;
+    source1.stop_position = 0xdeadbeefdeadbeefULL;
+    source3.current_position = 0xdeadbeefdeadbeefULL;
+    source3.stop_position = 0xdeadbeefdeadbeefULL;
+    current_position = 12345678;
+    stop_position = 87654321;
+    hr = IMediaSeeking_SetPositions(seeking, &current_position, AM_SEEKING_AbsolutePositioning,
+            &stop_position, AM_SEEKING_AbsolutePositioning);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(source1.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source1.current_position));
+    ok(source1.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source1.stop_position));
+    ok(source3.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source3.current_position));
+    ok(source3.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source3.stop_position));
+
+    IGraphBuilder_Disconnect(graph, pin2);
+    IGraphBuilder_Disconnect(graph, &source2.source.pin.IPin_iface);
+    IGraphBuilder_Disconnect(graph, pin3);
+    IGraphBuilder_Disconnect(graph, &source3.source.pin.IPin_iface);
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IMediaSeeking_Release(seeking);
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin1);
+    ref = IAMMediaStream_Release(stream1);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin2);
+    ref = IAMMediaStream_Release(stream2);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin3);
+    ref = IAMMediaStream_Release(stream3);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(amstream)
 {
     HANDLE file;
@@ -4270,6 +4510,7 @@ START_TEST(amstream)
     test_mediastreamfilter_get_state();
     test_mediastreamfilter_stop_pause_run();
     test_mediastreamfilter_support_seeking();
+    test_mediastreamfilter_set_positions();
 
     CoUninitialize();
 }
From aba27fd5a3241635adb15fa7ef40aa43bf3978a1 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 3 Jun 2020 14:28:16 -0500
Subject: [PATCH] amstream: Call MediaStreamFilter::SupportSeeking() in
 AMMultiMediaStream::OpenFile().

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/multimedia.c     | 2 ++
 dlls/amstream/tests/amstream.c | 4 ++++
 2 files changed, 6 insertions(+)

diff --git a/dlls/amstream/multimedia.c b/dlls/amstream/multimedia.c
index e77392e483a..e058e639ddb 100644
--- a/dlls/amstream/multimedia.c
+++ b/dlls/amstream/multimedia.c
@@ -442,6 +442,8 @@ static HRESULT WINAPI multimedia_stream_OpenFile(IAMMultiMediaStream *iface,
     if (SUCCEEDED(ret) && !(flags & AMMSF_NORENDER))
         ret = IGraphBuilder_Render(This->graph, This->ipin);
 
+    IMediaStreamFilter_SupportSeeking(This->filter, This->type == STREAMTYPE_READ);
+
     if (EnumPins)
         IEnumPins_Release(EnumPins);
     if (BaseFilter)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index a9d79e6b7a9..f082b78347a 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -224,9 +224,13 @@ static void test_openfile(void)
     if (pgraph)
         IGraphBuilder_Release(pgraph);
 
+    check_interface(pams, &IID_IMediaSeeking, FALSE);
+
     hr = IAMMultiMediaStream_OpenFile(pams, L"test.avi", 0);
     ok(hr==S_OK, "IAMMultiMediaStream_OpenFile returned: %x\n", hr);
 
+    check_interface(pams, &IID_IMediaSeeking, TRUE);
+
     hr = IAMMultiMediaStream_GetFilterGraph(pams, &pgraph);
     ok(hr==S_OK, "IAMMultiMediaStream_GetFilterGraph returned: %x\n", hr);
     ok(pgraph!=NULL, "Filtergraph should be created\n");
From 3d92885390513d28532c2926f2cb1041ead3a5a3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 3 Jun 2020 20:52:32 -0500
Subject: [PATCH] amstream/tests: Define and use a global variable holding an
 audio media type.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 220 +++++++--------------------------
 1 file changed, 44 insertions(+), 176 deletions(-)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index f082b78347a..2bc1310a96b 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -29,6 +29,26 @@
 #include "ksmedia.h"
 #include "wine/strmbase.h"
 
+static const WAVEFORMATEX audio_format =
+{
+    .wFormatTag = WAVE_FORMAT_PCM,
+    .nChannels = 1,
+    .nSamplesPerSec = 11025,
+    .wBitsPerSample = 16,
+    .nBlockAlign = 2,
+    .nAvgBytesPerSec = 2 * 11025,
+};
+
+static const AM_MEDIA_TYPE audio_mt =
+{
+    /* MEDIATYPE_Audio, MEDIASUBTYPE_PCM, FORMAT_WaveFormatEx */
+    .majortype = {0x73647561, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}},
+    .subtype = {0x00000001, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}},
+    .formattype = {0x05589f81, 0xc356, 0x11ce, {0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a}},
+    .cbFormat = sizeof(WAVEFORMATEX),
+    .pbFormat = (BYTE *)&audio_format,
+};
+
 static const WCHAR primary_video_sink_id[] = L"I{A35FF56A-9FDA-11D0-8FDF-00C04FD9189D}";
 static const WCHAR primary_audio_sink_id[] = L"I{A35FF56B-9FDA-11D0-8FDF-00C04FD9189D}";
 
@@ -2888,25 +2908,6 @@ static void test_audiostream_set_format(void)
 
 static void test_audiostream_receive_connection(void)
 {
-    static const WAVEFORMATEX valid_format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 2,
-        .nSamplesPerSec = 44100,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 4,
-        .nAvgBytesPerSec = 4 * 44100,
-    };
-
-    const AM_MEDIA_TYPE valid_mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&valid_format,
-    };
-
     WAVEFORMATEXTENSIBLE extensible_format;
     IAudioMediaStream *audio_stream;
     IAMMultiMediaStream *mmstream;
@@ -2933,56 +2934,56 @@ static void test_audiostream_receive_connection(void)
     hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &valid_mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     IGraphBuilder_Disconnect(graph, pin);
     IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
 
-    mt = valid_mt;
+    mt = audio_mt;
     mt.majortype = GUID_NULL;
     hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &mt);
     ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
 
-    mt = valid_mt;
+    mt = audio_mt;
     mt.subtype = MEDIASUBTYPE_RGB24;
     hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     IGraphBuilder_Disconnect(graph, pin);
     IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
 
-    mt = valid_mt;
+    mt = audio_mt;
     mt.formattype = GUID_NULL;
     hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &mt);
     ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
 
-    mt = valid_mt;
+    mt = audio_mt;
     mt.cbFormat = sizeof(WAVEFORMATEX) - 1;
     hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
     ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
 
-    extensible_format.Format = valid_format;
+    extensible_format.Format = audio_format;
     extensible_format.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
     extensible_format.Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
-    extensible_format.Samples.wValidBitsPerSample = valid_format.wBitsPerSample;
+    extensible_format.Samples.wValidBitsPerSample = audio_format.wBitsPerSample;
     extensible_format.dwChannelMask = KSAUDIO_SPEAKER_STEREO;
     extensible_format.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
-    mt = valid_mt;
+    mt = audio_mt;
     mt.cbFormat = sizeof(extensible_format);
     mt.pbFormat = (BYTE *)&extensible_format;
     hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
     ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
-    hr = IAudioMediaStream_SetFormat(audio_stream, &valid_format);
+    hr = IAudioMediaStream_SetFormat(audio_stream, &audio_format);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    format = valid_format;
-    format.nChannels = 1;
-    mt = valid_mt;
+    format = audio_format;
+    format.nChannels = 2;
+    mt = audio_mt;
     mt.pbFormat = (BYTE *)&format;
     hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
     ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &valid_mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     IGraphBuilder_Disconnect(graph, pin);
     IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
@@ -3035,25 +3036,6 @@ static void test_audiostream_set_state(void)
 
 void test_audiostream_end_of_stream(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     struct testfilter source;
     IGraphBuilder *graph;
@@ -3075,7 +3057,7 @@ void test_audiostream_end_of_stream(void)
     hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_EndOfStream(pin);
@@ -3113,25 +3095,6 @@ void test_audiostream_end_of_stream(void)
 
 static void test_audiostream_receive(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     ALLOCATOR_PROPERTIES properties =
     {
         .cBuffers = 3,
@@ -3171,7 +3134,7 @@ static void test_audiostream_receive(void)
     hr = IMemAllocator_Commit(allocator);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample1, NULL, NULL, 0);
@@ -3282,25 +3245,6 @@ static void test_audiostream_initialize(void)
 
 static void test_audiostream_begin_flush_end_flush(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     IAudioStreamSample *stream_sample;
     IAudioMediaStream *audio_stream;
@@ -3334,7 +3278,7 @@ static void test_audiostream_begin_flush_end_flush(void)
     hr = IAudioMediaStream_CreateSample(audio_stream, audio_data, 0, &stream_sample);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
@@ -3455,25 +3399,6 @@ static DWORD CALLBACK audiostream_receive(void *param)
 
 static void test_audiostreamsample_update(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     static const BYTE test_data[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     IAudioStreamSample *stream_sample;
@@ -3542,7 +3467,7 @@ static void test_audiostreamsample_update(void)
 
     hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -3697,25 +3622,6 @@ static void test_audiostreamsample_update(void)
 
 void test_audiostreamsample_completion_status(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     static const BYTE test_data[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     IAudioStreamSample *stream_sample1;
@@ -3762,7 +3668,7 @@ void test_audiostreamsample_completion_status(void)
     hr = IAudioMediaStream_CreateSample(audio_stream, audio_data2, 0, &stream_sample2);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -4101,25 +4007,6 @@ void test_mediastreamfilter_stop_pause_run(void)
 
 static void test_mediastreamfilter_support_seeking(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     static const MSPID mspid1 = {0x88888888, 1};
     static const MSPID mspid2 = {0x88888888, 2};
@@ -4178,7 +4065,7 @@ static void test_mediastreamfilter_support_seeking(void)
     hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
     ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     source2.get_duration_hr = E_FAIL;
@@ -4186,13 +4073,13 @@ static void test_mediastreamfilter_support_seeking(void)
     hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
     ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
     ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_interface(filter, &IID_IMediaSeeking, FALSE);
@@ -4238,25 +4125,6 @@ static void test_mediastreamfilter_support_seeking(void)
 
 static void test_mediastreamfilter_set_positions(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     static const MSPID mspid1 = {0x88888888, 1};
     static const MSPID mspid2 = {0x88888888, 2};
@@ -4322,15 +4190,15 @@ static void test_mediastreamfilter_set_positions(void)
     hr = IGraphBuilder_AddFilter(graph, &source3.filter.IBaseFilter_iface, NULL);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaStreamFilter_QueryInterface(filter, &IID_IMediaSeeking, (void **)&seeking);
From 56e72e071dfa0fd9954f765fabf8e2a9ccb01af1 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Wed, 3 Jun 2020 22:38:39 -0600
Subject: [PATCH] quartz/tests: Fix overflow in 32-bit time calculation.

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/systemclock.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/quartz/tests/systemclock.c b/dlls/quartz/tests/systemclock.c
index 71a7ac26d84..f13e89abedb 100644
--- a/dlls/quartz/tests/systemclock.c
+++ b/dlls/quartz/tests/systemclock.c
@@ -183,7 +183,7 @@ static void test_get_time(void)
     if (pGetTickCount64)
         time2 = pGetTickCount64() * 10000;
     else
-        time2 = GetTickCount() * 10000;
+        time2 = (REFERENCE_TIME)GetTickCount() * 10000;
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time1 % 10000 == 0, "Expected no less than 1ms coarseness, but got time %s.\n",
             wine_dbgstr_longlong(time1));
From 2680b076e33747bd20dcd283f6d526b1130d079d Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Mon, 8 Jun 2020 10:17:22 -0500
Subject: [PATCH] quartz/filtergraph: Add a stub IVideoFrameStep interface.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=42372
Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 57 ++++++++++++++++++++++++++++++++-
 dlls/quartz/tests/filtergraph.c |  1 +
 include/axextend.idl            | 13 ++++++++
 3 files changed, 70 insertions(+), 1 deletion(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 6217516db1e..918c41a3d67 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -181,7 +181,7 @@ typedef struct _IFilterGraphImpl {
     /* IRegisterServiceProvider */
     /* IResourceManager */
     /* IServiceProvider */
-    /* IVideoFrameStep */
+    IVideoFrameStep IVideoFrameStep_iface;
 
     IUnknown *outer_unk;
     LONG ref;
@@ -454,6 +454,9 @@ static HRESULT WINAPI FilterGraphInner_QueryInterface(IUnknown *iface, REFIID ri
     } else if (IsEqualGUID(&IID_IGraphVersion, riid)) {
         *ppvObj = &This->IGraphVersion_iface;
         TRACE("   returning IGraphVersion interface (%p)\n", *ppvObj);
+    } else if (IsEqualGUID(&IID_IVideoFrameStep, riid)) {
+        *ppvObj = &This->IVideoFrameStep_iface;
+        TRACE("   returning IVideoFrameStep interface (%p)\n", *ppvObj);
     } else {
         *ppvObj = NULL;
 	FIXME("unknown interface %s\n", debugstr_guid(riid));
@@ -5638,6 +5641,57 @@ static const IGraphVersionVtbl IGraphVersion_VTable =
     GraphVersion_QueryVersion,
 };
 
+static IFilterGraphImpl *impl_from_IVideoFrameStep(IVideoFrameStep *iface)
+{
+    return CONTAINING_RECORD(iface, IFilterGraphImpl, IVideoFrameStep_iface);
+}
+
+static HRESULT WINAPI VideoFrameStep_QueryInterface(IVideoFrameStep *iface, REFIID iid, void **out)
+{
+    IFilterGraphImpl *graph = impl_from_IVideoFrameStep(iface);
+    return IUnknown_QueryInterface(graph->outer_unk, iid, out);
+}
+
+static ULONG WINAPI VideoFrameStep_AddRef(IVideoFrameStep *iface)
+{
+    IFilterGraphImpl *graph = impl_from_IVideoFrameStep(iface);
+    return IUnknown_AddRef(graph->outer_unk);
+}
+
+static ULONG WINAPI VideoFrameStep_Release(IVideoFrameStep *iface)
+{
+    IFilterGraphImpl *graph = impl_from_IVideoFrameStep(iface);
+    return IUnknown_Release(graph->outer_unk);
+}
+
+static HRESULT WINAPI VideoFrameStep_Step(IVideoFrameStep *iface, DWORD frame_count, IUnknown *filter)
+{
+    FIXME("iface %p, frame_count %u, filter %p, stub!\n", iface, frame_count, filter);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI VideoFrameStep_CanStep(IVideoFrameStep *iface, LONG multiple, IUnknown *filter)
+{
+    FIXME("iface %p, multiple %d, filter %p, stub!\n", iface, multiple, filter);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI VideoFrameStep_CancelStep(IVideoFrameStep *iface)
+{
+    FIXME("iface %p, stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static const IVideoFrameStepVtbl VideoFrameStep_vtbl =
+{
+    VideoFrameStep_QueryInterface,
+    VideoFrameStep_AddRef,
+    VideoFrameStep_Release,
+    VideoFrameStep_Step,
+    VideoFrameStep_CanStep,
+    VideoFrameStep_CancelStep
+};
+
 static const IUnknownVtbl IInner_VTable =
 {
     FilterGraphInner_QueryInterface,
@@ -5668,6 +5722,7 @@ static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL
     fimpl->IMediaPosition_iface.lpVtbl = &IMediaPosition_VTable;
     fimpl->IObjectWithSite_iface.lpVtbl = &IObjectWithSite_VTable;
     fimpl->IGraphVersion_iface.lpVtbl = &IGraphVersion_VTable;
+    fimpl->IVideoFrameStep_iface.lpVtbl = &VideoFrameStep_vtbl;
     fimpl->ref = 1;
     list_init(&fimpl->filters);
     list_init(&fimpl->sorted_filters);
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index f0aa084192d..a3378efe0be 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -125,6 +125,7 @@ static void test_interfaces(void)
     check_interface(graph, &IID_IMediaPosition, TRUE);
     check_interface(graph, &IID_IMediaSeeking, TRUE);
     check_interface(graph, &IID_IObjectWithSite, TRUE);
+    check_interface(graph, &IID_IVideoFrameStep, TRUE);
     check_interface(graph, &IID_IVideoWindow, TRUE);
 
     check_interface(graph, &IID_IBaseFilter, FALSE);
diff --git a/include/axextend.idl b/include/axextend.idl
index 8b46d665b5d..7630ea247c4 100644
--- a/include/axextend.idl
+++ b/include/axextend.idl
@@ -1471,3 +1471,16 @@ interface IAMTVTuner : IAMTuner
     HRESULT get_VideoFrequency([out] long *freq);
     HRESULT get_AudioFrequency([out] long *freq);
 }
+
+[
+    local,
+    object,
+    uuid(e46a9787-2b71-444d-a4b5-1fab7b708d6a),
+    pointer_default(unique),
+]
+interface IVideoFrameStep : IUnknown
+{
+    HRESULT Step(DWORD frame_count, [in] IUnknown *filter);
+    HRESULT CanStep(long multiple, [in] IUnknown *filter);
+    HRESULT CancelStep();
+}
From 2cf4b6016e3b1dffb59ccfaf55199380ebf64b65 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 6 Jun 2020 16:03:13 -0500
Subject: [PATCH] strmbase: Clear the debug info before calling
 DeleteCriticalSection (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/strmbase/filter.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/dlls/strmbase/filter.c b/dlls/strmbase/filter.c
index 2809832ee82..8b8182a13ab 100644
--- a/dlls/strmbase/filter.c
+++ b/dlls/strmbase/filter.c
@@ -532,11 +532,13 @@ void strmbase_filter_init(struct strmbase_filter *filter, IUnknown *outer,
     filter->ops = ops;
 }
 
-void strmbase_filter_cleanup(struct strmbase_filter *This)
+void strmbase_filter_cleanup(struct strmbase_filter *filter)
 {
-    if (This->clock)
-        IReferenceClock_Release(This->clock);
+    if (filter->clock)
+        IReferenceClock_Release(filter->clock);
 
-    This->IBaseFilter_iface.lpVtbl = NULL;
-    DeleteCriticalSection(&This->csFilter);
+    filter->IBaseFilter_iface.lpVtbl = NULL;
+    if (filter->csFilter.DebugInfo != (RTL_CRITICAL_SECTION_DEBUG *)-1)
+        filter->csFilter.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&filter->csFilter);
 }
From 07729ea4ef7d53dc39f32d47f7bf9f1b7e3a5f1b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 6 Jun 2020 16:22:44 -0500
Subject: [PATCH] strmbase: Avoid leaking the media type on failure in
 IEnumMediaTypes::Next().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/strmbase/pin.c | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/dlls/strmbase/pin.c b/dlls/strmbase/pin.c
index eab7c0cb2e4..f08c6d01865 100644
--- a/dlls/strmbase/pin.c
+++ b/dlls/strmbase/pin.c
@@ -119,6 +119,7 @@ static HRESULT WINAPI enum_media_types_Next(IEnumMediaTypes *iface, ULONG count,
         AM_MEDIA_TYPE **mts, ULONG *ret_count)
 {
     struct enum_media_types *enummt = impl_from_IEnumMediaTypes(iface);
+    AM_MEDIA_TYPE mt;
     unsigned int i;
     HRESULT hr;
 
@@ -133,10 +134,14 @@ static HRESULT WINAPI enum_media_types_Next(IEnumMediaTypes *iface, ULONG count,
 
     for (i = 0; i < count; ++i)
     {
-        if ((mts[i] = CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE))))
-            hr = enummt->pin->ops->pin_get_media_type(enummt->pin, enummt->index + i, mts[i]);
-        else
-            hr = E_OUTOFMEMORY;
+        hr = enummt->pin->ops->pin_get_media_type(enummt->pin, enummt->index + i, &mt);
+        if (hr == S_OK)
+        {
+            if ((mts[i] = CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE))))
+                *mts[i] = mt;
+            else
+                hr = E_OUTOFMEMORY;
+        }
         if (FAILED(hr))
         {
             while (i--)
From 036fcf96c83cddee001ef1f3358a7fa25d1db839 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 7 Jun 2020 16:24:44 -0500
Subject: [PATCH] quartz/tests: Avoid leaking the media type from
 IPin::ConnectionMediaType() (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/avidec.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/quartz/tests/avidec.c b/dlls/quartz/tests/avidec.c
index 0e1e92a9509..9505bfb591d 100644
--- a/dlls/quartz/tests/avidec.c
+++ b/dlls/quartz/tests/avidec.c
@@ -967,6 +967,7 @@ static void test_connect_pin(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsource.source.pin.mt, &req_mt), "Media types didn't match.\n");
+    FreeMediaType(&mt);
 
     sink_bih = req_format.bmiHeader;
 
@@ -1072,6 +1073,7 @@ static void test_connect_pin(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsink.sink.pin.mt, &req_mt), "Media types didn't match.\n");
+    FreeMediaType(&mt);
 
     hr = IFilterGraph2_Disconnect(graph, source);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
From 4beda167575f24eaed7da4ee3cbbc92f6bea6339 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 7 Jun 2020 17:23:29 -0500
Subject: [PATCH] quartz: Free type libraries on process detach (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/main.c       |  5 ++++-
 dlls/strmbase/dispatch.c | 13 +++++++++++++
 include/wine/strmbase.h  |  1 +
 3 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/dlls/quartz/main.c b/dlls/quartz/main.c
index 4acb4f1a795..303cc30a931 100644
--- a/dlls/quartz/main.c
+++ b/dlls/quartz/main.c
@@ -31,8 +31,11 @@ LONG object_locks = 0;
 
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
-    if (reason == DLL_PROCESS_DETACH)
+    if (reason == DLL_PROCESS_DETACH && !reserved)
+    {
         video_window_unregister_class();
+        strmbase_release_typelibs();
+    }
     return QUARTZ_DllMain(instance, reason, reserved);
 }
 
diff --git a/dlls/strmbase/dispatch.c b/dlls/strmbase/dispatch.c
index 25573fa1a26..de817f20c0d 100644
--- a/dlls/strmbase/dispatch.c
+++ b/dlls/strmbase/dispatch.c
@@ -68,3 +68,16 @@ HRESULT strmbase_get_typeinfo(enum strmbase_type_id tid, ITypeInfo **ret)
     ITypeInfo_AddRef(*ret = control_typeinfo[tid]);
     return S_OK;
 }
+
+void strmbase_release_typelibs(void)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(control_typeinfo); ++i)
+    {
+        if (control_typeinfo[i])
+            ITypeInfo_Release(control_typeinfo[i]);
+    }
+    if (control_typelib)
+        ITypeLib_Release(control_typelib);
+}
diff --git a/include/wine/strmbase.h b/include/wine/strmbase.h
index 6789957e50a..02a5469de17 100644
--- a/include/wine/strmbase.h
+++ b/include/wine/strmbase.h
@@ -252,6 +252,7 @@ enum strmbase_type_id
 };
 
 HRESULT strmbase_get_typeinfo(enum strmbase_type_id tid, ITypeInfo **typeinfo);
+void strmbase_release_typelibs(void);
 
 struct strmbase_passthrough
 {
From 0e6fc4d81cceb46af52e0b83122ce5f6dd1b6961 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 7 Jun 2020 17:23:30 -0500
Subject: [PATCH] qedit: Free type libraries on process detach (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qedit/main.c          | 21 ++++++++++++---------
 dlls/qedit/mediadet.c      |  1 -
 dlls/qedit/qedit_private.h |  1 +
 dlls/qedit/samplegrabber.c |  1 -
 4 files changed, 13 insertions(+), 11 deletions(-)

diff --git a/dlls/qedit/main.c b/dlls/qedit/main.c
index f4d1bbb0613..a4a4f5ec38c 100644
--- a/dlls/qedit/main.c
+++ b/dlls/qedit/main.c
@@ -23,15 +23,18 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(qedit);
 
-static HINSTANCE instance;
+static HINSTANCE qedit_instance;
 
-BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpv)
+BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
-    switch(fdwReason) {
-        case DLL_PROCESS_ATTACH:
-            instance = hInstDLL;
-            DisableThreadLibraryCalls(hInstDLL);
-            break;
+    if (reason == DLL_PROCESS_ATTACH)
+    {
+        qedit_instance = instance;
+        DisableThreadLibraryCalls(instance);
+    }
+    else if (reason == DLL_PROCESS_DETACH && !reserved)
+    {
+        strmbase_release_typelibs();
     }
     return TRUE;
 }
@@ -243,7 +246,7 @@ HRESULT WINAPI DllRegisterServer(void)
     IFilterMapper2 *mapper;
     HRESULT hr;
 
-    if (FAILED(hr = __wine_register_resources( instance )))
+    if (FAILED(hr = __wine_register_resources(qedit_instance)))
         return hr;
 
     if (FAILED(hr = CoCreateInstance(&CLSID_FilterMapper2, NULL, CLSCTX_INPROC_SERVER,
@@ -267,7 +270,7 @@ HRESULT WINAPI DllUnregisterServer(void)
     IFilterMapper2 *mapper;
     HRESULT hr;
 
-    if (FAILED(hr = __wine_unregister_resources( instance )))
+    if (FAILED(hr = __wine_unregister_resources(qedit_instance)))
         return hr;
 
     if (FAILED(hr = CoCreateInstance(&CLSID_FilterMapper2, NULL, CLSCTX_INPROC_SERVER,
diff --git a/dlls/qedit/mediadet.c b/dlls/qedit/mediadet.c
index d32679b6bb8..e1defaa9a67 100644
--- a/dlls/qedit/mediadet.c
+++ b/dlls/qedit/mediadet.c
@@ -28,7 +28,6 @@
 #include "ole2.h"
 
 #include "qedit_private.h"
-#include "wine/strmbase.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qedit);
diff --git a/dlls/qedit/qedit_private.h b/dlls/qedit/qedit_private.h
index 7011c9f70dd..0c0655084d5 100644
--- a/dlls/qedit/qedit_private.h
+++ b/dlls/qedit/qedit_private.h
@@ -32,6 +32,7 @@
 #include "winuser.h"
 #include "dshow.h"
 #include "qedit.h"
+#include "wine/strmbase.h"
 
 HRESULT timeline_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
 HRESULT media_detector_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
diff --git a/dlls/qedit/samplegrabber.c b/dlls/qedit/samplegrabber.c
index bd8480df48b..1619111f95d 100644
--- a/dlls/qedit/samplegrabber.c
+++ b/dlls/qedit/samplegrabber.c
@@ -29,7 +29,6 @@
 
 #include "qedit_private.h"
 #include "wine/debug.h"
-#include "wine/strmbase.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qedit);
 
From b6c96cf763b2994b9b71d8a53988749d7dea1914 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 7 Jun 2020 17:23:31 -0500
Subject: [PATCH] qasf: Free type libraries on process detach (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qasf/qasf_main.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/qasf/qasf_main.c b/dlls/qasf/qasf_main.c
index 2e65b693fa0..ac671d3919c 100644
--- a/dlls/qasf/qasf_main.c
+++ b/dlls/qasf/qasf_main.c
@@ -108,6 +108,10 @@ BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
         DisableThreadLibraryCalls(instance);
         qasf_instance = instance;
     }
+    else if (reason == DLL_PROCESS_DETACH && !reserved)
+    {
+        strmbase_release_typelibs();
+    }
     return TRUE;
 }
 
From 05f319a39477ff675f14cd9ed6765ce3a5900e11 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Jun 2020 18:59:41 -0500
Subject: [PATCH] strmbase: Release the allocator in IPin::Disconnect()
 (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/videorenderer.c |  2 +-
 dlls/quartz/tests/vmr9.c          |  2 +-
 dlls/strmbase/pin.c               | 13 +++++++++++++
 3 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/dlls/quartz/tests/videorenderer.c b/dlls/quartz/tests/videorenderer.c
index 7330859466e..d603ea46edd 100644
--- a/dlls/quartz/tests/videorenderer.c
+++ b/dlls/quartz/tests/videorenderer.c
@@ -1443,7 +1443,7 @@ static void test_connect_pin(void)
     ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     ref = IMemAllocator_Release(allocator);
-    todo_wine ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IMemInputPin_Release(input);
     IPin_Release(pin);
     ref = IFilterGraph2_Release(graph);
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 7dd6dbe1dd2..14b6539a6bd 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -3072,7 +3072,7 @@ static void test_renderless_formats(void)
         ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
 
         hr = IMemInputPin_GetAllocator(input, &allocator);
-        todo_wine_if (i == 0) ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
+        todo_wine ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
         if (hr != S_OK)
         {
             test_allocator(input);
diff --git a/dlls/strmbase/pin.c b/dlls/strmbase/pin.c
index f08c6d01865..e5017c2ff98 100644
--- a/dlls/strmbase/pin.c
+++ b/dlls/strmbase/pin.c
@@ -594,6 +594,13 @@ static HRESULT WINAPI source_Disconnect(IPin *iface)
             IMemInputPin_Release(This->pMemInputPin);
             This->pMemInputPin = NULL;
         }
+
+        if (This->pAllocator)
+        {
+            IMemAllocator_Release(This->pAllocator);
+            This->pAllocator = NULL;
+        }
+
         if (This->pin.peer)
         {
             IPin_Release(This->pin.peer);
@@ -930,6 +937,12 @@ static HRESULT WINAPI sink_Disconnect(IPin *iface)
         if (pin->pFuncsTable->sink_disconnect)
             pin->pFuncsTable->sink_disconnect(pin);
 
+        if (pin->pAllocator)
+        {
+            IMemAllocator_Release(pin->pAllocator);
+            pin->pAllocator = NULL;
+        }
+
         IPin_Release(pin->pin.peer);
         pin->pin.peer = NULL;
         FreeMediaType(&pin->pin.mt);
From 609a832a56b0e313013b05eb5e9e609887b03544 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 10 Jun 2020 23:09:06 +0700
Subject: [PATCH] quartz/filtergraph: Always try to query IMediaSeeking if it's
 not cached yet.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 33 +++++++++++++++++++------
 dlls/quartz/tests/filtergraph.c | 43 ++++++++++++++++++++++++++++++---
 2 files changed, 65 insertions(+), 11 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 918c41a3d67..b1968069b86 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -588,6 +588,21 @@ static BOOL has_output_pins(IBaseFilter *filter)
     return FALSE;
 }
 
+static void update_seeking(struct filter *filter)
+{
+    if (!filter->seeking)
+    {
+        /* The Legend of Heroes: Trails of Cold Steel II destroys its filter when
+         * its IMediaSeeking interface is released, so cache the interface instead
+         * of querying for it every time.
+         * Some filters (e.g. MediaStreamFilter) can become seekable when they are
+         * already in the graph, so always try to query IMediaSeeking if it's not
+         * cached yet. */
+        if (FAILED(IBaseFilter_QueryInterface(filter->filter, &IID_IMediaSeeking, (void **)&filter->seeking)))
+            filter->seeking = NULL;
+    }
+}
+
 static BOOL is_renderer(struct filter *filter)
 {
     IAMFilterMiscFlags *flags;
@@ -599,8 +614,12 @@ static BOOL is_renderer(struct filter *filter)
             ret = TRUE;
         IAMFilterMiscFlags_Release(flags);
     }
-    else if (filter->seeking && !has_output_pins(filter->filter))
-        ret = TRUE;
+    else
+    {
+        update_seeking(filter);
+        if (filter->seeking && !has_output_pins(filter->filter))
+            ret = TRUE;
+    }
     return ret;
 }
 
@@ -666,15 +685,10 @@ static HRESULT WINAPI FilterGraph2_AddFilter(IFilterGraph2 *iface,
 
     IBaseFilter_AddRef(entry->filter = filter);
 
-    /* The Legend of Heroes: Trails of Cold Steel II destroys its filter when
-     * its IMediaSeeking interface is released, so cache the interface instead
-     * of querying for it every time. */
-    if (FAILED(IBaseFilter_QueryInterface(filter, &IID_IMediaSeeking, (void **)&entry->seeking)))
-        entry->seeking = NULL;
-
     list_add_head(&graph->filters, &entry->entry);
     list_add_head(&graph->sorted_filters, &entry->sorted_entry);
     entry->sorting = FALSE;
+    entry->seeking = NULL;
     ++graph->version;
 
     if (is_renderer(entry))
@@ -2252,6 +2266,7 @@ static HRESULT all_renderers_seek(IFilterGraphImpl *This, fnFoundSeek FoundSeek,
 
     LIST_FOR_EACH_ENTRY(filter, &This->filters, struct filter, entry)
     {
+        update_seeking(filter);
         if (!filter->seeking)
             continue;
         hr = FoundSeek(This, filter->seeking, arg);
@@ -2457,6 +2472,7 @@ static HRESULT WINAPI MediaSeeking_GetStopPosition(IMediaSeeking *iface, LONGLON
 
     LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
+        update_seeking(filter);
         if (!filter->seeking)
             continue;
 
@@ -2565,6 +2581,7 @@ static HRESULT WINAPI MediaSeeking_SetPositions(IMediaSeeking *iface, LONGLONG *
     {
         LONGLONG current = current_ptr ? *current_ptr : 0, stop = stop_ptr ? *stop_ptr : 0;
 
+        update_seeking(filter);
         if (!filter->seeking)
             continue;
 
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index a3378efe0be..d1c081681a3 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -3619,6 +3619,17 @@ static void test_ec_complete(void)
     ok(filter3.ref == 1, "Got outstanding refcount %d.\n", filter3.ref);
 }
 
+/* Remove and re-add the filter, to flush the graph's internal
+ * IMediaSeeking cache. Don't expose IMediaSeeking when adding, to show
+ * that it's only queried when needed. */
+static void flush_cached_seeking(IFilterGraph2 *graph, struct testfilter *filter)
+{
+    IFilterGraph2_RemoveFilter(graph, &filter->IBaseFilter_iface);
+    filter->IMediaSeeking_iface.lpVtbl = NULL;
+    IFilterGraph2_AddFilter(graph, &filter->IBaseFilter_iface, NULL);
+    filter->IMediaSeeking_iface.lpVtbl = &testseek_vtbl;
+}
+
 static void test_graph_seeking(void)
 {
     struct testfilter filter1, filter2;
@@ -3659,9 +3670,6 @@ static void test_graph_seeking(void)
     testfilter_init(&filter1, NULL, 0);
     testfilter_init(&filter2, NULL, 0);
 
-    filter1.IMediaSeeking_iface.lpVtbl = &testseek_vtbl;
-    filter2.IMediaSeeking_iface.lpVtbl = &testseek_vtbl;
-
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaSeeking, (void **)&seeking);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaFilter, (void **)&filter);
@@ -3824,6 +3832,8 @@ static void test_graph_seeking(void)
 
     IFilterGraph2_AddFilter(graph, &filter1.IBaseFilter_iface, NULL);
     IFilterGraph2_AddFilter(graph, &filter2.IBaseFilter_iface, NULL);
+    filter1.IMediaSeeking_iface.lpVtbl = &testseek_vtbl;
+    filter2.IMediaSeeking_iface.lpVtbl = &testseek_vtbl;
 
     filter1.seek_caps = AM_SEEKING_CanDoSegments | AM_SEEKING_CanGetCurrentPos;
     filter2.seek_caps = AM_SEEKING_CanDoSegments | AM_SEEKING_CanGetDuration;
@@ -3833,6 +3843,9 @@ static void test_graph_seeking(void)
     ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
     ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter2.seeking_ref);
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     caps = AM_SEEKING_CanDoSegments | AM_SEEKING_CanGetCurrentPos;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
     ok(hr == S_FALSE, "Got hr %#x.\n", hr);
@@ -3848,6 +3861,9 @@ static void test_graph_seeking(void)
     ok(hr == E_FAIL, "Got hr %#x.\n", hr);
     ok(!caps, "Got caps %#x.\n", caps);
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     hr = IMediaSeeking_IsFormatSupported(seeking, &testguid);
     ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
@@ -3905,6 +3921,9 @@ static void test_graph_seeking(void)
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &testguid, 0x123456789a, &TIME_FORMAT_NONE);
     todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     filter1.seek_duration = 0x12345;
     filter2.seek_duration = 0x23456;
     hr = IMediaSeeking_GetDuration(seeking, &time);
@@ -3917,6 +3936,9 @@ static void test_graph_seeking(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x23456, "Got time %s.\n", wine_dbgstr_longlong(time));
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     filter1.seek_stop = 0x54321;
     filter2.seek_stop = 0x65432;
     hr = IMediaSeeking_GetStopPosition(seeking, &time);
@@ -3948,16 +3970,25 @@ static void test_graph_seeking(void)
     ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     filter1.seek_hr = filter2.seek_hr = S_OK;
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!time, "Got time %s.\n", wine_dbgstr_longlong(time));
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     current = stop = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 0x65432, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     current = 0x123;
     stop = 0x321;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
@@ -4025,6 +4056,9 @@ static void test_graph_seeking(void)
     ok(filter2.seek_current == 0x123, "Got time %s.\n", wine_dbgstr_longlong(filter2.seek_current));
     ok(filter2.seek_stop == 0x321, "Got time %s.\n", wine_dbgstr_longlong(filter2.seek_stop));
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     hr = IMediaSeeking_SetRate(seeking, 2.0);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(filter1.seek_rate == 2.0, "Got rate %.16e.\n", filter1.seek_rate);
@@ -4040,6 +4074,9 @@ static void test_graph_seeking(void)
     todo_wine ok(filter1.seek_rate == -1.0, "Got rate %.16e.\n", filter1.seek_rate);
     todo_wine ok(filter2.seek_rate == -1.0, "Got rate %.16e.\n", filter2.seek_rate);
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     hr = IMediaSeeking_GetRate(seeking, &rate);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(rate == -1.0, "Got rate %.16e.\n", rate);
From e92c851d95497fbb36000be17f78b70ee3b2bf09 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 10 Jun 2020 23:09:07 +0700
Subject: [PATCH] quartz/filtergraph: Count renderers in IMediaControl::Pause
 and ::Run.

Some filters (e.g. MediaStreamFilter) can become renderers when they are already in the graph.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 23 +++++++++++++++++------
 dlls/quartz/tests/filtergraph.c | 11 +++++++----
 2 files changed, 24 insertions(+), 10 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index b1968069b86..0d0ccc2b624 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -691,9 +691,6 @@ static HRESULT WINAPI FilterGraph2_AddFilter(IFilterGraph2 *iface,
     entry->seeking = NULL;
     ++graph->version;
 
-    if (is_renderer(entry))
-        ++graph->nRenderers;
-
     return duplicate_name ? VFW_S_DUPLICATE_NAME : hr;
 }
 
@@ -766,9 +763,6 @@ static HRESULT WINAPI FilterGraph2_RemoveFilter(IFilterGraph2 *iface, IBaseFilte
             hr = IBaseFilter_JoinFilterGraph(pFilter, NULL, NULL);
             if (SUCCEEDED(hr))
             {
-                if (is_renderer(entry))
-                    --This->nRenderers;
-
                 IBaseFilter_SetSyncSource(pFilter, NULL);
                 IBaseFilter_Release(pFilter);
                 if (entry->seeking)
@@ -5171,6 +5165,19 @@ static HRESULT WINAPI MediaFilter_Stop(IMediaFilter *iface)
     return hr;
 }
 
+static void update_render_count(IFilterGraphImpl *graph)
+{
+    /* Some filters (e.g. MediaStreamFilter) can become renderers when they are
+     * already in the graph. */
+    struct filter *filter;
+    graph->nRenderers = 0;
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
+    {
+        if (is_renderer(filter))
+            ++graph->nRenderers;
+    }
+}
+
 static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
 {
     IFilterGraphImpl *graph = impl_from_IMediaFilter(iface);
@@ -5187,6 +5194,8 @@ static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
         return S_OK;
     }
 
+    update_render_count(graph);
+
     if (graph->defaultclock && !graph->refClock)
         IFilterGraph2_SetDefaultSyncSource(&graph->IFilterGraph2_iface);
 
@@ -5229,6 +5238,8 @@ static HRESULT WINAPI MediaFilter_Run(IMediaFilter *iface, REFERENCE_TIME start)
     }
     graph->EcCompleteCount = 0;
 
+    update_render_count(graph);
+
     if (graph->defaultclock && !graph->refClock)
         IFilterGraph2_SetDefaultSyncSource(&graph->IFilterGraph2_iface);
 
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index d1c081681a3..50c2402c326 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -3463,10 +3463,6 @@ static void test_ec_complete(void)
     testsource_init(&source_pins[2], NULL, 0);
     testfilter_init(&source, source_pins, 3);
 
-    filter1.IAMFilterMiscFlags_iface.lpVtbl = &testmiscflags_vtbl;
-    filter2.IAMFilterMiscFlags_iface.lpVtbl = &testmiscflags_vtbl;
-    filter1.misc_flags = filter2.misc_flags = AM_FILTER_MISC_FLAGS_IS_RENDERER;
-
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaEvent, (void **)&eventsrc);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaEventSink, (void **)&eventsink);
@@ -3481,8 +3477,15 @@ static void test_ec_complete(void)
 
     /* EC_COMPLETE is only delivered to the user after all renderers deliver it. */
 
+    filter1.IAMFilterMiscFlags_iface.lpVtbl = &testmiscflags_vtbl;
+    filter2.IAMFilterMiscFlags_iface.lpVtbl = &testmiscflags_vtbl;
+    filter3.IAMFilterMiscFlags_iface.lpVtbl = &testmiscflags_vtbl;
+    filter1.misc_flags = filter2.misc_flags = AM_FILTER_MISC_FLAGS_IS_RENDERER;
+
     IMediaControl_Run(control);
 
+    filter3.misc_flags = AM_FILTER_MISC_FLAGS_IS_RENDERER;
+
     while ((hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 0)) == S_OK)
     {
         ok(code != EC_COMPLETE, "Got unexpected EC_COMPLETE.\n");
From ff38669c1adb127aebfe2dea640d720790cd2436 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Fri, 12 Jun 2020 14:57:09 +0700
Subject: [PATCH] quartz/filtergraph: Always sort filter list before use.

Some applications (e.g. Earth 2150) call IPin::Connect directly
instead of IFilterGraph::ConnectDirect.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 48 +++++++++++++--------------------
 dlls/quartz/tests/filtergraph.c | 11 +++++---
 2 files changed, 27 insertions(+), 32 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 0d0ccc2b624..fa20d98981b 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -151,7 +151,7 @@ typedef struct _ITF_CACHE_ENTRY {
 
 struct filter
 {
-    struct list entry, sorted_entry;
+    struct list entry;
     IBaseFilter *filter;
     IMediaSeeking *seeking;
     WCHAR *name;
@@ -187,17 +187,7 @@ typedef struct _IFilterGraphImpl {
     LONG ref;
     IUnknown *punkFilterMapper2;
 
-    /* We keep two lists of filters, one unsorted and one topologically sorted.
-     * The former is necessary for functions like IGraphBuilder::Connect() and
-     * IGraphBuilder::Render() that iterate through the filter list but may
-     * add to it while doing so; the latter is for functions like
-     * IMediaControl::Run() that should propagate messages to all filters
-     * (including unconnected ones) but must do so in topological order from
-     * sinks to sources. We can easily guarantee that the loop in Connect() will
-     * touch each filter exactly once so long as we aren't reordering it, but
-     * using the sorted filters list there would be hard. This seems to be the
-     * easiest and clearest solution. */
-    struct list filters, sorted_filters;
+    struct list filters;
     unsigned int name_index;
 
     IReferenceClock *refClock;
@@ -686,7 +676,6 @@ static HRESULT WINAPI FilterGraph2_AddFilter(IFilterGraph2 *iface,
     IBaseFilter_AddRef(entry->filter = filter);
 
     list_add_head(&graph->filters, &entry->entry);
-    list_add_head(&graph->sorted_filters, &entry->sorted_entry);
     entry->sorting = FALSE;
     entry->seeking = NULL;
     ++graph->version;
@@ -768,7 +757,6 @@ static HRESULT WINAPI FilterGraph2_RemoveFilter(IFilterGraph2 *iface, IBaseFilte
                 if (entry->seeking)
                     IMediaSeeking_Release(entry->seeking);
                 list_remove(&entry->entry);
-                list_remove(&entry->sorted_entry);
                 CoTaskMemFree(entry->name);
                 heap_free(entry);
                 This->version++;
@@ -897,7 +885,7 @@ static struct filter *find_sorted_filter(IFilterGraphImpl *graph, IBaseFilter *i
 {
     struct filter *filter;
 
-    LIST_FOR_EACH_ENTRY(filter, &graph->sorted_filters, struct filter, sorted_entry)
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         if (filter->filter == iface)
             return filter;
@@ -941,21 +929,21 @@ static void sort_filter_recurse(IFilterGraphImpl *graph, struct filter *filter,
 
     filter->sorting = FALSE;
 
-    list_remove(&filter->sorted_entry);
-    list_add_head(sorted, &filter->sorted_entry);
+    list_remove(&filter->entry);
+    list_add_head(sorted, &filter->entry);
 }
 
 static void sort_filters(IFilterGraphImpl *graph)
 {
     struct list sorted = LIST_INIT(sorted), *cursor;
 
-    while ((cursor = list_head(&graph->sorted_filters)))
+    while ((cursor = list_head(&graph->filters)))
     {
-        struct filter *filter = LIST_ENTRY(cursor, struct filter, sorted_entry);
+        struct filter *filter = LIST_ENTRY(cursor, struct filter, entry);
         sort_filter_recurse(graph, filter, &sorted);
     }
 
-    list_move_tail(&graph->sorted_filters, &sorted);
+    list_move_tail(&graph->filters, &sorted);
 }
 
 /* NOTE: despite the implication, it doesn't matter which
@@ -1008,9 +996,6 @@ static HRESULT WINAPI FilterGraph2_ConnectDirect(IFilterGraph2 *iface, IPin *ppi
         }
     }
 
-    if (SUCCEEDED(hr))
-        sort_filters(This);
-
     return hr;
 }
 
@@ -5138,9 +5123,11 @@ static HRESULT WINAPI MediaFilter_Stop(IMediaFilter *iface)
         return S_OK;
     }
 
+    sort_filters(graph);
+
     if (graph->state == State_Running)
     {
-        LIST_FOR_EACH_ENTRY(filter, &graph->sorted_filters, struct filter, sorted_entry)
+        LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
         {
             filter_hr = IBaseFilter_Pause(filter->filter);
             if (hr == S_OK)
@@ -5148,7 +5135,7 @@ static HRESULT WINAPI MediaFilter_Stop(IMediaFilter *iface)
         }
     }
 
-    LIST_FOR_EACH_ENTRY(filter, &graph->sorted_filters, struct filter, sorted_entry)
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         filter_hr = IBaseFilter_Stop(filter->filter);
         if (hr == S_OK)
@@ -5194,6 +5181,7 @@ static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
         return S_OK;
     }
 
+    sort_filters(graph);
     update_render_count(graph);
 
     if (graph->defaultclock && !graph->refClock)
@@ -5207,7 +5195,7 @@ static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
         graph->current_pos += graph->stream_elapsed;
     }
 
-    LIST_FOR_EACH_ENTRY(filter, &graph->sorted_filters, struct filter, sorted_entry)
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         filter_hr = IBaseFilter_Pause(filter->filter);
         if (hr == S_OK)
@@ -5238,6 +5226,7 @@ static HRESULT WINAPI MediaFilter_Run(IMediaFilter *iface, REFERENCE_TIME start)
     }
     graph->EcCompleteCount = 0;
 
+    sort_filters(graph);
     update_render_count(graph);
 
     if (graph->defaultclock && !graph->refClock)
@@ -5251,7 +5240,7 @@ static HRESULT WINAPI MediaFilter_Run(IMediaFilter *iface, REFERENCE_TIME start)
             stream_start += 500000;
     }
 
-    LIST_FOR_EACH_ENTRY(filter, &graph->sorted_filters, struct filter, sorted_entry)
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         filter_hr = IBaseFilter_Run(filter->filter, stream_start);
         if (hr == S_OK)
@@ -5278,9 +5267,11 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
 
     EnterCriticalSection(&graph->cs);
 
+    sort_filters(graph);
+
     *state = graph->state;
 
-    LIST_FOR_EACH_ENTRY(filter, &graph->sorted_filters, struct filter, sorted_entry)
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         FILTER_STATE filter_state;
         int wait;
@@ -5753,7 +5744,6 @@ static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL
     fimpl->IVideoFrameStep_iface.lpVtbl = &VideoFrameStep_vtbl;
     fimpl->ref = 1;
     list_init(&fimpl->filters);
-    list_init(&fimpl->sorted_filters);
     fimpl->name_index = 1;
     fimpl->refClock = NULL;
     fimpl->hEventCompletion = CreateEventW(0, TRUE, FALSE, 0);
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 50c2402c326..4f4abeac9b9 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -3166,7 +3166,9 @@ static void test_filter_state(void)
     IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
     IFilterGraph2_AddFilter(graph, &sink.IBaseFilter_iface, NULL);
     IFilterGraph2_AddFilter(graph, &dummy.IBaseFilter_iface, NULL);
-    IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, NULL);
+    /* Using IPin::Connect instead of IFilterGraph2::ConnectDirect to show that */
+    /* FilterGraph does not rely on ::ConnectDirect to track filter connections. */
+    IPin_Connect(&source_pin.IPin_iface, &sink_pin.IPin_iface, NULL);
 
     check_filter_state(graph, State_Stopped);
 
@@ -3241,9 +3243,12 @@ static void test_filter_state(void)
     IFilterGraph2_QueryInterface(graph, &IID_IMediaFilter, (void **)&filter);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
 
-    IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
+    /* Add the filters in reverse order this time. */
     IFilterGraph2_AddFilter(graph, &sink.IBaseFilter_iface, NULL);
-    IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, NULL);
+    IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
+    /* Using IPin::Connect instead of IFilterGraph2::ConnectDirect to show that */
+    /* FilterGraph does not rely on ::ConnectDirect to track filter connections. */
+    IPin_Connect(&source_pin.IPin_iface, &sink_pin.IPin_iface, NULL);
 
     hr = IMediaFilter_Pause(filter);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
From 8dcd253e06b0e4ae4a6611c6f5e89e9ad00678cd Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 12 Jun 2020 16:28:26 -0500
Subject: [PATCH] quartz/vmr9: Trace the arguments to
 IVMRWindowlessControl9::SetVideoPosition().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 19 ++++++++++---------
 1 file changed, 10 insertions(+), 9 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 4ea3b483a75..776d927f2ab 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -1679,20 +1679,21 @@ static HRESULT WINAPI VMR9WindowlessControl_GetMaxIdealVideoSize(IVMRWindowlessC
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI VMR9WindowlessControl_SetVideoPosition(IVMRWindowlessControl9 *iface, const RECT *source, const RECT *dest)
+static HRESULT WINAPI VMR9WindowlessControl_SetVideoPosition(IVMRWindowlessControl9 *iface,
+        const RECT *src, const RECT *dst)
 {
-    struct quartz_vmr *This = impl_from_IVMRWindowlessControl9(iface);
+    struct quartz_vmr *filter = impl_from_IVMRWindowlessControl9(iface);
 
-    TRACE("(%p/%p)->(%p, %p)\n", iface, This, source, dest);
+    TRACE("filter %p, src %s, dst %s.\n", filter, wine_dbgstr_rect(src), wine_dbgstr_rect(dst));
 
-    EnterCriticalSection(&This->renderer.filter.csFilter);
+    EnterCriticalSection(&filter->renderer.filter.csFilter);
 
-    if (source)
-        This->window.src = *source;
-    if (dest)
-        This->window.dst = *dest;
+    if (src)
+        filter->window.src = *src;
+    if (dst)
+        filter->window.dst = *dst;
 
-    LeaveCriticalSection(&This->renderer.filter.csFilter);
+    LeaveCriticalSection(&filter->renderer.filter.csFilter);
 
     return S_OK;
 }
From 408a3074c4297a0004b8aa485d4cb3e296d3fe04 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 12 Jun 2020 16:28:27 -0500
Subject: [PATCH] quartz/vmr9: Implement
 IVMRWindowlessControl9::SetAspectRatioMode().

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=35215
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr9.c | 37 +++++++++++++++++
 dlls/quartz/vmr9.c       | 87 +++++++++++++++++++++++++++-------------
 2 files changed, 96 insertions(+), 28 deletions(-)

diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 14b6539a6bd..a227a647f65 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -3770,6 +3770,7 @@ static void test_windowless_size(void)
     LONG width, height, aspect_width, aspect_height;
     IVMRWindowlessControl9 *windowless_control;
     IFilterGraph2 *graph = create_graph();
+    VMR9AspectRatioMode aspect_mode;
     struct testfilter source;
     IMemAllocator *allocator;
     RECT src, dst, expect;
@@ -3813,6 +3814,11 @@ static void test_windowless_size(void)
     hr = IVMRWindowlessControl9_GetNativeVideoSize(windowless_control, &width, NULL, &aspect_width, &aspect_height);
     ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
+    aspect_mode = 0xdeadbeef;
+    hr = IVMRWindowlessControl9_GetAspectRatioMode(windowless_control, &aspect_mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(aspect_mode == VMR9ARMode_None, "Got mode %u.\n", aspect_mode);
+
     width = height = 0xdeadbeef;
     hr = IVMRWindowlessControl9_GetNativeVideoSize(windowless_control, &width, &height, NULL, NULL);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -3867,6 +3873,37 @@ static void test_windowless_size(void)
     SetRect(&expect, 0, 0, 640, 480);
     ok(EqualRect(&src, &expect), "Got window rect %s.\n", wine_dbgstr_rect(&src));
 
+    hr = IVMRWindowlessControl9_SetAspectRatioMode(windowless_control, VMR9ARMode_LetterBox);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    aspect_mode = 0xdeadbeef;
+    hr = IVMRWindowlessControl9_GetAspectRatioMode(windowless_control, &aspect_mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(aspect_mode == VMR9ARMode_LetterBox, "Got mode %u.\n", aspect_mode);
+
+    memset(&src, 0xcc, sizeof(src));
+    memset(&dst, 0xcc, sizeof(dst));
+    hr = IVMRWindowlessControl9_GetVideoPosition(windowless_control, &src, &dst);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    SetRect(&expect, 4, 6, 16, 12);
+    ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
+    SetRect(&expect, 40, 60, 120, 160);
+    ok(EqualRect(&dst, &expect), "Got dest rect %s.\n", wine_dbgstr_rect(&dst));
+
+    SetRect(&src, 0, 0, 32, 16);
+    SetRect(&dst, 0, 0, 640, 480);
+    hr = IVMRWindowlessControl9_SetVideoPosition(windowless_control, &src, &dst);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    memset(&src, 0xcc, sizeof(src));
+    memset(&dst, 0xcc, sizeof(dst));
+    hr = IVMRWindowlessControl9_GetVideoPosition(windowless_control, &src, &dst);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    SetRect(&expect, 0, 0, 32, 16);
+    ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
+    SetRect(&expect, 0, 0, 640, 480);
+    ok(EqualRect(&dst, &expect), "Got dest rect %s.\n", wine_dbgstr_rect(&dst));
+
 out:
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 776d927f2ab..449943f2dc3 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -106,6 +106,7 @@ struct quartz_vmr
 
     LONG VideoWidth;
     LONG VideoHeight;
+    VMR9AspectRatioMode aspect_mode;
 
     HANDLE run_event;
 };
@@ -1715,18 +1716,26 @@ static HRESULT WINAPI VMR9WindowlessControl_GetVideoPosition(IVMRWindowlessContr
 
 static HRESULT WINAPI VMR9WindowlessControl_GetAspectRatioMode(IVMRWindowlessControl9 *iface, DWORD *mode)
 {
-    struct quartz_vmr *This = impl_from_IVMRWindowlessControl9(iface);
+    struct quartz_vmr *filter = impl_from_IVMRWindowlessControl9(iface);
 
-    FIXME("(%p/%p)->(...) stub\n", iface, This);
-    return E_NOTIMPL;
+    TRACE("filter %p, mode %p.\n", filter, mode);
+
+    EnterCriticalSection(&filter->renderer.filter.csFilter);
+    *mode = filter->aspect_mode;
+    LeaveCriticalSection(&filter->renderer.filter.csFilter);
+    return S_OK;
 }
 
 static HRESULT WINAPI VMR9WindowlessControl_SetAspectRatioMode(IVMRWindowlessControl9 *iface, DWORD mode)
 {
-    struct quartz_vmr *This = impl_from_IVMRWindowlessControl9(iface);
+    struct quartz_vmr *filter = impl_from_IVMRWindowlessControl9(iface);
 
-    FIXME("(%p/%p)->(...) stub\n", iface, This);
-    return E_NOTIMPL;
+    TRACE("filter %p, mode %u.\n", filter, mode);
+
+    EnterCriticalSection(&filter->renderer.filter.csFilter);
+    filter->aspect_mode = mode;
+    LeaveCriticalSection(&filter->renderer.filter.csFilter);
+    return S_OK;
 }
 
 static HRESULT WINAPI VMR9WindowlessControl_SetVideoClippingWindow(IVMRWindowlessControl9 *iface, HWND window)
@@ -2625,37 +2634,59 @@ static HRESULT VMR9_ImagePresenter_PresentOffscreenSurface(struct default_presen
 static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *iface,
         DWORD_PTR cookie, VMR9PresentationInfo *info)
 {
-    struct default_presenter *This = impl_from_IVMRImagePresenter9(iface);
+    struct default_presenter *presenter = impl_from_IVMRImagePresenter9(iface);
+    const struct quartz_vmr *filter = presenter->pVMR9;
+    IDirect3DDevice9 *device = presenter->d3d9_dev;
+    const RECT src = filter->window.src;
+    RECT dst = filter->window.dst;
     HRESULT hr;
-    BOOL render = FALSE;
 
-    TRACE("presenter %p, cookie %#Ix, info %p.\n", This, cookie, info);
+    TRACE("presenter %p, cookie %#Ix, info %p.\n", presenter, cookie, info);
 
     /* This might happen if we don't have active focus (eg on a different virtual desktop) */
-    if (!This->d3d9_dev)
+    if (!device)
         return S_OK;
 
-    /* Display image here */
-    hr = IDirect3DDevice9_Clear(This->d3d9_dev, 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0);
-    if (FAILED(hr))
-        FIXME("hr: %08x\n", hr);
-    hr = IDirect3DDevice9_BeginScene(This->d3d9_dev);
-    if (SUCCEEDED(hr))
-    {
-        hr = VMR9_ImagePresenter_PresentOffscreenSurface(This, info->lpSurf);
-        render = SUCCEEDED(hr);
-    }
-    else
-        FIXME("BeginScene: %08x\n", hr);
-    hr = IDirect3DDevice9_EndScene(This->d3d9_dev);
-    if (render && SUCCEEDED(hr))
+    if (FAILED(hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET,
+            D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0)))
+        ERR("Failed to clear, hr %#x.\n", hr);
+
+    if (FAILED(hr = IDirect3DDevice9_BeginScene(device)))
+        ERR("Failed to begin scene, hr %#x.\n", hr);
+
+    VMR9_ImagePresenter_PresentOffscreenSurface(presenter, info->lpSurf);
+
+    if (FAILED(hr = IDirect3DDevice9_EndScene(device)))
+        ERR("Failed to end scene, hr %#x.\n", hr);
+
+    if (filter->aspect_mode == VMR9ARMode_LetterBox)
     {
-        hr = IDirect3DDevice9_Present(This->d3d9_dev, &This->pVMR9->window.src,
-                &This->pVMR9->window.dst, NULL, NULL);
-        if (FAILED(hr))
-            FIXME("Presenting image: %08x\n", hr);
+        unsigned int src_width = src.right - src.left, src_height = src.bottom - src.top;
+        unsigned int dst_width = dst.right - dst.left, dst_height = dst.bottom - dst.top;
+
+        if (src_width * dst_height > dst_width * src_height)
+        {
+            /* src is "wider" than dst. */
+            unsigned int dst_center = (dst.top + dst.bottom) / 2;
+            unsigned int scaled_height = src_height * dst_width / src_width;
+
+            dst.top = dst_center - scaled_height / 2;
+            dst.bottom = dst.top + scaled_height;
+        }
+        else if (src_width * dst_height < dst_width * src_height)
+        {
+            /* src is "taller" than dst. */
+            unsigned int dst_center = (dst.left + dst.right) / 2;
+            unsigned int scaled_width = src_width * dst_height / src_height;
+
+            dst.left = dst_center - scaled_width / 2;
+            dst.right = dst.left + scaled_width;
+        }
     }
 
+    if (FAILED(hr = IDirect3DDevice9_Present(device, &src, &dst, NULL, NULL)))
+        ERR("Failed to present, hr %#x.\n", hr);
+
     return S_OK;
 }
 
From 5444ce2f0db7b3f7b4e1fdf3f7bb8d18b79f315b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 12 Jun 2020 16:28:28 -0500
Subject: [PATCH] quartz/vmr9: Get rid of
 VMR9_ImagePresenter_PresentOffscreenSurface().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 31 ++++++++++---------------------
 1 file changed, 10 insertions(+), 21 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 449943f2dc3..6b653e56092 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -2611,26 +2611,6 @@ static HRESULT WINAPI VMR9_ImagePresenter_StopPresenting(IVMRImagePresenter9 *if
     return S_OK;
 }
 
-static HRESULT VMR9_ImagePresenter_PresentOffscreenSurface(struct default_presenter *This, IDirect3DSurface9 *surface)
-{
-    HRESULT hr;
-    IDirect3DSurface9 *target = NULL;
-
-    hr = IDirect3DDevice9_GetBackBuffer(This->d3d9_dev, 0, 0, D3DBACKBUFFER_TYPE_MONO, &target);
-    if (FAILED(hr))
-    {
-        ERR("IDirect3DDevice9_GetBackBuffer -- %08x\n", hr);
-        return hr;
-    }
-
-    hr = IDirect3DDevice9_StretchRect(This->d3d9_dev, surface, NULL, target, NULL, D3DTEXF_POINT);
-    if (FAILED(hr))
-        ERR("IDirect3DDevice9_StretchRect -- %08x\n", hr);
-    IDirect3DSurface9_Release(target);
-
-    return hr;
-}
-
 static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *iface,
         DWORD_PTR cookie, VMR9PresentationInfo *info)
 {
@@ -2638,6 +2618,7 @@ static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *ifac
     const struct quartz_vmr *filter = presenter->pVMR9;
     IDirect3DDevice9 *device = presenter->d3d9_dev;
     const RECT src = filter->window.src;
+    IDirect3DSurface9 *backbuffer;
     RECT dst = filter->window.dst;
     HRESULT hr;
 
@@ -2654,7 +2635,15 @@ static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *ifac
     if (FAILED(hr = IDirect3DDevice9_BeginScene(device)))
         ERR("Failed to begin scene, hr %#x.\n", hr);
 
-    VMR9_ImagePresenter_PresentOffscreenSurface(presenter, info->lpSurf);
+    if (FAILED(hr = IDirect3DDevice9_GetBackBuffer(device, 0, 0, D3DBACKBUFFER_TYPE_MONO, &backbuffer)))
+    {
+        ERR("Failed to get backbuffer, hr %#x.\n", hr);
+        return hr;
+    }
+
+    if (FAILED(hr = IDirect3DDevice9_StretchRect(device, info->lpSurf, NULL, backbuffer, NULL, D3DTEXF_POINT)))
+        ERR("Failed to blit image, hr %#x.\n", hr);
+    IDirect3DSurface9_Release(backbuffer);
 
     if (FAILED(hr = IDirect3DDevice9_EndScene(device)))
         ERR("Failed to end scene, hr %#x.\n", hr);
From 5161554b9d4e8d999f21a420b4c56067e209d435 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 13 Jun 2020 13:55:38 -0500
Subject: [PATCH] quartz/tests: Relax some timings.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/videorenderer.c | 2 +-
 dlls/quartz/tests/vmr9.c          | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/quartz/tests/videorenderer.c b/dlls/quartz/tests/videorenderer.c
index d603ea46edd..ab2b4f9e0d4 100644
--- a/dlls/quartz/tests/videorenderer.c
+++ b/dlls/quartz/tests/videorenderer.c
@@ -1082,7 +1082,7 @@ static void test_sample_time(IBaseFilter *filter, IPin *pin, IMemInputPin *input
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame_time(input, 2, 0x66); /* orange */
-    ok(WaitForSingleObject(thread, 800) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
+    ok(WaitForSingleObject(thread, 500) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
     hr = join_thread(thread);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index a227a647f65..2641b7a04bb 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -1430,7 +1430,7 @@ static void test_sample_time(IPin *pin, IMemInputPin *input, IMediaControl *cont
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame_time(input, 2, 0x00ff00ff); /* magenta */
-    ok(WaitForSingleObject(thread, 800) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
+    ok(WaitForSingleObject(thread, 500) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
     hr = join_thread(thread);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
From cdab25b03a2e82d717c73f28e4e68e048472f2e3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 15 Jun 2020 22:51:23 -0500
Subject: [PATCH] quartz: Try to connect all source pins when autoplugging from
 the registry.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 41 +++++++++++++--------------------
 dlls/quartz/tests/filtergraph.c | 22 +++++++++---------
 2 files changed, 27 insertions(+), 36 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index fa20d98981b..cb212e4961b 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -1327,7 +1327,6 @@ static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *ppinOut,
     while (IEnumMoniker_Next(pEnumMoniker, 1, &pMoniker, NULL) == S_OK)
     {
         VARIANT var;
-        IPin* ppinfilter = NULL;
         IBaseFilter* pfilter = NULL;
         IAMGraphBuilderCallback *callback = NULL;
 
@@ -1390,35 +1389,27 @@ static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *ppinOut,
             goto error;
         }
 
-        hr = IEnumPins_Next(penumpins, 1, &ppinfilter, NULL);
-        IEnumPins_Release(penumpins);
-
-        if (FAILED(hr)) {
-            WARN("Obtaining next pin: (%x)\n", hr);
-            goto error;
-        }
-        if (hr == S_FALSE) {
-            WARN("Cannot use this filter: no pins\n");
-            goto error;
-        }
-
-        hr = IFilterGraph2_ConnectDirect(iface, ppinOut, ppinfilter, NULL);
-        if (FAILED(hr)) {
-            TRACE("Cannot connect to filter (%x), trying next one\n", hr);
-            goto error;
-        }
-        TRACE("Successfully connected to filter, follow chain...\n");
-
-        if (SUCCEEDED(hr = connect_output_pin(This, pfilter, ppinIn)))
+        while (IEnumPins_Next(penumpins, 1, &pin, NULL) == S_OK)
         {
-            IPin_Release(ppinfilter);
-            IBaseFilter_Release(pfilter);
-            break;
+            if (SUCCEEDED(IFilterGraph2_ConnectDirect(iface, ppinOut, pin, NULL)))
+            {
+                if (SUCCEEDED(hr = connect_output_pin(This, pfilter, ppinIn)))
+                {
+                    IPin_Release(pin);
+                    IEnumPins_Release(penumpins);
+                    IBaseFilter_Release(pfilter);
+                    IEnumMoniker_Release(pEnumMoniker);
+                    goto out;
+                }
+                IFilterGraph2_Disconnect(iface, pin);
+                IFilterGraph2_Disconnect(iface, ppinOut);
+            }
+            IPin_Release(pin);
         }
+        IEnumPins_Release(penumpins);
 
 error:
         VariantClear(&var);
-        if (ppinfilter) IPin_Release(ppinfilter);
         if (pfilter) {
             IFilterGraph2_RemoveFilter(iface, pfilter);
             IBaseFilter_Release(pfilter);
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 4f4abeac9b9..d062ea39c61 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -2136,9 +2136,9 @@ static void test_graph_builder_connect(void)
     testfilter_init(&parser1, parser1_pins, 3);
     parser1.pin_count = 2;
 
-    testsink_init(&parser2_pins[0]);
-    testsource_init(&parser2_pins[1], &sink_type, 1);
-    parser2_pins[1].request_mt = &sink_type;
+    testsource_init(&parser2_pins[0], &sink_type, 1);
+    testsink_init(&parser2_pins[1]);
+    parser2_pins[0].request_mt = &sink_type;
     testfilter_init(&parser2, parser2_pins, 2);
 
     testsink_init(&parser3_pins[0]);
@@ -2215,8 +2215,8 @@ static void test_graph_builder_connect(void)
     sink_pin.accept_mt = &sink_type;
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    ok(source_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
-    ok(sink_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
+    ok(source_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", source_pin.peer);
+    ok(sink_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", sink_pin.peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
     IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
     IFilterGraph2_Disconnect(graph, sink_pin.peer);
@@ -2227,8 +2227,8 @@ static void test_graph_builder_connect(void)
     {
         hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
         ok(hr == S_OK, "Got hr %#x for Connect() hr %#x.\n", hr, source_pin.Connect_hr);
-        ok(source_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
-        ok(sink_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
+        ok(source_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", source_pin.peer);
+        ok(sink_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", sink_pin.peer);
         IFilterGraph2_Disconnect(graph, source_pin.peer);
         IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
         IFilterGraph2_Disconnect(graph, sink_pin.peer);
@@ -2379,9 +2379,9 @@ todo_wine
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser1_pins[0].IPin_iface
-            || source_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
+            || source_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser1_pins[1].IPin_iface
-            || sink_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
+            || sink_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", sink_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
@@ -2417,8 +2417,8 @@ todo_wine
 
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    ok(source_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
-    ok(sink_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
+    ok(source_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", source_pin.peer);
+    ok(sink_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", sink_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
From 2ddc3e475858f8b91a4e3bdc083660e76fc08bce Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 15 Jun 2020 22:51:24 -0500
Subject: [PATCH] quartz/tests: Test autoplugging order.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/filtergraph.c | 34 +++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index d062ea39c61..22ed37cd307 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -800,6 +800,7 @@ struct testpin
     const AM_MEDIA_TYPE *types;
     unsigned int type_count, enum_idx;
     AM_MEDIA_TYPE *request_mt, *accept_mt;
+    const struct testpin *require_connected_pin;
 
     HRESULT Connect_hr;
     HRESULT EnumMediaTypes_hr;
@@ -1059,6 +1060,9 @@ static HRESULT WINAPI testsink_ReceiveConnection(IPin *iface, IPin *peer, const
     if (pin->accept_mt && memcmp(pin->accept_mt, mt, sizeof(*mt)))
         return VFW_E_TYPE_NOT_ACCEPTED;
 
+    if (pin->require_connected_pin && !pin->require_connected_pin->peer)
+        return VFW_E_TYPE_NOT_ACCEPTED;
+
     pin->peer = peer;
     IPin_AddRef(peer);
     return S_OK;
@@ -1112,6 +1116,9 @@ static HRESULT WINAPI testsource_Connect(IPin *iface, IPin *peer, const AM_MEDIA
     if (FAILED(pin->Connect_hr))
         return pin->Connect_hr;
 
+    if (pin->require_connected_pin && !pin->require_connected_pin->peer)
+        return VFW_E_NO_ACCEPTABLE_TYPES;
+
     ok(!mt, "Got media type %p.\n", mt);
 
     if (SUCCEEDED(hr = IPin_ReceiveConnection(peer, &pin->IPin_iface, pin->request_mt)))
@@ -2338,6 +2345,33 @@ todo_wine
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 
+    /* The graph connects from source to sink, not from sink to source. */
+
+    graph = create_graph();
+    IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, L"source");
+    IFilterGraph2_AddFilter(graph, &parser1.IBaseFilter_iface, L"parser");
+    IFilterGraph2_AddFilter(graph, &sink.IBaseFilter_iface, L"sink");
+
+    parser1_pins[0].require_connected_pin = &parser1_pins[1];
+
+    hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
+    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x.\n", hr);
+    ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
+    ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
+
+    parser1_pins[0].require_connected_pin = NULL;
+    parser1_pins[1].require_connected_pin = &parser1_pins[0];
+
+    hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(source_pin.peer == &parser1_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
+    ok(sink_pin.peer == &parser1_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
+
+    parser1_pins[1].require_connected_pin = NULL;
+
+    ref = IFilterGraph2_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
     /* Test enumeration of filters from the registry. */
 
     graph = create_graph();
From c603a5bfbca40f42169aa3b299e81de519781640 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 15 Jun 2020 22:51:25 -0500
Subject: [PATCH] quartz: Combine IGraphBuilder::Render() and
 IGraphBuilder::Connect() into a single helper.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 750 +++++++++-----------------------
 dlls/quartz/tests/filtergraph.c |  11 +-
 2 files changed, 205 insertions(+), 556 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index cb212e4961b..e3faf64fb82 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -207,7 +207,6 @@ typedef struct _IFilterGraphImpl {
     int nItfCacheEntries;
     BOOL defaultclock;
     GUID timeformatseek;
-    LONG recursioncount;
     IUnknown *pSite;
     LONG version;
 
@@ -1059,27 +1058,6 @@ static HRESULT WINAPI FilterGraph2_SetDefaultSyncSource(IFilterGraph2 *iface)
     return hr;
 }
 
-static HRESULT GetFilterInfo(IMoniker* pMoniker, VARIANT* pvar)
-{
-    IPropertyBag * pPropBagCat = NULL;
-    HRESULT hr;
-
-    VariantInit(pvar);
-
-    hr = IMoniker_BindToStorage(pMoniker, NULL, NULL, &IID_IPropertyBag, (LPVOID*)&pPropBagCat);
-
-    if (SUCCEEDED(hr))
-        hr = IPropertyBag_Read(pPropBagCat, L"FriendlyName", pvar, NULL);
-
-    if (SUCCEEDED(hr))
-        TRACE("Moniker = %s\n", debugstr_w(V_BSTR(pvar)));
-
-    if (pPropBagCat)
-        IPropertyBag_Release(pPropBagCat);
-
-    return hr;
-}
-
 struct filter_create_params
 {
     HRESULT hr;
@@ -1141,621 +1119,292 @@ static HRESULT create_filter(IFilterGraphImpl *graph, IMoniker *moniker, IBaseFi
         return IMoniker_BindToObject(moniker, NULL, NULL, &IID_IBaseFilter, (void **)filter);
 }
 
-/* Attempt to connect one of the output pins on filter to sink. Helper for
- * FilterGraph2_Connect(). */
-static HRESULT connect_output_pin(IFilterGraphImpl *graph, IBaseFilter *filter, IPin *sink)
-{
-    IEnumPins *enumpins;
-    PIN_INFO info;
-    HRESULT hr;
-    IPin *pin;
-
-    hr = IBaseFilter_EnumPins(filter, &enumpins);
-    if (FAILED(hr))
-        return hr;
-
-    while (IEnumPins_Next(enumpins, 1, &pin, NULL) == S_OK)
-    {
-        IPin_QueryPinInfo(pin, &info);
-        IBaseFilter_Release(info.pFilter);
-        if (info.dir == PINDIR_OUTPUT)
-        {
-            if (info.achName[0] == '~')
-            {
-                TRACE("Skipping non-rendered pin %s.\n", debugstr_w(info.achName));
-                IPin_Release(pin);
-                continue;
-            }
-
-            if (SUCCEEDED(IFilterGraph2_Connect(&graph->IFilterGraph2_iface, pin, sink)))
-            {
-                IPin_Release(pin);
-                IEnumPins_Release(enumpins);
-                return S_OK;
-            }
-        }
-        IPin_Release(pin);
-    }
-
-    IEnumPins_Release(enumpins);
-    return VFW_E_CANNOT_CONNECT;
-}
+static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink, unsigned int recursion_depth);
 
-/*** IGraphBuilder methods ***/
-static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *ppinOut, IPin *ppinIn)
+static HRESULT autoplug_through_sink(IFilterGraphImpl *graph, IPin *source,
+        IBaseFilter *filter, IPin *middle_sink, IPin *sink, unsigned int recursion_depth)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
-    struct filter *filter;
-    HRESULT hr;
-    IPin *pin;
-    AM_MEDIA_TYPE* mt = NULL;
-    IEnumMediaTypes* penummt = NULL;
-    ULONG nbmt;
-    IEnumPins* penumpins;
-    IEnumMoniker* pEnumMoniker;
-    GUID tab[2];
-    IMoniker* pMoniker;
-    PIN_INFO PinInfo;
+    BOOL any = FALSE, all = TRUE;
+    IPin *middle_source, *peer;
+    IEnumPins *source_enum;
     PIN_DIRECTION dir;
-    IFilterMapper2 *pFilterMapper2 = NULL;
-
-    TRACE("(%p/%p)->(%p, %p)\n", This, iface, ppinOut, ppinIn);
-
-    if(!ppinOut || !ppinIn)
-        return E_POINTER;
-
-    if (TRACE_ON(quartz))
-    {
-        hr = IPin_QueryPinInfo(ppinIn, &PinInfo);
-        if (FAILED(hr))
-            return hr;
-
-        TRACE("Filter owning ppinIn(%p) => %p\n", ppinIn, PinInfo.pFilter);
-        IBaseFilter_Release(PinInfo.pFilter);
-
-        hr = IPin_QueryPinInfo(ppinOut, &PinInfo);
-        if (FAILED(hr))
-            return hr;
+    PIN_INFO info;
+    HRESULT hr;
 
-        TRACE("Filter owning ppinOut(%p) => %p\n", ppinOut, PinInfo.pFilter);
-        IBaseFilter_Release(PinInfo.pFilter);
-    }
+    TRACE("Trying to autoplug %p to %p through %p.\n", source, sink, middle_sink);
 
-    EnterCriticalSection(&This->cs);
-    ++This->recursioncount;
-    if (This->recursioncount >= 5)
-    {
-        WARN("Recursion count has reached %d\n", This->recursioncount);
-        hr = VFW_E_CANNOT_CONNECT;
-        goto out;
-    }
-
-    hr = IPin_QueryDirection(ppinOut, &dir);
-    if (FAILED(hr))
-        goto out;
+    IPin_QueryDirection(middle_sink, &dir);
+    if (dir != PINDIR_INPUT)
+        return E_FAIL;
 
-    if (dir == PINDIR_INPUT)
+    if (IPin_ConnectedTo(middle_sink, &peer) == S_OK)
     {
-        IPin *temp;
-
-        TRACE("Directions seem backwards, swapping pins\n");
-
-        temp = ppinIn;
-        ppinIn = ppinOut;
-        ppinOut = temp;
+        IPin_Release(peer);
+        return E_FAIL;
     }
 
-    /* Try direct connection first */
-    hr = IFilterGraph2_ConnectDirect(iface, ppinOut, ppinIn, NULL);
-
-    /* If direct connection succeeded, we should propagate that return value.
-     * If it returned VFW_E_NOT_CONNECTED or VFW_E_NO_AUDIO_HARDWARE, then don't
-     * even bother trying intermediate filters, since they won't succeed. */
-    if (SUCCEEDED(hr) || hr == VFW_E_NOT_CONNECTED || hr == VFW_E_NO_AUDIO_HARDWARE)
-        goto out;
+    if (FAILED(hr = IFilterGraph2_ConnectDirect(&graph->IFilterGraph2_iface, source, middle_sink, NULL)))
+        return E_FAIL;
 
-    TRACE("Direct connection failed, trying to render using extra filters\n");
+    if (FAILED(hr = IBaseFilter_EnumPins(filter, &source_enum)))
+        goto err;
 
-    LIST_FOR_EACH_ENTRY(filter, &This->filters, struct filter, entry)
+    while (IEnumPins_Next(source_enum, 1, &middle_source, NULL) == S_OK)
     {
-        hr = IBaseFilter_EnumPins(filter->filter, &penumpins);
-        if (FAILED(hr))
-            goto out;
-
-        while (IEnumPins_Next(penumpins, 1, &pin, NULL) == S_OK)
+        IPin_QueryPinInfo(middle_source, &info);
+        IBaseFilter_Release(info.pFilter);
+        if (info.dir != PINDIR_OUTPUT)
         {
-            IPin_QueryDirection(pin, &dir);
-            if (dir == PINDIR_INPUT && SUCCEEDED(IFilterGraph2_ConnectDirect(iface,
-                    ppinOut, pin, NULL)))
-            {
-                if (SUCCEEDED(hr = connect_output_pin(This, filter->filter, ppinIn)))
-                {
-                    IPin_Release(pin);
-                    IEnumPins_Release(penumpins);
-                    goto out;
-                }
-
-                IFilterGraph2_Disconnect(iface, pin);
-                IFilterGraph2_Disconnect(iface, ppinOut);
-            }
-            IPin_Release(pin);
-        }
-
-        IEnumPins_Release(penumpins);
-    }
-
-    /* Find the appropriate transform filter than can transform the minor media type of output pin of the upstream 
-     * filter to the minor mediatype of input pin of the renderer */
-    hr = IPin_EnumMediaTypes(ppinOut, &penummt);
-    if (FAILED(hr))
-    {
-        WARN("EnumMediaTypes (%x)\n", hr);
-        goto out;
-    }
-
-    hr = IEnumMediaTypes_Next(penummt, 1, &mt, &nbmt);
-    if (FAILED(hr)) {
-        WARN("IEnumMediaTypes_Next (%x)\n", hr);
-        goto out;
-    }
-
-    if (!nbmt)
-    {
-        WARN("No media type found!\n");
-        hr = VFW_E_INVALIDMEDIATYPE;
-        goto out;
-    }
-    TRACE("MajorType %s\n", debugstr_guid(&mt->majortype));
-    TRACE("SubType %s\n", debugstr_guid(&mt->subtype));
-
-    hr = IUnknown_QueryInterface(This->punkFilterMapper2, &IID_IFilterMapper2, (void**)&pFilterMapper2);
-    if (FAILED(hr)) {
-        WARN("Unable to get IFilterMapper2 (%x)\n", hr);
-        goto out;
-    }
-
-    /* Try to find a suitable filter that can connect to the pin to render */
-    tab[0] = mt->majortype;
-    tab[1] = mt->subtype;
-    hr = IFilterMapper2_EnumMatchingFilters(pFilterMapper2, &pEnumMoniker, 0, FALSE, MERIT_UNLIKELY, TRUE, 1, tab, NULL, NULL, FALSE, FALSE, 0, NULL, NULL, NULL);
-    if (FAILED(hr)) {
-        WARN("Unable to enum filters (%x)\n", hr);
-        goto out;
-    }
-
-    hr = VFW_E_CANNOT_RENDER;
-    while (IEnumMoniker_Next(pEnumMoniker, 1, &pMoniker, NULL) == S_OK)
-    {
-        VARIANT var;
-        IBaseFilter* pfilter = NULL;
-        IAMGraphBuilderCallback *callback = NULL;
-
-        hr = GetFilterInfo(pMoniker, &var);
-        if (FAILED(hr)) {
-            WARN("Unable to retrieve filter info (%x)\n", hr);
-            goto error;
-        }
-
-        hr = create_filter(This, pMoniker, &pfilter);
-        IMoniker_Release(pMoniker);
-        if (FAILED(hr)) {
-            WARN("Unable to create filter (%x), trying next one\n", hr);
-            goto error;
+            IPin_Release(middle_source);
+            continue;
         }
-
-        if (This->pSite)
+        if (info.achName[0] == '~')
         {
-            IUnknown_QueryInterface(This->pSite, &IID_IAMGraphBuilderCallback, (LPVOID*)&callback);
-            if (callback)
-            {
-                HRESULT rc;
-                rc = IAMGraphBuilderCallback_SelectedFilter(callback, pMoniker);
-                if (FAILED(rc))
-                {
-                    TRACE("Filter rejected by IAMGraphBuilderCallback_SelectedFilter\n");
-                    IAMGraphBuilderCallback_Release(callback);
-                    goto error;
-                }
-            }
+            TRACE("Skipping non-rendered pin %s.\n", debugstr_w(info.achName));
+            IPin_Release(middle_source);
+            continue;
         }
-
-        if (callback)
+        if (IPin_ConnectedTo(middle_source, &peer) == S_OK)
         {
-            HRESULT rc;
-            rc = IAMGraphBuilderCallback_CreatedFilter(callback, pfilter);
-            IAMGraphBuilderCallback_Release(callback);
-            if (FAILED(rc))
-            {
-                IBaseFilter_Release(pfilter);
-                pfilter = NULL;
-                TRACE("Filter rejected by IAMGraphBuilderCallback_CreatedFilter\n");
-                goto error;
-            }
-        }
-
-        hr = IFilterGraph2_AddFilter(iface, pfilter, V_BSTR(&var));
-        if (FAILED(hr)) {
-            WARN("Unable to add filter (%x)\n", hr);
-            IBaseFilter_Release(pfilter);
-            pfilter = NULL;
-            goto error;
-        }
-
-        VariantClear(&var);
-
-        hr = IBaseFilter_EnumPins(pfilter, &penumpins);
-        if (FAILED(hr)) {
-            WARN("Enumpins (%x)\n", hr);
-            goto error;
+            IPin_Release(peer);
+            IPin_Release(middle_source);
+            continue;
         }
 
-        while (IEnumPins_Next(penumpins, 1, &pin, NULL) == S_OK)
+        hr = autoplug(graph, middle_source, sink, recursion_depth + 1);
+        IPin_Release(middle_source);
+        if (SUCCEEDED(hr) && sink)
         {
-            if (SUCCEEDED(IFilterGraph2_ConnectDirect(iface, ppinOut, pin, NULL)))
-            {
-                if (SUCCEEDED(hr = connect_output_pin(This, pfilter, ppinIn)))
-                {
-                    IPin_Release(pin);
-                    IEnumPins_Release(penumpins);
-                    IBaseFilter_Release(pfilter);
-                    IEnumMoniker_Release(pEnumMoniker);
-                    goto out;
-                }
-                IFilterGraph2_Disconnect(iface, pin);
-                IFilterGraph2_Disconnect(iface, ppinOut);
-            }
-            IPin_Release(pin);
-        }
-        IEnumPins_Release(penumpins);
-
-error:
-        VariantClear(&var);
-        if (pfilter) {
-            IFilterGraph2_RemoveFilter(iface, pfilter);
-            IBaseFilter_Release(pfilter);
+            IEnumPins_Release(source_enum);
+            return hr;
         }
+        if (SUCCEEDED(hr))
+            any = TRUE;
+        if (hr != S_OK)
+            all = FALSE;
     }
+    IEnumPins_Release(source_enum);
 
-    if (FAILED(hr))
-        hr = VFW_E_CANNOT_CONNECT;
-
-    IEnumMoniker_Release(pEnumMoniker);
+    if (!sink)
+    {
+        if (all)
+            return S_OK;
+        if (any)
+            return VFW_S_PARTIAL_RENDER;
+    }
 
-out:
-    if (pFilterMapper2)
-        IFilterMapper2_Release(pFilterMapper2);
-    if (penummt)
-        IEnumMediaTypes_Release(penummt);
-    if (mt)
-        DeleteMediaType(mt);
-    --This->recursioncount;
-    LeaveCriticalSection(&This->cs);
-    TRACE("--> %08x\n", hr);
-    return hr;
+err:
+    IFilterGraph2_Disconnect(&graph->IFilterGraph2_iface, source);
+    IFilterGraph2_Disconnect(&graph->IFilterGraph2_iface, middle_sink);
+    return E_FAIL;
 }
 
-/* Render all output pins of the given filter. Helper for FilterGraph2_Render(). */
-static HRESULT render_output_pins(IFilterGraphImpl *graph, IBaseFilter *filter)
+static HRESULT autoplug_through_filter(IFilterGraphImpl *graph, IPin *source,
+        IBaseFilter *filter, IPin *sink, unsigned int recursion_depth)
 {
-    BOOL renderany = FALSE;
-    BOOL renderall = TRUE;
-    IEnumPins *enumpins;
-    IPin *pin, *peer;
-    PIN_INFO info;
+    IEnumPins *sink_enum;
+    IPin *filter_sink;
+    HRESULT hr;
 
-    IBaseFilter_EnumPins(filter, &enumpins);
-    while (IEnumPins_Next(enumpins, 1, &pin, NULL) == S_OK)
+    TRACE("Trying to autoplug %p to %p through %p.\n", source, sink, filter);
+
+    if (FAILED(hr = IBaseFilter_EnumPins(filter, &sink_enum)))
+        return hr;
+
+    while (IEnumPins_Next(sink_enum, 1, &filter_sink, NULL) == S_OK)
     {
-        IPin_QueryPinInfo(pin, &info);
-        IBaseFilter_Release(info.pFilter);
-        if (info.dir == PINDIR_OUTPUT)
+        hr = autoplug_through_sink(graph, source, filter, filter_sink, sink, recursion_depth);
+        IPin_Release(filter_sink);
+        if (SUCCEEDED(hr))
         {
-            if (info.achName[0] == '~')
-            {
-                TRACE("Skipping non-rendered pin %s.\n", debugstr_w(info.achName));
-                IPin_Release(pin);
-                continue;
-            }
-
-            if (IPin_ConnectedTo(pin, &peer) == VFW_E_NOT_CONNECTED)
-            {
-                HRESULT hr;
-                hr = IFilterGraph2_Render(&graph->IFilterGraph2_iface, pin);
-                if (SUCCEEDED(hr))
-                    renderany = TRUE;
-                else
-                    renderall = FALSE;
-            }
-            else
-                IPin_Release(peer);
+            IEnumPins_Release(sink_enum);
+            return hr;
         }
-
-        IPin_Release(pin);
     }
-
-    IEnumPins_Release(enumpins);
-
-    if (renderall)
-        return S_OK;
-
-    if (renderany)
-        return VFW_S_PARTIAL_RENDER;
-
-    return VFW_E_CANNOT_RENDER;
+    IEnumPins_Release(sink_enum);
+    return VFW_E_CANNOT_CONNECT;
 }
 
-/* Ogg hates me if I create a direct rendering method
- *
- * It can only connect to a pin properly once, so use a recursive method that does
- *
- *  +----+ --- (PIN 1) (Render is called on this pin)
- *  |    |
- *  +----+ --- (PIN 2)
- *
- *  Enumerate possible renderers that EXACTLY match the requested type
- *
- *  If none is available, try to add intermediate filters that can connect to the input pin
- *  then call Render on that intermediate pin's output pins
- *  if it succeeds: Render returns success, if it doesn't, the intermediate filter is removed,
- *  and another filter that can connect to the input pin is tried
- *  if we run out of filters that can, give up and return VFW_E_CANNOT_RENDER
- *  It's recursive, but fun!
- */
-
-static HRESULT WINAPI FilterGraph2_Render(IFilterGraph2 *iface, IPin *ppinOut)
+/* Common helper for IGraphBuilder::Connect() and IGraphBuilder::Render(), which
+ * share most of the same code. Render() calls this with a NULL sink. */
+static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink, unsigned int recursion_depth)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
-    IEnumMediaTypes* penummt;
+    IAMGraphBuilderCallback *callback = NULL;
+    IEnumMediaTypes *enummt;
+    IFilterMapper2 *mapper;
     struct filter *filter;
-    AM_MEDIA_TYPE* mt;
-    ULONG nbmt;
+    AM_MEDIA_TYPE *mt;
     HRESULT hr;
 
-    IEnumMoniker* pEnumMoniker;
-    GUID tab[4];
-    ULONG nb;
-    IMoniker* pMoniker;
-    IFilterMapper2 *pFilterMapper2 = NULL;
+    TRACE("Trying to autoplug %p to %p, recursion depth %u.\n", source, sink, recursion_depth);
 
-    TRACE("(%p/%p)->(%p)\n", This, iface, ppinOut);
+    if (recursion_depth >= 5)
+    {
+        WARN("Recursion depth has reached 5; aborting.\n");
+        return VFW_E_CANNOT_CONNECT;
+    }
 
-    if (TRACE_ON(quartz))
+    if (sink)
     {
-        PIN_INFO PinInfo;
+        /* Try to connect directly to this sink. */
+        hr = IFilterGraph2_ConnectDirect(&graph->IFilterGraph2_iface, source, sink, NULL);
 
-        hr = IPin_QueryPinInfo(ppinOut, &PinInfo);
-        if (FAILED(hr))
+        /* If direct connection succeeded, we should propagate that return value.
+         * If it returned VFW_E_NOT_CONNECTED or VFW_E_NO_AUDIO_HARDWARE, then don't
+         * even bother trying intermediate filters, since they won't succeed. */
+        if (SUCCEEDED(hr) || hr == VFW_E_NOT_CONNECTED || hr == VFW_E_NO_AUDIO_HARDWARE)
             return hr;
-
-        TRACE("Filter owning pin => %p\n", PinInfo.pFilter);
-        IBaseFilter_Release(PinInfo.pFilter);
     }
 
-    /* Try to find out if there is a renderer for the specified subtype already, and use that
-     */
-    EnterCriticalSection(&This->cs);
-    LIST_FOR_EACH_ENTRY(filter, &This->filters, struct filter, entry)
+    /* Always prefer filters in the graph. */
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
-        IEnumPins *enumpins = NULL;
-        IPin *pin = NULL;
-
-        hr = IBaseFilter_EnumPins(filter->filter, &enumpins);
-
-        if (FAILED(hr) || !enumpins)
-            continue;
-
-        IEnumPins_Reset(enumpins);
-        while (IEnumPins_Next(enumpins, 1, &pin, NULL) == S_OK)
-        {
-            IPin *to = NULL;
-            PIN_DIRECTION dir = PINDIR_OUTPUT;
-
-            IPin_QueryDirection(pin, &dir);
-            if (dir != PINDIR_INPUT)
-            {
-                IPin_Release(pin);
-                continue;
-            }
-            IPin_ConnectedTo(pin, &to);
-
-            if (to == NULL)
-            {
-                hr = FilterGraph2_ConnectDirect(iface, ppinOut, pin, NULL);
-                if (SUCCEEDED(hr))
-                {
-                    TRACE("Connected successfully %p/%p, %08x look if we should render more!\n", ppinOut, pin, hr);
-                    IPin_Release(pin);
-
-                    hr = render_output_pins(This, filter->filter);
-                    if (FAILED(hr))
-                    {
-                        IPin_Disconnect(ppinOut);
-                        IPin_Disconnect(pin);
-                        continue;
-                    }
-                    IEnumPins_Release(enumpins);
-                    LeaveCriticalSection(&This->cs);
-                    return hr;
-                }
-                WARN("Could not connect!\n");
-            }
-            else
-                IPin_Release(to);
-
-            IPin_Release(pin);
-        }
-        IEnumPins_Release(enumpins);
+        if (SUCCEEDED(hr = autoplug_through_filter(graph, source, filter->filter, sink, recursion_depth)))
+            return hr;
     }
 
-    LeaveCriticalSection(&This->cs);
+    IUnknown_QueryInterface(graph->punkFilterMapper2, &IID_IFilterMapper2, (void **)&mapper);
 
-    hr = IPin_EnumMediaTypes(ppinOut, &penummt);
-    if (FAILED(hr)) {
-        WARN("EnumMediaTypes (%x)\n", hr);
+    if (FAILED(hr = IPin_EnumMediaTypes(source, &enummt)))
+    {
+        IFilterMapper2_Release(mapper);
         return hr;
     }
 
-    IEnumMediaTypes_Reset(penummt);
+    if (graph->pSite)
+        IUnknown_QueryInterface(graph->pSite, &IID_IAMGraphBuilderCallback, (void **)&callback);
 
-    /* Looks like no existing renderer of the kind exists
-     * Try adding new ones
-     */
-    tab[0] = tab[1] = GUID_NULL;
-    while (SUCCEEDED(hr))
+    while (IEnumMediaTypes_Next(enummt, 1, &mt, NULL) == S_OK)
     {
-        hr = IEnumMediaTypes_Next(penummt, 1, &mt, &nbmt);
-        if (FAILED(hr)) {
-            WARN("IEnumMediaTypes_Next (%x)\n", hr);
-            break;
-        }
-        if (!nbmt)
-        {
-            hr = VFW_E_CANNOT_RENDER;
-            break;
-        }
-        else
+        GUID types[2] = {mt->majortype, mt->subtype};
+        IEnumMoniker *enummoniker;
+        IBaseFilter *filter;
+        IMoniker *moniker;
+
+        DeleteMediaType(mt);
+
+        if (FAILED(hr = IFilterMapper2_EnumMatchingFilters(mapper, &enummoniker, 0, FALSE,
+                MERIT_UNLIKELY, TRUE, 1, types, NULL, NULL, FALSE, FALSE, 0, NULL, NULL, NULL)))
+            goto out;
+
+        while (IEnumMoniker_Next(enummoniker, 1, &moniker, NULL) == S_OK)
         {
-            TRACE("MajorType %s\n", debugstr_guid(&mt->majortype));
-            TRACE("SubType %s\n", debugstr_guid(&mt->subtype));
+            IPropertyBag *bag;
+            VARIANT var;
 
-            /* Only enumerate once, this doesn't account for all previous ones, but this should be enough nonetheless */
-            if (IsEqualIID(&tab[0], &mt->majortype) && IsEqualIID(&tab[1], &mt->subtype))
+            VariantInit(&var);
+            IMoniker_BindToStorage(moniker, NULL, NULL, &IID_IPropertyBag, (void **)&bag);
+            hr = IPropertyBag_Read(bag, L"FriendlyName", &var, NULL);
+            IPropertyBag_Release(bag);
+            if (FAILED(hr))
             {
-                DeleteMediaType(mt);
+                IMoniker_Release(moniker);
                 continue;
             }
 
-            if (pFilterMapper2 == NULL)
+            if (callback && FAILED(hr = IAMGraphBuilderCallback_SelectedFilter(callback, moniker)))
             {
-                hr = IUnknown_QueryInterface(This->punkFilterMapper2, &IID_IFilterMapper2, (void**)&pFilterMapper2);
-                if (FAILED(hr))
-                {
-                    WARN("Unable to query IFilterMapper2 (%x)\n", hr);
-                    break;
-                }
+                TRACE("Filter rejected by IAMGraphBuilderCallback::SelectedFilter(), hr %#x.\n", hr);
+                IMoniker_Release(moniker);
+                continue;
             }
 
-            /* Try to find a suitable renderer with the same media type */
-            tab[0] = mt->majortype;
-            tab[1] = mt->subtype;
-            hr = IFilterMapper2_EnumMatchingFilters(pFilterMapper2, &pEnumMoniker, 0, FALSE, MERIT_UNLIKELY, TRUE, 1, tab, NULL, NULL, FALSE, FALSE, 0, NULL, NULL, NULL);
+            hr = create_filter(graph, moniker, &filter);
+            IMoniker_Release(moniker);
             if (FAILED(hr))
             {
-                WARN("Unable to enum filters (%x)\n", hr);
-                break;
+                ERR("Failed to create filter for %s, hr %#x.\n", debugstr_w(V_BSTR(&var)), hr);
+                VariantClear(&var);
+                continue;
             }
-        }
-        hr = E_FAIL;
 
-        while (IEnumMoniker_Next(pEnumMoniker, 1, &pMoniker, &nb) == S_OK)
-        {
-            VARIANT var;
-            IPin* ppinfilter;
-            IBaseFilter* pfilter = NULL;
-            IEnumPins* penumpins = NULL;
-            ULONG pin;
-
-            hr = GetFilterInfo(pMoniker, &var);
-            if (FAILED(hr)) {
-                WARN("Unable to retrieve filter info (%x)\n", hr);
-                goto error;
+            if (callback && FAILED(hr = IAMGraphBuilderCallback_CreatedFilter(callback, filter)))
+            {
+                TRACE("Filter rejected by IAMGraphBuilderCallback::CreatedFilter(), hr %#x.\n", hr);
+                IBaseFilter_Release(filter);
+                continue;
             }
 
-            hr = create_filter(This, pMoniker, &pfilter);
-            IMoniker_Release(pMoniker);
+            hr = IFilterGraph2_AddFilter(&graph->IFilterGraph2_iface, filter, V_BSTR(&var));
+            VariantClear(&var);
             if (FAILED(hr))
             {
-                WARN("Unable to create filter (%x), trying next one\n", hr);
-                goto error;
-            }
-
-            hr = IFilterGraph2_AddFilter(iface, pfilter, V_BSTR(&var));
-            if (FAILED(hr)) {
-                WARN("Unable to add filter (%x)\n", hr);
-                IBaseFilter_Release(pfilter);
-                pfilter = NULL;
-                goto error;
+                ERR("Failed to add filter, hr %#x.\n", hr);
+                IBaseFilter_Release(filter);
+                continue;
             }
 
-            hr = IBaseFilter_EnumPins(pfilter, &penumpins);
-            if (FAILED(hr)) {
-                WARN("Splitter Enumpins (%x)\n", hr);
-                goto error;
+            hr = autoplug_through_filter(graph, source, filter, sink, recursion_depth);
+            if (SUCCEEDED(hr))
+            {
+                IBaseFilter_Release(filter);
+                goto out;
             }
 
-            while ((hr = IEnumPins_Next(penumpins, 1, &ppinfilter, &pin)) == S_OK)
-            {
-                PIN_DIRECTION dir;
+            IFilterGraph2_RemoveFilter(&graph->IFilterGraph2_iface, filter);
+            IBaseFilter_Release(filter);
+        }
+        IEnumMoniker_Release(enummoniker);
+    }
 
-                if (pin == 0) {
-                    WARN("No Pin\n");
-                    hr = E_FAIL;
-                    goto error;
-                }
+    hr = VFW_E_CANNOT_CONNECT;
 
-                hr = IPin_QueryDirection(ppinfilter, &dir);
-                if (FAILED(hr)) {
-                    IPin_Release(ppinfilter);
-                    WARN("QueryDirection failed (%x)\n", hr);
-                    goto error;
-                }
-                if (dir != PINDIR_INPUT) {
-                    IPin_Release(ppinfilter);
-                    continue; /* Wrong direction */
-                }
+out:
+    if (callback) IAMGraphBuilderCallback_Release(callback);
+    IEnumMediaTypes_Release(enummt);
+    IFilterMapper2_Release(mapper);
+    return hr;
+}
 
-                /* Connect the pin to the "Renderer" */
-                hr = IFilterGraph2_ConnectDirect(iface, ppinOut, ppinfilter, NULL);
-                IPin_Release(ppinfilter);
+static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *source, IPin *sink)
+{
+    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    PIN_DIRECTION dir;
+    HRESULT hr;
 
-                if (FAILED(hr)) {
-                    WARN("Unable to connect %s to renderer (%x)\n", debugstr_w(V_BSTR(&var)), hr);
-                    goto error;
-                }
-                TRACE("Connected, recursing %s\n",  debugstr_w(V_BSTR(&var)));
+    TRACE("graph %p, source %p, sink %p.\n", graph, source, sink);
 
-                VariantClear(&var);
+    if (!source || !sink)
+        return E_POINTER;
 
-                hr = render_output_pins(This, pfilter);
-                if (FAILED(hr)) {
-                    WARN("Unable to connect recursively (%x)\n", hr);
-                    goto error;
-                }
-                IBaseFilter_Release(pfilter);
-                break;
-            }
-            if (SUCCEEDED(hr)) {
-                IEnumPins_Release(penumpins);
-                break; /* out of IEnumMoniker_Next loop */
-            }
+    if (FAILED(hr = IPin_QueryDirection(source, &dir)))
+        return hr;
 
-            /* IEnumPins_Next failed, all other failure case caught by goto error */
-            WARN("IEnumPins_Next (%x)\n", hr);
-            /* goto error */
+    if (dir == PINDIR_INPUT)
+    {
+        IPin *temp;
 
-error:
-            VariantClear(&var);
-            if (penumpins)
-                IEnumPins_Release(penumpins);
-            if (pfilter) {
-                IFilterGraph2_RemoveFilter(iface, pfilter);
-                IBaseFilter_Release(pfilter);
-            }
-            if (SUCCEEDED(hr)) DebugBreak();
-        }
+        TRACE("Directions seem backwards, swapping pins\n");
 
-        IEnumMoniker_Release(pEnumMoniker);
-        if (nbmt)
-            DeleteMediaType(mt);
-        if (SUCCEEDED(hr))
-            break;
-        hr = S_OK;
+        temp = sink;
+        sink = source;
+        source = temp;
     }
 
-    if (pFilterMapper2)
-        IFilterMapper2_Release(pFilterMapper2);
+    EnterCriticalSection(&graph->cs);
+
+    hr = autoplug(graph, source, sink, 0);
+
+    LeaveCriticalSection(&graph->cs);
+
+    TRACE("Returning %#x.\n", hr);
+    return hr;
+}
+
+static HRESULT WINAPI FilterGraph2_Render(IFilterGraph2 *iface, IPin *source)
+{
+    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    HRESULT hr;
+
+    TRACE("graph %p, source %p.\n", graph, source);
+
+    EnterCriticalSection(&graph->cs);
+    hr = autoplug(graph, source, NULL, 0);
+    LeaveCriticalSection(&graph->cs);
+    if (hr == VFW_E_CANNOT_CONNECT)
+        hr = VFW_E_CANNOT_RENDER;
 
-    IEnumMediaTypes_Release(penummt);
+    TRACE("Returning %#x.\n", hr);
     return hr;
 }
 
@@ -5755,7 +5404,6 @@ static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL
     memcpy(&fimpl->timeformatseek, &TIME_FORMAT_MEDIA_TIME, sizeof(GUID));
     fimpl->stream_start = fimpl->stream_elapsed = 0;
     fimpl->punkFilterMapper2 = NULL;
-    fimpl->recursioncount = 0;
     fimpl->version = 0;
     fimpl->current_pos = 0;
 
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 22ed37cd307..5a61b754648 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -2110,7 +2110,7 @@ static void test_graph_builder_connect(void)
 {
     static const GUID parser1_clsid = {0x12345678};
     static const GUID parser2_clsid = {0x87654321};
-    AM_MEDIA_TYPE source_type = {{0}}, sink_type = {{0}}, parser3_type = {{0}};
+    AM_MEDIA_TYPE source_types[2] = {{{0}}}, sink_type = {{0}}, parser3_type = {{0}};
     struct testpin source_pin, sink_pin, sink2_pin, parser1_pins[3], parser2_pins[2], parser3_pins[2];
     struct testfilter source, sink, sink2, parser1, parser2, parser3;
     struct testfilter_cf parser1_cf = { {&testfilter_cf_vtbl}, &parser1 };
@@ -2125,10 +2125,11 @@ static void test_graph_builder_connect(void)
     HRESULT hr;
     ULONG ref;
 
-    memset(&source_type.majortype, 0xcc, sizeof(GUID));
+    memset(&source_types[0].majortype, 0xcc, sizeof(GUID));
+    memset(&source_types[1].majortype, 0xdd, sizeof(GUID));
     memset(&sink_type.majortype, 0x66, sizeof(GUID));
-    testsource_init(&source_pin, &source_type, 1);
-    source_pin.request_mt = &source_type;
+    testsource_init(&source_pin, source_types, 2);
+    source_pin.request_mt = &source_types[1];
     testfilter_init(&source, &source_pin, 1);
     testsink_init(&sink_pin);
     testfilter_init(&sink, &sink_pin, 1);
@@ -2398,7 +2399,7 @@ todo_wine
     regpins[1].cInstances = 1;
     regpins[1].nMediaTypes = 1;
     regpins[1].lpMediaType = &regtypes;
-    regtypes.clsMajorType = &source_type.majortype;
+    regtypes.clsMajorType = &source_types[1].majortype;
     regtypes.clsMinorType = &MEDIASUBTYPE_NULL;
     hr = IFilterMapper2_RegisterFilter(mapper, &parser1_clsid, L"test", NULL, NULL, NULL, &regfilter);
     if (hr == E_ACCESSDENIED)
From 15303e54016ef92e583d98386c8dcbefe52d9b74 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 15 Jun 2020 22:51:26 -0500
Subject: [PATCH] quartz: Implement IFilterGraph2::RenderEx().

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=35215
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 49 ++++++++++++++++++++++-----------
 dlls/quartz/tests/filtergraph.c | 28 +++++++++++++++----
 2 files changed, 56 insertions(+), 21 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index e3faf64fb82..a23e35d6a1c 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -1119,10 +1119,12 @@ static HRESULT create_filter(IFilterGraphImpl *graph, IMoniker *moniker, IBaseFi
         return IMoniker_BindToObject(moniker, NULL, NULL, &IID_IBaseFilter, (void **)filter);
 }
 
-static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink, unsigned int recursion_depth);
+static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink,
+        BOOL render_to_existing, unsigned int recursion_depth);
 
 static HRESULT autoplug_through_sink(IFilterGraphImpl *graph, IPin *source,
-        IBaseFilter *filter, IPin *middle_sink, IPin *sink, unsigned int recursion_depth)
+        IBaseFilter *filter, IPin *middle_sink, IPin *sink,
+        BOOL render_to_existing, BOOL allow_renderers, unsigned int recursion_depth)
 {
     BOOL any = FALSE, all = TRUE;
     IPin *middle_source, *peer;
@@ -1171,7 +1173,7 @@ static HRESULT autoplug_through_sink(IFilterGraphImpl *graph, IPin *source,
             continue;
         }
 
-        hr = autoplug(graph, middle_source, sink, recursion_depth + 1);
+        hr = autoplug(graph, middle_source, sink, render_to_existing, recursion_depth + 1);
         IPin_Release(middle_source);
         if (SUCCEEDED(hr) && sink)
         {
@@ -1187,7 +1189,7 @@ static HRESULT autoplug_through_sink(IFilterGraphImpl *graph, IPin *source,
 
     if (!sink)
     {
-        if (all)
+        if (all && (any || allow_renderers))
             return S_OK;
         if (any)
             return VFW_S_PARTIAL_RENDER;
@@ -1200,7 +1202,8 @@ static HRESULT autoplug_through_sink(IFilterGraphImpl *graph, IPin *source,
 }
 
 static HRESULT autoplug_through_filter(IFilterGraphImpl *graph, IPin *source,
-        IBaseFilter *filter, IPin *sink, unsigned int recursion_depth)
+        IBaseFilter *filter, IPin *sink, BOOL render_to_existing,
+        BOOL allow_renderers, unsigned int recursion_depth)
 {
     IEnumPins *sink_enum;
     IPin *filter_sink;
@@ -1213,7 +1216,8 @@ static HRESULT autoplug_through_filter(IFilterGraphImpl *graph, IPin *source,
 
     while (IEnumPins_Next(sink_enum, 1, &filter_sink, NULL) == S_OK)
     {
-        hr = autoplug_through_sink(graph, source, filter, filter_sink, sink, recursion_depth);
+        hr = autoplug_through_sink(graph, source, filter, filter_sink, sink,
+                render_to_existing, allow_renderers, recursion_depth);
         IPin_Release(filter_sink);
         if (SUCCEEDED(hr))
         {
@@ -1227,7 +1231,8 @@ static HRESULT autoplug_through_filter(IFilterGraphImpl *graph, IPin *source,
 
 /* Common helper for IGraphBuilder::Connect() and IGraphBuilder::Render(), which
  * share most of the same code. Render() calls this with a NULL sink. */
-static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink, unsigned int recursion_depth)
+static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink,
+        BOOL render_to_existing, unsigned int recursion_depth)
 {
     IAMGraphBuilderCallback *callback = NULL;
     IEnumMediaTypes *enummt;
@@ -1259,7 +1264,8 @@ static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink, unsig
     /* Always prefer filters in the graph. */
     LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
-        if (SUCCEEDED(hr = autoplug_through_filter(graph, source, filter->filter, sink, recursion_depth)))
+        if (SUCCEEDED(hr = autoplug_through_filter(graph, source, filter->filter,
+                sink, render_to_existing, TRUE, recursion_depth)))
             return hr;
     }
 
@@ -1334,7 +1340,8 @@ static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink, unsig
                 continue;
             }
 
-            hr = autoplug_through_filter(graph, source, filter, sink, recursion_depth);
+            hr = autoplug_through_filter(graph, source, filter, sink,
+                    render_to_existing, !render_to_existing, recursion_depth);
             if (SUCCEEDED(hr))
             {
                 IBaseFilter_Release(filter);
@@ -1383,7 +1390,7 @@ static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *source, I
 
     EnterCriticalSection(&graph->cs);
 
-    hr = autoplug(graph, source, sink, 0);
+    hr = autoplug(graph, source, sink, FALSE, 0);
 
     LeaveCriticalSection(&graph->cs);
 
@@ -1399,7 +1406,7 @@ static HRESULT WINAPI FilterGraph2_Render(IFilterGraph2 *iface, IPin *source)
     TRACE("graph %p, source %p.\n", graph, source);
 
     EnterCriticalSection(&graph->cs);
-    hr = autoplug(graph, source, NULL, 0);
+    hr = autoplug(graph, source, NULL, FALSE, 0);
     LeaveCriticalSection(&graph->cs);
     if (hr == VFW_E_CANNOT_CONNECT)
         hr = VFW_E_CANNOT_RENDER;
@@ -1598,14 +1605,24 @@ static HRESULT WINAPI FilterGraph2_ReconnectEx(IFilterGraph2 *iface, IPin *pin,
     return hr;
 }
 
-static HRESULT WINAPI FilterGraph2_RenderEx(IFilterGraph2 *iface, IPin *pPinOut, DWORD dwFlags,
-        DWORD *pvContext)
+static HRESULT WINAPI FilterGraph2_RenderEx(IFilterGraph2 *iface, IPin *source, DWORD flags, DWORD *context)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
+    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    HRESULT hr;
 
-    TRACE("(%p/%p)->(%p %08x %p): stub !!!\n", This, iface, pPinOut, dwFlags, pvContext);
+    TRACE("graph %p, source %p, flags %#x, context %p.\n", graph, source, flags, context);
 
-    return S_OK;
+    if (flags & ~AM_RENDEREX_RENDERTOEXISTINGRENDERERS)
+        FIXME("Unknown flags %#x.\n", flags);
+
+    EnterCriticalSection(&graph->cs);
+    hr = autoplug(graph, source, NULL, !!(flags & AM_RENDEREX_RENDERTOEXISTINGRENDERERS), 0);
+    LeaveCriticalSection(&graph->cs);
+    if (hr == VFW_E_CANNOT_CONNECT)
+        hr = VFW_E_CANNOT_RENDER;
+
+    TRACE("Returning %#x.\n", hr);
+    return hr;
 }
 
 
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 5a61b754648..de8e32034f8 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -1978,9 +1978,6 @@ static void test_graph_builder_render(void)
 
     /* Test enumeration of filters from the registry. */
 
-    graph = create_graph();
-    IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
-
     CoRegisterClassObject(&sink1_clsid, (IUnknown *)&sink1_cf.IClassFactory_iface,
             CLSCTX_INPROC_SERVER, REGCLS_MULTIPLEUSE, &cookie1);
     CoRegisterClassObject(&sink2_clsid, (IUnknown *)&sink2_cf.IClassFactory_iface,
@@ -2007,6 +2004,9 @@ static void test_graph_builder_render(void)
     }
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
+    graph = create_graph();
+    IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
+
     regpins.dwFlags = REG_PINFLAG_B_RENDERER;
     IFilterMapper2_RegisterFilter(mapper, &sink2_clsid, L"test", NULL, NULL, NULL, &regfilter);
 
@@ -2086,6 +2086,26 @@ static void test_graph_builder_render(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink1_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
 
+    ref = IFilterGraph2_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+    /* Test AM_RENDEREX_RENDERTOEXISTINGRENDERERS. */
+
+    graph = create_graph();
+    IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
+
+    hr = IFilterGraph2_RenderEx(graph, &source_pin.IPin_iface, AM_RENDEREX_RENDERTOEXISTINGRENDERERS, NULL);
+    ok(hr == VFW_E_CANNOT_RENDER, "Got hr %#x.\n", hr);
+
+    IFilterGraph2_AddFilter(graph, &sink1.IBaseFilter_iface, NULL);
+
+    hr = IFilterGraph2_RenderEx(graph, &source_pin.IPin_iface, AM_RENDEREX_RENDERTOEXISTINGRENDERERS, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(source_pin.peer == &sink1_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
+
+    ref = IFilterGraph2_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
     IFilterMapper2_UnregisterFilter(mapper, NULL, NULL, &sink1_clsid);
     IFilterMapper2_UnregisterFilter(mapper, NULL, NULL, &sink2_clsid);
 
@@ -2093,8 +2113,6 @@ static void test_graph_builder_render(void)
     CoRevokeClassObject(cookie1);
     CoRevokeClassObject(cookie2);
     IFilterMapper2_Release(mapper);
-    ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ok(source.ref == 1, "Got outstanding refcount %d.\n", source.ref);
     ok(source_pin.ref == 1, "Got outstanding refcount %d.\n", source_pin.ref);
     ok(sink1.ref == 1, "Got outstanding refcount %d.\n", sink1.ref);
From 57b627fba69d633042201f7d9c26b2545afa186d Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 18 Jun 2020 01:18:29 +0700
Subject: [PATCH] amstream: Implement MediaStreamFilter::GetCurrentStreamTime.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/filter.c         |  28 ++++++-
 dlls/amstream/tests/amstream.c | 137 +++++++++++++++++++++++++++++++++
 2 files changed, 162 insertions(+), 3 deletions(-)

diff --git a/dlls/amstream/filter.c b/dlls/amstream/filter.c
index 05a02e3f666..3dff686b213 100644
--- a/dlls/amstream/filter.c
+++ b/dlls/amstream/filter.c
@@ -174,6 +174,7 @@ struct filter
     IAMMediaStream **streams;
     IAMMediaStream *seekable_stream;
     FILTER_STATE state;
+    REFERENCE_TIME start_time;
 };
 
 static inline struct filter *impl_from_IMediaStreamFilter(IMediaStreamFilter *iface)
@@ -295,6 +296,7 @@ static HRESULT WINAPI filter_Run(IMediaStreamFilter *iface, REFERENCE_TIME start
 
     EnterCriticalSection(&filter->cs);
 
+    filter->start_time = start;
     set_state(filter, State_Running);
 
     LeaveCriticalSection(&filter->cs);
@@ -614,11 +616,31 @@ static HRESULT WINAPI filter_ReferenceTimeToStreamTime(IMediaStreamFilter *iface
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI filter_GetCurrentStreamTime(IMediaStreamFilter *iface, REFERENCE_TIME *pCurrentStreamTime)
+static HRESULT WINAPI filter_GetCurrentStreamTime(IMediaStreamFilter *iface, REFERENCE_TIME *time)
 {
-    FIXME("(%p)->(%p): Stub!\n", iface, pCurrentStreamTime);
+    struct filter *filter = impl_from_IMediaStreamFilter(iface);
 
-    return E_NOTIMPL;
+    TRACE("filter %p, time %p.\n", filter, time);
+
+    if (!time)
+        return E_POINTER;
+
+    EnterCriticalSection(&filter->cs);
+
+    if (filter->state != State_Running || !filter->clock)
+    {
+        *time = 0;
+        LeaveCriticalSection(&filter->cs);
+        return S_FALSE;
+    }
+
+    IReferenceClock_GetTime(filter->clock, time);
+
+    *time -= filter->start_time;
+
+    LeaveCriticalSection(&filter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI filter_WaitUntil(IMediaStreamFilter *iface, REFERENCE_TIME WaitStreamTime)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 2bc1310a96b..e1f6a15ad38 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -2641,6 +2641,87 @@ static const IMediaSeekingVtbl testsource_seeking_vtbl =
     testsource_seeking_GetPreroll,
 };
 
+struct testclock
+{
+    IReferenceClock IReferenceClock_iface;
+    LONG refcount;
+    LONGLONG time;
+    HRESULT get_time_hr;
+};
+
+static inline struct testclock *impl_from_IReferenceClock(IReferenceClock *iface)
+{
+    return CONTAINING_RECORD(iface, struct testclock, IReferenceClock_iface);
+}
+
+static HRESULT WINAPI testclock_QueryInterface(IReferenceClock *iface, REFIID iid, void **out)
+{
+    if (winetest_debug > 1) trace("QueryInterface(%s)\n", wine_dbgstr_guid(iid));
+    if (IsEqualGUID(iid, &IID_IReferenceClock)
+            || IsEqualGUID(iid, &IID_IUnknown))
+    {
+        *out = iface;
+        IReferenceClock_AddRef(iface);
+        return S_OK;
+    }
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI testclock_AddRef(IReferenceClock *iface)
+{
+    struct testclock *clock = impl_from_IReferenceClock(iface);
+    return InterlockedIncrement(&clock->refcount);
+}
+
+static ULONG WINAPI testclock_Release(IReferenceClock *iface)
+{
+    struct testclock *clock = impl_from_IReferenceClock(iface);
+    return InterlockedDecrement(&clock->refcount);
+}
+
+static HRESULT WINAPI testclock_GetTime(IReferenceClock *iface, REFERENCE_TIME *time)
+{
+    struct testclock *clock = impl_from_IReferenceClock(iface);
+    if (SUCCEEDED(clock->get_time_hr))
+        *time = clock->time;
+    return clock->get_time_hr;
+}
+
+static HRESULT WINAPI testclock_AdviseTime(IReferenceClock *iface, REFERENCE_TIME base, REFERENCE_TIME offset, HEVENT event, DWORD_PTR *cookie)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testclock_AdvisePeriodic(IReferenceClock *iface, REFERENCE_TIME start, REFERENCE_TIME period, HSEMAPHORE semaphore, DWORD_PTR *cookie)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testclock_Unadvise(IReferenceClock *iface, DWORD_PTR cookie)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static IReferenceClockVtbl testclock_vtbl =
+{
+    testclock_QueryInterface,
+    testclock_AddRef,
+    testclock_Release,
+    testclock_GetTime,
+    testclock_AdviseTime,
+    testclock_AdvisePeriodic,
+    testclock_Unadvise,
+};
+
+static void testclock_init(struct testclock *clock)
+{
+    memset(clock, 0, sizeof(*clock));
+    clock->IReferenceClock_iface.lpVtbl = &testclock_vtbl;
+}
+
 static void test_audiostream_get_format(void)
 {
     static const WAVEFORMATEX pin_format =
@@ -4330,6 +4411,61 @@ static void test_mediastreamfilter_set_positions(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_mediastreamfilter_get_current_stream_time(void)
+{
+    IMediaStreamFilter *filter;
+    struct testclock clock;
+    REFERENCE_TIME time;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&CLSID_MediaStreamFilter, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IMediaStreamFilter, (void **)&filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    testclock_init(&clock);
+
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IMediaStreamFilter_GetCurrentStreamTime(filter, NULL);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+    }
+
+    time = 0xdeadbeefdeadbeef;
+    hr = IMediaStreamFilter_GetCurrentStreamTime(filter, &time);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(time == 0, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    hr = IMediaStreamFilter_SetSyncSource(filter, &clock.IReferenceClock_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    clock.get_time_hr = E_FAIL;
+
+    time = 0xdeadbeefdeadbeef;
+    hr = IMediaStreamFilter_GetCurrentStreamTime(filter, &time);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(time == 0, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    hr = IMediaStreamFilter_Run(filter, 23456789);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    time = 0xdeadbeefdeadbeef;
+    hr = IMediaStreamFilter_GetCurrentStreamTime(filter, &time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(time == 0xdeadbeefdd47d2da, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    clock.time = 34567890;
+    clock.get_time_hr = S_OK;
+
+    time = 0xdeadbeefdeadbeef;
+    hr = IMediaStreamFilter_GetCurrentStreamTime(filter, &time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(time == 11111101, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(amstream)
 {
     HANDLE file;
@@ -4383,6 +4519,7 @@ START_TEST(amstream)
     test_mediastreamfilter_stop_pause_run();
     test_mediastreamfilter_support_seeking();
     test_mediastreamfilter_set_positions();
+    test_mediastreamfilter_get_current_stream_time();
 
     CoUninitialize();
 }
From b12ac596fdb6cadff2d77ff34a234bf73be3dfb0 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Fri, 19 Jun 2020 16:10:28 +0200
Subject: [PATCH] amstream: Get rid of the IDirectDrawStreamSampleImpl typedef.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c | 73 +++++++++++++++++++------------------
 1 file changed, 37 insertions(+), 36 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 1c924e40a20..e2f24c3b4c8 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -952,21 +952,22 @@ HRESULT ddraw_stream_create(IUnknown *outer, void **out)
     return S_OK;
 }
 
-typedef struct {
+struct ddraw_sample
+{
     IDirectDrawStreamSample IDirectDrawStreamSample_iface;
     LONG ref;
     IMediaStream *parent;
     IDirectDrawSurface *surface;
     RECT rect;
-} IDirectDrawStreamSampleImpl;
+};
 
-static inline IDirectDrawStreamSampleImpl *impl_from_IDirectDrawStreamSample(IDirectDrawStreamSample *iface)
+static inline struct ddraw_sample *impl_from_IDirectDrawStreamSample(IDirectDrawStreamSample *iface)
 {
-    return CONTAINING_RECORD(iface, IDirectDrawStreamSampleImpl, IDirectDrawStreamSample_iface);
+    return CONTAINING_RECORD(iface, struct ddraw_sample, IDirectDrawStreamSample_iface);
 }
 
 /*** IUnknown methods ***/
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_QueryInterface(IDirectDrawStreamSample *iface,
+static HRESULT WINAPI ddraw_sample_QueryInterface(IDirectDrawStreamSample *iface,
         REFIID riid, void **ret_iface)
 {
     TRACE("(%p)->(%s,%p)\n", iface, debugstr_guid(riid), ret_iface);
@@ -986,43 +987,43 @@ static HRESULT WINAPI IDirectDrawStreamSampleImpl_QueryInterface(IDirectDrawStre
     return E_NOINTERFACE;
 }
 
-static ULONG WINAPI IDirectDrawStreamSampleImpl_AddRef(IDirectDrawStreamSample *iface)
+static ULONG WINAPI ddraw_sample_AddRef(IDirectDrawStreamSample *iface)
 {
-    IDirectDrawStreamSampleImpl *This = impl_from_IDirectDrawStreamSample(iface);
-    ULONG ref = InterlockedIncrement(&This->ref);
+    struct ddraw_sample *sample = impl_from_IDirectDrawStreamSample(iface);
+    ULONG ref = InterlockedIncrement(&sample->ref);
 
     TRACE("(%p)->(): new ref = %u\n", iface, ref);
 
     return ref;
 }
 
-static ULONG WINAPI IDirectDrawStreamSampleImpl_Release(IDirectDrawStreamSample *iface)
+static ULONG WINAPI ddraw_sample_Release(IDirectDrawStreamSample *iface)
 {
-    IDirectDrawStreamSampleImpl *This = impl_from_IDirectDrawStreamSample(iface);
-    ULONG ref = InterlockedDecrement(&This->ref);
+    struct ddraw_sample *sample = impl_from_IDirectDrawStreamSample(iface);
+    ULONG ref = InterlockedDecrement(&sample->ref);
 
     TRACE("(%p)->(): new ref = %u\n", iface, ref);
 
     if (!ref)
     {
-        if (This->surface)
-            IDirectDrawSurface_Release(This->surface);
-        IMediaStream_Release(This->parent);
-        HeapFree(GetProcessHeap(), 0, This);
+        if (sample->surface)
+            IDirectDrawSurface_Release(sample->surface);
+        IMediaStream_Release(sample->parent);
+        HeapFree(GetProcessHeap(), 0, sample);
     }
 
     return ref;
 }
 
 /*** IStreamSample methods ***/
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_GetMediaStream(IDirectDrawStreamSample *iface, IMediaStream **media_stream)
+static HRESULT WINAPI ddraw_sample_GetMediaStream(IDirectDrawStreamSample *iface, IMediaStream **media_stream)
 {
     FIXME("(%p)->(%p): stub\n", iface, media_stream);
 
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_GetSampleTimes(IDirectDrawStreamSample *iface, STREAM_TIME *start_time,
+static HRESULT WINAPI ddraw_sample_GetSampleTimes(IDirectDrawStreamSample *iface, STREAM_TIME *start_time,
                                                                  STREAM_TIME *end_time, STREAM_TIME *current_time)
 {
     FIXME("(%p)->(%p,%p,%p): stub\n", iface, start_time, end_time, current_time);
@@ -1030,7 +1031,7 @@ static HRESULT WINAPI IDirectDrawStreamSampleImpl_GetSampleTimes(IDirectDrawStre
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_SetSampleTimes(IDirectDrawStreamSample *iface, const STREAM_TIME *start_time,
+static HRESULT WINAPI ddraw_sample_SetSampleTimes(IDirectDrawStreamSample *iface, const STREAM_TIME *start_time,
                                                                  const STREAM_TIME *end_time)
 {
     FIXME("(%p)->(%p,%p): stub\n", iface, start_time, end_time);
@@ -1038,7 +1039,7 @@ static HRESULT WINAPI IDirectDrawStreamSampleImpl_SetSampleTimes(IDirectDrawStre
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_Update(IDirectDrawStreamSample *iface, DWORD flags, HANDLE event,
+static HRESULT WINAPI ddraw_sample_Update(IDirectDrawStreamSample *iface, DWORD flags, HANDLE event,
                                                          PAPCFUNC func_APC, DWORD APC_data)
 {
     FIXME("(%p)->(%x,%p,%p,%u): stub\n", iface, flags, event, func_APC, APC_data);
@@ -1046,7 +1047,7 @@ static HRESULT WINAPI IDirectDrawStreamSampleImpl_Update(IDirectDrawStreamSample
     return S_OK;
 }
 
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_CompletionStatus(IDirectDrawStreamSample *iface, DWORD flags, DWORD milliseconds)
+static HRESULT WINAPI ddraw_sample_CompletionStatus(IDirectDrawStreamSample *iface, DWORD flags, DWORD milliseconds)
 {
     FIXME("(%p)->(%x,%u): stub\n", iface, flags, milliseconds);
 
@@ -1054,27 +1055,27 @@ static HRESULT WINAPI IDirectDrawStreamSampleImpl_CompletionStatus(IDirectDrawSt
 }
 
 /*** IDirectDrawStreamSample methods ***/
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_GetSurface(IDirectDrawStreamSample *iface, IDirectDrawSurface **ddraw_surface,
+static HRESULT WINAPI ddraw_sample_GetSurface(IDirectDrawStreamSample *iface, IDirectDrawSurface **ddraw_surface,
                                                              RECT *rect)
 {
-    IDirectDrawStreamSampleImpl *This = impl_from_IDirectDrawStreamSample(iface);
+    struct ddraw_sample *sample = impl_from_IDirectDrawStreamSample(iface);
 
     TRACE("(%p)->(%p,%p)\n", iface, ddraw_surface, rect);
 
     if (ddraw_surface)
     {
-        *ddraw_surface = This->surface;
+        *ddraw_surface = sample->surface;
         if (*ddraw_surface)
             IDirectDrawSurface_AddRef(*ddraw_surface);
     }
 
     if (rect)
-        *rect = This->rect;
+        *rect = sample->rect;
 
     return S_OK;
 }
 
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_SetRect(IDirectDrawStreamSample *iface, const RECT *rect)
+static HRESULT WINAPI ddraw_sample_SetRect(IDirectDrawStreamSample *iface, const RECT *rect)
 {
     FIXME("(%p)->(%p): stub\n", iface, rect);
 
@@ -1084,24 +1085,24 @@ static HRESULT WINAPI IDirectDrawStreamSampleImpl_SetRect(IDirectDrawStreamSampl
 static const struct IDirectDrawStreamSampleVtbl DirectDrawStreamSample_Vtbl =
 {
     /*** IUnknown methods ***/
-    IDirectDrawStreamSampleImpl_QueryInterface,
-    IDirectDrawStreamSampleImpl_AddRef,
-    IDirectDrawStreamSampleImpl_Release,
+    ddraw_sample_QueryInterface,
+    ddraw_sample_AddRef,
+    ddraw_sample_Release,
     /*** IStreamSample methods ***/
-    IDirectDrawStreamSampleImpl_GetMediaStream,
-    IDirectDrawStreamSampleImpl_GetSampleTimes,
-    IDirectDrawStreamSampleImpl_SetSampleTimes,
-    IDirectDrawStreamSampleImpl_Update,
-    IDirectDrawStreamSampleImpl_CompletionStatus,
+    ddraw_sample_GetMediaStream,
+    ddraw_sample_GetSampleTimes,
+    ddraw_sample_SetSampleTimes,
+    ddraw_sample_Update,
+    ddraw_sample_CompletionStatus,
     /*** IDirectDrawStreamSample methods ***/
-    IDirectDrawStreamSampleImpl_GetSurface,
-    IDirectDrawStreamSampleImpl_SetRect
+    ddraw_sample_GetSurface,
+    ddraw_sample_SetRect
 };
 
 static HRESULT ddrawstreamsample_create(IDirectDrawMediaStream *parent, IDirectDrawSurface *surface,
     const RECT *rect, IDirectDrawStreamSample **ddraw_stream_sample)
 {
-    IDirectDrawStreamSampleImpl *object;
+    struct ddraw_sample *object;
     HRESULT hr;
 
     TRACE("(%p)\n", ddraw_stream_sample);
From b80907047662004f5f370d1a244adfceb22be39b Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Fri, 19 Jun 2020 16:10:29 +0200
Subject: [PATCH] amstream/tests: Add IDirectDrawStreamSample::GetMediaStream()
 tests.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 64 ++++++++++++++++++++--------------
 1 file changed, 38 insertions(+), 26 deletions(-)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index e1f6a15ad38..72ef7912aa9 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -2006,44 +2006,44 @@ static void test_media_types(void)
 
 static void test_IDirectDrawStreamSample(void)
 {
+    IDirectDrawMediaStream *ddraw_stream = NULL;
+    IDirectDrawStreamSample *sample = NULL;
+    IDirectDrawSurface *surface, *surface2;
+    IMediaStream *stream2, *stream = NULL;
     DDSURFACEDESC desc = { sizeof(desc) };
-    IAMMultiMediaStream *pams;
-    HRESULT hr;
-    IMediaStream *pvidstream = NULL;
-    IDirectDrawMediaStream *pddstream = NULL;
-    IDirectDrawStreamSample *pddsample = NULL;
+    IAMMultiMediaStream *mmstream;
     IDirectDrawSurface7 *surface7;
-    IDirectDrawSurface *surface, *surface2;
     IDirectDraw *ddraw, *ddraw2;
     IDirectDraw7 *ddraw7;
+    HRESULT hr;
     RECT rect;
 
-    if (!(pams = create_ammultimediastream()))
+    if (!(mmstream = create_ammultimediastream()))
         return;
     if (!create_directdraw())
     {
-        IAMMultiMediaStream_Release(pams);
+        IAMMultiMediaStream_Release(mmstream);
         return;
     }
 
-    hr = IAMMultiMediaStream_Initialize(pams, STREAMTYPE_READ, 0, NULL);
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
-    hr = IAMMultiMediaStream_AddMediaStream(pams, (IUnknown*)pdd7, &MSPID_PrimaryVideo, 0, NULL);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown*)pdd7, &MSPID_PrimaryVideo, 0, NULL);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
-    hr = IAMMultiMediaStream_GetMediaStream(pams, &MSPID_PrimaryVideo, &pvidstream);
+    hr = IAMMultiMediaStream_GetMediaStream(mmstream, &MSPID_PrimaryVideo, &stream);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     if (FAILED(hr)) goto error;
 
-    hr = IMediaStream_QueryInterface(pvidstream, &IID_IDirectDrawMediaStream, (LPVOID*)&pddstream);
+    hr = IMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (LPVOID*)&ddraw_stream);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     if (FAILED(hr)) goto error;
 
-    hr = IDirectDrawMediaStream_GetDirectDraw(pddstream, &ddraw);
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
-    hr = IDirectDrawMediaStream_GetDirectDraw(pddstream, &ddraw2);
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw2);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(ddraw == ddraw2, "got %p, %p\n", ddraw, ddraw2);
 
@@ -2055,14 +2055,26 @@ static void test_IDirectDrawStreamSample(void)
     IDirectDraw_Release(ddraw2);
     IDirectDraw_Release(ddraw);
 
-    hr = IDirectDrawMediaStream_CreateSample(pddstream, NULL, NULL, 0, &pddsample);
+    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, &sample);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
     surface = NULL;
-    hr = IDirectDrawStreamSample_GetSurface(pddsample, &surface, &rect);
+    hr = IDirectDrawStreamSample_GetSurface(sample, &surface, &rect);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(surface != NULL, "got %p\n", surface);
 
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IDirectDrawStreamSample_GetMediaStream(sample, NULL);
+        ok(hr == E_POINTER, "got 0x%08x\n", hr);
+    }
+
+    hr = IDirectDrawStreamSample_GetMediaStream(sample, &stream2);
+    todo_wine ok(hr == S_OK, "got 0x%08x\n", hr);
+    todo_wine ok(stream2 == stream, "Expected stream %p, got %p.\n", stream, stream2);
+    if (hr == S_OK) IMediaStream_Release(stream2);
+
     hr = IDirectDrawSurface_QueryInterface(surface, &IID_IDirectDrawSurface7, (void **)&surface7);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     IDirectDrawSurface7_Release(surface7);
@@ -2074,39 +2086,39 @@ static void test_IDirectDrawStreamSample(void)
     ok(desc.ddpfPixelFormat.dwFlags == DDPF_RGB, "format flags %08x\n", desc.ddpfPixelFormat.dwFlags);
     ok(desc.ddpfPixelFormat.dwRGBBitCount, "dwRGBBitCount %d\n", desc.ddpfPixelFormat.dwRGBBitCount);
     IDirectDrawSurface_Release(surface);
-    IDirectDrawStreamSample_Release(pddsample);
+    IDirectDrawStreamSample_Release(sample);
 
     hr = IDirectDrawSurface7_QueryInterface(pdds7, &IID_IDirectDrawSurface, (void **)&surface);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
     EXPECT_REF(surface, 1);
-    hr = IDirectDrawMediaStream_CreateSample(pddstream, surface, NULL, 0, &pddsample);
+    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, surface, NULL, 0, &sample);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     EXPECT_REF(surface, 2);
 
     surface2 = NULL;
     SetRectEmpty(&rect);
-    hr = IDirectDrawStreamSample_GetSurface(pddsample, &surface2, &rect);
+    hr = IDirectDrawStreamSample_GetSurface(sample, &surface2, &rect);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(surface == surface2, "got %p\n", surface2);
     ok(rect.right > 0 && rect.bottom > 0, "got %d, %d\n", rect.right, rect.bottom);
     EXPECT_REF(surface, 3);
     IDirectDrawSurface_Release(surface2);
 
-    hr = IDirectDrawStreamSample_GetSurface(pddsample, NULL, NULL);
+    hr = IDirectDrawStreamSample_GetSurface(sample, NULL, NULL);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
-    IDirectDrawStreamSample_Release(pddsample);
+    IDirectDrawStreamSample_Release(sample);
     IDirectDrawSurface_Release(surface);
 
 error:
-    if (pddstream)
-        IDirectDrawMediaStream_Release(pddstream);
-    if (pvidstream)
-        IMediaStream_Release(pvidstream);
+    if (ddraw_stream)
+        IDirectDrawMediaStream_Release(ddraw_stream);
+    if (stream)
+        IMediaStream_Release(stream);
 
     release_directdraw();
-    IAMMultiMediaStream_Release(pams);
+    IAMMultiMediaStream_Release(mmstream);
 }
 
 static IUnknown *create_audio_data(void)
From 1e81d551903d548d42d04d5076181741309d23c8 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Fri, 19 Jun 2020 16:10:30 +0200
Subject: [PATCH] amstream: Don't crash on NULL ddraw in
 IDirectDrawMediaStream::GetDirectDraw().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index e2f24c3b4c8..c471a66200d 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -377,6 +377,9 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetDirectDraw(IDirectDrawMedi
 
     TRACE("(%p)->(%p)\n", iface, ddraw);
 
+    if (!ddraw)
+        return E_POINTER;
+
     *ddraw = NULL;
     if (!This->ddraw)
     {
From 0736217336e8b84e27996c44474e49ba828cea13 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Sat, 20 Jun 2020 00:18:51 +0700
Subject: [PATCH] amstream: Implement IAudioStreamSample::GetSampleTimes.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    |  33 +++++-
 dlls/amstream/tests/amstream.c | 181 +++++++++++++++++++++++++++++++++
 2 files changed, 212 insertions(+), 2 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 8fba8777190..4c6c326d847 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -34,6 +34,7 @@ struct queued_receive
     DWORD length;
     BYTE *pointer;
     DWORD position;
+    STREAM_TIME start_time;
 };
 
 struct audio_stream
@@ -66,6 +67,8 @@ typedef struct {
     LONG ref;
     struct audio_stream *parent;
     IAudioData *audio_data;
+    STREAM_TIME start_time;
+    STREAM_TIME end_time;
     HANDLE update_event;
 
     struct list entry;
@@ -102,6 +105,12 @@ static void flush_receive_queue(struct audio_stream *stream)
         remove_queued_receive(LIST_ENTRY(entry, struct queued_receive, entry));
 }
 
+static STREAM_TIME stream_time_from_position(struct audio_stream *stream, struct queued_receive *receive)
+{
+    const WAVEFORMATEX *format = (WAVEFORMATEX *)stream->mt.pbFormat;
+    return receive->start_time + (receive->position * 10000000 + format->nAvgBytesPerSec / 2) / format->nAvgBytesPerSec;
+}
+
 static void process_update(IAudioStreamSampleImpl *sample, struct queued_receive *receive)
 {
     DWORD advance;
@@ -109,9 +118,14 @@ static void process_update(IAudioStreamSampleImpl *sample, struct queued_receive
     advance = min(receive->length - receive->position, sample->length - sample->position);
     memcpy(&sample->pointer[sample->position], &receive->pointer[receive->position], advance);
 
+    if (!sample->position)
+        sample->start_time = stream_time_from_position(sample->parent, receive);
+
     receive->position += advance;
     sample->position += advance;
 
+    sample->end_time = stream_time_from_position(sample->parent, receive);
+
     sample->update_hr = (sample->position == sample->length) ? S_OK : MS_S_PENDING;
 }
 
@@ -204,9 +218,19 @@ static HRESULT WINAPI IAudioStreamSampleImpl_GetMediaStream(IAudioStreamSample *
 static HRESULT WINAPI IAudioStreamSampleImpl_GetSampleTimes(IAudioStreamSample *iface, STREAM_TIME *start_time,
                                                                  STREAM_TIME *end_time, STREAM_TIME *current_time)
 {
-    FIXME("(%p)->(%p,%p,%p): stub\n", iface, start_time, end_time, current_time);
+    IAudioStreamSampleImpl *sample = impl_from_IAudioStreamSample(iface);
 
-    return E_NOTIMPL;
+    TRACE("sample %p, start_time %p, end_time %p, current_time %p.\n", sample, start_time, end_time, current_time);
+
+    if (current_time)
+        IMediaStreamFilter_GetCurrentStreamTime(sample->parent->filter, current_time);
+
+    if (start_time)
+        *start_time = sample->start_time;
+    if (end_time)
+        *end_time = sample->end_time;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI IAudioStreamSampleImpl_SetSampleTimes(IAudioStreamSample *iface, const STREAM_TIME *start_time,
@@ -1228,6 +1252,8 @@ static HRESULT WINAPI audio_meminput_Receive(IMemInputPin *iface, IMediaSample *
 {
     struct audio_stream *stream = impl_from_IMemInputPin(iface);
     struct queued_receive *receive;
+    REFERENCE_TIME start_time = 0;
+    REFERENCE_TIME end_time = 0;
     BYTE *pointer;
     HRESULT hr;
 
@@ -1253,6 +1279,8 @@ static HRESULT WINAPI audio_meminput_Receive(IMemInputPin *iface, IMediaSample *
         return hr;
     }
 
+    IMediaSample_GetTime(sample, &start_time, &end_time);
+
     receive = calloc(1, sizeof(*receive));
     if (!receive)
     {
@@ -1263,6 +1291,7 @@ static HRESULT WINAPI audio_meminput_Receive(IMemInputPin *iface, IMediaSample *
     receive->length = IMediaSample_GetActualDataLength(sample);
     receive->pointer = pointer;
     receive->sample = sample;
+    receive->start_time = start_time;
     IMediaSample_AddRef(receive->sample);
     list_add_tail(&stream->receive_queue, &receive->entry);
 
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 72ef7912aa9..c7510f30c4d 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -3863,6 +3863,186 @@ void test_audiostreamsample_completion_status(void)
     CloseHandle(event);
 }
 
+static void test_audiostreamsample_get_sample_times(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    static const BYTE test_data[8] = { 0 };
+    IAudioStreamSample *stream_sample;
+    IMediaFilter *graph_media_filter;
+    IAudioMediaStream *audio_stream;
+    STREAM_TIME filter_start_time;
+    IMemInputPin *mem_input_pin;
+    IMediaStreamFilter *filter;
+    IMediaSample *media_sample;
+    struct testfilter source;
+    STREAM_TIME current_time;
+    struct testclock clock;
+    IAudioData *audio_data;
+    STREAM_TIME start_time;
+    STREAM_TIME end_time;
+    IGraphBuilder *graph;
+    IMediaStream *stream;
+    HRESULT hr;
+    ULONG ref;
+    IPin *pin;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!!filter, "Expected non-null filter.\n");
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IAudioMediaStream, (void **)&audio_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IMemInputPin, (void **)&mem_input_pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    hr = IGraphBuilder_QueryInterface(graph, &IID_IMediaFilter, (void **)&graph_media_filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    testfilter_init(&source);
+    hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER, &IID_IAudioData, (void **)&audio_data);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAudioMediaStream_CreateSample(audio_stream, audio_data, 0, &stream_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAudioData_SetBuffer(audio_data, 5, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    testclock_init(&clock);
+
+    clock.time = 12345678;
+
+    current_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, NULL, NULL, &current_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(current_time == 0, "Got current time %s.\n", wine_dbgstr_longlong(current_time));
+
+    IMediaFilter_SetSyncSource(graph_media_filter, &clock.IReferenceClock_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    current_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, NULL, NULL, &current_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(current_time == 0, "Got current time %s.\n", wine_dbgstr_longlong(current_time));
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_GetCurrentStreamTime(filter, &filter_start_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    clock.get_time_hr = E_FAIL;
+
+    current_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, NULL, NULL, &current_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(current_time == 0xdeadbeefddf15da1 + filter_start_time, "Expected current time %s, got %s.\n",
+            wine_dbgstr_longlong(0xdeadbeefddf15da1 + filter_start_time), wine_dbgstr_longlong(current_time));
+
+    clock.get_time_hr = S_OK;
+
+    current_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, NULL, NULL, &current_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(current_time == filter_start_time, "Expected current time %s, got %s.\n",
+            wine_dbgstr_longlong(filter_start_time), wine_dbgstr_longlong(current_time));
+
+    clock.time = 23456789;
+
+    current_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, NULL, NULL, &current_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(current_time == filter_start_time + 11111111, "Expected current time %s, got %s.\n",
+            wine_dbgstr_longlong(filter_start_time + 11111111), wine_dbgstr_longlong(current_time));
+
+    start_time = 0xdeadbeefdeadbeef;
+    end_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, &start_time, &end_time, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(start_time == 0, "Got start time %s.\n", wine_dbgstr_longlong(start_time));
+    ok(end_time == 0, "Got end time %s.\n", wine_dbgstr_longlong(end_time));
+
+    media_sample = audiostream_allocate_sample(&source, test_data, 8);
+    start_time = 12345678;
+    end_time = 23456789;
+    hr = IMediaSample_SetTime(media_sample, &start_time, &end_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(mem_input_pin, media_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    IMediaSample_Release(media_sample);
+
+    hr = IAudioStreamSample_Update(stream_sample, 0, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    start_time = 0xdeadbeefdeadbeef;
+    end_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, &start_time, &end_time, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(start_time == 12345678, "Got start time %s.\n", wine_dbgstr_longlong(start_time));
+    ok(end_time == 12347946, "Got end time %s.\n", wine_dbgstr_longlong(end_time));
+
+    media_sample = audiostream_allocate_sample(&source, test_data, 6);
+    start_time = 12345678;
+    end_time = 23456789;
+    hr = IMediaSample_SetTime(media_sample, &start_time, &end_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(mem_input_pin, media_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    IMediaSample_Release(media_sample);
+
+    hr = IAudioStreamSample_Update(stream_sample, 0, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    start_time = 0xdeadbeefdeadbeef;
+    end_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, &start_time, &end_time, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(start_time == 12347946, "Got start time %s.\n", wine_dbgstr_longlong(start_time));
+    ok(end_time == 12346585, "Got end time %s.\n", wine_dbgstr_longlong(end_time));
+
+    hr = IPin_EndOfStream(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAudioStreamSample_Update(stream_sample, 0, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    start_time = 0xdeadbeefdeadbeef;
+    end_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, &start_time, &end_time, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(start_time == 12346585, "Got start time %s.\n", wine_dbgstr_longlong(start_time));
+    ok(end_time == 12348399, "Got end time %s.\n", wine_dbgstr_longlong(end_time));
+
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    IGraphBuilder_Disconnect(graph, pin);
+    IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
+
+    ref = IAudioStreamSample_Release(stream_sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAudioData_Release(audio_data);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IMediaFilter_Release(graph_media_filter);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin);
+    IMemInputPin_Release(mem_input_pin);
+    IAudioMediaStream_Release(audio_stream);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void test_ddrawstream_initialize(void)
 {
     IDirectDrawMediaStream *ddraw_stream;
@@ -4522,6 +4702,7 @@ START_TEST(amstream)
 
     test_audiostreamsample_update();
     test_audiostreamsample_completion_status();
+    test_audiostreamsample_get_sample_times();
 
     test_ddrawstream_initialize();
 
From b9712f2f37f6648108c608e3e33046a697ef36b4 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Sat, 20 Jun 2020 00:18:52 +0700
Subject: [PATCH] amstream: Implement AMAudioStream::NewSegment.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    |  18 +++--
 dlls/amstream/tests/amstream.c | 119 +++++++++++++++++++++++++++++++--
 2 files changed, 129 insertions(+), 8 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 4c6c326d847..a19cb4ea96f 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -56,6 +56,7 @@ struct audio_stream
     AM_MEDIA_TYPE mt;
     WAVEFORMATEX format;
     FILTER_STATE state;
+    REFERENCE_TIME segment_start;
     BOOL eos;
     BOOL flushing;
     struct list receive_queue;
@@ -1158,9 +1159,18 @@ static HRESULT WINAPI audio_sink_EndFlush(IPin *iface)
 
 static HRESULT WINAPI audio_sink_NewSegment(IPin *iface, REFERENCE_TIME start, REFERENCE_TIME stop, double rate)
 {
-    FIXME("iface %p, start %s, stop %s, rate %0.16e, stub!\n",
-            iface, wine_dbgstr_longlong(start), wine_dbgstr_longlong(stop), rate);
-    return E_NOTIMPL;
+    struct audio_stream *stream = impl_from_IPin(iface);
+
+    TRACE("stream %p, start %s, stop %s, rate %0.16e\n",
+            stream, wine_dbgstr_longlong(start), wine_dbgstr_longlong(stop), rate);
+
+    EnterCriticalSection(&stream->cs);
+
+    stream->segment_start = start;
+
+    LeaveCriticalSection(&stream->cs);
+
+    return S_OK;
 }
 
 static const IPinVtbl audio_sink_vtbl =
@@ -1291,7 +1301,7 @@ static HRESULT WINAPI audio_meminput_Receive(IMemInputPin *iface, IMediaSample *
     receive->length = IMediaSample_GetActualDataLength(sample);
     receive->pointer = pointer;
     receive->sample = sample;
-    receive->start_time = start_time;
+    receive->start_time = start_time + stream->segment_start;
     IMediaSample_AddRef(receive->sample);
     list_add_tail(&stream->receive_queue, &receive->entry);
 
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index c7510f30c4d..eb9b852ba48 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -3440,10 +3440,6 @@ static void test_audiostream_begin_flush_end_flush(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
-static void CALLBACK apc_func(ULONG_PTR param)
-{
-}
-
 static IMediaSample *audiostream_allocate_sample(struct testfilter *source, const BYTE *input_data, DWORD input_length)
 {
     IMediaSample *sample;
@@ -3464,6 +3460,120 @@ static IMediaSample *audiostream_allocate_sample(struct testfilter *source, cons
     return sample;
 }
 
+static void test_audiostream_new_segment(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    static const BYTE test_data[8] = { 0 };
+    IAudioStreamSample *stream_sample;
+    IAudioMediaStream *audio_stream;
+    IMemInputPin *mem_input_pin;
+    IMediaSample *media_sample;
+    struct testfilter source;
+    IAudioData *audio_data;
+    STREAM_TIME start_time;
+    STREAM_TIME end_time;
+    IGraphBuilder *graph;
+    IMediaStream *stream;
+    HRESULT hr;
+    ULONG ref;
+    IPin *pin;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IAudioMediaStream, (void **)&audio_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IMemInputPin, (void **)&mem_input_pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    testfilter_init(&source);
+    hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER, &IID_IAudioData, (void **)&audio_data);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAudioMediaStream_CreateSample(audio_stream, audio_data, 0, &stream_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAudioData_SetBuffer(audio_data, 5, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_NewSegment(pin, 11111111, 22222222, 1.0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    media_sample = audiostream_allocate_sample(&source, test_data, 5);
+    start_time = 12345678;
+    end_time = 23456789;
+    hr = IMediaSample_SetTime(media_sample, &start_time, &end_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(mem_input_pin, media_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    IMediaSample_Release(media_sample);
+
+    hr = IAudioStreamSample_Update(stream_sample, 0, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    start_time = 0xdeadbeefdeadbeef;
+    end_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, &start_time, &end_time, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(start_time == 23456789, "Got start time %s.\n", wine_dbgstr_longlong(start_time));
+    ok(end_time == 23459057, "Got end time %s.\n", wine_dbgstr_longlong(end_time));
+
+    hr = IPin_NewSegment(pin, 11111111, 22222222, 2.0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    media_sample = audiostream_allocate_sample(&source, test_data, 5);
+    start_time = 12345678;
+    end_time = 23456789;
+    hr = IMediaSample_SetTime(media_sample, &start_time, &end_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(mem_input_pin, media_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    IMediaSample_Release(media_sample);
+
+    hr = IAudioStreamSample_Update(stream_sample, 0, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    start_time = 0xdeadbeefdeadbeef;
+    end_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, &start_time, &end_time, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(start_time == 23456789, "Got start time %s.\n", wine_dbgstr_longlong(start_time));
+    ok(end_time == 23459057, "Got end time %s.\n", wine_dbgstr_longlong(end_time));
+
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    IGraphBuilder_Disconnect(graph, pin);
+    IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
+
+    ref = IAudioStreamSample_Release(stream_sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAudioData_Release(audio_data);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin);
+    IMemInputPin_Release(mem_input_pin);
+    IAudioMediaStream_Release(audio_stream);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void CALLBACK apc_func(ULONG_PTR param)
+{
+}
+
 static IPin *audiostream_pin;
 static IMemInputPin *audiostream_mem_input_pin;
 static IMediaSample *audiostream_media_sample;
@@ -4699,6 +4809,7 @@ START_TEST(amstream)
     test_audiostream_receive();
     test_audiostream_initialize();
     test_audiostream_begin_flush_end_flush();
+    test_audiostream_new_segment();
 
     test_audiostreamsample_update();
     test_audiostreamsample_completion_status();
