From 410934a762a048fbff8d35927a70ce55f97a9d63 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 22 May 2020 16:25:51 -0500
Subject: [PATCH] amstream: Simplify flush_receive_queue() a bit.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 68b8b84f505..4e82d76da0d 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -95,13 +95,10 @@ static void remove_queued_update(IAudioStreamSampleImpl *sample)
 
 static void flush_receive_queue(struct audio_stream *stream)
 {
-    while (!list_empty(&stream->receive_queue))
-    {
-        struct queued_receive *receive =
-            LIST_ENTRY(list_head(&stream->receive_queue), struct queued_receive, entry);
+    struct list *entry;
 
-        remove_queued_receive(receive);
-    }
+    while ((entry = list_head(&stream->receive_queue)))
+        remove_queued_receive(LIST_ENTRY(entry, struct queued_receive, entry));
 }
 
 static void process_update(IAudioStreamSampleImpl *sample, struct queued_receive *receive)
From f5aaca10affba65460206f6869fdf7fb10197468 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 25 May 2020 14:17:32 -0500
Subject: [PATCH] amstream: Don't duplicate IMediaStream method
 implementations.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c | 61 +++++++++-------------------------
 dlls/amstream/ddrawstream.c | 65 ++++++++++---------------------------
 2 files changed, 32 insertions(+), 94 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 4e82d76da0d..d620abc6ecf 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -605,76 +605,45 @@ static ULONG WINAPI audio_IAudioMediaStream_Release(IAudioMediaStream *iface)
     return IAMMediaStream_Release(&This->IAMMediaStream_iface);
 }
 
-/*** IMediaStream methods ***/
 static HRESULT WINAPI audio_IAudioMediaStream_GetMultiMediaStream(IAudioMediaStream *iface,
-        IMultiMediaStream **multi_media_stream)
+        IMultiMediaStream **mmstream)
 {
-    struct audio_stream *This = impl_from_IAudioMediaStream(iface);
-
-    TRACE("(%p/%p)->(%p)\n", iface, This, multi_media_stream);
-
-    if (!multi_media_stream)
-        return E_POINTER;
-
-    IMultiMediaStream_AddRef(This->parent);
-    *multi_media_stream = This->parent;
-
-    return S_OK;
+    struct audio_stream *stream = impl_from_IAudioMediaStream(iface);
+    return IAMMediaStream_GetMultiMediaStream(&stream->IAMMediaStream_iface, mmstream);
 }
 
 static HRESULT WINAPI audio_IAudioMediaStream_GetInformation(IAudioMediaStream *iface,
         MSPID *purpose_id, STREAM_TYPE *type)
 {
-    struct audio_stream *This = impl_from_IAudioMediaStream(iface);
-
-    TRACE("(%p/%p)->(%p,%p)\n", iface, This, purpose_id, type);
-
-    if (purpose_id)
-        *purpose_id = This->purpose_id;
-    if (type)
-        *type = This->stream_type;
-
-    return S_OK;
+    struct audio_stream *stream = impl_from_IAudioMediaStream(iface);
+    return IAMMediaStream_GetInformation(&stream->IAMMediaStream_iface, purpose_id, type);
 }
 
 static HRESULT WINAPI audio_IAudioMediaStream_SetSameFormat(IAudioMediaStream *iface,
-        IMediaStream *stream_format, DWORD flags)
+        IMediaStream *other, DWORD flags)
 {
-    struct audio_stream *This = impl_from_IAudioMediaStream(iface);
-
-    FIXME("(%p/%p)->(%p,%x) stub!\n", iface, This, stream_format, flags);
-
-    return S_FALSE;
+    struct audio_stream *stream = impl_from_IAudioMediaStream(iface);
+    return IAMMediaStream_SetSameFormat(&stream->IAMMediaStream_iface, other, flags);
 }
 
 static HRESULT WINAPI audio_IAudioMediaStream_AllocateSample(IAudioMediaStream *iface,
         DWORD flags, IStreamSample **sample)
 {
-    struct audio_stream *This = impl_from_IAudioMediaStream(iface);
-
-    FIXME("(%p/%p)->(%x,%p) stub!\n", iface, This, flags, sample);
-
-    return S_FALSE;
+    struct audio_stream *stream = impl_from_IAudioMediaStream(iface);
+    return IAMMediaStream_AllocateSample(&stream->IAMMediaStream_iface, flags, sample);
 }
 
 static HRESULT WINAPI audio_IAudioMediaStream_CreateSharedSample(IAudioMediaStream *iface,
         IStreamSample *existing_sample, DWORD flags, IStreamSample **sample)
 {
-    struct audio_stream *This = impl_from_IAudioMediaStream(iface);
-
-    FIXME("(%p/%p)->(%p,%x,%p) stub!\n", iface, This, existing_sample, flags, sample);
-
-    return S_FALSE;
+    struct audio_stream *stream = impl_from_IAudioMediaStream(iface);
+    return IAMMediaStream_CreateSharedSample(&stream->IAMMediaStream_iface, existing_sample, flags, sample);
 }
 
-static HRESULT WINAPI audio_IAudioMediaStream_SendEndOfStream(IAudioMediaStream *iface,
-        DWORD flags)
+static HRESULT WINAPI audio_IAudioMediaStream_SendEndOfStream(IAudioMediaStream *iface, DWORD flags)
 {
-    struct audio_stream *This = impl_from_IAudioMediaStream(iface);
-
-    FIXME("(%p/%p)->(%x) stub!\n", iface, This, flags);
-
-    return S_FALSE;
+    struct audio_stream *stream = impl_from_IAudioMediaStream(iface);
+    return IAMMediaStream_SendEndOfStream(&stream->IAMMediaStream_iface, flags);
 }
 
 /*** IAudioMediaStream methods ***/
diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 9c552f1a03f..6ef74eb7de0 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -292,76 +292,45 @@ static ULONG WINAPI ddraw_IDirectDrawMediaStream_Release(IDirectDrawMediaStream
     return IAMMediaStream_Release(&This->IAMMediaStream_iface);
 }
 
-/*** IMediaStream methods ***/
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetMultiMediaStream(IDirectDrawMediaStream *iface,
-        IMultiMediaStream **multi_media_stream)
+        IMultiMediaStream **mmstream)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
-
-    TRACE("(%p/%p)->(%p)\n", This, iface, multi_media_stream);
-
-    if (!multi_media_stream)
-        return E_POINTER;
-
-    IMultiMediaStream_AddRef(This->parent);
-    *multi_media_stream = This->parent;
-
-    return S_OK;
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    return IAMMediaStream_GetMultiMediaStream(&stream->IAMMediaStream_iface, mmstream);
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetInformation(IDirectDrawMediaStream *iface,
         MSPID *purpose_id, STREAM_TYPE *type)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
-
-    TRACE("(%p/%p)->(%p,%p)\n", This, iface, purpose_id, type);
-
-    if (purpose_id)
-        *purpose_id = This->purpose_id;
-    if (type)
-        *type = This->stream_type;
-
-    return S_OK;
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    return IAMMediaStream_GetInformation(&stream->IAMMediaStream_iface, purpose_id, type);
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SetSameFormat(IDirectDrawMediaStream *iface,
-        IMediaStream *pStreamThatHasDesiredFormat, DWORD dwFlags)
+        IMediaStream *other, DWORD flags)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
-
-    FIXME("(%p/%p)->(%p,%x) stub!\n", This, iface, pStreamThatHasDesiredFormat, dwFlags);
-
-    return S_FALSE;
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    return IAMMediaStream_SetSameFormat(&stream->IAMMediaStream_iface, other, flags);
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_AllocateSample(IDirectDrawMediaStream *iface,
-        DWORD dwFlags, IStreamSample **ppSample)
+        DWORD flags, IStreamSample **sample)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
-
-    FIXME("(%p/%p)->(%x,%p) stub!\n", This, iface, dwFlags, ppSample);
-
-    return S_FALSE;
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    return IAMMediaStream_AllocateSample(&stream->IAMMediaStream_iface, flags, sample);
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_CreateSharedSample(IDirectDrawMediaStream *iface,
-        IStreamSample *pExistingSample, DWORD dwFlags, IStreamSample **ppSample)
+        IStreamSample *existing_sample, DWORD flags, IStreamSample **sample)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
-
-    FIXME("(%p/%p)->(%p,%x,%p) stub!\n", This, iface, pExistingSample, dwFlags, ppSample);
-
-    return S_FALSE;
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    return IAMMediaStream_CreateSharedSample(&stream->IAMMediaStream_iface, existing_sample, flags, sample);
 }
 
-static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SendEndOfStream(IDirectDrawMediaStream *iface,
-        DWORD dwFlags)
+static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SendEndOfStream(IDirectDrawMediaStream *iface, DWORD flags)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
-
-    FIXME("(%p/%p)->(%x) stub!\n", This, iface, dwFlags);
-
-    return S_FALSE;
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    return IAMMediaStream_SendEndOfStream(&stream->IAMMediaStream_iface, flags);
 }
 
 /*** IDirectDrawMediaStream methods ***/
From 4300981d6b997c0b4c70c3415d4bbcd694d1a7f1 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Mon, 25 May 2020 14:17:33 -0500
Subject: [PATCH] amstream: Don't crash if parent is NULL in AMAudioStream::
 and AMDirectDrawStream::GetMultiMediaStream.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c | 14 +++++++-------
 dlls/amstream/ddrawstream.c | 14 +++++++-------
 2 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index d620abc6ecf..265c3bf9f20 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -429,18 +429,18 @@ static ULONG WINAPI audio_IAMMediaStream_Release(IAMMediaStream *iface)
 
 /*** IMediaStream methods ***/
 static HRESULT WINAPI audio_IAMMediaStream_GetMultiMediaStream(IAMMediaStream *iface,
-        IMultiMediaStream** multi_media_stream)
+        IMultiMediaStream **mmstream)
 {
-    struct audio_stream *This = impl_from_IAMMediaStream(iface);
+    struct audio_stream *stream = impl_from_IAMMediaStream(iface);
 
-    TRACE("(%p/%p)->(%p)\n", This, iface, multi_media_stream);
+    TRACE("stream %p, mmstream %p.\n", stream, mmstream);
 
-    if (!multi_media_stream)
+    if (!mmstream)
         return E_POINTER;
 
-    IMultiMediaStream_AddRef(This->parent);
-    *multi_media_stream = This->parent;
-
+    if (stream->parent)
+        IMultiMediaStream_AddRef(stream->parent);
+    *mmstream = stream->parent;
     return S_OK;
 }
 
diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 6ef74eb7de0..a4bfe948d2d 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -125,18 +125,18 @@ static ULONG WINAPI ddraw_IAMMediaStream_Release(IAMMediaStream *iface)
 
 /*** IMediaStream methods ***/
 static HRESULT WINAPI ddraw_IAMMediaStream_GetMultiMediaStream(IAMMediaStream *iface,
-        IMultiMediaStream** multi_media_stream)
+        IMultiMediaStream **mmstream)
 {
-    struct ddraw_stream *This = impl_from_IAMMediaStream(iface);
+    struct ddraw_stream *stream = impl_from_IAMMediaStream(iface);
 
-    TRACE("(%p/%p)->(%p)\n", This, iface, multi_media_stream);
+    TRACE("stream %p, mmstream %p.\n", stream, mmstream);
 
-    if (!multi_media_stream)
+    if (!mmstream)
         return E_POINTER;
 
-    IMultiMediaStream_AddRef(This->parent);
-    *multi_media_stream = This->parent;
-
+    if (stream->parent)
+        IMultiMediaStream_AddRef(stream->parent);
+    *mmstream = stream->parent;
     return S_OK;
 }
 
From dc93d5f856cd14eddc2db688248a700c256d17ee Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 27 May 2020 14:26:22 -0500
Subject: [PATCH] quartz/vmr9: Fake success from
 IVMRMixerConrol9::SetMixingPrefs().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr9.c | 33 +++++++++++++++++++++++++++++++++
 dlls/quartz/vmr9.c       | 14 +++++++++++---
 2 files changed, 44 insertions(+), 3 deletions(-)

diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index dfa9dae73e5..0a8ae371a6b 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -3876,6 +3876,38 @@ static void test_windowless_size(void)
     DestroyWindow(window);
 }
 
+static void test_mixing_prefs(void)
+{
+    IBaseFilter *filter = create_vmr9(VMR9Mode_Windowed);
+    IVMRMixerControl9 *mixer_control;
+    DWORD flags;
+    HRESULT hr;
+    ULONG ref;
+
+    set_mixing_mode(filter, 1);
+
+    hr = IBaseFilter_QueryInterface(filter, &IID_IVMRMixerControl9, (void **)&mixer_control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IVMRMixerControl9_GetMixingPrefs(mixer_control, &flags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(flags == (MixerPref9_NoDecimation | MixerPref9_ARAdjustXorY | MixerPref9_BiLinearFiltering
+            | MixerPref9_RenderTargetRGB), "Got flags %#x.\n", flags);
+
+    hr = IVMRMixerControl9_SetMixingPrefs(mixer_control, MixerPref9_NoDecimation
+            | MixerPref9_ARAdjustXorY | MixerPref9_PointFiltering | MixerPref9_RenderTargetRGB);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IVMRMixerControl9_GetMixingPrefs(mixer_control, &flags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(flags == (MixerPref9_NoDecimation | MixerPref9_ARAdjustXorY | MixerPref9_PointFiltering
+            | MixerPref9_RenderTargetRGB), "Got flags %#x.\n", flags);
+
+    IVMRMixerControl9_Release(mixer_control);
+    ref = IBaseFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(vmr9)
 {
     IBaseFilter *filter;
@@ -3910,6 +3942,7 @@ START_TEST(vmr9)
     test_surface_allocator_notify_refcount();
     test_basic_video();
     test_windowless_size();
+    test_mixing_prefs();
 
     CoUninitialize();
 }
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 81e265f104a..a716a6e7128 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -84,6 +84,7 @@ struct quartz_vmr
     BOOL allocator_is_ex;
 
     DWORD stream_count;
+    DWORD mixing_prefs;
 
     /*
      * The Video Mixing Renderer supports 3 modes, renderless, windowless and windowed
@@ -2227,7 +2228,10 @@ static HRESULT WINAPI mixer_control9_SetMixingPrefs(IVMRMixerControl9 *iface, DW
 
     FIXME("filter %p, flags %#x, stub!\n", filter, flags);
 
-    return E_NOTIMPL;
+    EnterCriticalSection(&filter->renderer.filter.csFilter);
+    filter->mixing_prefs = flags;
+    LeaveCriticalSection(&filter->renderer.filter.csFilter);
+    return S_OK;
 }
 
 static HRESULT WINAPI mixer_control9_GetMixingPrefs(IVMRMixerControl9 *iface, DWORD *flags)
@@ -2236,8 +2240,9 @@ static HRESULT WINAPI mixer_control9_GetMixingPrefs(IVMRMixerControl9 *iface, DW
 
     FIXME("filter %p, flags %p, stub!\n", filter, flags);
 
-    *flags = MixerPref9_NoDecimation | MixerPref9_ARAdjustXorY | MixerPref9_BiLinearFiltering | MixerPref9_RenderTargetRGB;
-
+    EnterCriticalSection(&filter->renderer.filter.csFilter);
+    *flags = filter->mixing_prefs;
+    LeaveCriticalSection(&filter->renderer.filter.csFilter);
     return S_OK;
 }
 
@@ -2500,6 +2505,9 @@ static HRESULT vmr_create(IUnknown *outer, IUnknown **out, const CLSID *clsid)
 
     object->run_event = CreateEventW(NULL, TRUE, FALSE, NULL);
 
+    object->mixing_prefs = MixerPref9_NoDecimation | MixerPref9_ARAdjustXorY
+            | MixerPref9_BiLinearFiltering | MixerPref9_RenderTargetRGB;
+
     TRACE("Created VMR %p.\n", object);
     *out = &object->renderer.filter.IUnknown_inner;
     return S_OK;
From f020fe051b02d7bda90a1fdb028a60e2ab7400f0 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 May 2020 11:47:33 -0500
Subject: [PATCH] quartz/vmr9: Use TRACE for some implemented methods.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 59 +++++++++++++++++++++++++---------------------
 1 file changed, 32 insertions(+), 27 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index a716a6e7128..7fca3550d1b 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -1699,17 +1699,18 @@ static HRESULT WINAPI VMR9WindowlessControl_SetVideoPosition(IVMRWindowlessContr
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9WindowlessControl_GetVideoPosition(IVMRWindowlessControl9 *iface, RECT *source, RECT *dest)
+static HRESULT WINAPI VMR9WindowlessControl_GetVideoPosition(IVMRWindowlessControl9 *iface, RECT *src, RECT *dst)
 {
-    struct quartz_vmr *This = impl_from_IVMRWindowlessControl9(iface);
+    struct quartz_vmr *filter = impl_from_IVMRWindowlessControl9(iface);
 
-    if (source)
-        *source = This->window.src;
+    TRACE("filter %p, src %p, dst %p.\n", filter, src, dst);
 
-    if (dest)
-        *dest = This->window.dst;
+    if (src)
+        *src = filter->window.src;
+
+    if (dst)
+        *dst = filter->window.dst;
 
-    FIXME("(%p/%p)->(%p/%p) stub\n", iface, This, source, dest);
     return S_OK;
 }
 
@@ -1955,42 +1956,46 @@ static ULONG WINAPI VMR9SurfaceAllocatorNotify_Release(IVMRSurfaceAllocatorNotif
     return refcount;
 }
 
-static HRESULT WINAPI VMR9SurfaceAllocatorNotify_AdviseSurfaceAllocator(IVMRSurfaceAllocatorNotify9 *iface, DWORD_PTR id, IVMRSurfaceAllocator9 *alloc)
+static HRESULT WINAPI VMR9SurfaceAllocatorNotify_AdviseSurfaceAllocator(
+        IVMRSurfaceAllocatorNotify9 *iface, DWORD_PTR cookie, IVMRSurfaceAllocator9 *allocator)
 {
-    struct quartz_vmr *This = impl_from_IVMRSurfaceAllocatorNotify9(iface);
+    struct quartz_vmr *filter = impl_from_IVMRSurfaceAllocatorNotify9(iface);
 
-    /* FIXME: This code is not tested!!! */
-    FIXME("(%p/%p)->(...) stub\n", iface, This);
-    This->cookie = id;
+    TRACE("filter %p, cookie %#Ix, allocator %p.\n", filter, cookie, allocator);
 
-    if (This->presenter)
+    filter->cookie = cookie;
+
+    if (filter->presenter)
         return VFW_E_WRONG_STATE;
 
-    if (FAILED(IVMRSurfaceAllocator9_QueryInterface(alloc, &IID_IVMRImagePresenter9, (void **)&This->presenter)))
+    if (FAILED(IVMRSurfaceAllocator9_QueryInterface(allocator, &IID_IVMRImagePresenter9, (void **)&filter->presenter)))
         return E_NOINTERFACE;
 
-    if (SUCCEEDED(IVMRSurfaceAllocator9_QueryInterface(alloc, &IID_IVMRSurfaceAllocatorEx9, (void **)&This->allocator)))
-        This->allocator_is_ex = 1;
+    if (SUCCEEDED(IVMRSurfaceAllocator9_QueryInterface(allocator,
+            &IID_IVMRSurfaceAllocatorEx9, (void **)&filter->allocator)))
+        filter->allocator_is_ex = 1;
     else
     {
-        This->allocator = (IVMRSurfaceAllocatorEx9 *)alloc;
-        IVMRSurfaceAllocator9_AddRef(alloc);
-        This->allocator_is_ex = 0;
+        filter->allocator = (IVMRSurfaceAllocatorEx9 *)allocator;
+        IVMRSurfaceAllocator9_AddRef(allocator);
+        filter->allocator_is_ex = 0;
     }
 
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9SurfaceAllocatorNotify_SetD3DDevice(IVMRSurfaceAllocatorNotify9 *iface, IDirect3DDevice9 *device, HMONITOR monitor)
+static HRESULT WINAPI VMR9SurfaceAllocatorNotify_SetD3DDevice(IVMRSurfaceAllocatorNotify9 *iface,
+        IDirect3DDevice9 *device, HMONITOR monitor)
 {
-    struct quartz_vmr *This = impl_from_IVMRSurfaceAllocatorNotify9(iface);
+    struct quartz_vmr *filter = impl_from_IVMRSurfaceAllocatorNotify9(iface);
 
-    FIXME("(%p/%p)->(...) semi-stub\n", iface, This);
-    if (This->allocator_d3d9_dev)
-        IDirect3DDevice9_Release(This->allocator_d3d9_dev);
-    This->allocator_d3d9_dev = device;
-    IDirect3DDevice9_AddRef(This->allocator_d3d9_dev);
-    This->allocator_mon = monitor;
+    TRACE("filter %p, device %p, monitor %p.\n", filter, device, monitor);
+
+    if (filter->allocator_d3d9_dev)
+        IDirect3DDevice9_Release(filter->allocator_d3d9_dev);
+    filter->allocator_d3d9_dev = device;
+    IDirect3DDevice9_AddRef(device);
+    filter->allocator_mon = monitor;
 
     return S_OK;
 }
From 39489e4d01ace78e90943c066e7e43105cf208a2 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 May 2020 11:47:34 -0500
Subject: [PATCH] quartz/vmr9: Don't query for IVMRSurfaceAllocatorEx9.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr9.c |  1 +
 dlls/quartz/vmr9.c       | 33 ++++++++++++---------------------
 2 files changed, 13 insertions(+), 21 deletions(-)

diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 0a8ae371a6b..2921d1aed02 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -2852,6 +2852,7 @@ static HRESULT WINAPI allocator_QueryInterface(IVMRSurfaceAllocator9 *iface, REF
         IVMRImagePresenter9_AddRef(&presenter_iface);
         return S_OK;
     }
+    ok(!IsEqualGUID(iid, &IID_IVMRSurfaceAllocatorEx9), "Unexpected query for IVMRSurfaceAllocatorEx9.\n");
     *out = NULL;
     return E_NOTIMPL;
 }
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 7fca3550d1b..e02b642dbc1 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -79,9 +79,8 @@ struct quartz_vmr
 
     IOverlay IOverlay_iface;
 
-    IVMRSurfaceAllocatorEx9 *allocator;
+    IVMRSurfaceAllocator9 *allocator;
     IVMRImagePresenter9 *presenter;
-    BOOL allocator_is_ex;
 
     DWORD stream_count;
     DWORD mixing_prefs;
@@ -345,7 +344,7 @@ static HRESULT initialize_device(struct quartz_vmr *filter, VMR9AllocationInfo *
     HRESULT hr;
     DWORD i;
 
-    if (FAILED(hr = IVMRSurfaceAllocatorEx9_InitializeDevice(filter->allocator,
+    if (FAILED(hr = IVMRSurfaceAllocator9_InitializeDevice(filter->allocator,
             filter->cookie, info, &count)))
     {
         WARN("Failed to initialize device (flags %#x), hr %#x.\n", info->dwFlags, hr);
@@ -354,13 +353,13 @@ static HRESULT initialize_device(struct quartz_vmr *filter, VMR9AllocationInfo *
 
     for (i = 0; i < count; ++i)
     {
-        if (FAILED(hr = IVMRSurfaceAllocatorEx9_GetSurface(filter->allocator,
+        if (FAILED(hr = IVMRSurfaceAllocator9_GetSurface(filter->allocator,
                 filter->cookie, i, 0, &filter->surfaces[i])))
         {
             ERR("Failed to get surface %u, hr %#x.\n", i, hr);
             while (i--)
                 IDirect3DSurface9_Release(filter->surfaces[i]);
-            IVMRSurfaceAllocatorEx9_TerminateDevice(filter->allocator, filter->cookie);
+            IVMRSurfaceAllocator9_TerminateDevice(filter->allocator, filter->cookie);
             return hr;
         }
     }
@@ -533,7 +532,7 @@ static HRESULT WINAPI VMR9_BreakConnect(struct strmbase_renderer *This)
         for (i = 0; i < pVMR9->num_surfaces; ++i)
             IDirect3DSurface9_Release(pVMR9->surfaces[i]);
         free(pVMR9->surfaces);
-        IVMRSurfaceAllocatorEx9_TerminateDevice(pVMR9->allocator, pVMR9->cookie);
+        IVMRSurfaceAllocator9_TerminateDevice(pVMR9->allocator, pVMR9->cookie);
         pVMR9->num_surfaces = 0;
     }
     return hr;
@@ -558,8 +557,8 @@ static void vmr_destroy(struct strmbase_renderer *iface)
 
     if (filter->allocator)
     {
-        IVMRSurfaceAllocatorEx9_TerminateDevice(filter->allocator, filter->cookie);
-        IVMRSurfaceAllocatorEx9_Release(filter->allocator);
+        IVMRSurfaceAllocator9_TerminateDevice(filter->allocator, filter->cookie);
+        IVMRSurfaceAllocator9_Release(filter->allocator);
     }
     if (filter->presenter)
         IVMRImagePresenter9_Release(filter->presenter);
@@ -1353,7 +1352,7 @@ static HRESULT WINAPI VMR9FilterConfig_SetRenderingMode(IVMRFilterConfig9 *iface
     }
 
     if (This->allocator)
-        IVMRSurfaceAllocatorEx9_Release(This->allocator);
+        IVMRSurfaceAllocator9_Release(This->allocator);
     if (This->presenter)
         IVMRImagePresenter9_Release(This->presenter);
 
@@ -1364,7 +1363,6 @@ static HRESULT WINAPI VMR9FilterConfig_SetRenderingMode(IVMRFilterConfig9 *iface
     {
     case VMR9Mode_Windowed:
     case VMR9Mode_Windowless:
-        This->allocator_is_ex = 0;
         This->cookie = ~0;
 
         hr = VMR9DefaultAllocatorPresenterImpl_create(This, (LPVOID*)&This->presenter);
@@ -1378,7 +1376,7 @@ static HRESULT WINAPI VMR9FilterConfig_SetRenderingMode(IVMRFilterConfig9 *iface
             This->presenter = NULL;
         }
         else
-            hr = IVMRSurfaceAllocatorEx9_AdviseNotify(This->allocator, &This->IVMRSurfaceAllocatorNotify9_iface);
+            hr = IVMRSurfaceAllocator9_AdviseNotify(This->allocator, &This->IVMRSurfaceAllocatorNotify9_iface);
         break;
     case VMR9Mode_Renderless:
         break;
@@ -1971,15 +1969,8 @@ static HRESULT WINAPI VMR9SurfaceAllocatorNotify_AdviseSurfaceAllocator(
     if (FAILED(IVMRSurfaceAllocator9_QueryInterface(allocator, &IID_IVMRImagePresenter9, (void **)&filter->presenter)))
         return E_NOINTERFACE;
 
-    if (SUCCEEDED(IVMRSurfaceAllocator9_QueryInterface(allocator,
-            &IID_IVMRSurfaceAllocatorEx9, (void **)&filter->allocator)))
-        filter->allocator_is_ex = 1;
-    else
-    {
-        filter->allocator = (IVMRSurfaceAllocatorEx9 *)allocator;
-        IVMRSurfaceAllocator9_AddRef(allocator);
-        filter->allocator_is_ex = 0;
-    }
+    filter->allocator = allocator;
+    IVMRSurfaceAllocator9_AddRef(allocator);
 
     return S_OK;
 }
@@ -2827,7 +2818,7 @@ static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9Allocation
 
     if (FAILED(hr))
     {
-        IVMRSurfaceAllocatorEx9_TerminateDevice(This->pVMR9->allocator, This->pVMR9->cookie);
+        IVMRSurfaceAllocator9_TerminateDevice(This->pVMR9->allocator, This->pVMR9->cookie);
         return FALSE;
     }
 
From aa44879a09b29997e68f416c0c6e77d0a0ea82bf Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 May 2020 11:47:35 -0500
Subject: [PATCH] quartz/vmr9: Don't expose IVMRSurfaceAllocatorEx9 from the
 default presenter.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 58 +++++++++++++++++++++++-----------------------
 1 file changed, 29 insertions(+), 29 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index e02b642dbc1..bc03326599f 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -174,7 +174,7 @@ static inline struct quartz_vmr *impl_from_IVMRWindowlessControl9(IVMRWindowless
 struct default_presenter
 {
     IVMRImagePresenter9 IVMRImagePresenter9_iface;
-    IVMRSurfaceAllocatorEx9 IVMRSurfaceAllocatorEx9_iface;
+    IVMRSurfaceAllocator9 IVMRSurfaceAllocator9_iface;
 
     LONG refCount;
 
@@ -195,9 +195,9 @@ static inline struct default_presenter *impl_from_IVMRImagePresenter9(IVMRImageP
     return CONTAINING_RECORD(iface, struct default_presenter, IVMRImagePresenter9_iface);
 }
 
-static inline struct default_presenter *impl_from_IVMRSurfaceAllocatorEx9(IVMRSurfaceAllocatorEx9 *iface)
+static inline struct default_presenter *impl_from_IVMRSurfaceAllocator9(IVMRSurfaceAllocator9 *iface)
 {
-    return CONTAINING_RECORD(iface, struct default_presenter, IVMRSurfaceAllocatorEx9_iface);
+    return CONTAINING_RECORD(iface, struct default_presenter, IVMRSurfaceAllocator9_iface);
 }
 
 static HRESULT VMR9DefaultAllocatorPresenterImpl_create(struct quartz_vmr *parent, LPVOID * ppv);
@@ -1367,7 +1367,8 @@ static HRESULT WINAPI VMR9FilterConfig_SetRenderingMode(IVMRFilterConfig9 *iface
 
         hr = VMR9DefaultAllocatorPresenterImpl_create(This, (LPVOID*)&This->presenter);
         if (SUCCEEDED(hr))
-            hr = IVMRImagePresenter9_QueryInterface(This->presenter, &IID_IVMRSurfaceAllocatorEx9, (LPVOID*)&This->allocator);
+            hr = IVMRImagePresenter9_QueryInterface(This->presenter,
+                    &IID_IVMRSurfaceAllocator9, (void **)&This->allocator);
         if (FAILED(hr))
         {
             ERR("Unable to find Presenter interface\n");
@@ -2530,8 +2531,8 @@ static HRESULT WINAPI VMR9_ImagePresenter_QueryInterface(IVMRImagePresenter9 *if
 
     if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IVMRImagePresenter9))
         *ppv = &This->IVMRImagePresenter9_iface;
-    else if (IsEqualIID(riid, &IID_IVMRSurfaceAllocatorEx9))
-        *ppv = &This->IVMRSurfaceAllocatorEx9_iface;
+    else if (IsEqualIID(riid, &IID_IVMRSurfaceAllocator9))
+        *ppv = &This->IVMRSurfaceAllocator9_iface;
 
     if (*ppv)
     {
@@ -2667,25 +2668,22 @@ static const IVMRImagePresenter9Vtbl VMR9_ImagePresenter =
     VMR9_ImagePresenter_PresentImage
 };
 
-static HRESULT WINAPI VMR9_SurfaceAllocator_QueryInterface(IVMRSurfaceAllocatorEx9 *iface, REFIID riid, LPVOID * ppv)
+static HRESULT WINAPI VMR9_SurfaceAllocator_QueryInterface(IVMRSurfaceAllocator9 *iface, REFIID iid, void **out)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocatorEx9(iface);
-
-    return VMR9_ImagePresenter_QueryInterface(&This->IVMRImagePresenter9_iface, riid, ppv);
+    struct default_presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
+    return IVMRImagePresenter9_QueryInterface(&presenter->IVMRImagePresenter9_iface, iid, out);
 }
 
-static ULONG WINAPI VMR9_SurfaceAllocator_AddRef(IVMRSurfaceAllocatorEx9 *iface)
+static ULONG WINAPI VMR9_SurfaceAllocator_AddRef(IVMRSurfaceAllocator9 *iface)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocatorEx9(iface);
-
-    return VMR9_ImagePresenter_AddRef(&This->IVMRImagePresenter9_iface);
+    struct default_presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
+    return IVMRImagePresenter9_AddRef(&presenter->IVMRImagePresenter9_iface);
 }
 
-static ULONG WINAPI VMR9_SurfaceAllocator_Release(IVMRSurfaceAllocatorEx9 *iface)
+static ULONG WINAPI VMR9_SurfaceAllocator_Release(IVMRSurfaceAllocator9 *iface)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocatorEx9(iface);
-
-    return VMR9_ImagePresenter_Release(&This->IVMRImagePresenter9_iface);
+    struct default_presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
+    return IVMRImagePresenter9_Release(&presenter->IVMRImagePresenter9_iface);
 }
 
 static HRESULT VMR9_SurfaceAllocator_SetAllocationSettings(struct default_presenter *This, VMR9AllocationInfo *allocinfo)
@@ -2827,9 +2825,10 @@ static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9Allocation
     return TRUE;
 }
 
-static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocatorEx9 *iface, DWORD_PTR id, VMR9AllocationInfo *allocinfo, DWORD *numbuffers)
+static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocator9 *iface,
+        DWORD_PTR cookie, VMR9AllocationInfo *allocinfo, DWORD *numbuffers)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocatorEx9(iface);
+    struct default_presenter *This = impl_from_IVMRSurfaceAllocator9(iface);
 
     This->info = *allocinfo;
 
@@ -2842,16 +2841,17 @@ static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocato
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9_SurfaceAllocator_TerminateDevice(IVMRSurfaceAllocatorEx9 *iface, DWORD_PTR id)
+static HRESULT WINAPI VMR9_SurfaceAllocator_TerminateDevice(IVMRSurfaceAllocator9 *iface, DWORD_PTR cookie)
 {
-    TRACE("iface %p, id %#lx.\n", iface, id);
+    TRACE("iface %p, cookie %#lx.\n", iface, cookie);
 
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9_SurfaceAllocator_GetSurface(IVMRSurfaceAllocatorEx9 *iface, DWORD_PTR id, DWORD surfaceindex, DWORD flags, IDirect3DSurface9 **surface)
+static HRESULT WINAPI VMR9_SurfaceAllocator_GetSurface(IVMRSurfaceAllocator9 *iface,
+        DWORD_PTR cookie, DWORD surfaceindex, DWORD flags, IDirect3DSurface9 **surface)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocatorEx9(iface);
+    struct default_presenter *This = impl_from_IVMRSurfaceAllocator9(iface);
 
     /* Update everything first, this is needed because the surface might be destroyed in the reset */
     if (!This->d3d9_dev)
@@ -2871,9 +2871,10 @@ static HRESULT WINAPI VMR9_SurfaceAllocator_GetSurface(IVMRSurfaceAllocatorEx9 *
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9_SurfaceAllocator_AdviseNotify(IVMRSurfaceAllocatorEx9 *iface, IVMRSurfaceAllocatorNotify9 *allocnotify)
+static HRESULT WINAPI VMR9_SurfaceAllocator_AdviseNotify(IVMRSurfaceAllocator9 *iface,
+        IVMRSurfaceAllocatorNotify9 *allocnotify)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocatorEx9(iface);
+    struct default_presenter *This = impl_from_IVMRSurfaceAllocator9(iface);
 
     TRACE("(%p/%p)->(...)\n", iface, This);
 
@@ -2882,7 +2883,7 @@ static HRESULT WINAPI VMR9_SurfaceAllocator_AdviseNotify(IVMRSurfaceAllocatorEx9
     return S_OK;
 }
 
-static const IVMRSurfaceAllocatorEx9Vtbl VMR9_SurfaceAllocator =
+static const IVMRSurfaceAllocator9Vtbl VMR9_SurfaceAllocator =
 {
     VMR9_SurfaceAllocator_QueryInterface,
     VMR9_SurfaceAllocator_AddRef,
@@ -2891,7 +2892,6 @@ static const IVMRSurfaceAllocatorEx9Vtbl VMR9_SurfaceAllocator =
     VMR9_SurfaceAllocator_TerminateDevice,
     VMR9_SurfaceAllocator_GetSurface,
     VMR9_SurfaceAllocator_AdviseNotify,
-    NULL /* This isn't the SurfaceAllocatorEx type yet, working on it */
 };
 
 static IDirect3D9 *init_d3d9(HMODULE d3d9_handle)
@@ -2940,7 +2940,7 @@ static HRESULT VMR9DefaultAllocatorPresenterImpl_create(struct quartz_vmr *paren
     }
 
     object->IVMRImagePresenter9_iface.lpVtbl = &VMR9_ImagePresenter;
-    object->IVMRSurfaceAllocatorEx9_iface.lpVtbl = &VMR9_SurfaceAllocator;
+    object->IVMRSurfaceAllocator9_iface.lpVtbl = &VMR9_SurfaceAllocator;
 
     object->refCount = 1;
     object->pVMR9 = parent;
From 6ccbc0579d7b3857687e2611ca586a4cbb9d99a3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 May 2020 11:47:36 -0500
Subject: [PATCH] quartz/vmr9: Remove the unused "allocator_mon" field.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index bc03326599f..6f699ce70fb 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -97,7 +97,6 @@ struct quartz_vmr
 
     /* Presentation related members */
     IDirect3DDevice9 *allocator_d3d9_dev;
-    HMONITOR allocator_mon;
     IDirect3DSurface9 **surfaces;
     DWORD num_surfaces;
     DWORD cur_surface;
@@ -1987,7 +1986,6 @@ static HRESULT WINAPI VMR9SurfaceAllocatorNotify_SetD3DDevice(IVMRSurfaceAllocat
         IDirect3DDevice9_Release(filter->allocator_d3d9_dev);
     filter->allocator_d3d9_dev = device;
     IDirect3DDevice9_AddRef(device);
-    filter->allocator_mon = monitor;
 
     return S_OK;
 }
@@ -2001,7 +1999,6 @@ static HRESULT WINAPI VMR9SurfaceAllocatorNotify_ChangeD3DDevice(IVMRSurfaceAllo
         IDirect3DDevice9_Release(This->allocator_d3d9_dev);
     This->allocator_d3d9_dev = device;
     IDirect3DDevice9_AddRef(This->allocator_d3d9_dev);
-    This->allocator_mon = monitor;
 
     return S_OK;
 }
From c6abb3b241b67934b1bebebac70293ea3e0cdf3c Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 May 2020 11:47:37 -0500
Subject: [PATCH] quartz/vmr9: Get rid of CreateRenderingWindow().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 32 ++++++++++----------------------
 1 file changed, 10 insertions(+), 22 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 6f699ce70fb..8ba82e8259c 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -2751,8 +2751,10 @@ static UINT d3d9_adapter_from_hwnd(IDirect3D9 *d3d9, HWND hwnd, HMONITOR *mon_ou
     return d3d9_adapter;
 }
 
-static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9AllocationInfo *info, DWORD *numbuffers)
+static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocator9 *iface,
+        DWORD_PTR cookie, VMR9AllocationInfo *info, DWORD *numbuffers)
 {
+    struct default_presenter *This = impl_from_IVMRSurfaceAllocator9(iface);
     D3DPRESENT_PARAMETERS d3dpp;
     IDirect3DDevice9 *device;
     DWORD d3d9_adapter;
@@ -2760,7 +2762,9 @@ static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9Allocation
     HWND window;
     HRESULT hr;
 
-    TRACE("(%p)->()\n", This);
+    TRACE("presenter %p, cookie %#Ix, info %p, numbuffers %p.\n", This, cookie, info, numbuffers);
+
+    This->info = *info;
 
     if (This->pVMR9->mode == VMR9Mode_Windowed)
         window = This->pVMR9->window.hwnd;
@@ -2783,7 +2787,7 @@ static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9Allocation
     if (FAILED(hr))
     {
         ERR("Could not create device: %08x\n", hr);
-        return FALSE;
+        return hr;
     }
 
     IDirect3DDevice9_GetDeviceCaps(device, &caps);
@@ -2791,14 +2795,14 @@ static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9Allocation
     {
         WARN("Device does not support blitting from textures.\n");
         IDirect3DDevice9_Release(device);
-        return FALSE;
+        return VFW_E_DDRAW_CAPS_NOT_SUITABLE;
     }
 
     This->d3d9_dev = device;
     IVMRSurfaceAllocatorNotify9_SetD3DDevice(This->SurfaceAllocatorNotify, This->d3d9_dev, This->hMon);
 
     if (!(This->d3d9_surfaces = calloc(*numbuffers, sizeof(IDirect3DSurface9 *))))
-        return FALSE;
+        return E_OUTOFMEMORY;
 
     hr = VMR9_SurfaceAllocator_SetAllocationSettings(This, info);
     if (FAILED(hr))
@@ -2814,27 +2818,11 @@ static BOOL CreateRenderingWindow(struct default_presenter *This, VMR9Allocation
     if (FAILED(hr))
     {
         IVMRSurfaceAllocator9_TerminateDevice(This->pVMR9->allocator, This->pVMR9->cookie);
-        return FALSE;
+        return hr;
     }
 
     This->num_surfaces = *numbuffers;
 
-    return TRUE;
-}
-
-static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocator9 *iface,
-        DWORD_PTR cookie, VMR9AllocationInfo *allocinfo, DWORD *numbuffers)
-{
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocator9(iface);
-
-    This->info = *allocinfo;
-
-    if (!CreateRenderingWindow(This, allocinfo, numbuffers))
-    {
-        ERR("Failed to create rendering window, expect no output!\n");
-        return VFW_E_WRONG_STATE;
-    }
-
     return S_OK;
 }
 
From e48fabff525061c8eea9558084a97308cebe6b7b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 May 2020 11:47:38 -0500
Subject: [PATCH] quartz/vmr9: Trace argument values instead of omitting them.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 27 +++++++++++++++------------
 1 file changed, 15 insertions(+), 12 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 8ba82e8259c..4ea3b483a75 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -2583,19 +2583,21 @@ static ULONG WINAPI VMR9_ImagePresenter_Release(IVMRImagePresenter9 *iface)
     return refCount;
 }
 
-static HRESULT WINAPI VMR9_ImagePresenter_StartPresenting(IVMRImagePresenter9 *iface, DWORD_PTR id)
+static HRESULT WINAPI VMR9_ImagePresenter_StartPresenting(IVMRImagePresenter9 *iface, DWORD_PTR cookie)
 {
-    struct default_presenter *This = impl_from_IVMRImagePresenter9(iface);
+    struct default_presenter *presenter = impl_from_IVMRImagePresenter9(iface);
+
+    TRACE("presenter %p, cookie %#Ix.\n", presenter, cookie);
 
-    TRACE("(%p/%p/%p)->(...) stub\n", iface, This,This->pVMR9);
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9_ImagePresenter_StopPresenting(IVMRImagePresenter9 *iface, DWORD_PTR id)
+static HRESULT WINAPI VMR9_ImagePresenter_StopPresenting(IVMRImagePresenter9 *iface, DWORD_PTR cookie)
 {
-    struct default_presenter *This = impl_from_IVMRImagePresenter9(iface);
+    struct default_presenter *presenter = impl_from_IVMRImagePresenter9(iface);
+
+    TRACE("presenter %p, cookie %#Ix.\n", presenter, cookie);
 
-    TRACE("(%p/%p/%p)->(...) stub\n", iface, This,This->pVMR9);
     return S_OK;
 }
 
@@ -2619,13 +2621,14 @@ static HRESULT VMR9_ImagePresenter_PresentOffscreenSurface(struct default_presen
     return hr;
 }
 
-static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *iface, DWORD_PTR id, VMR9PresentationInfo *info)
+static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *iface,
+        DWORD_PTR cookie, VMR9PresentationInfo *info)
 {
     struct default_presenter *This = impl_from_IVMRImagePresenter9(iface);
     HRESULT hr;
     BOOL render = FALSE;
 
-    TRACE("(%p/%p/%p)->(...) stub\n", iface, This, This->pVMR9);
+    TRACE("presenter %p, cookie %#Ix, info %p.\n", This, cookie, info);
 
     /* This might happen if we don't have active focus (eg on a different virtual desktop) */
     if (!This->d3d9_dev)
@@ -2857,14 +2860,14 @@ static HRESULT WINAPI VMR9_SurfaceAllocator_GetSurface(IVMRSurfaceAllocator9 *if
 }
 
 static HRESULT WINAPI VMR9_SurfaceAllocator_AdviseNotify(IVMRSurfaceAllocator9 *iface,
-        IVMRSurfaceAllocatorNotify9 *allocnotify)
+        IVMRSurfaceAllocatorNotify9 *notify)
 {
-    struct default_presenter *This = impl_from_IVMRSurfaceAllocator9(iface);
+    struct default_presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
 
-    TRACE("(%p/%p)->(...)\n", iface, This);
+    TRACE("presenter %p, notify %p.\n", presenter, notify);
 
     /* No AddRef taken here or the base VMR9 filter would never be destroyed */
-    This->SurfaceAllocatorNotify = allocnotify;
+    presenter->SurfaceAllocatorNotify = notify;
     return S_OK;
 }
 
From 8b5f9145f7cf889513a2226197086a39bf17deb0 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 28 May 2020 02:05:48 +0700
Subject: [PATCH] amstream: Move initialization code from audio_stream_create
 into AMAudioStream::Initialize and ::JoinAMMultiMediaStream.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c | 50 +++++++++++++++++++++++++++----------
 1 file changed, 37 insertions(+), 13 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 265c3bf9f20..a38cbc5f639 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -502,11 +502,24 @@ static HRESULT WINAPI audio_IAMMediaStream_SendEndOfStream(IAMMediaStream *iface
 static HRESULT WINAPI audio_IAMMediaStream_Initialize(IAMMediaStream *iface, IUnknown *source_object, DWORD flags,
                                                     REFMSPID purpose_id, const STREAM_TYPE stream_type)
 {
-    struct audio_stream *This = impl_from_IAMMediaStream(iface);
+    struct audio_stream *stream = impl_from_IAMMediaStream(iface);
 
-    FIXME("(%p/%p)->(%p,%x,%p,%u) stub!\n", This, iface, source_object, flags, purpose_id, stream_type);
+    TRACE("stream %p, source_object %p, flags %x, purpose_id %s, stream_type %u.\n", stream, source_object, flags,
+            debugstr_guid(purpose_id), stream_type);
 
-    return S_FALSE;
+    if (!purpose_id)
+        return E_POINTER;
+
+    if (source_object)
+        FIXME("Specifying a stream object is not yet supported.\n");
+
+    if (flags & AMMSF_CREATEPEER)
+        FIXME("AMMSF_CREATEPEER is not yet supported.\n");
+
+    stream->purpose_id = *purpose_id;
+    stream->stream_type = stream_type;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_IAMMediaStream_SetState(IAMMediaStream *iface, FILTER_STATE state)
@@ -530,13 +543,15 @@ static HRESULT WINAPI audio_IAMMediaStream_SetState(IAMMediaStream *iface, FILTE
 }
 
 static HRESULT WINAPI audio_IAMMediaStream_JoinAMMultiMediaStream(IAMMediaStream *iface,
-        IAMMultiMediaStream *am_multi_media_stream)
+        IAMMultiMediaStream *mmstream)
 {
-    struct audio_stream *This = impl_from_IAMMediaStream(iface);
+    struct audio_stream *stream = impl_from_IAMMediaStream(iface);
 
-    FIXME("(%p/%p)->(%p) stub!\n", This, iface, am_multi_media_stream);
+    TRACE("stream %p, mmstream %p.\n", stream, mmstream);
 
-    return S_FALSE;
+    stream->parent = (IMultiMediaStream *)mmstream;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_IAMMediaStream_JoinFilter(IAMMediaStream *iface, IMediaStreamFilter *filter)
@@ -1262,12 +1277,10 @@ HRESULT audio_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
         IUnknown *stream_object, STREAM_TYPE stream_type, IAMMediaStream **media_stream)
 {
     struct audio_stream *object;
+    HRESULT hr;
 
     TRACE("(%p,%s,%p,%p)\n", parent, debugstr_guid(purpose_id), stream_object, media_stream);
 
-    if (stream_object)
-        FIXME("Specifying a stream object is not yet supported.\n");
-
     object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
     if (!object)
         return E_OUTOFMEMORY;
@@ -1279,12 +1292,23 @@ HRESULT audio_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
     object->ref = 1;
 
     InitializeCriticalSection(&object->cs);
-    object->parent = parent;
-    object->purpose_id = *purpose_id;
-    object->stream_type = stream_type;
     list_init(&object->receive_queue);
     list_init(&object->update_queue);
 
+    hr = IAMMediaStream_Initialize(&object->IAMMediaStream_iface, stream_object, 0, purpose_id, stream_type);
+    if (FAILED(hr))
+    {
+        IAMMediaStream_Release(&object->IAMMediaStream_iface);
+        return hr;
+    }
+
+    hr = IAMMediaStream_JoinAMMultiMediaStream(&object->IAMMediaStream_iface, (IAMMultiMediaStream *)parent);
+    if (FAILED(hr))
+    {
+        IAMMediaStream_Release(&object->IAMMediaStream_iface);
+        return hr;
+    }
+
     *media_stream = &object->IAMMediaStream_iface;
 
     return S_OK;
From f568c47a470c7a567dfdc3c64d186f935501d47c Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 28 May 2020 02:05:49 +0700
Subject: [PATCH] amstream: Move initialization code from ddraw_stream_create
 into AMDirectDrawStream::Initialize and ::JoinAMMultiMediaStream.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c | 49 +++++++++++++++++++++++++++----------
 1 file changed, 36 insertions(+), 13 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index a4bfe948d2d..8e99ea3bf55 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -198,11 +198,26 @@ static HRESULT WINAPI ddraw_IAMMediaStream_SendEndOfStream(IAMMediaStream *iface
 static HRESULT WINAPI ddraw_IAMMediaStream_Initialize(IAMMediaStream *iface, IUnknown *source_object, DWORD flags,
                                                     REFMSPID purpose_id, const STREAM_TYPE stream_type)
 {
-    struct ddraw_stream *This = impl_from_IAMMediaStream(iface);
+    struct ddraw_stream *stream = impl_from_IAMMediaStream(iface);
+    HRESULT hr;
 
-    FIXME("(%p/%p)->(%p,%x,%p,%u) stub!\n", This, iface, source_object, flags, purpose_id, stream_type);
+    TRACE("stream %p, source_object %p, flags %x, purpose_id %s, stream_type %u.\n", stream, source_object, flags,
+            debugstr_guid(purpose_id), stream_type);
 
-    return S_FALSE;
+    if (!purpose_id)
+        return E_POINTER;
+
+    if (flags & AMMSF_CREATEPEER)
+        FIXME("AMMSF_CREATEPEER is not yet supported.\n");
+
+    stream->purpose_id = *purpose_id;
+    stream->stream_type = stream_type;
+
+    if (source_object
+            && FAILED(hr = IUnknown_QueryInterface(source_object, &IID_IDirectDraw7, (void **)&stream->ddraw)))
+        FIXME("Stream object doesn't implement IDirectDraw7 interface, hr %#x.\n", hr);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI ddraw_IAMMediaStream_SetState(IAMMediaStream *iface, FILTER_STATE state)
@@ -214,13 +229,15 @@ static HRESULT WINAPI ddraw_IAMMediaStream_SetState(IAMMediaStream *iface, FILTE
     return S_FALSE;
 }
 
-static HRESULT WINAPI ddraw_IAMMediaStream_JoinAMMultiMediaStream(IAMMediaStream *iface, IAMMultiMediaStream *am_multi_media_stream)
+static HRESULT WINAPI ddraw_IAMMediaStream_JoinAMMultiMediaStream(IAMMediaStream *iface, IAMMultiMediaStream *mmstream)
 {
-    struct ddraw_stream *This = impl_from_IAMMediaStream(iface);
+    struct ddraw_stream *stream = impl_from_IAMMediaStream(iface);
+
+    TRACE("stream %p, mmstream %p.\n", stream, mmstream);
 
-    FIXME("(%p/%p)->(%p) stub!\n", This, iface, am_multi_media_stream);
+    stream->parent = (IMultiMediaStream *)mmstream;
 
-    return S_FALSE;
+    return S_OK;
 }
 
 static HRESULT WINAPI ddraw_IAMMediaStream_JoinFilter(IAMMediaStream *iface, IMediaStreamFilter *filter)
@@ -929,13 +946,19 @@ HRESULT ddraw_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
 
     InitializeCriticalSection(&object->cs);
 
-    object->parent = parent;
-    object->purpose_id = *purpose_id;
-    object->stream_type = stream_type;
+    hr = IAMMediaStream_Initialize(&object->IAMMediaStream_iface, stream_object, 0, purpose_id, stream_type);
+    if (FAILED(hr))
+    {
+        IAMMediaStream_Release(&object->IAMMediaStream_iface);
+        return hr;
+    }
 
-    if (stream_object
-            && FAILED(hr = IUnknown_QueryInterface(stream_object, &IID_IDirectDraw7, (void **)&object->ddraw)))
-        FIXME("Stream object doesn't implement IDirectDraw7 interface, hr %#x.\n", hr);
+    hr = IAMMediaStream_JoinAMMultiMediaStream(&object->IAMMediaStream_iface, (IAMMultiMediaStream *)parent);
+    if (FAILED(hr))
+    {
+        IAMMediaStream_Release(&object->IAMMediaStream_iface);
+        return hr;
+    }
 
     *media_stream = &object->IAMMediaStream_iface;
 
From 5eb568354cc6eddc6653cbf7ed53606ae8b488fb Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 28 May 2020 02:05:50 +0700
Subject: [PATCH] amstream: Move initialization calls from *_stream_create into
 AMMultiMediaStream::AddMediaStream.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/amstream_private.h |  6 ++----
 dlls/amstream/audiostream.c      | 23 +++++------------------
 dlls/amstream/ddrawstream.c      | 23 +++++------------------
 dlls/amstream/multimedia.c       | 18 +++++++++++++-----
 dlls/amstream/tests/amstream.c   |  2 +-
 5 files changed, 26 insertions(+), 46 deletions(-)

diff --git a/dlls/amstream/amstream_private.h b/dlls/amstream/amstream_private.h
index bec107f819b..e71563cb115 100644
--- a/dlls/amstream/amstream_private.h
+++ b/dlls/amstream/amstream_private.h
@@ -37,9 +37,7 @@
 HRESULT multimedia_stream_create(IUnknown *outer, void **out) DECLSPEC_HIDDEN;
 HRESULT AMAudioData_create(IUnknown *pUnkOuter, LPVOID *ppObj) DECLSPEC_HIDDEN;
 HRESULT filter_create(IUnknown *outer, void **out) DECLSPEC_HIDDEN;
-HRESULT ddraw_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
-        IUnknown *stream_object, STREAM_TYPE type, IAMMediaStream **stream) DECLSPEC_HIDDEN;
-HRESULT audio_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
-        IUnknown *stream_object, STREAM_TYPE stream_type, IAMMediaStream **media_stream) DECLSPEC_HIDDEN;
+HRESULT ddraw_stream_create(IUnknown *outer, void **out) DECLSPEC_HIDDEN;
+HRESULT audio_stream_create(IUnknown *outer, void **out) DECLSPEC_HIDDEN;
 
 #endif /* __AMSTREAM_PRIVATE_INCLUDED__ */
diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index a38cbc5f639..f9470fa5f90 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -1273,13 +1273,12 @@ static const IMemInputPinVtbl audio_meminput_vtbl =
     audio_meminput_ReceiveCanBlock,
 };
 
-HRESULT audio_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
-        IUnknown *stream_object, STREAM_TYPE stream_type, IAMMediaStream **media_stream)
+HRESULT audio_stream_create(IUnknown *outer, void **out)
 {
     struct audio_stream *object;
-    HRESULT hr;
 
-    TRACE("(%p,%s,%p,%p)\n", parent, debugstr_guid(purpose_id), stream_object, media_stream);
+    if (outer)
+        return CLASS_E_NOAGGREGATION;
 
     object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
     if (!object)
@@ -1295,21 +1294,9 @@ HRESULT audio_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
     list_init(&object->receive_queue);
     list_init(&object->update_queue);
 
-    hr = IAMMediaStream_Initialize(&object->IAMMediaStream_iface, stream_object, 0, purpose_id, stream_type);
-    if (FAILED(hr))
-    {
-        IAMMediaStream_Release(&object->IAMMediaStream_iface);
-        return hr;
-    }
-
-    hr = IAMMediaStream_JoinAMMultiMediaStream(&object->IAMMediaStream_iface, (IAMMultiMediaStream *)parent);
-    if (FAILED(hr))
-    {
-        IAMMediaStream_Release(&object->IAMMediaStream_iface);
-        return hr;
-    }
+    TRACE("Created audio stream %p.\n", object);
 
-    *media_stream = &object->IAMMediaStream_iface;
+    *out = &object->IAMMediaStream_iface;
 
     return S_OK;
 }
diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 8e99ea3bf55..1c924e40a20 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -926,13 +926,12 @@ static const IMemInputPinVtbl ddraw_meminput_vtbl =
     ddraw_meminput_ReceiveCanBlock,
 };
 
-HRESULT ddraw_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
-        IUnknown *stream_object, STREAM_TYPE stream_type, IAMMediaStream **media_stream)
+HRESULT ddraw_stream_create(IUnknown *outer, void **out)
 {
     struct ddraw_stream *object;
-    HRESULT hr;
 
-    TRACE("(%p,%s,%p,%p)\n", parent, debugstr_guid(purpose_id), stream_object, media_stream);
+    if (outer)
+        return CLASS_E_NOAGGREGATION;
 
     object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
     if (!object)
@@ -946,21 +945,9 @@ HRESULT ddraw_stream_create(IMultiMediaStream *parent, const MSPID *purpose_id,
 
     InitializeCriticalSection(&object->cs);
 
-    hr = IAMMediaStream_Initialize(&object->IAMMediaStream_iface, stream_object, 0, purpose_id, stream_type);
-    if (FAILED(hr))
-    {
-        IAMMediaStream_Release(&object->IAMMediaStream_iface);
-        return hr;
-    }
-
-    hr = IAMMediaStream_JoinAMMultiMediaStream(&object->IAMMediaStream_iface, (IAMMultiMediaStream *)parent);
-    if (FAILED(hr))
-    {
-        IAMMediaStream_Release(&object->IAMMediaStream_iface);
-        return hr;
-    }
+    TRACE("Created ddraw stream %p.\n", object);
 
-    *media_stream = &object->IAMMediaStream_iface;
+    *out = &object->IAMMediaStream_iface;
 
     return S_OK;
 }
diff --git a/dlls/amstream/multimedia.c b/dlls/amstream/multimedia.c
index be8fd4ecbfc..e77392e483a 100644
--- a/dlls/amstream/multimedia.c
+++ b/dlls/amstream/multimedia.c
@@ -301,6 +301,7 @@ static HRESULT WINAPI multimedia_stream_GetFilter(IAMMultiMediaStream *iface,
 static void add_stream(struct multimedia_stream *mmstream, IAMMediaStream *stream, IMediaStream **ret_stream)
 {
     IMediaStreamFilter_AddMediaStream(mmstream->filter, stream);
+    IAMMediaStream_JoinAMMultiMediaStream(stream, &mmstream->IAMMultiMediaStream_iface);
     if (ret_stream)
     {
         *ret_stream = (IMediaStream *)stream;
@@ -377,19 +378,26 @@ static HRESULT WINAPI multimedia_stream_AddMediaStream(IAMMultiMediaStream *ifac
     }
 
     if (IsEqualGUID(PurposeId, &MSPID_PrimaryVideo))
-        hr = ddraw_stream_create((IMultiMediaStream*)iface, PurposeId, stream_object, This->type, &pStream);
+        hr = ddraw_stream_create(NULL, (void **)&pStream);
     else if (IsEqualGUID(PurposeId, &MSPID_PrimaryAudio))
-        hr = audio_stream_create((IMultiMediaStream*)iface, PurposeId, stream_object, This->type, &pStream);
+        hr = audio_stream_create(NULL, (void **)&pStream);
     else
         return MS_E_PURPOSEID;
 
-    if (SUCCEEDED(hr))
+    if (FAILED(hr))
+        return hr;
+
+    hr = IAMMediaStream_Initialize(pStream, stream_object, dwFlags, PurposeId, This->type);
+    if (FAILED(hr))
     {
-        add_stream(This, pStream, ret_stream);
         IAMMediaStream_Release(pStream);
+        return hr;
     }
 
-    return hr;
+    add_stream(This, pStream, ret_stream);
+    IAMMediaStream_Release(pStream);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI multimedia_stream_OpenFile(IAMMultiMediaStream *iface,
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 073e372c94f..13c00aac25a 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -730,7 +730,7 @@ static void test_add_stream(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(stream == (IMediaStream *)&teststream, "Streams didn't match.\n");
     if (hr == S_OK) IMediaStream_Release(stream);
-    todo_wine ok(teststream.mmstream == mmstream, "IAMMultiMediaStream objects didn't match.\n");
+    ok(teststream.mmstream == mmstream, "IAMMultiMediaStream objects didn't match.\n");
     ok(teststream.filter == stream_filter, "IMediaStreamFilter objects didn't match.\n");
     todo_wine ok(!!teststream.graph, "Expected a non-NULL graph.\n");
 
From 7d07142b1f2664ef6cd0939ddc8a40894f97d702 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 28 May 2020 02:05:51 +0700
Subject: [PATCH] amstream: Allow AMAudioStream and AMDirectDrawStream to be
 created by CoCreateInstance.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/amstream_classes.idl | 7 +++++++
 dlls/amstream/main.c               | 3 ++-
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/dlls/amstream/amstream_classes.idl b/dlls/amstream/amstream_classes.idl
index e6bda830b40..2251bf734e3 100644
--- a/dlls/amstream/amstream_classes.idl
+++ b/dlls/amstream/amstream_classes.idl
@@ -34,6 +34,13 @@ coclass MediaStreamFilter { interface IMediaStreamFilter; }
 ]
 coclass AMDirectDrawStream { interface IAMMultiMediaStream; }
 
+[
+    helpstring("AuStream Class"),
+    threading(both),
+    uuid(8496e040-af4c-11d0-8212-00c04fc32c45)
+]
+coclass AMAudioStream { interface IAMMediaStream; }
+
 [
     helpstring("MMStream Class"),
     threading(both),
diff --git a/dlls/amstream/main.c b/dlls/amstream/main.c
index c718f42448c..c581e516bd1 100644
--- a/dlls/amstream/main.c
+++ b/dlls/amstream/main.c
@@ -74,7 +74,8 @@ struct object_creation_info
 static const struct object_creation_info object_creation[] =
 {
     { &CLSID_AMMultiMediaStream, multimedia_stream_create },
-    { &CLSID_AMDirectDrawStream, multimedia_stream_create },
+    { &CLSID_AMDirectDrawStream, ddraw_stream_create },
+    { &CLSID_AMAudioStream, audio_stream_create },
     { &CLSID_AMAudioData, AMAudioData_create },
     { &CLSID_MediaStreamFilter, filter_create }
 };
From d17b009bf6fd7842bdb174b982d3435f44e0f770 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 28 May 2020 02:05:52 +0700
Subject: [PATCH] amstream: Add tests for IAMMediaStream::Initialize and
 ::JoinAMMultiMediaStream.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 143 +++++++++++++++++++++++++++++++++
 1 file changed, 143 insertions(+)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 13c00aac25a..d5b90d92574 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -3046,6 +3046,44 @@ static void test_audiostream_receive(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_audiostream_initialize(void)
+{
+    IAMMediaStream *stream;
+    STREAM_TYPE type;
+    MSPID mspid;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IAMMediaStream_Initialize(stream, NULL, 0, NULL, STREAMTYPE_WRITE);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+    }
+
+    hr = IAMMediaStream_Initialize(stream, NULL, 0, &test_mspid, STREAMTYPE_WRITE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMediaStream_GetInformation(stream, &mspid, &type);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(IsEqualGUID(&mspid, &test_mspid), "Got mspid %s.\n", wine_dbgstr_guid(&mspid));
+    ok(type == STREAMTYPE_WRITE, "Got type %u.\n", type);
+
+    hr = IAMMediaStream_Initialize(stream, NULL, 0, &MSPID_PrimaryAudio, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMediaStream_GetInformation(stream, &mspid, &type);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(IsEqualGUID(&mspid, &MSPID_PrimaryAudio), "Got mspid %s.\n", wine_dbgstr_guid(&mspid));
+    ok(type == STREAMTYPE_READ, "Got type %u.\n", type);
+
+    ref = IAMMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void CALLBACK apc_func(ULONG_PTR param)
 {
 }
@@ -3507,6 +3545,106 @@ void test_audiostreamsample_completion_status(void)
     CloseHandle(event);
 }
 
+static void test_ddrawstream_initialize(void)
+{
+    IDirectDrawMediaStream *ddraw_stream;
+    IAMMediaStream *stream;
+    IDirectDraw *ddraw2;
+    IDirectDraw *ddraw;
+    STREAM_TYPE type;
+    MSPID mspid;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = DirectDrawCreate(NULL, &ddraw, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = CoCreateInstance(&CLSID_AMDirectDrawStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (void **)&ddraw_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IAMMediaStream_Initialize(stream, NULL, 0, NULL, STREAMTYPE_WRITE);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+    }
+
+    hr = IAMMediaStream_Initialize(stream, NULL, 0, &test_mspid, STREAMTYPE_WRITE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMediaStream_GetInformation(stream, &mspid, &type);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(IsEqualGUID(&mspid, &test_mspid), "Got mspid %s.\n", wine_dbgstr_guid(&mspid));
+    ok(type == STREAMTYPE_WRITE, "Got type %u.\n", type);
+
+    hr = IAMMediaStream_Initialize(stream, (IUnknown *)ddraw, 0, &MSPID_PrimaryAudio, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMediaStream_GetInformation(stream, &mspid, &type);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(IsEqualGUID(&mspid, &MSPID_PrimaryAudio), "Got mspid %s.\n", wine_dbgstr_guid(&mspid));
+    ok(type == STREAMTYPE_READ, "Got type %u.\n", type);
+
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(ddraw2 == ddraw, "Expected ddraw %p, got %p.\n", ddraw, ddraw2);
+
+    IDirectDrawMediaStream_Release(ddraw_stream);
+    ref = IAMMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IDirectDraw_Release(ddraw2);
+    ref = IDirectDraw_Release(ddraw);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void check_ammediastream_join_am_multi_media_stream(const CLSID *clsid)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IMultiMediaStream *mmstream2;
+    IAMMediaStream *stream;
+    HRESULT hr;
+    ULONG mmstream_ref;
+    ULONG ref;
+
+    hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    mmstream_ref = get_refcount(mmstream);
+
+    hr = IAMMediaStream_JoinAMMultiMediaStream(stream, mmstream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    ref = get_refcount(mmstream);
+    ok(ref == mmstream_ref, "Expected outstanding refcount %d, got %d.\n", mmstream_ref, ref);
+
+    hr = IAMMediaStream_GetMultiMediaStream(stream, &mmstream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mmstream2 == (IMultiMediaStream *)mmstream, "Expected mmstream %p, got %p.\n", mmstream, mmstream2);
+
+    IMultiMediaStream_Release(mmstream2);
+
+    hr = IAMMediaStream_JoinAMMultiMediaStream(stream, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMediaStream_GetMultiMediaStream(stream, &mmstream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mmstream2 == NULL, "Got mmstream %p.\n", mmstream2);
+
+    ref = IAMMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_ammediastream_join_am_multi_media_stream(void)
+{
+    check_ammediastream_join_am_multi_media_stream(&CLSID_AMAudioStream);
+    check_ammediastream_join_am_multi_media_stream(&CLSID_AMDirectDrawStream);
+}
+
 void test_mediastreamfilter_get_state(void)
 {
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
@@ -3681,10 +3819,15 @@ START_TEST(amstream)
     test_audiostream_set_state();
     test_audiostream_end_of_stream();
     test_audiostream_receive();
+    test_audiostream_initialize();
 
     test_audiostreamsample_update();
     test_audiostreamsample_completion_status();
 
+    test_ddrawstream_initialize();
+
+    test_ammediastream_join_am_multi_media_stream();
+
     test_mediastreamfilter_get_state();
     test_mediastreamfilter_stop_pause_run();
 
From d1197ffaeb983abf226c27ad1a557a47644ea829 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 3 Jun 2020 14:28:12 -0500
Subject: [PATCH] amstream: Leave critical section on error in
 MediaStreamFilter::EnumPins().

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/filter.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/amstream/filter.c b/dlls/amstream/filter.c
index fb9b1d9aee5..f89fe13e625 100644
--- a/dlls/amstream/filter.c
+++ b/dlls/amstream/filter.c
@@ -361,14 +361,14 @@ static HRESULT WINAPI filter_EnumPins(IMediaStreamFilter *iface, IEnumPins **enu
 
     TRACE("iface %p, enum_pins %p.\n", iface, enum_pins);
 
-    EnterCriticalSection(&filter->cs);
-
     if (!enum_pins)
         return E_POINTER;
 
     if (!(object = heap_alloc(sizeof(*object))))
         return E_OUTOFMEMORY;
 
+    EnterCriticalSection(&filter->cs);
+
     object->IEnumPins_iface.lpVtbl = &enum_pins_vtbl;
     object->refcount = 1;
     object->count = filter->nb_streams;
@@ -376,6 +376,7 @@ static HRESULT WINAPI filter_EnumPins(IMediaStreamFilter *iface, IEnumPins **enu
     if (!(object->pins = heap_alloc(filter->nb_streams * sizeof(*object->pins))))
     {
         heap_free(object);
+        LeaveCriticalSection(&filter->cs);
         return E_OUTOFMEMORY;
     }
     for (i = 0; i < filter->nb_streams; ++i)
From ae1ca7029a4aea3e2b466dd6bc1958af38f15274 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 3 Jun 2020 14:28:13 -0500
Subject: [PATCH] amstream: Implement AMAudioStream::BeginFlush() and
 ::EndFlush().

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    |  36 ++++++++--
 dlls/amstream/tests/amstream.c | 124 +++++++++++++++++++++++++++++++++
 2 files changed, 155 insertions(+), 5 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index f9470fa5f90..8fba8777190 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -56,6 +56,7 @@ struct audio_stream
     WAVEFORMATEX format;
     FILTER_STATE state;
     BOOL eos;
+    BOOL flushing;
     struct list receive_queue;
     struct list update_queue;
 };
@@ -1084,7 +1085,7 @@ static HRESULT WINAPI audio_sink_EndOfStream(IPin *iface)
 
     EnterCriticalSection(&stream->cs);
 
-    if (stream->eos)
+    if (stream->eos || stream->flushing)
     {
         LeaveCriticalSection(&stream->cs);
         return E_FAIL;
@@ -1101,14 +1102,34 @@ static HRESULT WINAPI audio_sink_EndOfStream(IPin *iface)
 
 static HRESULT WINAPI audio_sink_BeginFlush(IPin *iface)
 {
-    FIXME("iface %p, stub!\n", iface);
-    return E_NOTIMPL;
+    struct audio_stream *stream = impl_from_IPin(iface);
+
+    TRACE("stream %p.\n", stream);
+
+    EnterCriticalSection(&stream->cs);
+
+    stream->flushing = TRUE;
+    stream->eos = FALSE;
+    flush_receive_queue(stream);
+
+    LeaveCriticalSection(&stream->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_sink_EndFlush(IPin *iface)
 {
-    FIXME("iface %p, stub!\n", iface);
-    return E_NOTIMPL;
+    struct audio_stream *stream = impl_from_IPin(iface);
+
+    TRACE("stream %p.\n", stream);
+
+    EnterCriticalSection(&stream->cs);
+
+    stream->flushing = FALSE;
+
+    LeaveCriticalSection(&stream->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_sink_NewSegment(IPin *iface, REFERENCE_TIME start, REFERENCE_TIME stop, double rate)
@@ -1219,6 +1240,11 @@ static HRESULT WINAPI audio_meminput_Receive(IMemInputPin *iface, IMediaSample *
         LeaveCriticalSection(&stream->cs);
         return VFW_E_WRONG_STATE;
     }
+    if (stream->flushing)
+    {
+        LeaveCriticalSection(&stream->cs);
+        return S_FALSE;
+    }
 
     hr = IMediaSample_GetPointer(sample, &pointer);
     if (FAILED(hr))
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index d5b90d92574..2c97a0aa90f 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -3084,6 +3084,129 @@ static void test_audiostream_initialize(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_audiostream_begin_flush_end_flush(void)
+{
+    static const WAVEFORMATEX format =
+    {
+        .wFormatTag = WAVE_FORMAT_PCM,
+        .nChannels = 1,
+        .nSamplesPerSec = 11025,
+        .wBitsPerSample = 16,
+        .nBlockAlign = 2,
+        .nAvgBytesPerSec = 2 * 11025,
+    };
+
+    const AM_MEDIA_TYPE mt =
+    {
+        .majortype = MEDIATYPE_Audio,
+        .subtype = MEDIASUBTYPE_PCM,
+        .formattype = FORMAT_WaveFormatEx,
+        .cbFormat = sizeof(WAVEFORMATEX),
+        .pbFormat = (BYTE *)&format,
+    };
+
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IAudioStreamSample *stream_sample;
+    IAudioMediaStream *audio_stream;
+    IMediaSample *media_sample;
+    struct testfilter source;
+    IAudioData *audio_data;
+    IGraphBuilder *graph;
+    IMediaStream *stream;
+    HRESULT hr;
+    ULONG ref;
+    IPin *pin;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IAudioMediaStream, (void **)&audio_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    testfilter_init(&source);
+    hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER, &IID_IAudioData, (void **)&audio_data);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAudioData_SetBuffer(audio_data, 16, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAudioMediaStream_CreateSample(audio_stream, audio_data, 0, &stream_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = BaseOutputPinImpl_GetDeliveryBuffer(&source.source, &media_sample, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(source.source.pMemInputPin, media_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ref = get_refcount(media_sample);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+
+    hr = IPin_EndOfStream(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_BeginFlush(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    ref = IMediaSample_Release(media_sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+    hr = BaseOutputPinImpl_GetDeliveryBuffer(&source.source, &media_sample, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(source.source.pMemInputPin, media_sample);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    ref = IMediaSample_Release(media_sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+    hr = IAudioStreamSample_Update(stream_sample, SSUPDATE_ASYNC, NULL, NULL, 0);
+    ok(hr == MS_S_PENDING, "Got hr %#x.\n", hr);
+
+    hr = IPin_EndOfStream(pin);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+
+    hr = IPin_EndFlush(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = BaseOutputPinImpl_GetDeliveryBuffer(&source.source, &media_sample, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(source.source.pMemInputPin, media_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ref = IMediaSample_Release(media_sample);
+    ok(ref == 1, "Got outstanding refcount %d.\n", ref);
+
+    hr = IPin_EndOfStream(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    IGraphBuilder_Disconnect(graph, pin);
+    IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
+
+    ref = IAudioStreamSample_Release(stream_sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAudioData_Release(audio_data);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin);
+    IAudioMediaStream_Release(audio_stream);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void CALLBACK apc_func(ULONG_PTR param)
 {
 }
@@ -3820,6 +3943,7 @@ START_TEST(amstream)
     test_audiostream_end_of_stream();
     test_audiostream_receive();
     test_audiostream_initialize();
+    test_audiostream_begin_flush_end_flush();
 
     test_audiostreamsample_update();
     test_audiostreamsample_completion_status();
From 77134d806d3a3c4fca3e996952a36a78c545cf72 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 3 Jun 2020 14:28:14 -0500
Subject: [PATCH] amstream: Implement MediaStreamFilter::SupportSeeking().

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/filter.c         | 270 ++++++++++++++++++++++++++--
 dlls/amstream/tests/amstream.c | 316 +++++++++++++++++++++++++++++++++
 2 files changed, 568 insertions(+), 18 deletions(-)

diff --git a/dlls/amstream/filter.c b/dlls/amstream/filter.c
index f89fe13e625..f1e0811d679 100644
--- a/dlls/amstream/filter.c
+++ b/dlls/amstream/filter.c
@@ -163,6 +163,7 @@ static const IEnumPinsVtbl enum_pins_vtbl =
 struct filter
 {
     IMediaStreamFilter IMediaStreamFilter_iface;
+    IMediaSeeking IMediaSeeking_iface;
     LONG refcount;
     CRITICAL_SECTION cs;
 
@@ -171,6 +172,7 @@ struct filter
     IFilterGraph *graph;
     ULONG nb_streams;
     IAMMediaStream **streams;
+    IAMMediaStream *seekable_stream;
     FILTER_STATE state;
 };
 
@@ -179,26 +181,27 @@ static inline struct filter *impl_from_IMediaStreamFilter(IMediaStreamFilter *if
     return CONTAINING_RECORD(iface, struct filter, IMediaStreamFilter_iface);
 }
 
-static HRESULT WINAPI filter_QueryInterface(IMediaStreamFilter *iface, REFIID riid, void **ret_iface)
+static HRESULT WINAPI filter_QueryInterface(IMediaStreamFilter *iface, REFIID iid, void **out)
 {
-    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ret_iface);
+    struct filter *filter = impl_from_IMediaStreamFilter(iface);
 
-    *ret_iface = NULL;
+    TRACE("filter %p, iid %s, out %p.\n", filter, debugstr_guid(iid), out);
 
-    if (IsEqualIID(riid, &IID_IUnknown) ||
-        IsEqualIID(riid, &IID_IPersist) ||
-        IsEqualIID(riid, &IID_IMediaFilter) ||
-        IsEqualIID(riid, &IID_IBaseFilter) ||
-        IsEqualIID(riid, &IID_IMediaStreamFilter))
-        *ret_iface = iface;
+    *out = NULL;
 
-    if (*ret_iface)
-    {
-        IMediaStreamFilter_AddRef(*ret_iface);
-        return S_OK;
-    }
+    if (IsEqualGUID(iid, &IID_IUnknown)
+            || IsEqualGUID(iid, &IID_IPersist)
+            || IsEqualGUID(iid, &IID_IMediaFilter)
+            || IsEqualGUID(iid, &IID_IBaseFilter)
+            || IsEqualGUID(iid, &IID_IMediaStreamFilter))
+        *out = iface;
+    else if (IsEqualGUID(iid, &IID_IMediaSeeking) && filter->seekable_stream)
+        *out = &filter->IMediaSeeking_iface;
+    else
+        return E_NOINTERFACE;
 
-    return E_NOINTERFACE;
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
 }
 
 static ULONG WINAPI filter_AddRef(IMediaStreamFilter *iface)
@@ -538,11 +541,70 @@ static HRESULT WINAPI filter_EnumMediaStreams(IMediaStreamFilter *iface, LONG in
     return S_OK;
 }
 
-static HRESULT WINAPI filter_SupportSeeking(IMediaStreamFilter *iface, BOOL bRenderer)
+static IMediaSeeking *get_seeking(IAMMediaStream *stream)
 {
-    FIXME("(%p)->(%d): Stub!\n", iface, bRenderer);
+    IMediaSeeking *seeking;
+    IPin *pin, *peer;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    if (FAILED(IAMMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin)))
+    {
+        WARN("Stream %p does not support IPin.\n", stream);
+        return NULL;
+    }
+
+    hr = IPin_ConnectedTo(pin, &peer);
+    IPin_Release(pin);
+    if (FAILED(hr))
+        return NULL;
+
+    hr = IPin_QueryInterface(peer, &IID_IMediaSeeking, (void **)&seeking);
+    IPin_Release(peer);
+    if (FAILED(hr))
+        return NULL;
+
+    return seeking;
+}
+
+static HRESULT WINAPI filter_SupportSeeking(IMediaStreamFilter *iface, BOOL renderer)
+{
+    struct filter *filter = impl_from_IMediaStreamFilter(iface);
+    unsigned int i;
+
+    TRACE("filter %p, renderer %d\n", iface, renderer);
+
+    if (!renderer)
+        FIXME("Non-renderer filter support is not yet implemented.\n");
+
+    EnterCriticalSection(&filter->cs);
+
+    if (filter->seekable_stream)
+    {
+        LeaveCriticalSection(&filter->cs);
+        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
+    }
+
+    for (i = 0; i < filter->nb_streams; ++i)
+    {
+        IMediaSeeking *seeking = get_seeking(filter->streams[i]);
+        LONGLONG duration;
+
+        if (!seeking)
+            continue;
+
+        if (SUCCEEDED(IMediaSeeking_GetDuration(seeking, &duration)))
+        {
+            filter->seekable_stream = filter->streams[i];
+            IMediaSeeking_Release(seeking);
+            LeaveCriticalSection(&filter->cs);
+            return S_OK;
+        }
+
+        IMediaSeeking_Release(seeking);
+    }
+
+    LeaveCriticalSection(&filter->cs);
+    return E_NOINTERFACE;
 }
 
 static HRESULT WINAPI filter_ReferenceTimeToStreamTime(IMediaStreamFilter *iface, REFERENCE_TIME *pTime)
@@ -608,6 +670,177 @@ static const IMediaStreamFilterVtbl filter_vtbl =
     filter_EndOfStream
 };
 
+static inline struct filter *impl_from_IMediaSeeking(IMediaSeeking *iface)
+{
+    return CONTAINING_RECORD(iface, struct filter, IMediaSeeking_iface);
+}
+
+static HRESULT WINAPI filter_seeking_QueryInterface(IMediaSeeking *iface, REFIID iid, void **out)
+{
+    struct filter *filter = impl_from_IMediaSeeking(iface);
+    return IMediaStreamFilter_QueryInterface(&filter->IMediaStreamFilter_iface, iid, out);
+}
+
+static ULONG WINAPI filter_seeking_AddRef(IMediaSeeking *iface)
+{
+    struct filter *filter = impl_from_IMediaSeeking(iface);
+    return IMediaStreamFilter_AddRef(&filter->IMediaStreamFilter_iface);
+}
+
+static ULONG WINAPI filter_seeking_Release(IMediaSeeking *iface)
+{
+    struct filter *filter = impl_from_IMediaSeeking(iface);
+    return IMediaStreamFilter_Release(&filter->IMediaStreamFilter_iface);
+}
+
+static HRESULT WINAPI filter_seeking_GetCapabilities(IMediaSeeking *iface, DWORD *capabilities)
+{
+    FIXME("iface %p, capabilities %p, stub!\n", iface, capabilities);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_CheckCapabilities(IMediaSeeking *iface, DWORD *capabilities)
+{
+    FIXME("iface %p, capabilities %p, stub!\n", iface, capabilities);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_IsFormatSupported(IMediaSeeking *iface, const GUID *format)
+{
+    FIXME("iface %p, format %s, stub!\n", iface, debugstr_guid(format));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_QueryPreferredFormat(IMediaSeeking *iface, GUID *format)
+{
+    FIXME("iface %p, format %p, stub!\n", iface, format);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetTimeFormat(IMediaSeeking *iface, GUID *format)
+{
+    FIXME("iface %p, format %p, stub!\n", iface, format);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_IsUsingTimeFormat(IMediaSeeking *iface, const GUID *format)
+{
+    FIXME("iface %p, format %s, stub!\n", iface, debugstr_guid(format));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_SetTimeFormat(IMediaSeeking *iface, const GUID *format)
+{
+    FIXME("iface %p, format %s, stub!\n", iface, debugstr_guid(format));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetDuration(IMediaSeeking *iface, LONGLONG *duration)
+{
+    FIXME("iface %p, duration %p, stub!\n", iface, duration);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetStopPosition(IMediaSeeking *iface, LONGLONG *stop)
+{
+    FIXME("iface %p, stop %p, stub!\n", iface, stop);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetCurrentPosition(IMediaSeeking *iface, LONGLONG *current)
+{
+    FIXME("iface %p, current %p, stub!\n", iface, current);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_ConvertTimeFormat(IMediaSeeking *iface, LONGLONG *target,
+        const GUID *target_format, LONGLONG source, const GUID *source_format)
+{
+    FIXME("iface %p, target %p, target_format %s, source 0x%s, source_format %s, stub!\n", iface, target, debugstr_guid(target_format),
+            wine_dbgstr_longlong(source), debugstr_guid(source_format));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_SetPositions(IMediaSeeking *iface, LONGLONG *current_ptr, DWORD current_flags,
+        LONGLONG *stop_ptr, DWORD stop_flags)
+{
+    FIXME("iface %p, current %s, current_flags %#x, stop %s, stop_flags %#x, stub!\n", iface,
+            current_ptr ? wine_dbgstr_longlong(*current_ptr) : "<null>", current_flags,
+            stop_ptr ? wine_dbgstr_longlong(*stop_ptr): "<null>", stop_flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetPositions(IMediaSeeking *iface, LONGLONG *current, LONGLONG *stop)
+{
+    FIXME("iface %p, current %p, stop %p, stub!\n", iface, current, stop);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetAvailable(IMediaSeeking *iface, LONGLONG *earliest, LONGLONG *latest)
+{
+    FIXME("iface %p, earliest %p, latest %p, stub!\n", iface, earliest, latest);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_SetRate(IMediaSeeking *iface, double rate)
+{
+    FIXME("iface %p, rate %f, stub!\n", iface, rate);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetRate(IMediaSeeking *iface, double *rate)
+{
+    FIXME("iface %p, rate %p, stub!\n", iface, rate);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI filter_seeking_GetPreroll(IMediaSeeking *iface, LONGLONG *preroll)
+{
+    FIXME("iface %p, preroll %p, stub!\n", iface, preroll);
+
+    return E_NOTIMPL;
+}
+
+static const IMediaSeekingVtbl filter_seeking_vtbl =
+{
+    filter_seeking_QueryInterface,
+    filter_seeking_AddRef,
+    filter_seeking_Release,
+    filter_seeking_GetCapabilities,
+    filter_seeking_CheckCapabilities,
+    filter_seeking_IsFormatSupported,
+    filter_seeking_QueryPreferredFormat,
+    filter_seeking_GetTimeFormat,
+    filter_seeking_IsUsingTimeFormat,
+    filter_seeking_SetTimeFormat,
+    filter_seeking_GetDuration,
+    filter_seeking_GetStopPosition,
+    filter_seeking_GetCurrentPosition,
+    filter_seeking_ConvertTimeFormat,
+    filter_seeking_SetPositions,
+    filter_seeking_GetPositions,
+    filter_seeking_GetAvailable,
+    filter_seeking_SetRate,
+    filter_seeking_GetRate,
+    filter_seeking_GetPreroll,
+};
+
 HRESULT filter_create(IUnknown *outer, void **out)
 {
     struct filter *object;
@@ -621,6 +854,7 @@ HRESULT filter_create(IUnknown *outer, void **out)
         return E_OUTOFMEMORY;
 
     object->IMediaStreamFilter_iface.lpVtbl = &filter_vtbl;
+    object->IMediaSeeking_iface.lpVtbl = &filter_seeking_vtbl;
     object->refcount = 1;
     InitializeCriticalSection(&object->cs);
     object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": MediaStreamFilter.cs");
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 2c97a0aa90f..11813b5439f 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -2348,6 +2348,8 @@ struct testfilter
 {
     struct strmbase_filter filter;
     struct strmbase_source source;
+    IMediaSeeking IMediaSeeking_iface;
+    HRESULT get_duration_hr;
 };
 
 static inline struct testfilter *impl_from_BaseFilter(struct strmbase_filter *iface)
@@ -2394,6 +2396,25 @@ static const struct strmbase_filter_ops testfilter_ops =
     .filter_cleanup_stream = testfilter_cleanup_stream,
 };
 
+static inline struct testfilter *impl_from_base_pin(struct strmbase_pin *iface)
+{
+    return CONTAINING_RECORD(iface, struct testfilter, source.pin);
+}
+
+static HRESULT testsource_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
+{
+    struct testfilter *filter = impl_from_base_pin(iface);
+
+    if (IsEqualGUID(iid, &IID_IMediaSeeking) && filter->IMediaSeeking_iface.lpVtbl)
+        *out = &filter->IMediaSeeking_iface;
+    else
+        return E_NOINTERFACE;
+
+    IUnknown_AddRef((IUnknown *)*out);
+
+    return S_OK;
+}
+
 static HRESULT WINAPI testsource_DecideBufferSize(struct strmbase_source *iface,
         IMemAllocator *alloc, ALLOCATOR_PROPERTIES *requested)
 {
@@ -2413,6 +2434,7 @@ static HRESULT WINAPI testsource_DecideBufferSize(struct strmbase_source *iface,
 
 static const struct strmbase_source_ops testsource_ops =
 {
+    .base.pin_query_interface = testsource_query_interface,
     .pfnAttemptConnection = BaseOutputPinImpl_AttemptConnection,
     .pfnDecideBufferSize = testsource_DecideBufferSize,
     .pfnDecideAllocator = BaseOutputPinImpl_DecideAllocator,
@@ -2421,10 +2443,166 @@ static const struct strmbase_source_ops testsource_ops =
 static void testfilter_init(struct testfilter *filter)
 {
     static const GUID clsid = {0xabacab};
+    memset(filter, 0, sizeof(*filter));
     strmbase_filter_init(&filter->filter, NULL, &clsid, &testfilter_ops);
     strmbase_source_init(&filter->source, &filter->filter, L"", &testsource_ops);
 }
 
+static inline struct testfilter *impl_from_IMediaSeeking(IMediaSeeking *iface)
+{
+    return CONTAINING_RECORD(iface, struct testfilter, IMediaSeeking_iface);
+}
+
+static HRESULT WINAPI testsource_seeking_QueryInterface(IMediaSeeking *iface, REFIID iid, void **out)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+    return IBaseFilter_QueryInterface(&filter->filter.IBaseFilter_iface, iid, out);
+}
+
+static ULONG WINAPI testsource_seeking_AddRef(IMediaSeeking *iface)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+    return IBaseFilter_AddRef(&filter->filter.IBaseFilter_iface);
+}
+
+static ULONG WINAPI testsource_seeking_Release(IMediaSeeking *iface)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+    return IBaseFilter_Release(&filter->filter.IBaseFilter_iface);
+}
+
+static HRESULT WINAPI testsource_seeking_GetCapabilities(IMediaSeeking *iface, DWORD *capabilities)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_CheckCapabilities(IMediaSeeking *iface, DWORD *capabilities)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_IsFormatSupported(IMediaSeeking *iface, const GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_QueryPreferredFormat(IMediaSeeking *iface, GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetTimeFormat(IMediaSeeking *iface, GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_IsUsingTimeFormat(IMediaSeeking *iface, const GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_SetTimeFormat(IMediaSeeking *iface, const GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetDuration(IMediaSeeking *iface, LONGLONG *duration)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+
+    if (SUCCEEDED(filter->get_duration_hr))
+        *duration = 0x8000000000000000ULL;
+
+    return filter->get_duration_hr;
+}
+
+static HRESULT WINAPI testsource_seeking_GetStopPosition(IMediaSeeking *iface, LONGLONG *stop)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetCurrentPosition(IMediaSeeking *iface, LONGLONG *current)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_ConvertTimeFormat(IMediaSeeking *iface, LONGLONG *target,
+        const GUID *target_format, LONGLONG source, const GUID *source_format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_SetPositions(IMediaSeeking *iface, LONGLONG *current_ptr, DWORD current_flags,
+        LONGLONG *stop_ptr, DWORD stop_flags)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetPositions(IMediaSeeking *iface, LONGLONG *current, LONGLONG *stop)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetAvailable(IMediaSeeking *iface, LONGLONG *earliest, LONGLONG *latest)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_SetRate(IMediaSeeking *iface, double rate)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetRate(IMediaSeeking *iface, double *rate)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetPreroll(IMediaSeeking *iface, LONGLONG *preroll)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static const IMediaSeekingVtbl testsource_seeking_vtbl =
+{
+    testsource_seeking_QueryInterface,
+    testsource_seeking_AddRef,
+    testsource_seeking_Release,
+    testsource_seeking_GetCapabilities,
+    testsource_seeking_CheckCapabilities,
+    testsource_seeking_IsFormatSupported,
+    testsource_seeking_QueryPreferredFormat,
+    testsource_seeking_GetTimeFormat,
+    testsource_seeking_IsUsingTimeFormat,
+    testsource_seeking_SetTimeFormat,
+    testsource_seeking_GetDuration,
+    testsource_seeking_GetStopPosition,
+    testsource_seeking_GetCurrentPosition,
+    testsource_seeking_ConvertTimeFormat,
+    testsource_seeking_SetPositions,
+    testsource_seeking_GetPositions,
+    testsource_seeking_GetAvailable,
+    testsource_seeking_SetRate,
+    testsource_seeking_GetRate,
+    testsource_seeking_GetPreroll,
+};
+
 static void test_audiostream_get_format(void)
 {
     static const WAVEFORMATEX pin_format =
@@ -3903,6 +4081,143 @@ void test_mediastreamfilter_stop_pause_run(void)
     check_mediastreamfilter_state(State_Running, mediastreamfilter_run, mediastreamfilter_stop);
 }
 
+static void test_mediastreamfilter_support_seeking(void)
+{
+    static const WAVEFORMATEX format =
+    {
+        .wFormatTag = WAVE_FORMAT_PCM,
+        .nChannels = 1,
+        .nSamplesPerSec = 11025,
+        .wBitsPerSample = 16,
+        .nBlockAlign = 2,
+        .nAvgBytesPerSec = 2 * 11025,
+    };
+
+    const AM_MEDIA_TYPE mt =
+    {
+        .majortype = MEDIATYPE_Audio,
+        .subtype = MEDIASUBTYPE_PCM,
+        .formattype = FORMAT_WaveFormatEx,
+        .cbFormat = sizeof(WAVEFORMATEX),
+        .pbFormat = (BYTE *)&format,
+    };
+
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    static const MSPID mspid1 = {0x88888888, 1};
+    static const MSPID mspid2 = {0x88888888, 2};
+    static const MSPID mspid3 = {0x88888888, 3};
+    struct testfilter source1, source2, source3;
+    IAMMediaStream *stream1, *stream2, *stream3;
+    IMediaStreamFilter *filter;
+    IPin *pin1, *pin2, *pin3;
+    ULONG ref, seeking_ref;
+    IGraphBuilder *graph;
+    HRESULT hr;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream1);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream1, NULL, 0, &mspid1, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream2, NULL, 0, &mspid2, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream3, NULL, 0, &mspid3, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream1, &mspid1, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream2, &mspid2, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream3, &mspid3, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream1, &IID_IPin, (void **)&pin1);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream2, &IID_IPin, (void **)&pin2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream3, &IID_IPin, (void **)&pin3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    testfilter_init(&source1);
+    testfilter_init(&source2);
+    testfilter_init(&source3);
+    source2.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    source3.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    hr = IGraphBuilder_AddFilter(graph, &source1.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_AddFilter(graph, &source2.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_AddFilter(graph, &source3.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    source2.get_duration_hr = E_FAIL;
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    check_interface(filter, &IID_IMediaSeeking, FALSE);
+
+    seeking_ref = get_refcount(&source3.IMediaSeeking_iface);
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    check_interface(filter, &IID_IMediaSeeking, TRUE);
+
+    ref = get_refcount(&source3.IMediaSeeking_iface);
+    ok(ref == seeking_ref, "Expected outstanding refcount %d, got %d.\n", seeking_ref, ref);
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED), "Got hr %#x.\n", hr);
+
+    IGraphBuilder_Disconnect(graph, pin1);
+    IGraphBuilder_Disconnect(graph, &source1.source.pin.IPin_iface);
+
+    IGraphBuilder_Disconnect(graph, pin2);
+    IGraphBuilder_Disconnect(graph, &source2.source.pin.IPin_iface);
+
+    IGraphBuilder_Disconnect(graph, pin3);
+    IGraphBuilder_Disconnect(graph, &source3.source.pin.IPin_iface);
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin1);
+    ref = IAMMediaStream_Release(stream1);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin2);
+    ref = IAMMediaStream_Release(stream2);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin3);
+    ref = IAMMediaStream_Release(stream3);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(amstream)
 {
     HANDLE file;
@@ -3954,6 +4269,7 @@ START_TEST(amstream)
 
     test_mediastreamfilter_get_state();
     test_mediastreamfilter_stop_pause_run();
+    test_mediastreamfilter_support_seeking();
 
     CoUninitialize();
 }
From 1c99a8e0952f977cc5647744d806590c13f925bd Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 3 Jun 2020 14:28:15 -0500
Subject: [PATCH] amstream: Implement MediaStreamFilter::SetPositions().

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/filter.c         |  24 +++-
 dlls/amstream/tests/amstream.c | 245 ++++++++++++++++++++++++++++++++-
 2 files changed, 265 insertions(+), 4 deletions(-)

diff --git a/dlls/amstream/filter.c b/dlls/amstream/filter.c
index f1e0811d679..05a02e3f666 100644
--- a/dlls/amstream/filter.c
+++ b/dlls/amstream/filter.c
@@ -775,11 +775,31 @@ static HRESULT WINAPI filter_seeking_ConvertTimeFormat(IMediaSeeking *iface, LON
 static HRESULT WINAPI filter_seeking_SetPositions(IMediaSeeking *iface, LONGLONG *current_ptr, DWORD current_flags,
         LONGLONG *stop_ptr, DWORD stop_flags)
 {
-    FIXME("iface %p, current %s, current_flags %#x, stop %s, stop_flags %#x, stub!\n", iface,
+    struct filter *filter = impl_from_IMediaSeeking(iface);
+    IMediaSeeking *seeking;
+    HRESULT hr;
+
+    TRACE("iface %p, current %s, current_flags %#x, stop %s, stop_flags %#x.\n", iface,
             current_ptr ? wine_dbgstr_longlong(*current_ptr) : "<null>", current_flags,
             stop_ptr ? wine_dbgstr_longlong(*stop_ptr): "<null>", stop_flags);
 
-    return E_NOTIMPL;
+    EnterCriticalSection(&filter->cs);
+
+    seeking = get_seeking(filter->seekable_stream);
+
+    if (!seeking)
+    {
+        LeaveCriticalSection(&filter->cs);
+        return E_NOTIMPL;
+    }
+
+    hr = IMediaSeeking_SetPositions(seeking, current_ptr, current_flags, stop_ptr, stop_flags);
+
+    IMediaSeeking_Release(seeking);
+
+    LeaveCriticalSection(&filter->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI filter_seeking_GetPositions(IMediaSeeking *iface, LONGLONG *current, LONGLONG *stop)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 11813b5439f..a9d79e6b7a9 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -2349,7 +2349,10 @@ struct testfilter
     struct strmbase_filter filter;
     struct strmbase_source source;
     IMediaSeeking IMediaSeeking_iface;
+    LONGLONG current_position;
+    LONGLONG stop_position;
     HRESULT get_duration_hr;
+    HRESULT set_positions_hr;
 };
 
 static inline struct testfilter *impl_from_BaseFilter(struct strmbase_filter *iface)
@@ -2446,6 +2449,7 @@ static void testfilter_init(struct testfilter *filter)
     memset(filter, 0, sizeof(*filter));
     strmbase_filter_init(&filter->filter, NULL, &clsid, &testfilter_ops);
     strmbase_source_init(&filter->source, &filter->filter, L"", &testsource_ops);
+    filter->stop_position = 0x8000000000000000ULL;
 }
 
 static inline struct testfilter *impl_from_IMediaSeeking(IMediaSeeking *iface)
@@ -2545,8 +2549,18 @@ static HRESULT WINAPI testsource_seeking_ConvertTimeFormat(IMediaSeeking *iface,
 static HRESULT WINAPI testsource_seeking_SetPositions(IMediaSeeking *iface, LONGLONG *current_ptr, DWORD current_flags,
         LONGLONG *stop_ptr, DWORD stop_flags)
 {
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+
+    if (SUCCEEDED(filter->set_positions_hr))
+    {
+        if (current_ptr)
+            filter->current_position = *current_ptr;
+
+        if (stop_ptr)
+            filter->stop_position = *stop_ptr;
+    }
+
+    return filter->set_positions_hr;
 }
 
 static HRESULT WINAPI testsource_seeking_GetPositions(IMediaSeeking *iface, LONGLONG *current, LONGLONG *stop)
@@ -4218,6 +4232,232 @@ static void test_mediastreamfilter_support_seeking(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_mediastreamfilter_set_positions(void)
+{
+    static const WAVEFORMATEX format =
+    {
+        .wFormatTag = WAVE_FORMAT_PCM,
+        .nChannels = 1,
+        .nSamplesPerSec = 11025,
+        .wBitsPerSample = 16,
+        .nBlockAlign = 2,
+        .nAvgBytesPerSec = 2 * 11025,
+    };
+
+    const AM_MEDIA_TYPE mt =
+    {
+        .majortype = MEDIATYPE_Audio,
+        .subtype = MEDIASUBTYPE_PCM,
+        .formattype = FORMAT_WaveFormatEx,
+        .cbFormat = sizeof(WAVEFORMATEX),
+        .pbFormat = (BYTE *)&format,
+    };
+
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    static const MSPID mspid1 = {0x88888888, 1};
+    static const MSPID mspid2 = {0x88888888, 2};
+    static const MSPID mspid3 = {0x88888888, 3};
+    IMediaStreamFilter *filter;
+    struct testfilter source1;
+    struct testfilter source2;
+    struct testfilter source3;
+    LONGLONG current_position;
+    IAMMediaStream *stream1;
+    IAMMediaStream *stream2;
+    IAMMediaStream *stream3;
+    LONGLONG stop_position;
+    IMediaSeeking *seeking;
+    IGraphBuilder *graph;
+    IPin *pin1;
+    IPin *pin2;
+    IPin *pin3;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream1);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream1, NULL, 0, &mspid1, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream2, NULL, 0, &mspid2, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream3, NULL, 0, &mspid3, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream1, &mspid1, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream2, &mspid2, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream3, &mspid3, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream1, &IID_IPin, (void **)&pin1);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream2, &IID_IPin, (void **)&pin2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream3, &IID_IPin, (void **)&pin3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    testfilter_init(&source1);
+    testfilter_init(&source2);
+    testfilter_init(&source3);
+    source1.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    source2.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    source3.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    hr = IGraphBuilder_AddFilter(graph, &source1.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_AddFilter(graph, &source2.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_AddFilter(graph, &source3.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_QueryInterface(filter, &IID_IMediaSeeking, (void **)&seeking);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    current_position = 12345678;
+    stop_position = 87654321;
+    source1.current_position = 0xdeadbeefdeadbeefULL;
+    source1.stop_position = 0xdeadbeefdeadbeefULL;
+    source2.current_position = 0xdeadbeefdeadbeefULL;
+    source2.stop_position = 0xdeadbeefdeadbeefULL;
+    source3.current_position = 0xdeadbeefdeadbeefULL;
+    source3.stop_position = 0xdeadbeefdeadbeefULL;
+    hr = IMediaSeeking_SetPositions(seeking, &current_position, AM_SEEKING_AbsolutePositioning,
+            &stop_position, AM_SEEKING_AbsolutePositioning);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(source1.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source1.current_position));
+    ok(source1.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source1.stop_position));
+    ok(source2.current_position == 12345678, "Got current position %s.\n",
+            wine_dbgstr_longlong(source2.current_position));
+    ok(source2.stop_position == 87654321, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source2.stop_position));
+    ok(source3.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source3.current_position));
+    ok(source3.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source3.stop_position));
+
+    source2.set_positions_hr = E_FAIL;
+    source1.current_position = 0xdeadbeefdeadbeefULL;
+    source1.stop_position = 0xdeadbeefdeadbeefULL;
+    source3.current_position = 0xdeadbeefdeadbeefULL;
+    source3.stop_position = 0xdeadbeefdeadbeefULL;
+    current_position = 12345678;
+    stop_position = 87654321;
+    hr = IMediaSeeking_SetPositions(seeking, &current_position, AM_SEEKING_AbsolutePositioning,
+            &stop_position, AM_SEEKING_AbsolutePositioning);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(source1.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source1.current_position));
+    ok(source1.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source1.stop_position));
+    ok(source3.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source3.current_position));
+    ok(source3.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source3.stop_position));
+
+    source2.set_positions_hr = E_NOTIMPL;
+    source1.current_position = 0xdeadbeefdeadbeefULL;
+    source1.stop_position = 0xdeadbeefdeadbeefULL;
+    source3.current_position = 0xdeadbeefdeadbeefULL;
+    source3.stop_position = 0xdeadbeefdeadbeefULL;
+    current_position = 12345678;
+    stop_position = 87654321;
+    hr = IMediaSeeking_SetPositions(seeking, &current_position, AM_SEEKING_AbsolutePositioning,
+            &stop_position, AM_SEEKING_AbsolutePositioning);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(source1.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source1.current_position));
+    ok(source1.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source1.stop_position));
+    ok(source3.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source3.current_position));
+    ok(source3.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source3.stop_position));
+
+    source2.IMediaSeeking_iface.lpVtbl = NULL;
+    source1.current_position = 0xdeadbeefdeadbeefULL;
+    source1.stop_position = 0xdeadbeefdeadbeefULL;
+    source3.current_position = 0xdeadbeefdeadbeefULL;
+    source3.stop_position = 0xdeadbeefdeadbeefULL;
+    current_position = 12345678;
+    stop_position = 87654321;
+    hr = IMediaSeeking_SetPositions(seeking, &current_position, AM_SEEKING_AbsolutePositioning,
+            &stop_position, AM_SEEKING_AbsolutePositioning);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(source1.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source1.current_position));
+    ok(source1.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source1.stop_position));
+    ok(source3.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source3.current_position));
+    ok(source3.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source3.stop_position));
+
+    IGraphBuilder_Disconnect(graph, pin2);
+    IGraphBuilder_Disconnect(graph, &source2.source.pin.IPin_iface);
+
+    source2.IMediaSeeking_iface.lpVtbl = NULL;
+    source1.current_position = 0xdeadbeefdeadbeefULL;
+    source1.stop_position = 0xdeadbeefdeadbeefULL;
+    source3.current_position = 0xdeadbeefdeadbeefULL;
+    source3.stop_position = 0xdeadbeefdeadbeefULL;
+    current_position = 12345678;
+    stop_position = 87654321;
+    hr = IMediaSeeking_SetPositions(seeking, &current_position, AM_SEEKING_AbsolutePositioning,
+            &stop_position, AM_SEEKING_AbsolutePositioning);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(source1.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source1.current_position));
+    ok(source1.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source1.stop_position));
+    ok(source3.current_position == 0xdeadbeefdeadbeefULL, "Got current position %s.\n",
+            wine_dbgstr_longlong(source3.current_position));
+    ok(source3.stop_position == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n",
+            wine_dbgstr_longlong(source3.stop_position));
+
+    IGraphBuilder_Disconnect(graph, pin2);
+    IGraphBuilder_Disconnect(graph, &source2.source.pin.IPin_iface);
+    IGraphBuilder_Disconnect(graph, pin3);
+    IGraphBuilder_Disconnect(graph, &source3.source.pin.IPin_iface);
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IMediaSeeking_Release(seeking);
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin1);
+    ref = IAMMediaStream_Release(stream1);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin2);
+    ref = IAMMediaStream_Release(stream2);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin3);
+    ref = IAMMediaStream_Release(stream3);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(amstream)
 {
     HANDLE file;
@@ -4270,6 +4510,7 @@ START_TEST(amstream)
     test_mediastreamfilter_get_state();
     test_mediastreamfilter_stop_pause_run();
     test_mediastreamfilter_support_seeking();
+    test_mediastreamfilter_set_positions();
 
     CoUninitialize();
 }
From aba27fd5a3241635adb15fa7ef40aa43bf3978a1 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 3 Jun 2020 14:28:16 -0500
Subject: [PATCH] amstream: Call MediaStreamFilter::SupportSeeking() in
 AMMultiMediaStream::OpenFile().

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/multimedia.c     | 2 ++
 dlls/amstream/tests/amstream.c | 4 ++++
 2 files changed, 6 insertions(+)

diff --git a/dlls/amstream/multimedia.c b/dlls/amstream/multimedia.c
index e77392e483a..e058e639ddb 100644
--- a/dlls/amstream/multimedia.c
+++ b/dlls/amstream/multimedia.c
@@ -442,6 +442,8 @@ static HRESULT WINAPI multimedia_stream_OpenFile(IAMMultiMediaStream *iface,
     if (SUCCEEDED(ret) && !(flags & AMMSF_NORENDER))
         ret = IGraphBuilder_Render(This->graph, This->ipin);
 
+    IMediaStreamFilter_SupportSeeking(This->filter, This->type == STREAMTYPE_READ);
+
     if (EnumPins)
         IEnumPins_Release(EnumPins);
     if (BaseFilter)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index a9d79e6b7a9..f082b78347a 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -224,9 +224,13 @@ static void test_openfile(void)
     if (pgraph)
         IGraphBuilder_Release(pgraph);
 
+    check_interface(pams, &IID_IMediaSeeking, FALSE);
+
     hr = IAMMultiMediaStream_OpenFile(pams, L"test.avi", 0);
     ok(hr==S_OK, "IAMMultiMediaStream_OpenFile returned: %x\n", hr);
 
+    check_interface(pams, &IID_IMediaSeeking, TRUE);
+
     hr = IAMMultiMediaStream_GetFilterGraph(pams, &pgraph);
     ok(hr==S_OK, "IAMMultiMediaStream_GetFilterGraph returned: %x\n", hr);
     ok(pgraph!=NULL, "Filtergraph should be created\n");
From 3d92885390513d28532c2926f2cb1041ead3a5a3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 3 Jun 2020 20:52:32 -0500
Subject: [PATCH] amstream/tests: Define and use a global variable holding an
 audio media type.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 220 +++++++--------------------------
 1 file changed, 44 insertions(+), 176 deletions(-)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index f082b78347a..2bc1310a96b 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -29,6 +29,26 @@
 #include "ksmedia.h"
 #include "wine/strmbase.h"
 
+static const WAVEFORMATEX audio_format =
+{
+    .wFormatTag = WAVE_FORMAT_PCM,
+    .nChannels = 1,
+    .nSamplesPerSec = 11025,
+    .wBitsPerSample = 16,
+    .nBlockAlign = 2,
+    .nAvgBytesPerSec = 2 * 11025,
+};
+
+static const AM_MEDIA_TYPE audio_mt =
+{
+    /* MEDIATYPE_Audio, MEDIASUBTYPE_PCM, FORMAT_WaveFormatEx */
+    .majortype = {0x73647561, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}},
+    .subtype = {0x00000001, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}},
+    .formattype = {0x05589f81, 0xc356, 0x11ce, {0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a}},
+    .cbFormat = sizeof(WAVEFORMATEX),
+    .pbFormat = (BYTE *)&audio_format,
+};
+
 static const WCHAR primary_video_sink_id[] = L"I{A35FF56A-9FDA-11D0-8FDF-00C04FD9189D}";
 static const WCHAR primary_audio_sink_id[] = L"I{A35FF56B-9FDA-11D0-8FDF-00C04FD9189D}";
 
@@ -2888,25 +2908,6 @@ static void test_audiostream_set_format(void)
 
 static void test_audiostream_receive_connection(void)
 {
-    static const WAVEFORMATEX valid_format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 2,
-        .nSamplesPerSec = 44100,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 4,
-        .nAvgBytesPerSec = 4 * 44100,
-    };
-
-    const AM_MEDIA_TYPE valid_mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&valid_format,
-    };
-
     WAVEFORMATEXTENSIBLE extensible_format;
     IAudioMediaStream *audio_stream;
     IAMMultiMediaStream *mmstream;
@@ -2933,56 +2934,56 @@ static void test_audiostream_receive_connection(void)
     hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &valid_mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     IGraphBuilder_Disconnect(graph, pin);
     IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
 
-    mt = valid_mt;
+    mt = audio_mt;
     mt.majortype = GUID_NULL;
     hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &mt);
     ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
 
-    mt = valid_mt;
+    mt = audio_mt;
     mt.subtype = MEDIASUBTYPE_RGB24;
     hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     IGraphBuilder_Disconnect(graph, pin);
     IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
 
-    mt = valid_mt;
+    mt = audio_mt;
     mt.formattype = GUID_NULL;
     hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &mt);
     ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
 
-    mt = valid_mt;
+    mt = audio_mt;
     mt.cbFormat = sizeof(WAVEFORMATEX) - 1;
     hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
     ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
 
-    extensible_format.Format = valid_format;
+    extensible_format.Format = audio_format;
     extensible_format.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
     extensible_format.Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
-    extensible_format.Samples.wValidBitsPerSample = valid_format.wBitsPerSample;
+    extensible_format.Samples.wValidBitsPerSample = audio_format.wBitsPerSample;
     extensible_format.dwChannelMask = KSAUDIO_SPEAKER_STEREO;
     extensible_format.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
-    mt = valid_mt;
+    mt = audio_mt;
     mt.cbFormat = sizeof(extensible_format);
     mt.pbFormat = (BYTE *)&extensible_format;
     hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
     ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
-    hr = IAudioMediaStream_SetFormat(audio_stream, &valid_format);
+    hr = IAudioMediaStream_SetFormat(audio_stream, &audio_format);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    format = valid_format;
-    format.nChannels = 1;
-    mt = valid_mt;
+    format = audio_format;
+    format.nChannels = 2;
+    mt = audio_mt;
     mt.pbFormat = (BYTE *)&format;
     hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
     ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &valid_mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     IGraphBuilder_Disconnect(graph, pin);
     IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
@@ -3035,25 +3036,6 @@ static void test_audiostream_set_state(void)
 
 void test_audiostream_end_of_stream(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     struct testfilter source;
     IGraphBuilder *graph;
@@ -3075,7 +3057,7 @@ void test_audiostream_end_of_stream(void)
     hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_EndOfStream(pin);
@@ -3113,25 +3095,6 @@ void test_audiostream_end_of_stream(void)
 
 static void test_audiostream_receive(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     ALLOCATOR_PROPERTIES properties =
     {
         .cBuffers = 3,
@@ -3171,7 +3134,7 @@ static void test_audiostream_receive(void)
     hr = IMemAllocator_Commit(allocator);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample1, NULL, NULL, 0);
@@ -3282,25 +3245,6 @@ static void test_audiostream_initialize(void)
 
 static void test_audiostream_begin_flush_end_flush(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     IAudioStreamSample *stream_sample;
     IAudioMediaStream *audio_stream;
@@ -3334,7 +3278,7 @@ static void test_audiostream_begin_flush_end_flush(void)
     hr = IAudioMediaStream_CreateSample(audio_stream, audio_data, 0, &stream_sample);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
@@ -3455,25 +3399,6 @@ static DWORD CALLBACK audiostream_receive(void *param)
 
 static void test_audiostreamsample_update(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     static const BYTE test_data[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     IAudioStreamSample *stream_sample;
@@ -3542,7 +3467,7 @@ static void test_audiostreamsample_update(void)
 
     hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -3697,25 +3622,6 @@ static void test_audiostreamsample_update(void)
 
 void test_audiostreamsample_completion_status(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     static const BYTE test_data[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     IAudioStreamSample *stream_sample1;
@@ -3762,7 +3668,7 @@ void test_audiostreamsample_completion_status(void)
     hr = IAudioMediaStream_CreateSample(audio_stream, audio_data2, 0, &stream_sample2);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -4101,25 +4007,6 @@ void test_mediastreamfilter_stop_pause_run(void)
 
 static void test_mediastreamfilter_support_seeking(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     static const MSPID mspid1 = {0x88888888, 1};
     static const MSPID mspid2 = {0x88888888, 2};
@@ -4178,7 +4065,7 @@ static void test_mediastreamfilter_support_seeking(void)
     hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
     ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     source2.get_duration_hr = E_FAIL;
@@ -4186,13 +4073,13 @@ static void test_mediastreamfilter_support_seeking(void)
     hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
     ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
     ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_interface(filter, &IID_IMediaSeeking, FALSE);
@@ -4238,25 +4125,6 @@ static void test_mediastreamfilter_support_seeking(void)
 
 static void test_mediastreamfilter_set_positions(void)
 {
-    static const WAVEFORMATEX format =
-    {
-        .wFormatTag = WAVE_FORMAT_PCM,
-        .nChannels = 1,
-        .nSamplesPerSec = 11025,
-        .wBitsPerSample = 16,
-        .nBlockAlign = 2,
-        .nAvgBytesPerSec = 2 * 11025,
-    };
-
-    const AM_MEDIA_TYPE mt =
-    {
-        .majortype = MEDIATYPE_Audio,
-        .subtype = MEDIASUBTYPE_PCM,
-        .formattype = FORMAT_WaveFormatEx,
-        .cbFormat = sizeof(WAVEFORMATEX),
-        .pbFormat = (BYTE *)&format,
-    };
-
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     static const MSPID mspid1 = {0x88888888, 1};
     static const MSPID mspid2 = {0x88888888, 2};
@@ -4322,15 +4190,15 @@ static void test_mediastreamfilter_set_positions(void)
     hr = IGraphBuilder_AddFilter(graph, &source3.filter.IBaseFilter_iface, NULL);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &mt);
+    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &audio_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaStreamFilter_QueryInterface(filter, &IID_IMediaSeeking, (void **)&seeking);
From 56e72e071dfa0fd9954f765fabf8e2a9ccb01af1 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Wed, 3 Jun 2020 22:38:39 -0600
Subject: [PATCH] quartz/tests: Fix overflow in 32-bit time calculation.

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/systemclock.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/quartz/tests/systemclock.c b/dlls/quartz/tests/systemclock.c
index 71a7ac26d84..f13e89abedb 100644
--- a/dlls/quartz/tests/systemclock.c
+++ b/dlls/quartz/tests/systemclock.c
@@ -183,7 +183,7 @@ static void test_get_time(void)
     if (pGetTickCount64)
         time2 = pGetTickCount64() * 10000;
     else
-        time2 = GetTickCount() * 10000;
+        time2 = (REFERENCE_TIME)GetTickCount() * 10000;
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time1 % 10000 == 0, "Expected no less than 1ms coarseness, but got time %s.\n",
             wine_dbgstr_longlong(time1));
From 2680b076e33747bd20dcd283f6d526b1130d079d Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Mon, 8 Jun 2020 10:17:22 -0500
Subject: [PATCH] quartz/filtergraph: Add a stub IVideoFrameStep interface.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=42372
Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 57 ++++++++++++++++++++++++++++++++-
 dlls/quartz/tests/filtergraph.c |  1 +
 include/axextend.idl            | 13 ++++++++
 3 files changed, 70 insertions(+), 1 deletion(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 6217516db1e..918c41a3d67 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -181,7 +181,7 @@ typedef struct _IFilterGraphImpl {
     /* IRegisterServiceProvider */
     /* IResourceManager */
     /* IServiceProvider */
-    /* IVideoFrameStep */
+    IVideoFrameStep IVideoFrameStep_iface;
 
     IUnknown *outer_unk;
     LONG ref;
@@ -454,6 +454,9 @@ static HRESULT WINAPI FilterGraphInner_QueryInterface(IUnknown *iface, REFIID ri
     } else if (IsEqualGUID(&IID_IGraphVersion, riid)) {
         *ppvObj = &This->IGraphVersion_iface;
         TRACE("   returning IGraphVersion interface (%p)\n", *ppvObj);
+    } else if (IsEqualGUID(&IID_IVideoFrameStep, riid)) {
+        *ppvObj = &This->IVideoFrameStep_iface;
+        TRACE("   returning IVideoFrameStep interface (%p)\n", *ppvObj);
     } else {
         *ppvObj = NULL;
 	FIXME("unknown interface %s\n", debugstr_guid(riid));
@@ -5638,6 +5641,57 @@ static const IGraphVersionVtbl IGraphVersion_VTable =
     GraphVersion_QueryVersion,
 };
 
+static IFilterGraphImpl *impl_from_IVideoFrameStep(IVideoFrameStep *iface)
+{
+    return CONTAINING_RECORD(iface, IFilterGraphImpl, IVideoFrameStep_iface);
+}
+
+static HRESULT WINAPI VideoFrameStep_QueryInterface(IVideoFrameStep *iface, REFIID iid, void **out)
+{
+    IFilterGraphImpl *graph = impl_from_IVideoFrameStep(iface);
+    return IUnknown_QueryInterface(graph->outer_unk, iid, out);
+}
+
+static ULONG WINAPI VideoFrameStep_AddRef(IVideoFrameStep *iface)
+{
+    IFilterGraphImpl *graph = impl_from_IVideoFrameStep(iface);
+    return IUnknown_AddRef(graph->outer_unk);
+}
+
+static ULONG WINAPI VideoFrameStep_Release(IVideoFrameStep *iface)
+{
+    IFilterGraphImpl *graph = impl_from_IVideoFrameStep(iface);
+    return IUnknown_Release(graph->outer_unk);
+}
+
+static HRESULT WINAPI VideoFrameStep_Step(IVideoFrameStep *iface, DWORD frame_count, IUnknown *filter)
+{
+    FIXME("iface %p, frame_count %u, filter %p, stub!\n", iface, frame_count, filter);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI VideoFrameStep_CanStep(IVideoFrameStep *iface, LONG multiple, IUnknown *filter)
+{
+    FIXME("iface %p, multiple %d, filter %p, stub!\n", iface, multiple, filter);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI VideoFrameStep_CancelStep(IVideoFrameStep *iface)
+{
+    FIXME("iface %p, stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static const IVideoFrameStepVtbl VideoFrameStep_vtbl =
+{
+    VideoFrameStep_QueryInterface,
+    VideoFrameStep_AddRef,
+    VideoFrameStep_Release,
+    VideoFrameStep_Step,
+    VideoFrameStep_CanStep,
+    VideoFrameStep_CancelStep
+};
+
 static const IUnknownVtbl IInner_VTable =
 {
     FilterGraphInner_QueryInterface,
@@ -5668,6 +5722,7 @@ static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL
     fimpl->IMediaPosition_iface.lpVtbl = &IMediaPosition_VTable;
     fimpl->IObjectWithSite_iface.lpVtbl = &IObjectWithSite_VTable;
     fimpl->IGraphVersion_iface.lpVtbl = &IGraphVersion_VTable;
+    fimpl->IVideoFrameStep_iface.lpVtbl = &VideoFrameStep_vtbl;
     fimpl->ref = 1;
     list_init(&fimpl->filters);
     list_init(&fimpl->sorted_filters);
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index f0aa084192d..a3378efe0be 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -125,6 +125,7 @@ static void test_interfaces(void)
     check_interface(graph, &IID_IMediaPosition, TRUE);
     check_interface(graph, &IID_IMediaSeeking, TRUE);
     check_interface(graph, &IID_IObjectWithSite, TRUE);
+    check_interface(graph, &IID_IVideoFrameStep, TRUE);
     check_interface(graph, &IID_IVideoWindow, TRUE);
 
     check_interface(graph, &IID_IBaseFilter, FALSE);
diff --git a/include/axextend.idl b/include/axextend.idl
index 8b46d665b5d..7630ea247c4 100644
--- a/include/axextend.idl
+++ b/include/axextend.idl
@@ -1471,3 +1471,16 @@ interface IAMTVTuner : IAMTuner
     HRESULT get_VideoFrequency([out] long *freq);
     HRESULT get_AudioFrequency([out] long *freq);
 }
+
+[
+    local,
+    object,
+    uuid(e46a9787-2b71-444d-a4b5-1fab7b708d6a),
+    pointer_default(unique),
+]
+interface IVideoFrameStep : IUnknown
+{
+    HRESULT Step(DWORD frame_count, [in] IUnknown *filter);
+    HRESULT CanStep(long multiple, [in] IUnknown *filter);
+    HRESULT CancelStep();
+}
From 2cf4b6016e3b1dffb59ccfaf55199380ebf64b65 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 6 Jun 2020 16:03:13 -0500
Subject: [PATCH] strmbase: Clear the debug info before calling
 DeleteCriticalSection (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/strmbase/filter.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/dlls/strmbase/filter.c b/dlls/strmbase/filter.c
index 2809832ee82..8b8182a13ab 100644
--- a/dlls/strmbase/filter.c
+++ b/dlls/strmbase/filter.c
@@ -532,11 +532,13 @@ void strmbase_filter_init(struct strmbase_filter *filter, IUnknown *outer,
     filter->ops = ops;
 }
 
-void strmbase_filter_cleanup(struct strmbase_filter *This)
+void strmbase_filter_cleanup(struct strmbase_filter *filter)
 {
-    if (This->clock)
-        IReferenceClock_Release(This->clock);
+    if (filter->clock)
+        IReferenceClock_Release(filter->clock);
 
-    This->IBaseFilter_iface.lpVtbl = NULL;
-    DeleteCriticalSection(&This->csFilter);
+    filter->IBaseFilter_iface.lpVtbl = NULL;
+    if (filter->csFilter.DebugInfo != (RTL_CRITICAL_SECTION_DEBUG *)-1)
+        filter->csFilter.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&filter->csFilter);
 }
From 07729ea4ef7d53dc39f32d47f7bf9f1b7e3a5f1b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 6 Jun 2020 16:22:44 -0500
Subject: [PATCH] strmbase: Avoid leaking the media type on failure in
 IEnumMediaTypes::Next().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/strmbase/pin.c | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/dlls/strmbase/pin.c b/dlls/strmbase/pin.c
index eab7c0cb2e4..f08c6d01865 100644
--- a/dlls/strmbase/pin.c
+++ b/dlls/strmbase/pin.c
@@ -119,6 +119,7 @@ static HRESULT WINAPI enum_media_types_Next(IEnumMediaTypes *iface, ULONG count,
         AM_MEDIA_TYPE **mts, ULONG *ret_count)
 {
     struct enum_media_types *enummt = impl_from_IEnumMediaTypes(iface);
+    AM_MEDIA_TYPE mt;
     unsigned int i;
     HRESULT hr;
 
@@ -133,10 +134,14 @@ static HRESULT WINAPI enum_media_types_Next(IEnumMediaTypes *iface, ULONG count,
 
     for (i = 0; i < count; ++i)
     {
-        if ((mts[i] = CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE))))
-            hr = enummt->pin->ops->pin_get_media_type(enummt->pin, enummt->index + i, mts[i]);
-        else
-            hr = E_OUTOFMEMORY;
+        hr = enummt->pin->ops->pin_get_media_type(enummt->pin, enummt->index + i, &mt);
+        if (hr == S_OK)
+        {
+            if ((mts[i] = CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE))))
+                *mts[i] = mt;
+            else
+                hr = E_OUTOFMEMORY;
+        }
         if (FAILED(hr))
         {
             while (i--)
From 2ad5d4f159ef447c288fc9463fa7e50a8342a612 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Thu, 28 May 2020 00:38:09 +0200
Subject: [PATCH] quartz/tests: Fix -Wabsolute-value warnings.

Signed-off-by: Jacek Caban <jacek@codeweavers.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/filtergraph.c | 18 ++++++++++++------
 dlls/quartz/tests/systemclock.c |  8 +++++++-
 dlls/quartz/tests/vmr9.c        | 21 +++++++++++----------
 3 files changed, 30 insertions(+), 17 deletions(-)

diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 68b4863442f..f0aa084192d 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -41,6 +41,12 @@ typedef struct TestFilterImpl
     UINT nPins;
 } TestFilterImpl;
 
+static BOOL compare_time(ULONGLONG x, ULONGLONG y, unsigned int max_diff)
+{
+    ULONGLONG diff = x > y ? x - y : y - x;
+    return diff <= max_diff;
+}
+
 static WCHAR *create_file(const WCHAR *name, const char *data, DWORD size)
 {
     static WCHAR pathW[MAX_PATH];
@@ -4057,13 +4063,13 @@ static void test_graph_seeking(void)
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
-        ok(abs(time - 1234 * 10000) < 40 * 10000,
+        ok(compare_time(time, 1234 * 10000, 40 * 10000),
                 "Expected about 1234ms, got %s.\n", wine_dbgstr_longlong(time));
     current = stop = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
-        ok(abs(current - 1234 * 10000) < 40 * 10000,
+        ok(compare_time(current, 1234 * 10000, 40 * 10000),
                 "Expected about 1234ms, got %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 9000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
@@ -4080,13 +4086,13 @@ static void test_graph_seeking(void)
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
-        ok(abs(time - 1334 * 10000) < 80 * 10000,
+        ok(compare_time(time, 1334 * 10000, 80 * 10000),
                 "Expected about 1334ms, got %s.\n", wine_dbgstr_longlong(time));
     current = stop = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
-        ok(abs(current - 1334 * 10000) < 80 * 10000,
+        ok(compare_time(current, 1334 * 10000, 80 * 10000),
                 "Expected about 1334ms, got %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 8000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
@@ -4100,13 +4106,13 @@ static void test_graph_seeking(void)
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
-        ok(abs(time - 1334 * 10000) < 80 * 10000,
+        ok(compare_time(time, 1334 * 10000, 80 * 10000),
                 "Expected about 1334ms, got %s.\n", wine_dbgstr_longlong(time));
     current = stop = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
-        ok(abs(current - 1334 * 10000) < 80 * 10000,
+        ok(compare_time(current, 1334 * 10000, 80 * 10000),
                 "Expected about 1334ms, got %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 8000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
diff --git a/dlls/quartz/tests/systemclock.c b/dlls/quartz/tests/systemclock.c
index b85a801f0ef..71a7ac26d84 100644
--- a/dlls/quartz/tests/systemclock.c
+++ b/dlls/quartz/tests/systemclock.c
@@ -24,6 +24,12 @@
 
 static ULONGLONG (WINAPI *pGetTickCount64)(void);
 
+static BOOL compare_time(REFERENCE_TIME x, REFERENCE_TIME y, unsigned int max_diff)
+{
+    REFERENCE_TIME diff = x > y ? x - y : y - x;
+    return diff <= max_diff;
+}
+
 static IReferenceClock *create_system_clock(void)
 {
     IReferenceClock *clock = NULL;
@@ -181,7 +187,7 @@ static void test_get_time(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time1 % 10000 == 0, "Expected no less than 1ms coarseness, but got time %s.\n",
             wine_dbgstr_longlong(time1));
-    ok(abs(time1 - time2) < 20 * 10000, "Expected about %s, got %s.\n",
+    ok(compare_time(time1, time2, 20 * 10000), "Expected about %s, got %s.\n",
             wine_dbgstr_longlong(time2), wine_dbgstr_longlong(time1));
 
     hr = IReferenceClock_GetTime(clock, &time2);
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 2921d1aed02..7dd6dbe1dd2 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -73,18 +73,19 @@ static inline BOOL compare_media_types(const AM_MEDIA_TYPE *a, const AM_MEDIA_TY
 
 static BOOL compare_double(double f, double g, unsigned int ulps)
 {
-    int64_t x = *(int64_t *)&f;
-    int64_t y = *(int64_t *)&g;
+    uint64_t x = *(ULONGLONG *)&f;
+    uint64_t y = *(ULONGLONG *)&g;
 
-    if (x < 0)
-        x = INT64_MIN - x;
-    if (y < 0)
-        y = INT64_MIN - y;
-
-    if (abs(x - y) > ulps)
-        return FALSE;
+    if (f < 0)
+        x = ~x + 1;
+    else
+        x |= ((ULONGLONG)1)<<63;
+    if (g < 0)
+        y = ~y + 1;
+    else
+        y |= ((ULONGLONG)1)<<63;
 
-    return TRUE;
+    return (x>y ? x-y : y-x) <= ulps;
 }
 
 static IFilterGraph2 *create_graph(void)
From 036fcf96c83cddee001ef1f3358a7fa25d1db839 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 7 Jun 2020 16:24:44 -0500
Subject: [PATCH] quartz/tests: Avoid leaking the media type from
 IPin::ConnectionMediaType() (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/avidec.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/quartz/tests/avidec.c b/dlls/quartz/tests/avidec.c
index 0e1e92a9509..9505bfb591d 100644
--- a/dlls/quartz/tests/avidec.c
+++ b/dlls/quartz/tests/avidec.c
@@ -967,6 +967,7 @@ static void test_connect_pin(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsource.source.pin.mt, &req_mt), "Media types didn't match.\n");
+    FreeMediaType(&mt);
 
     sink_bih = req_format.bmiHeader;
 
@@ -1072,6 +1073,7 @@ static void test_connect_pin(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsink.sink.pin.mt, &req_mt), "Media types didn't match.\n");
+    FreeMediaType(&mt);
 
     hr = IFilterGraph2_Disconnect(graph, source);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
From 4beda167575f24eaed7da4ee3cbbc92f6bea6339 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 7 Jun 2020 17:23:29 -0500
Subject: [PATCH] quartz: Free type libraries on process detach (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/main.c       |  5 ++++-
 dlls/strmbase/dispatch.c | 13 +++++++++++++
 include/wine/strmbase.h  |  1 +
 3 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/dlls/quartz/main.c b/dlls/quartz/main.c
index 4acb4f1a795..303cc30a931 100644
--- a/dlls/quartz/main.c
+++ b/dlls/quartz/main.c
@@ -31,8 +31,11 @@ LONG object_locks = 0;
 
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
-    if (reason == DLL_PROCESS_DETACH)
+    if (reason == DLL_PROCESS_DETACH && !reserved)
+    {
         video_window_unregister_class();
+        strmbase_release_typelibs();
+    }
     return QUARTZ_DllMain(instance, reason, reserved);
 }
 
diff --git a/dlls/strmbase/dispatch.c b/dlls/strmbase/dispatch.c
index 25573fa1a26..de817f20c0d 100644
--- a/dlls/strmbase/dispatch.c
+++ b/dlls/strmbase/dispatch.c
@@ -68,3 +68,16 @@ HRESULT strmbase_get_typeinfo(enum strmbase_type_id tid, ITypeInfo **ret)
     ITypeInfo_AddRef(*ret = control_typeinfo[tid]);
     return S_OK;
 }
+
+void strmbase_release_typelibs(void)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(control_typeinfo); ++i)
+    {
+        if (control_typeinfo[i])
+            ITypeInfo_Release(control_typeinfo[i]);
+    }
+    if (control_typelib)
+        ITypeLib_Release(control_typelib);
+}
diff --git a/include/wine/strmbase.h b/include/wine/strmbase.h
index 6789957e50a..02a5469de17 100644
--- a/include/wine/strmbase.h
+++ b/include/wine/strmbase.h
@@ -252,6 +252,7 @@ enum strmbase_type_id
 };
 
 HRESULT strmbase_get_typeinfo(enum strmbase_type_id tid, ITypeInfo **typeinfo);
+void strmbase_release_typelibs(void);
 
 struct strmbase_passthrough
 {
From 0e6fc4d81cceb46af52e0b83122ce5f6dd1b6961 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 7 Jun 2020 17:23:30 -0500
Subject: [PATCH] qedit: Free type libraries on process detach (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qedit/main.c          | 21 ++++++++++++---------
 dlls/qedit/mediadet.c      |  1 -
 dlls/qedit/qedit_private.h |  1 +
 dlls/qedit/samplegrabber.c |  1 -
 4 files changed, 13 insertions(+), 11 deletions(-)

diff --git a/dlls/qedit/main.c b/dlls/qedit/main.c
index f4d1bbb0613..a4a4f5ec38c 100644
--- a/dlls/qedit/main.c
+++ b/dlls/qedit/main.c
@@ -23,15 +23,18 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(qedit);
 
-static HINSTANCE instance;
+static HINSTANCE qedit_instance;
 
-BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpv)
+BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
-    switch(fdwReason) {
-        case DLL_PROCESS_ATTACH:
-            instance = hInstDLL;
-            DisableThreadLibraryCalls(hInstDLL);
-            break;
+    if (reason == DLL_PROCESS_ATTACH)
+    {
+        qedit_instance = instance;
+        DisableThreadLibraryCalls(instance);
+    }
+    else if (reason == DLL_PROCESS_DETACH && !reserved)
+    {
+        strmbase_release_typelibs();
     }
     return TRUE;
 }
@@ -243,7 +246,7 @@ HRESULT WINAPI DllRegisterServer(void)
     IFilterMapper2 *mapper;
     HRESULT hr;
 
-    if (FAILED(hr = __wine_register_resources( instance )))
+    if (FAILED(hr = __wine_register_resources(qedit_instance)))
         return hr;
 
     if (FAILED(hr = CoCreateInstance(&CLSID_FilterMapper2, NULL, CLSCTX_INPROC_SERVER,
@@ -267,7 +270,7 @@ HRESULT WINAPI DllUnregisterServer(void)
     IFilterMapper2 *mapper;
     HRESULT hr;
 
-    if (FAILED(hr = __wine_unregister_resources( instance )))
+    if (FAILED(hr = __wine_unregister_resources(qedit_instance)))
         return hr;
 
     if (FAILED(hr = CoCreateInstance(&CLSID_FilterMapper2, NULL, CLSCTX_INPROC_SERVER,
diff --git a/dlls/qedit/mediadet.c b/dlls/qedit/mediadet.c
index d32679b6bb8..e1defaa9a67 100644
--- a/dlls/qedit/mediadet.c
+++ b/dlls/qedit/mediadet.c
@@ -28,7 +28,6 @@
 #include "ole2.h"
 
 #include "qedit_private.h"
-#include "wine/strmbase.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qedit);
diff --git a/dlls/qedit/qedit_private.h b/dlls/qedit/qedit_private.h
index 7011c9f70dd..0c0655084d5 100644
--- a/dlls/qedit/qedit_private.h
+++ b/dlls/qedit/qedit_private.h
@@ -32,6 +32,7 @@
 #include "winuser.h"
 #include "dshow.h"
 #include "qedit.h"
+#include "wine/strmbase.h"
 
 HRESULT timeline_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
 HRESULT media_detector_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
diff --git a/dlls/qedit/samplegrabber.c b/dlls/qedit/samplegrabber.c
index bd8480df48b..1619111f95d 100644
--- a/dlls/qedit/samplegrabber.c
+++ b/dlls/qedit/samplegrabber.c
@@ -29,7 +29,6 @@
 
 #include "qedit_private.h"
 #include "wine/debug.h"
-#include "wine/strmbase.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qedit);
 
From b6c96cf763b2994b9b71d8a53988749d7dea1914 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 7 Jun 2020 17:23:31 -0500
Subject: [PATCH] qasf: Free type libraries on process detach (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qasf/qasf_main.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/qasf/qasf_main.c b/dlls/qasf/qasf_main.c
index 2e65b693fa0..ac671d3919c 100644
--- a/dlls/qasf/qasf_main.c
+++ b/dlls/qasf/qasf_main.c
@@ -108,6 +108,10 @@ BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
         DisableThreadLibraryCalls(instance);
         qasf_instance = instance;
     }
+    else if (reason == DLL_PROCESS_DETACH && !reserved)
+    {
+        strmbase_release_typelibs();
+    }
     return TRUE;
 }
 
From 05f319a39477ff675f14cd9ed6765ce3a5900e11 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Jun 2020 18:59:41 -0500
Subject: [PATCH] strmbase: Release the allocator in IPin::Disconnect()
 (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/videorenderer.c |  2 +-
 dlls/quartz/tests/vmr9.c          |  2 +-
 dlls/strmbase/pin.c               | 13 +++++++++++++
 3 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/dlls/quartz/tests/videorenderer.c b/dlls/quartz/tests/videorenderer.c
index 7330859466e..d603ea46edd 100644
--- a/dlls/quartz/tests/videorenderer.c
+++ b/dlls/quartz/tests/videorenderer.c
@@ -1443,7 +1443,7 @@ static void test_connect_pin(void)
     ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     ref = IMemAllocator_Release(allocator);
-    todo_wine ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IMemInputPin_Release(input);
     IPin_Release(pin);
     ref = IFilterGraph2_Release(graph);
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 7dd6dbe1dd2..14b6539a6bd 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -3072,7 +3072,7 @@ static void test_renderless_formats(void)
         ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
 
         hr = IMemInputPin_GetAllocator(input, &allocator);
-        todo_wine_if (i == 0) ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
+        todo_wine ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
         if (hr != S_OK)
         {
             test_allocator(input);
diff --git a/dlls/strmbase/pin.c b/dlls/strmbase/pin.c
index f08c6d01865..e5017c2ff98 100644
--- a/dlls/strmbase/pin.c
+++ b/dlls/strmbase/pin.c
@@ -594,6 +594,13 @@ static HRESULT WINAPI source_Disconnect(IPin *iface)
             IMemInputPin_Release(This->pMemInputPin);
             This->pMemInputPin = NULL;
         }
+
+        if (This->pAllocator)
+        {
+            IMemAllocator_Release(This->pAllocator);
+            This->pAllocator = NULL;
+        }
+
         if (This->pin.peer)
         {
             IPin_Release(This->pin.peer);
@@ -930,6 +937,12 @@ static HRESULT WINAPI sink_Disconnect(IPin *iface)
         if (pin->pFuncsTable->sink_disconnect)
             pin->pFuncsTable->sink_disconnect(pin);
 
+        if (pin->pAllocator)
+        {
+            IMemAllocator_Release(pin->pAllocator);
+            pin->pAllocator = NULL;
+        }
+
         IPin_Release(pin->pin.peer);
         pin->pin.peer = NULL;
         FreeMediaType(&pin->pin.mt);
From 609a832a56b0e313013b05eb5e9e609887b03544 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 10 Jun 2020 23:09:06 +0700
Subject: [PATCH] quartz/filtergraph: Always try to query IMediaSeeking if it's
 not cached yet.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 33 +++++++++++++++++++------
 dlls/quartz/tests/filtergraph.c | 43 ++++++++++++++++++++++++++++++---
 2 files changed, 65 insertions(+), 11 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 918c41a3d67..b1968069b86 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -588,6 +588,21 @@ static BOOL has_output_pins(IBaseFilter *filter)
     return FALSE;
 }
 
+static void update_seeking(struct filter *filter)
+{
+    if (!filter->seeking)
+    {
+        /* The Legend of Heroes: Trails of Cold Steel II destroys its filter when
+         * its IMediaSeeking interface is released, so cache the interface instead
+         * of querying for it every time.
+         * Some filters (e.g. MediaStreamFilter) can become seekable when they are
+         * already in the graph, so always try to query IMediaSeeking if it's not
+         * cached yet. */
+        if (FAILED(IBaseFilter_QueryInterface(filter->filter, &IID_IMediaSeeking, (void **)&filter->seeking)))
+            filter->seeking = NULL;
+    }
+}
+
 static BOOL is_renderer(struct filter *filter)
 {
     IAMFilterMiscFlags *flags;
@@ -599,8 +614,12 @@ static BOOL is_renderer(struct filter *filter)
             ret = TRUE;
         IAMFilterMiscFlags_Release(flags);
     }
-    else if (filter->seeking && !has_output_pins(filter->filter))
-        ret = TRUE;
+    else
+    {
+        update_seeking(filter);
+        if (filter->seeking && !has_output_pins(filter->filter))
+            ret = TRUE;
+    }
     return ret;
 }
 
@@ -666,15 +685,10 @@ static HRESULT WINAPI FilterGraph2_AddFilter(IFilterGraph2 *iface,
 
     IBaseFilter_AddRef(entry->filter = filter);
 
-    /* The Legend of Heroes: Trails of Cold Steel II destroys its filter when
-     * its IMediaSeeking interface is released, so cache the interface instead
-     * of querying for it every time. */
-    if (FAILED(IBaseFilter_QueryInterface(filter, &IID_IMediaSeeking, (void **)&entry->seeking)))
-        entry->seeking = NULL;
-
     list_add_head(&graph->filters, &entry->entry);
     list_add_head(&graph->sorted_filters, &entry->sorted_entry);
     entry->sorting = FALSE;
+    entry->seeking = NULL;
     ++graph->version;
 
     if (is_renderer(entry))
@@ -2252,6 +2266,7 @@ static HRESULT all_renderers_seek(IFilterGraphImpl *This, fnFoundSeek FoundSeek,
 
     LIST_FOR_EACH_ENTRY(filter, &This->filters, struct filter, entry)
     {
+        update_seeking(filter);
         if (!filter->seeking)
             continue;
         hr = FoundSeek(This, filter->seeking, arg);
@@ -2457,6 +2472,7 @@ static HRESULT WINAPI MediaSeeking_GetStopPosition(IMediaSeeking *iface, LONGLON
 
     LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
+        update_seeking(filter);
         if (!filter->seeking)
             continue;
 
@@ -2565,6 +2581,7 @@ static HRESULT WINAPI MediaSeeking_SetPositions(IMediaSeeking *iface, LONGLONG *
     {
         LONGLONG current = current_ptr ? *current_ptr : 0, stop = stop_ptr ? *stop_ptr : 0;
 
+        update_seeking(filter);
         if (!filter->seeking)
             continue;
 
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index a3378efe0be..d1c081681a3 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -3619,6 +3619,17 @@ static void test_ec_complete(void)
     ok(filter3.ref == 1, "Got outstanding refcount %d.\n", filter3.ref);
 }
 
+/* Remove and re-add the filter, to flush the graph's internal
+ * IMediaSeeking cache. Don't expose IMediaSeeking when adding, to show
+ * that it's only queried when needed. */
+static void flush_cached_seeking(IFilterGraph2 *graph, struct testfilter *filter)
+{
+    IFilterGraph2_RemoveFilter(graph, &filter->IBaseFilter_iface);
+    filter->IMediaSeeking_iface.lpVtbl = NULL;
+    IFilterGraph2_AddFilter(graph, &filter->IBaseFilter_iface, NULL);
+    filter->IMediaSeeking_iface.lpVtbl = &testseek_vtbl;
+}
+
 static void test_graph_seeking(void)
 {
     struct testfilter filter1, filter2;
@@ -3659,9 +3670,6 @@ static void test_graph_seeking(void)
     testfilter_init(&filter1, NULL, 0);
     testfilter_init(&filter2, NULL, 0);
 
-    filter1.IMediaSeeking_iface.lpVtbl = &testseek_vtbl;
-    filter2.IMediaSeeking_iface.lpVtbl = &testseek_vtbl;
-
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaSeeking, (void **)&seeking);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaFilter, (void **)&filter);
@@ -3824,6 +3832,8 @@ static void test_graph_seeking(void)
 
     IFilterGraph2_AddFilter(graph, &filter1.IBaseFilter_iface, NULL);
     IFilterGraph2_AddFilter(graph, &filter2.IBaseFilter_iface, NULL);
+    filter1.IMediaSeeking_iface.lpVtbl = &testseek_vtbl;
+    filter2.IMediaSeeking_iface.lpVtbl = &testseek_vtbl;
 
     filter1.seek_caps = AM_SEEKING_CanDoSegments | AM_SEEKING_CanGetCurrentPos;
     filter2.seek_caps = AM_SEEKING_CanDoSegments | AM_SEEKING_CanGetDuration;
@@ -3833,6 +3843,9 @@ static void test_graph_seeking(void)
     ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
     ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter2.seeking_ref);
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     caps = AM_SEEKING_CanDoSegments | AM_SEEKING_CanGetCurrentPos;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
     ok(hr == S_FALSE, "Got hr %#x.\n", hr);
@@ -3848,6 +3861,9 @@ static void test_graph_seeking(void)
     ok(hr == E_FAIL, "Got hr %#x.\n", hr);
     ok(!caps, "Got caps %#x.\n", caps);
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     hr = IMediaSeeking_IsFormatSupported(seeking, &testguid);
     ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
@@ -3905,6 +3921,9 @@ static void test_graph_seeking(void)
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &testguid, 0x123456789a, &TIME_FORMAT_NONE);
     todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     filter1.seek_duration = 0x12345;
     filter2.seek_duration = 0x23456;
     hr = IMediaSeeking_GetDuration(seeking, &time);
@@ -3917,6 +3936,9 @@ static void test_graph_seeking(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x23456, "Got time %s.\n", wine_dbgstr_longlong(time));
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     filter1.seek_stop = 0x54321;
     filter2.seek_stop = 0x65432;
     hr = IMediaSeeking_GetStopPosition(seeking, &time);
@@ -3948,16 +3970,25 @@ static void test_graph_seeking(void)
     ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     filter1.seek_hr = filter2.seek_hr = S_OK;
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!time, "Got time %s.\n", wine_dbgstr_longlong(time));
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     current = stop = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 0x65432, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     current = 0x123;
     stop = 0x321;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
@@ -4025,6 +4056,9 @@ static void test_graph_seeking(void)
     ok(filter2.seek_current == 0x123, "Got time %s.\n", wine_dbgstr_longlong(filter2.seek_current));
     ok(filter2.seek_stop == 0x321, "Got time %s.\n", wine_dbgstr_longlong(filter2.seek_stop));
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     hr = IMediaSeeking_SetRate(seeking, 2.0);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(filter1.seek_rate == 2.0, "Got rate %.16e.\n", filter1.seek_rate);
@@ -4040,6 +4074,9 @@ static void test_graph_seeking(void)
     todo_wine ok(filter1.seek_rate == -1.0, "Got rate %.16e.\n", filter1.seek_rate);
     todo_wine ok(filter2.seek_rate == -1.0, "Got rate %.16e.\n", filter2.seek_rate);
 
+    flush_cached_seeking(graph, &filter1);
+    flush_cached_seeking(graph, &filter2);
+
     hr = IMediaSeeking_GetRate(seeking, &rate);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(rate == -1.0, "Got rate %.16e.\n", rate);
From e92c851d95497fbb36000be17f78b70ee3b2bf09 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 10 Jun 2020 23:09:07 +0700
Subject: [PATCH] quartz/filtergraph: Count renderers in IMediaControl::Pause
 and ::Run.

Some filters (e.g. MediaStreamFilter) can become renderers when they are already in the graph.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 23 +++++++++++++++++------
 dlls/quartz/tests/filtergraph.c | 11 +++++++----
 2 files changed, 24 insertions(+), 10 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index b1968069b86..0d0ccc2b624 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -691,9 +691,6 @@ static HRESULT WINAPI FilterGraph2_AddFilter(IFilterGraph2 *iface,
     entry->seeking = NULL;
     ++graph->version;
 
-    if (is_renderer(entry))
-        ++graph->nRenderers;
-
     return duplicate_name ? VFW_S_DUPLICATE_NAME : hr;
 }
 
@@ -766,9 +763,6 @@ static HRESULT WINAPI FilterGraph2_RemoveFilter(IFilterGraph2 *iface, IBaseFilte
             hr = IBaseFilter_JoinFilterGraph(pFilter, NULL, NULL);
             if (SUCCEEDED(hr))
             {
-                if (is_renderer(entry))
-                    --This->nRenderers;
-
                 IBaseFilter_SetSyncSource(pFilter, NULL);
                 IBaseFilter_Release(pFilter);
                 if (entry->seeking)
@@ -5171,6 +5165,19 @@ static HRESULT WINAPI MediaFilter_Stop(IMediaFilter *iface)
     return hr;
 }
 
+static void update_render_count(IFilterGraphImpl *graph)
+{
+    /* Some filters (e.g. MediaStreamFilter) can become renderers when they are
+     * already in the graph. */
+    struct filter *filter;
+    graph->nRenderers = 0;
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
+    {
+        if (is_renderer(filter))
+            ++graph->nRenderers;
+    }
+}
+
 static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
 {
     IFilterGraphImpl *graph = impl_from_IMediaFilter(iface);
@@ -5187,6 +5194,8 @@ static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
         return S_OK;
     }
 
+    update_render_count(graph);
+
     if (graph->defaultclock && !graph->refClock)
         IFilterGraph2_SetDefaultSyncSource(&graph->IFilterGraph2_iface);
 
@@ -5229,6 +5238,8 @@ static HRESULT WINAPI MediaFilter_Run(IMediaFilter *iface, REFERENCE_TIME start)
     }
     graph->EcCompleteCount = 0;
 
+    update_render_count(graph);
+
     if (graph->defaultclock && !graph->refClock)
         IFilterGraph2_SetDefaultSyncSource(&graph->IFilterGraph2_iface);
 
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index d1c081681a3..50c2402c326 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -3463,10 +3463,6 @@ static void test_ec_complete(void)
     testsource_init(&source_pins[2], NULL, 0);
     testfilter_init(&source, source_pins, 3);
 
-    filter1.IAMFilterMiscFlags_iface.lpVtbl = &testmiscflags_vtbl;
-    filter2.IAMFilterMiscFlags_iface.lpVtbl = &testmiscflags_vtbl;
-    filter1.misc_flags = filter2.misc_flags = AM_FILTER_MISC_FLAGS_IS_RENDERER;
-
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaEvent, (void **)&eventsrc);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaEventSink, (void **)&eventsink);
@@ -3481,8 +3477,15 @@ static void test_ec_complete(void)
 
     /* EC_COMPLETE is only delivered to the user after all renderers deliver it. */
 
+    filter1.IAMFilterMiscFlags_iface.lpVtbl = &testmiscflags_vtbl;
+    filter2.IAMFilterMiscFlags_iface.lpVtbl = &testmiscflags_vtbl;
+    filter3.IAMFilterMiscFlags_iface.lpVtbl = &testmiscflags_vtbl;
+    filter1.misc_flags = filter2.misc_flags = AM_FILTER_MISC_FLAGS_IS_RENDERER;
+
     IMediaControl_Run(control);
 
+    filter3.misc_flags = AM_FILTER_MISC_FLAGS_IS_RENDERER;
+
     while ((hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 0)) == S_OK)
     {
         ok(code != EC_COMPLETE, "Got unexpected EC_COMPLETE.\n");
From ff38669c1adb127aebfe2dea640d720790cd2436 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Fri, 12 Jun 2020 14:57:09 +0700
Subject: [PATCH] quartz/filtergraph: Always sort filter list before use.

Some applications (e.g. Earth 2150) call IPin::Connect directly
instead of IFilterGraph::ConnectDirect.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 48 +++++++++++++--------------------
 dlls/quartz/tests/filtergraph.c | 11 +++++---
 2 files changed, 27 insertions(+), 32 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 0d0ccc2b624..fa20d98981b 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -151,7 +151,7 @@ typedef struct _ITF_CACHE_ENTRY {
 
 struct filter
 {
-    struct list entry, sorted_entry;
+    struct list entry;
     IBaseFilter *filter;
     IMediaSeeking *seeking;
     WCHAR *name;
@@ -187,17 +187,7 @@ typedef struct _IFilterGraphImpl {
     LONG ref;
     IUnknown *punkFilterMapper2;
 
-    /* We keep two lists of filters, one unsorted and one topologically sorted.
-     * The former is necessary for functions like IGraphBuilder::Connect() and
-     * IGraphBuilder::Render() that iterate through the filter list but may
-     * add to it while doing so; the latter is for functions like
-     * IMediaControl::Run() that should propagate messages to all filters
-     * (including unconnected ones) but must do so in topological order from
-     * sinks to sources. We can easily guarantee that the loop in Connect() will
-     * touch each filter exactly once so long as we aren't reordering it, but
-     * using the sorted filters list there would be hard. This seems to be the
-     * easiest and clearest solution. */
-    struct list filters, sorted_filters;
+    struct list filters;
     unsigned int name_index;
 
     IReferenceClock *refClock;
@@ -686,7 +676,6 @@ static HRESULT WINAPI FilterGraph2_AddFilter(IFilterGraph2 *iface,
     IBaseFilter_AddRef(entry->filter = filter);
 
     list_add_head(&graph->filters, &entry->entry);
-    list_add_head(&graph->sorted_filters, &entry->sorted_entry);
     entry->sorting = FALSE;
     entry->seeking = NULL;
     ++graph->version;
@@ -768,7 +757,6 @@ static HRESULT WINAPI FilterGraph2_RemoveFilter(IFilterGraph2 *iface, IBaseFilte
                 if (entry->seeking)
                     IMediaSeeking_Release(entry->seeking);
                 list_remove(&entry->entry);
-                list_remove(&entry->sorted_entry);
                 CoTaskMemFree(entry->name);
                 heap_free(entry);
                 This->version++;
@@ -897,7 +885,7 @@ static struct filter *find_sorted_filter(IFilterGraphImpl *graph, IBaseFilter *i
 {
     struct filter *filter;
 
-    LIST_FOR_EACH_ENTRY(filter, &graph->sorted_filters, struct filter, sorted_entry)
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         if (filter->filter == iface)
             return filter;
@@ -941,21 +929,21 @@ static void sort_filter_recurse(IFilterGraphImpl *graph, struct filter *filter,
 
     filter->sorting = FALSE;
 
-    list_remove(&filter->sorted_entry);
-    list_add_head(sorted, &filter->sorted_entry);
+    list_remove(&filter->entry);
+    list_add_head(sorted, &filter->entry);
 }
 
 static void sort_filters(IFilterGraphImpl *graph)
 {
     struct list sorted = LIST_INIT(sorted), *cursor;
 
-    while ((cursor = list_head(&graph->sorted_filters)))
+    while ((cursor = list_head(&graph->filters)))
     {
-        struct filter *filter = LIST_ENTRY(cursor, struct filter, sorted_entry);
+        struct filter *filter = LIST_ENTRY(cursor, struct filter, entry);
         sort_filter_recurse(graph, filter, &sorted);
     }
 
-    list_move_tail(&graph->sorted_filters, &sorted);
+    list_move_tail(&graph->filters, &sorted);
 }
 
 /* NOTE: despite the implication, it doesn't matter which
@@ -1008,9 +996,6 @@ static HRESULT WINAPI FilterGraph2_ConnectDirect(IFilterGraph2 *iface, IPin *ppi
         }
     }
 
-    if (SUCCEEDED(hr))
-        sort_filters(This);
-
     return hr;
 }
 
@@ -5138,9 +5123,11 @@ static HRESULT WINAPI MediaFilter_Stop(IMediaFilter *iface)
         return S_OK;
     }
 
+    sort_filters(graph);
+
     if (graph->state == State_Running)
     {
-        LIST_FOR_EACH_ENTRY(filter, &graph->sorted_filters, struct filter, sorted_entry)
+        LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
         {
             filter_hr = IBaseFilter_Pause(filter->filter);
             if (hr == S_OK)
@@ -5148,7 +5135,7 @@ static HRESULT WINAPI MediaFilter_Stop(IMediaFilter *iface)
         }
     }
 
-    LIST_FOR_EACH_ENTRY(filter, &graph->sorted_filters, struct filter, sorted_entry)
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         filter_hr = IBaseFilter_Stop(filter->filter);
         if (hr == S_OK)
@@ -5194,6 +5181,7 @@ static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
         return S_OK;
     }
 
+    sort_filters(graph);
     update_render_count(graph);
 
     if (graph->defaultclock && !graph->refClock)
@@ -5207,7 +5195,7 @@ static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
         graph->current_pos += graph->stream_elapsed;
     }
 
-    LIST_FOR_EACH_ENTRY(filter, &graph->sorted_filters, struct filter, sorted_entry)
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         filter_hr = IBaseFilter_Pause(filter->filter);
         if (hr == S_OK)
@@ -5238,6 +5226,7 @@ static HRESULT WINAPI MediaFilter_Run(IMediaFilter *iface, REFERENCE_TIME start)
     }
     graph->EcCompleteCount = 0;
 
+    sort_filters(graph);
     update_render_count(graph);
 
     if (graph->defaultclock && !graph->refClock)
@@ -5251,7 +5240,7 @@ static HRESULT WINAPI MediaFilter_Run(IMediaFilter *iface, REFERENCE_TIME start)
             stream_start += 500000;
     }
 
-    LIST_FOR_EACH_ENTRY(filter, &graph->sorted_filters, struct filter, sorted_entry)
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         filter_hr = IBaseFilter_Run(filter->filter, stream_start);
         if (hr == S_OK)
@@ -5278,9 +5267,11 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
 
     EnterCriticalSection(&graph->cs);
 
+    sort_filters(graph);
+
     *state = graph->state;
 
-    LIST_FOR_EACH_ENTRY(filter, &graph->sorted_filters, struct filter, sorted_entry)
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         FILTER_STATE filter_state;
         int wait;
@@ -5753,7 +5744,6 @@ static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL
     fimpl->IVideoFrameStep_iface.lpVtbl = &VideoFrameStep_vtbl;
     fimpl->ref = 1;
     list_init(&fimpl->filters);
-    list_init(&fimpl->sorted_filters);
     fimpl->name_index = 1;
     fimpl->refClock = NULL;
     fimpl->hEventCompletion = CreateEventW(0, TRUE, FALSE, 0);
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 50c2402c326..4f4abeac9b9 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -3166,7 +3166,9 @@ static void test_filter_state(void)
     IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
     IFilterGraph2_AddFilter(graph, &sink.IBaseFilter_iface, NULL);
     IFilterGraph2_AddFilter(graph, &dummy.IBaseFilter_iface, NULL);
-    IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, NULL);
+    /* Using IPin::Connect instead of IFilterGraph2::ConnectDirect to show that */
+    /* FilterGraph does not rely on ::ConnectDirect to track filter connections. */
+    IPin_Connect(&source_pin.IPin_iface, &sink_pin.IPin_iface, NULL);
 
     check_filter_state(graph, State_Stopped);
 
@@ -3241,9 +3243,12 @@ static void test_filter_state(void)
     IFilterGraph2_QueryInterface(graph, &IID_IMediaFilter, (void **)&filter);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
 
-    IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
+    /* Add the filters in reverse order this time. */
     IFilterGraph2_AddFilter(graph, &sink.IBaseFilter_iface, NULL);
-    IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, NULL);
+    IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
+    /* Using IPin::Connect instead of IFilterGraph2::ConnectDirect to show that */
+    /* FilterGraph does not rely on ::ConnectDirect to track filter connections. */
+    IPin_Connect(&source_pin.IPin_iface, &sink_pin.IPin_iface, NULL);
 
     hr = IMediaFilter_Pause(filter);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
From 8dcd253e06b0e4ae4a6611c6f5e89e9ad00678cd Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 12 Jun 2020 16:28:26 -0500
Subject: [PATCH] quartz/vmr9: Trace the arguments to
 IVMRWindowlessControl9::SetVideoPosition().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 19 ++++++++++---------
 1 file changed, 10 insertions(+), 9 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 4ea3b483a75..776d927f2ab 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -1679,20 +1679,21 @@ static HRESULT WINAPI VMR9WindowlessControl_GetMaxIdealVideoSize(IVMRWindowlessC
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI VMR9WindowlessControl_SetVideoPosition(IVMRWindowlessControl9 *iface, const RECT *source, const RECT *dest)
+static HRESULT WINAPI VMR9WindowlessControl_SetVideoPosition(IVMRWindowlessControl9 *iface,
+        const RECT *src, const RECT *dst)
 {
-    struct quartz_vmr *This = impl_from_IVMRWindowlessControl9(iface);
+    struct quartz_vmr *filter = impl_from_IVMRWindowlessControl9(iface);
 
-    TRACE("(%p/%p)->(%p, %p)\n", iface, This, source, dest);
+    TRACE("filter %p, src %s, dst %s.\n", filter, wine_dbgstr_rect(src), wine_dbgstr_rect(dst));
 
-    EnterCriticalSection(&This->renderer.filter.csFilter);
+    EnterCriticalSection(&filter->renderer.filter.csFilter);
 
-    if (source)
-        This->window.src = *source;
-    if (dest)
-        This->window.dst = *dest;
+    if (src)
+        filter->window.src = *src;
+    if (dst)
+        filter->window.dst = *dst;
 
-    LeaveCriticalSection(&This->renderer.filter.csFilter);
+    LeaveCriticalSection(&filter->renderer.filter.csFilter);
 
     return S_OK;
 }
From 408a3074c4297a0004b8aa485d4cb3e296d3fe04 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 12 Jun 2020 16:28:27 -0500
Subject: [PATCH] quartz/vmr9: Implement
 IVMRWindowlessControl9::SetAspectRatioMode().

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=35215
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr9.c | 37 +++++++++++++++++
 dlls/quartz/vmr9.c       | 87 +++++++++++++++++++++++++++-------------
 2 files changed, 96 insertions(+), 28 deletions(-)

diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 14b6539a6bd..a227a647f65 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -3770,6 +3770,7 @@ static void test_windowless_size(void)
     LONG width, height, aspect_width, aspect_height;
     IVMRWindowlessControl9 *windowless_control;
     IFilterGraph2 *graph = create_graph();
+    VMR9AspectRatioMode aspect_mode;
     struct testfilter source;
     IMemAllocator *allocator;
     RECT src, dst, expect;
@@ -3813,6 +3814,11 @@ static void test_windowless_size(void)
     hr = IVMRWindowlessControl9_GetNativeVideoSize(windowless_control, &width, NULL, &aspect_width, &aspect_height);
     ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
+    aspect_mode = 0xdeadbeef;
+    hr = IVMRWindowlessControl9_GetAspectRatioMode(windowless_control, &aspect_mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(aspect_mode == VMR9ARMode_None, "Got mode %u.\n", aspect_mode);
+
     width = height = 0xdeadbeef;
     hr = IVMRWindowlessControl9_GetNativeVideoSize(windowless_control, &width, &height, NULL, NULL);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -3867,6 +3873,37 @@ static void test_windowless_size(void)
     SetRect(&expect, 0, 0, 640, 480);
     ok(EqualRect(&src, &expect), "Got window rect %s.\n", wine_dbgstr_rect(&src));
 
+    hr = IVMRWindowlessControl9_SetAspectRatioMode(windowless_control, VMR9ARMode_LetterBox);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    aspect_mode = 0xdeadbeef;
+    hr = IVMRWindowlessControl9_GetAspectRatioMode(windowless_control, &aspect_mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(aspect_mode == VMR9ARMode_LetterBox, "Got mode %u.\n", aspect_mode);
+
+    memset(&src, 0xcc, sizeof(src));
+    memset(&dst, 0xcc, sizeof(dst));
+    hr = IVMRWindowlessControl9_GetVideoPosition(windowless_control, &src, &dst);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    SetRect(&expect, 4, 6, 16, 12);
+    ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
+    SetRect(&expect, 40, 60, 120, 160);
+    ok(EqualRect(&dst, &expect), "Got dest rect %s.\n", wine_dbgstr_rect(&dst));
+
+    SetRect(&src, 0, 0, 32, 16);
+    SetRect(&dst, 0, 0, 640, 480);
+    hr = IVMRWindowlessControl9_SetVideoPosition(windowless_control, &src, &dst);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    memset(&src, 0xcc, sizeof(src));
+    memset(&dst, 0xcc, sizeof(dst));
+    hr = IVMRWindowlessControl9_GetVideoPosition(windowless_control, &src, &dst);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    SetRect(&expect, 0, 0, 32, 16);
+    ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
+    SetRect(&expect, 0, 0, 640, 480);
+    ok(EqualRect(&dst, &expect), "Got dest rect %s.\n", wine_dbgstr_rect(&dst));
+
 out:
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 776d927f2ab..449943f2dc3 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -106,6 +106,7 @@ struct quartz_vmr
 
     LONG VideoWidth;
     LONG VideoHeight;
+    VMR9AspectRatioMode aspect_mode;
 
     HANDLE run_event;
 };
@@ -1715,18 +1716,26 @@ static HRESULT WINAPI VMR9WindowlessControl_GetVideoPosition(IVMRWindowlessContr
 
 static HRESULT WINAPI VMR9WindowlessControl_GetAspectRatioMode(IVMRWindowlessControl9 *iface, DWORD *mode)
 {
-    struct quartz_vmr *This = impl_from_IVMRWindowlessControl9(iface);
+    struct quartz_vmr *filter = impl_from_IVMRWindowlessControl9(iface);
 
-    FIXME("(%p/%p)->(...) stub\n", iface, This);
-    return E_NOTIMPL;
+    TRACE("filter %p, mode %p.\n", filter, mode);
+
+    EnterCriticalSection(&filter->renderer.filter.csFilter);
+    *mode = filter->aspect_mode;
+    LeaveCriticalSection(&filter->renderer.filter.csFilter);
+    return S_OK;
 }
 
 static HRESULT WINAPI VMR9WindowlessControl_SetAspectRatioMode(IVMRWindowlessControl9 *iface, DWORD mode)
 {
-    struct quartz_vmr *This = impl_from_IVMRWindowlessControl9(iface);
+    struct quartz_vmr *filter = impl_from_IVMRWindowlessControl9(iface);
 
-    FIXME("(%p/%p)->(...) stub\n", iface, This);
-    return E_NOTIMPL;
+    TRACE("filter %p, mode %u.\n", filter, mode);
+
+    EnterCriticalSection(&filter->renderer.filter.csFilter);
+    filter->aspect_mode = mode;
+    LeaveCriticalSection(&filter->renderer.filter.csFilter);
+    return S_OK;
 }
 
 static HRESULT WINAPI VMR9WindowlessControl_SetVideoClippingWindow(IVMRWindowlessControl9 *iface, HWND window)
@@ -2625,37 +2634,59 @@ static HRESULT VMR9_ImagePresenter_PresentOffscreenSurface(struct default_presen
 static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *iface,
         DWORD_PTR cookie, VMR9PresentationInfo *info)
 {
-    struct default_presenter *This = impl_from_IVMRImagePresenter9(iface);
+    struct default_presenter *presenter = impl_from_IVMRImagePresenter9(iface);
+    const struct quartz_vmr *filter = presenter->pVMR9;
+    IDirect3DDevice9 *device = presenter->d3d9_dev;
+    const RECT src = filter->window.src;
+    RECT dst = filter->window.dst;
     HRESULT hr;
-    BOOL render = FALSE;
 
-    TRACE("presenter %p, cookie %#Ix, info %p.\n", This, cookie, info);
+    TRACE("presenter %p, cookie %#Ix, info %p.\n", presenter, cookie, info);
 
     /* This might happen if we don't have active focus (eg on a different virtual desktop) */
-    if (!This->d3d9_dev)
+    if (!device)
         return S_OK;
 
-    /* Display image here */
-    hr = IDirect3DDevice9_Clear(This->d3d9_dev, 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0);
-    if (FAILED(hr))
-        FIXME("hr: %08x\n", hr);
-    hr = IDirect3DDevice9_BeginScene(This->d3d9_dev);
-    if (SUCCEEDED(hr))
-    {
-        hr = VMR9_ImagePresenter_PresentOffscreenSurface(This, info->lpSurf);
-        render = SUCCEEDED(hr);
-    }
-    else
-        FIXME("BeginScene: %08x\n", hr);
-    hr = IDirect3DDevice9_EndScene(This->d3d9_dev);
-    if (render && SUCCEEDED(hr))
+    if (FAILED(hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET,
+            D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0)))
+        ERR("Failed to clear, hr %#x.\n", hr);
+
+    if (FAILED(hr = IDirect3DDevice9_BeginScene(device)))
+        ERR("Failed to begin scene, hr %#x.\n", hr);
+
+    VMR9_ImagePresenter_PresentOffscreenSurface(presenter, info->lpSurf);
+
+    if (FAILED(hr = IDirect3DDevice9_EndScene(device)))
+        ERR("Failed to end scene, hr %#x.\n", hr);
+
+    if (filter->aspect_mode == VMR9ARMode_LetterBox)
     {
-        hr = IDirect3DDevice9_Present(This->d3d9_dev, &This->pVMR9->window.src,
-                &This->pVMR9->window.dst, NULL, NULL);
-        if (FAILED(hr))
-            FIXME("Presenting image: %08x\n", hr);
+        unsigned int src_width = src.right - src.left, src_height = src.bottom - src.top;
+        unsigned int dst_width = dst.right - dst.left, dst_height = dst.bottom - dst.top;
+
+        if (src_width * dst_height > dst_width * src_height)
+        {
+            /* src is "wider" than dst. */
+            unsigned int dst_center = (dst.top + dst.bottom) / 2;
+            unsigned int scaled_height = src_height * dst_width / src_width;
+
+            dst.top = dst_center - scaled_height / 2;
+            dst.bottom = dst.top + scaled_height;
+        }
+        else if (src_width * dst_height < dst_width * src_height)
+        {
+            /* src is "taller" than dst. */
+            unsigned int dst_center = (dst.left + dst.right) / 2;
+            unsigned int scaled_width = src_width * dst_height / src_height;
+
+            dst.left = dst_center - scaled_width / 2;
+            dst.right = dst.left + scaled_width;
+        }
     }
 
+    if (FAILED(hr = IDirect3DDevice9_Present(device, &src, &dst, NULL, NULL)))
+        ERR("Failed to present, hr %#x.\n", hr);
+
     return S_OK;
 }
 
From 5444ce2f0db7b3f7b4e1fdf3f7bb8d18b79f315b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 12 Jun 2020 16:28:28 -0500
Subject: [PATCH] quartz/vmr9: Get rid of
 VMR9_ImagePresenter_PresentOffscreenSurface().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 31 ++++++++++---------------------
 1 file changed, 10 insertions(+), 21 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 449943f2dc3..6b653e56092 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -2611,26 +2611,6 @@ static HRESULT WINAPI VMR9_ImagePresenter_StopPresenting(IVMRImagePresenter9 *if
     return S_OK;
 }
 
-static HRESULT VMR9_ImagePresenter_PresentOffscreenSurface(struct default_presenter *This, IDirect3DSurface9 *surface)
-{
-    HRESULT hr;
-    IDirect3DSurface9 *target = NULL;
-
-    hr = IDirect3DDevice9_GetBackBuffer(This->d3d9_dev, 0, 0, D3DBACKBUFFER_TYPE_MONO, &target);
-    if (FAILED(hr))
-    {
-        ERR("IDirect3DDevice9_GetBackBuffer -- %08x\n", hr);
-        return hr;
-    }
-
-    hr = IDirect3DDevice9_StretchRect(This->d3d9_dev, surface, NULL, target, NULL, D3DTEXF_POINT);
-    if (FAILED(hr))
-        ERR("IDirect3DDevice9_StretchRect -- %08x\n", hr);
-    IDirect3DSurface9_Release(target);
-
-    return hr;
-}
-
 static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *iface,
         DWORD_PTR cookie, VMR9PresentationInfo *info)
 {
@@ -2638,6 +2618,7 @@ static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *ifac
     const struct quartz_vmr *filter = presenter->pVMR9;
     IDirect3DDevice9 *device = presenter->d3d9_dev;
     const RECT src = filter->window.src;
+    IDirect3DSurface9 *backbuffer;
     RECT dst = filter->window.dst;
     HRESULT hr;
 
@@ -2654,7 +2635,15 @@ static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *ifac
     if (FAILED(hr = IDirect3DDevice9_BeginScene(device)))
         ERR("Failed to begin scene, hr %#x.\n", hr);
 
-    VMR9_ImagePresenter_PresentOffscreenSurface(presenter, info->lpSurf);
+    if (FAILED(hr = IDirect3DDevice9_GetBackBuffer(device, 0, 0, D3DBACKBUFFER_TYPE_MONO, &backbuffer)))
+    {
+        ERR("Failed to get backbuffer, hr %#x.\n", hr);
+        return hr;
+    }
+
+    if (FAILED(hr = IDirect3DDevice9_StretchRect(device, info->lpSurf, NULL, backbuffer, NULL, D3DTEXF_POINT)))
+        ERR("Failed to blit image, hr %#x.\n", hr);
+    IDirect3DSurface9_Release(backbuffer);
 
     if (FAILED(hr = IDirect3DDevice9_EndScene(device)))
         ERR("Failed to end scene, hr %#x.\n", hr);
From 5161554b9d4e8d999f21a420b4c56067e209d435 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 13 Jun 2020 13:55:38 -0500
Subject: [PATCH] quartz/tests: Relax some timings.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/videorenderer.c | 2 +-
 dlls/quartz/tests/vmr9.c          | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/quartz/tests/videorenderer.c b/dlls/quartz/tests/videorenderer.c
index d603ea46edd..ab2b4f9e0d4 100644
--- a/dlls/quartz/tests/videorenderer.c
+++ b/dlls/quartz/tests/videorenderer.c
@@ -1082,7 +1082,7 @@ static void test_sample_time(IBaseFilter *filter, IPin *pin, IMemInputPin *input
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame_time(input, 2, 0x66); /* orange */
-    ok(WaitForSingleObject(thread, 800) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
+    ok(WaitForSingleObject(thread, 500) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
     hr = join_thread(thread);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index a227a647f65..2641b7a04bb 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -1430,7 +1430,7 @@ static void test_sample_time(IPin *pin, IMemInputPin *input, IMediaControl *cont
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame_time(input, 2, 0x00ff00ff); /* magenta */
-    ok(WaitForSingleObject(thread, 800) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
+    ok(WaitForSingleObject(thread, 500) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
     hr = join_thread(thread);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
From cdab25b03a2e82d717c73f28e4e68e048472f2e3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 15 Jun 2020 22:51:23 -0500
Subject: [PATCH] quartz: Try to connect all source pins when autoplugging from
 the registry.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 41 +++++++++++++--------------------
 dlls/quartz/tests/filtergraph.c | 22 +++++++++---------
 2 files changed, 27 insertions(+), 36 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index fa20d98981b..cb212e4961b 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -1327,7 +1327,6 @@ static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *ppinOut,
     while (IEnumMoniker_Next(pEnumMoniker, 1, &pMoniker, NULL) == S_OK)
     {
         VARIANT var;
-        IPin* ppinfilter = NULL;
         IBaseFilter* pfilter = NULL;
         IAMGraphBuilderCallback *callback = NULL;
 
@@ -1390,35 +1389,27 @@ static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *ppinOut,
             goto error;
         }
 
-        hr = IEnumPins_Next(penumpins, 1, &ppinfilter, NULL);
-        IEnumPins_Release(penumpins);
-
-        if (FAILED(hr)) {
-            WARN("Obtaining next pin: (%x)\n", hr);
-            goto error;
-        }
-        if (hr == S_FALSE) {
-            WARN("Cannot use this filter: no pins\n");
-            goto error;
-        }
-
-        hr = IFilterGraph2_ConnectDirect(iface, ppinOut, ppinfilter, NULL);
-        if (FAILED(hr)) {
-            TRACE("Cannot connect to filter (%x), trying next one\n", hr);
-            goto error;
-        }
-        TRACE("Successfully connected to filter, follow chain...\n");
-
-        if (SUCCEEDED(hr = connect_output_pin(This, pfilter, ppinIn)))
+        while (IEnumPins_Next(penumpins, 1, &pin, NULL) == S_OK)
         {
-            IPin_Release(ppinfilter);
-            IBaseFilter_Release(pfilter);
-            break;
+            if (SUCCEEDED(IFilterGraph2_ConnectDirect(iface, ppinOut, pin, NULL)))
+            {
+                if (SUCCEEDED(hr = connect_output_pin(This, pfilter, ppinIn)))
+                {
+                    IPin_Release(pin);
+                    IEnumPins_Release(penumpins);
+                    IBaseFilter_Release(pfilter);
+                    IEnumMoniker_Release(pEnumMoniker);
+                    goto out;
+                }
+                IFilterGraph2_Disconnect(iface, pin);
+                IFilterGraph2_Disconnect(iface, ppinOut);
+            }
+            IPin_Release(pin);
         }
+        IEnumPins_Release(penumpins);
 
 error:
         VariantClear(&var);
-        if (ppinfilter) IPin_Release(ppinfilter);
         if (pfilter) {
             IFilterGraph2_RemoveFilter(iface, pfilter);
             IBaseFilter_Release(pfilter);
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 4f4abeac9b9..d062ea39c61 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -2136,9 +2136,9 @@ static void test_graph_builder_connect(void)
     testfilter_init(&parser1, parser1_pins, 3);
     parser1.pin_count = 2;
 
-    testsink_init(&parser2_pins[0]);
-    testsource_init(&parser2_pins[1], &sink_type, 1);
-    parser2_pins[1].request_mt = &sink_type;
+    testsource_init(&parser2_pins[0], &sink_type, 1);
+    testsink_init(&parser2_pins[1]);
+    parser2_pins[0].request_mt = &sink_type;
     testfilter_init(&parser2, parser2_pins, 2);
 
     testsink_init(&parser3_pins[0]);
@@ -2215,8 +2215,8 @@ static void test_graph_builder_connect(void)
     sink_pin.accept_mt = &sink_type;
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    ok(source_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
-    ok(sink_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
+    ok(source_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", source_pin.peer);
+    ok(sink_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", sink_pin.peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
     IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
     IFilterGraph2_Disconnect(graph, sink_pin.peer);
@@ -2227,8 +2227,8 @@ static void test_graph_builder_connect(void)
     {
         hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
         ok(hr == S_OK, "Got hr %#x for Connect() hr %#x.\n", hr, source_pin.Connect_hr);
-        ok(source_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
-        ok(sink_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
+        ok(source_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", source_pin.peer);
+        ok(sink_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", sink_pin.peer);
         IFilterGraph2_Disconnect(graph, source_pin.peer);
         IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
         IFilterGraph2_Disconnect(graph, sink_pin.peer);
@@ -2379,9 +2379,9 @@ todo_wine
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser1_pins[0].IPin_iface
-            || source_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
+            || source_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser1_pins[1].IPin_iface
-            || sink_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
+            || sink_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", sink_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
@@ -2417,8 +2417,8 @@ todo_wine
 
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    ok(source_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
-    ok(sink_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
+    ok(source_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", source_pin.peer);
+    ok(sink_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", sink_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
From 2ddc3e475858f8b91a4e3bdc083660e76fc08bce Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 15 Jun 2020 22:51:24 -0500
Subject: [PATCH] quartz/tests: Test autoplugging order.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/filtergraph.c | 34 +++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index d062ea39c61..22ed37cd307 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -800,6 +800,7 @@ struct testpin
     const AM_MEDIA_TYPE *types;
     unsigned int type_count, enum_idx;
     AM_MEDIA_TYPE *request_mt, *accept_mt;
+    const struct testpin *require_connected_pin;
 
     HRESULT Connect_hr;
     HRESULT EnumMediaTypes_hr;
@@ -1059,6 +1060,9 @@ static HRESULT WINAPI testsink_ReceiveConnection(IPin *iface, IPin *peer, const
     if (pin->accept_mt && memcmp(pin->accept_mt, mt, sizeof(*mt)))
         return VFW_E_TYPE_NOT_ACCEPTED;
 
+    if (pin->require_connected_pin && !pin->require_connected_pin->peer)
+        return VFW_E_TYPE_NOT_ACCEPTED;
+
     pin->peer = peer;
     IPin_AddRef(peer);
     return S_OK;
@@ -1112,6 +1116,9 @@ static HRESULT WINAPI testsource_Connect(IPin *iface, IPin *peer, const AM_MEDIA
     if (FAILED(pin->Connect_hr))
         return pin->Connect_hr;
 
+    if (pin->require_connected_pin && !pin->require_connected_pin->peer)
+        return VFW_E_NO_ACCEPTABLE_TYPES;
+
     ok(!mt, "Got media type %p.\n", mt);
 
     if (SUCCEEDED(hr = IPin_ReceiveConnection(peer, &pin->IPin_iface, pin->request_mt)))
@@ -2338,6 +2345,33 @@ todo_wine
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 
+    /* The graph connects from source to sink, not from sink to source. */
+
+    graph = create_graph();
+    IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, L"source");
+    IFilterGraph2_AddFilter(graph, &parser1.IBaseFilter_iface, L"parser");
+    IFilterGraph2_AddFilter(graph, &sink.IBaseFilter_iface, L"sink");
+
+    parser1_pins[0].require_connected_pin = &parser1_pins[1];
+
+    hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
+    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x.\n", hr);
+    ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
+    ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
+
+    parser1_pins[0].require_connected_pin = NULL;
+    parser1_pins[1].require_connected_pin = &parser1_pins[0];
+
+    hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(source_pin.peer == &parser1_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
+    ok(sink_pin.peer == &parser1_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
+
+    parser1_pins[1].require_connected_pin = NULL;
+
+    ref = IFilterGraph2_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
     /* Test enumeration of filters from the registry. */
 
     graph = create_graph();
From c603a5bfbca40f42169aa3b299e81de519781640 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 15 Jun 2020 22:51:25 -0500
Subject: [PATCH] quartz: Combine IGraphBuilder::Render() and
 IGraphBuilder::Connect() into a single helper.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 750 +++++++++-----------------------
 dlls/quartz/tests/filtergraph.c |  11 +-
 2 files changed, 205 insertions(+), 556 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index cb212e4961b..e3faf64fb82 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -207,7 +207,6 @@ typedef struct _IFilterGraphImpl {
     int nItfCacheEntries;
     BOOL defaultclock;
     GUID timeformatseek;
-    LONG recursioncount;
     IUnknown *pSite;
     LONG version;
 
@@ -1059,27 +1058,6 @@ static HRESULT WINAPI FilterGraph2_SetDefaultSyncSource(IFilterGraph2 *iface)
     return hr;
 }
 
-static HRESULT GetFilterInfo(IMoniker* pMoniker, VARIANT* pvar)
-{
-    IPropertyBag * pPropBagCat = NULL;
-    HRESULT hr;
-
-    VariantInit(pvar);
-
-    hr = IMoniker_BindToStorage(pMoniker, NULL, NULL, &IID_IPropertyBag, (LPVOID*)&pPropBagCat);
-
-    if (SUCCEEDED(hr))
-        hr = IPropertyBag_Read(pPropBagCat, L"FriendlyName", pvar, NULL);
-
-    if (SUCCEEDED(hr))
-        TRACE("Moniker = %s\n", debugstr_w(V_BSTR(pvar)));
-
-    if (pPropBagCat)
-        IPropertyBag_Release(pPropBagCat);
-
-    return hr;
-}
-
 struct filter_create_params
 {
     HRESULT hr;
@@ -1141,621 +1119,292 @@ static HRESULT create_filter(IFilterGraphImpl *graph, IMoniker *moniker, IBaseFi
         return IMoniker_BindToObject(moniker, NULL, NULL, &IID_IBaseFilter, (void **)filter);
 }
 
-/* Attempt to connect one of the output pins on filter to sink. Helper for
- * FilterGraph2_Connect(). */
-static HRESULT connect_output_pin(IFilterGraphImpl *graph, IBaseFilter *filter, IPin *sink)
-{
-    IEnumPins *enumpins;
-    PIN_INFO info;
-    HRESULT hr;
-    IPin *pin;
-
-    hr = IBaseFilter_EnumPins(filter, &enumpins);
-    if (FAILED(hr))
-        return hr;
-
-    while (IEnumPins_Next(enumpins, 1, &pin, NULL) == S_OK)
-    {
-        IPin_QueryPinInfo(pin, &info);
-        IBaseFilter_Release(info.pFilter);
-        if (info.dir == PINDIR_OUTPUT)
-        {
-            if (info.achName[0] == '~')
-            {
-                TRACE("Skipping non-rendered pin %s.\n", debugstr_w(info.achName));
-                IPin_Release(pin);
-                continue;
-            }
-
-            if (SUCCEEDED(IFilterGraph2_Connect(&graph->IFilterGraph2_iface, pin, sink)))
-            {
-                IPin_Release(pin);
-                IEnumPins_Release(enumpins);
-                return S_OK;
-            }
-        }
-        IPin_Release(pin);
-    }
-
-    IEnumPins_Release(enumpins);
-    return VFW_E_CANNOT_CONNECT;
-}
+static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink, unsigned int recursion_depth);
 
-/*** IGraphBuilder methods ***/
-static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *ppinOut, IPin *ppinIn)
+static HRESULT autoplug_through_sink(IFilterGraphImpl *graph, IPin *source,
+        IBaseFilter *filter, IPin *middle_sink, IPin *sink, unsigned int recursion_depth)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
-    struct filter *filter;
-    HRESULT hr;
-    IPin *pin;
-    AM_MEDIA_TYPE* mt = NULL;
-    IEnumMediaTypes* penummt = NULL;
-    ULONG nbmt;
-    IEnumPins* penumpins;
-    IEnumMoniker* pEnumMoniker;
-    GUID tab[2];
-    IMoniker* pMoniker;
-    PIN_INFO PinInfo;
+    BOOL any = FALSE, all = TRUE;
+    IPin *middle_source, *peer;
+    IEnumPins *source_enum;
     PIN_DIRECTION dir;
-    IFilterMapper2 *pFilterMapper2 = NULL;
-
-    TRACE("(%p/%p)->(%p, %p)\n", This, iface, ppinOut, ppinIn);
-
-    if(!ppinOut || !ppinIn)
-        return E_POINTER;
-
-    if (TRACE_ON(quartz))
-    {
-        hr = IPin_QueryPinInfo(ppinIn, &PinInfo);
-        if (FAILED(hr))
-            return hr;
-
-        TRACE("Filter owning ppinIn(%p) => %p\n", ppinIn, PinInfo.pFilter);
-        IBaseFilter_Release(PinInfo.pFilter);
-
-        hr = IPin_QueryPinInfo(ppinOut, &PinInfo);
-        if (FAILED(hr))
-            return hr;
+    PIN_INFO info;
+    HRESULT hr;
 
-        TRACE("Filter owning ppinOut(%p) => %p\n", ppinOut, PinInfo.pFilter);
-        IBaseFilter_Release(PinInfo.pFilter);
-    }
+    TRACE("Trying to autoplug %p to %p through %p.\n", source, sink, middle_sink);
 
-    EnterCriticalSection(&This->cs);
-    ++This->recursioncount;
-    if (This->recursioncount >= 5)
-    {
-        WARN("Recursion count has reached %d\n", This->recursioncount);
-        hr = VFW_E_CANNOT_CONNECT;
-        goto out;
-    }
-
-    hr = IPin_QueryDirection(ppinOut, &dir);
-    if (FAILED(hr))
-        goto out;
+    IPin_QueryDirection(middle_sink, &dir);
+    if (dir != PINDIR_INPUT)
+        return E_FAIL;
 
-    if (dir == PINDIR_INPUT)
+    if (IPin_ConnectedTo(middle_sink, &peer) == S_OK)
     {
-        IPin *temp;
-
-        TRACE("Directions seem backwards, swapping pins\n");
-
-        temp = ppinIn;
-        ppinIn = ppinOut;
-        ppinOut = temp;
+        IPin_Release(peer);
+        return E_FAIL;
     }
 
-    /* Try direct connection first */
-    hr = IFilterGraph2_ConnectDirect(iface, ppinOut, ppinIn, NULL);
-
-    /* If direct connection succeeded, we should propagate that return value.
-     * If it returned VFW_E_NOT_CONNECTED or VFW_E_NO_AUDIO_HARDWARE, then don't
-     * even bother trying intermediate filters, since they won't succeed. */
-    if (SUCCEEDED(hr) || hr == VFW_E_NOT_CONNECTED || hr == VFW_E_NO_AUDIO_HARDWARE)
-        goto out;
+    if (FAILED(hr = IFilterGraph2_ConnectDirect(&graph->IFilterGraph2_iface, source, middle_sink, NULL)))
+        return E_FAIL;
 
-    TRACE("Direct connection failed, trying to render using extra filters\n");
+    if (FAILED(hr = IBaseFilter_EnumPins(filter, &source_enum)))
+        goto err;
 
-    LIST_FOR_EACH_ENTRY(filter, &This->filters, struct filter, entry)
+    while (IEnumPins_Next(source_enum, 1, &middle_source, NULL) == S_OK)
     {
-        hr = IBaseFilter_EnumPins(filter->filter, &penumpins);
-        if (FAILED(hr))
-            goto out;
-
-        while (IEnumPins_Next(penumpins, 1, &pin, NULL) == S_OK)
+        IPin_QueryPinInfo(middle_source, &info);
+        IBaseFilter_Release(info.pFilter);
+        if (info.dir != PINDIR_OUTPUT)
         {
-            IPin_QueryDirection(pin, &dir);
-            if (dir == PINDIR_INPUT && SUCCEEDED(IFilterGraph2_ConnectDirect(iface,
-                    ppinOut, pin, NULL)))
-            {
-                if (SUCCEEDED(hr = connect_output_pin(This, filter->filter, ppinIn)))
-                {
-                    IPin_Release(pin);
-                    IEnumPins_Release(penumpins);
-                    goto out;
-                }
-
-                IFilterGraph2_Disconnect(iface, pin);
-                IFilterGraph2_Disconnect(iface, ppinOut);
-            }
-            IPin_Release(pin);
-        }
-
-        IEnumPins_Release(penumpins);
-    }
-
-    /* Find the appropriate transform filter than can transform the minor media type of output pin of the upstream 
-     * filter to the minor mediatype of input pin of the renderer */
-    hr = IPin_EnumMediaTypes(ppinOut, &penummt);
-    if (FAILED(hr))
-    {
-        WARN("EnumMediaTypes (%x)\n", hr);
-        goto out;
-    }
-
-    hr = IEnumMediaTypes_Next(penummt, 1, &mt, &nbmt);
-    if (FAILED(hr)) {
-        WARN("IEnumMediaTypes_Next (%x)\n", hr);
-        goto out;
-    }
-
-    if (!nbmt)
-    {
-        WARN("No media type found!\n");
-        hr = VFW_E_INVALIDMEDIATYPE;
-        goto out;
-    }
-    TRACE("MajorType %s\n", debugstr_guid(&mt->majortype));
-    TRACE("SubType %s\n", debugstr_guid(&mt->subtype));
-
-    hr = IUnknown_QueryInterface(This->punkFilterMapper2, &IID_IFilterMapper2, (void**)&pFilterMapper2);
-    if (FAILED(hr)) {
-        WARN("Unable to get IFilterMapper2 (%x)\n", hr);
-        goto out;
-    }
-
-    /* Try to find a suitable filter that can connect to the pin to render */
-    tab[0] = mt->majortype;
-    tab[1] = mt->subtype;
-    hr = IFilterMapper2_EnumMatchingFilters(pFilterMapper2, &pEnumMoniker, 0, FALSE, MERIT_UNLIKELY, TRUE, 1, tab, NULL, NULL, FALSE, FALSE, 0, NULL, NULL, NULL);
-    if (FAILED(hr)) {
-        WARN("Unable to enum filters (%x)\n", hr);
-        goto out;
-    }
-
-    hr = VFW_E_CANNOT_RENDER;
-    while (IEnumMoniker_Next(pEnumMoniker, 1, &pMoniker, NULL) == S_OK)
-    {
-        VARIANT var;
-        IBaseFilter* pfilter = NULL;
-        IAMGraphBuilderCallback *callback = NULL;
-
-        hr = GetFilterInfo(pMoniker, &var);
-        if (FAILED(hr)) {
-            WARN("Unable to retrieve filter info (%x)\n", hr);
-            goto error;
-        }
-
-        hr = create_filter(This, pMoniker, &pfilter);
-        IMoniker_Release(pMoniker);
-        if (FAILED(hr)) {
-            WARN("Unable to create filter (%x), trying next one\n", hr);
-            goto error;
+            IPin_Release(middle_source);
+            continue;
         }
-
-        if (This->pSite)
+        if (info.achName[0] == '~')
         {
-            IUnknown_QueryInterface(This->pSite, &IID_IAMGraphBuilderCallback, (LPVOID*)&callback);
-            if (callback)
-            {
-                HRESULT rc;
-                rc = IAMGraphBuilderCallback_SelectedFilter(callback, pMoniker);
-                if (FAILED(rc))
-                {
-                    TRACE("Filter rejected by IAMGraphBuilderCallback_SelectedFilter\n");
-                    IAMGraphBuilderCallback_Release(callback);
-                    goto error;
-                }
-            }
+            TRACE("Skipping non-rendered pin %s.\n", debugstr_w(info.achName));
+            IPin_Release(middle_source);
+            continue;
         }
-
-        if (callback)
+        if (IPin_ConnectedTo(middle_source, &peer) == S_OK)
         {
-            HRESULT rc;
-            rc = IAMGraphBuilderCallback_CreatedFilter(callback, pfilter);
-            IAMGraphBuilderCallback_Release(callback);
-            if (FAILED(rc))
-            {
-                IBaseFilter_Release(pfilter);
-                pfilter = NULL;
-                TRACE("Filter rejected by IAMGraphBuilderCallback_CreatedFilter\n");
-                goto error;
-            }
-        }
-
-        hr = IFilterGraph2_AddFilter(iface, pfilter, V_BSTR(&var));
-        if (FAILED(hr)) {
-            WARN("Unable to add filter (%x)\n", hr);
-            IBaseFilter_Release(pfilter);
-            pfilter = NULL;
-            goto error;
-        }
-
-        VariantClear(&var);
-
-        hr = IBaseFilter_EnumPins(pfilter, &penumpins);
-        if (FAILED(hr)) {
-            WARN("Enumpins (%x)\n", hr);
-            goto error;
+            IPin_Release(peer);
+            IPin_Release(middle_source);
+            continue;
         }
 
-        while (IEnumPins_Next(penumpins, 1, &pin, NULL) == S_OK)
+        hr = autoplug(graph, middle_source, sink, recursion_depth + 1);
+        IPin_Release(middle_source);
+        if (SUCCEEDED(hr) && sink)
         {
-            if (SUCCEEDED(IFilterGraph2_ConnectDirect(iface, ppinOut, pin, NULL)))
-            {
-                if (SUCCEEDED(hr = connect_output_pin(This, pfilter, ppinIn)))
-                {
-                    IPin_Release(pin);
-                    IEnumPins_Release(penumpins);
-                    IBaseFilter_Release(pfilter);
-                    IEnumMoniker_Release(pEnumMoniker);
-                    goto out;
-                }
-                IFilterGraph2_Disconnect(iface, pin);
-                IFilterGraph2_Disconnect(iface, ppinOut);
-            }
-            IPin_Release(pin);
-        }
-        IEnumPins_Release(penumpins);
-
-error:
-        VariantClear(&var);
-        if (pfilter) {
-            IFilterGraph2_RemoveFilter(iface, pfilter);
-            IBaseFilter_Release(pfilter);
+            IEnumPins_Release(source_enum);
+            return hr;
         }
+        if (SUCCEEDED(hr))
+            any = TRUE;
+        if (hr != S_OK)
+            all = FALSE;
     }
+    IEnumPins_Release(source_enum);
 
-    if (FAILED(hr))
-        hr = VFW_E_CANNOT_CONNECT;
-
-    IEnumMoniker_Release(pEnumMoniker);
+    if (!sink)
+    {
+        if (all)
+            return S_OK;
+        if (any)
+            return VFW_S_PARTIAL_RENDER;
+    }
 
-out:
-    if (pFilterMapper2)
-        IFilterMapper2_Release(pFilterMapper2);
-    if (penummt)
-        IEnumMediaTypes_Release(penummt);
-    if (mt)
-        DeleteMediaType(mt);
-    --This->recursioncount;
-    LeaveCriticalSection(&This->cs);
-    TRACE("--> %08x\n", hr);
-    return hr;
+err:
+    IFilterGraph2_Disconnect(&graph->IFilterGraph2_iface, source);
+    IFilterGraph2_Disconnect(&graph->IFilterGraph2_iface, middle_sink);
+    return E_FAIL;
 }
 
-/* Render all output pins of the given filter. Helper for FilterGraph2_Render(). */
-static HRESULT render_output_pins(IFilterGraphImpl *graph, IBaseFilter *filter)
+static HRESULT autoplug_through_filter(IFilterGraphImpl *graph, IPin *source,
+        IBaseFilter *filter, IPin *sink, unsigned int recursion_depth)
 {
-    BOOL renderany = FALSE;
-    BOOL renderall = TRUE;
-    IEnumPins *enumpins;
-    IPin *pin, *peer;
-    PIN_INFO info;
+    IEnumPins *sink_enum;
+    IPin *filter_sink;
+    HRESULT hr;
 
-    IBaseFilter_EnumPins(filter, &enumpins);
-    while (IEnumPins_Next(enumpins, 1, &pin, NULL) == S_OK)
+    TRACE("Trying to autoplug %p to %p through %p.\n", source, sink, filter);
+
+    if (FAILED(hr = IBaseFilter_EnumPins(filter, &sink_enum)))
+        return hr;
+
+    while (IEnumPins_Next(sink_enum, 1, &filter_sink, NULL) == S_OK)
     {
-        IPin_QueryPinInfo(pin, &info);
-        IBaseFilter_Release(info.pFilter);
-        if (info.dir == PINDIR_OUTPUT)
+        hr = autoplug_through_sink(graph, source, filter, filter_sink, sink, recursion_depth);
+        IPin_Release(filter_sink);
+        if (SUCCEEDED(hr))
         {
-            if (info.achName[0] == '~')
-            {
-                TRACE("Skipping non-rendered pin %s.\n", debugstr_w(info.achName));
-                IPin_Release(pin);
-                continue;
-            }
-
-            if (IPin_ConnectedTo(pin, &peer) == VFW_E_NOT_CONNECTED)
-            {
-                HRESULT hr;
-                hr = IFilterGraph2_Render(&graph->IFilterGraph2_iface, pin);
-                if (SUCCEEDED(hr))
-                    renderany = TRUE;
-                else
-                    renderall = FALSE;
-            }
-            else
-                IPin_Release(peer);
+            IEnumPins_Release(sink_enum);
+            return hr;
         }
-
-        IPin_Release(pin);
     }
-
-    IEnumPins_Release(enumpins);
-
-    if (renderall)
-        return S_OK;
-
-    if (renderany)
-        return VFW_S_PARTIAL_RENDER;
-
-    return VFW_E_CANNOT_RENDER;
+    IEnumPins_Release(sink_enum);
+    return VFW_E_CANNOT_CONNECT;
 }
 
-/* Ogg hates me if I create a direct rendering method
- *
- * It can only connect to a pin properly once, so use a recursive method that does
- *
- *  +----+ --- (PIN 1) (Render is called on this pin)
- *  |    |
- *  +----+ --- (PIN 2)
- *
- *  Enumerate possible renderers that EXACTLY match the requested type
- *
- *  If none is available, try to add intermediate filters that can connect to the input pin
- *  then call Render on that intermediate pin's output pins
- *  if it succeeds: Render returns success, if it doesn't, the intermediate filter is removed,
- *  and another filter that can connect to the input pin is tried
- *  if we run out of filters that can, give up and return VFW_E_CANNOT_RENDER
- *  It's recursive, but fun!
- */
-
-static HRESULT WINAPI FilterGraph2_Render(IFilterGraph2 *iface, IPin *ppinOut)
+/* Common helper for IGraphBuilder::Connect() and IGraphBuilder::Render(), which
+ * share most of the same code. Render() calls this with a NULL sink. */
+static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink, unsigned int recursion_depth)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
-    IEnumMediaTypes* penummt;
+    IAMGraphBuilderCallback *callback = NULL;
+    IEnumMediaTypes *enummt;
+    IFilterMapper2 *mapper;
     struct filter *filter;
-    AM_MEDIA_TYPE* mt;
-    ULONG nbmt;
+    AM_MEDIA_TYPE *mt;
     HRESULT hr;
 
-    IEnumMoniker* pEnumMoniker;
-    GUID tab[4];
-    ULONG nb;
-    IMoniker* pMoniker;
-    IFilterMapper2 *pFilterMapper2 = NULL;
+    TRACE("Trying to autoplug %p to %p, recursion depth %u.\n", source, sink, recursion_depth);
 
-    TRACE("(%p/%p)->(%p)\n", This, iface, ppinOut);
+    if (recursion_depth >= 5)
+    {
+        WARN("Recursion depth has reached 5; aborting.\n");
+        return VFW_E_CANNOT_CONNECT;
+    }
 
-    if (TRACE_ON(quartz))
+    if (sink)
     {
-        PIN_INFO PinInfo;
+        /* Try to connect directly to this sink. */
+        hr = IFilterGraph2_ConnectDirect(&graph->IFilterGraph2_iface, source, sink, NULL);
 
-        hr = IPin_QueryPinInfo(ppinOut, &PinInfo);
-        if (FAILED(hr))
+        /* If direct connection succeeded, we should propagate that return value.
+         * If it returned VFW_E_NOT_CONNECTED or VFW_E_NO_AUDIO_HARDWARE, then don't
+         * even bother trying intermediate filters, since they won't succeed. */
+        if (SUCCEEDED(hr) || hr == VFW_E_NOT_CONNECTED || hr == VFW_E_NO_AUDIO_HARDWARE)
             return hr;
-
-        TRACE("Filter owning pin => %p\n", PinInfo.pFilter);
-        IBaseFilter_Release(PinInfo.pFilter);
     }
 
-    /* Try to find out if there is a renderer for the specified subtype already, and use that
-     */
-    EnterCriticalSection(&This->cs);
-    LIST_FOR_EACH_ENTRY(filter, &This->filters, struct filter, entry)
+    /* Always prefer filters in the graph. */
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
-        IEnumPins *enumpins = NULL;
-        IPin *pin = NULL;
-
-        hr = IBaseFilter_EnumPins(filter->filter, &enumpins);
-
-        if (FAILED(hr) || !enumpins)
-            continue;
-
-        IEnumPins_Reset(enumpins);
-        while (IEnumPins_Next(enumpins, 1, &pin, NULL) == S_OK)
-        {
-            IPin *to = NULL;
-            PIN_DIRECTION dir = PINDIR_OUTPUT;
-
-            IPin_QueryDirection(pin, &dir);
-            if (dir != PINDIR_INPUT)
-            {
-                IPin_Release(pin);
-                continue;
-            }
-            IPin_ConnectedTo(pin, &to);
-
-            if (to == NULL)
-            {
-                hr = FilterGraph2_ConnectDirect(iface, ppinOut, pin, NULL);
-                if (SUCCEEDED(hr))
-                {
-                    TRACE("Connected successfully %p/%p, %08x look if we should render more!\n", ppinOut, pin, hr);
-                    IPin_Release(pin);
-
-                    hr = render_output_pins(This, filter->filter);
-                    if (FAILED(hr))
-                    {
-                        IPin_Disconnect(ppinOut);
-                        IPin_Disconnect(pin);
-                        continue;
-                    }
-                    IEnumPins_Release(enumpins);
-                    LeaveCriticalSection(&This->cs);
-                    return hr;
-                }
-                WARN("Could not connect!\n");
-            }
-            else
-                IPin_Release(to);
-
-            IPin_Release(pin);
-        }
-        IEnumPins_Release(enumpins);
+        if (SUCCEEDED(hr = autoplug_through_filter(graph, source, filter->filter, sink, recursion_depth)))
+            return hr;
     }
 
-    LeaveCriticalSection(&This->cs);
+    IUnknown_QueryInterface(graph->punkFilterMapper2, &IID_IFilterMapper2, (void **)&mapper);
 
-    hr = IPin_EnumMediaTypes(ppinOut, &penummt);
-    if (FAILED(hr)) {
-        WARN("EnumMediaTypes (%x)\n", hr);
+    if (FAILED(hr = IPin_EnumMediaTypes(source, &enummt)))
+    {
+        IFilterMapper2_Release(mapper);
         return hr;
     }
 
-    IEnumMediaTypes_Reset(penummt);
+    if (graph->pSite)
+        IUnknown_QueryInterface(graph->pSite, &IID_IAMGraphBuilderCallback, (void **)&callback);
 
-    /* Looks like no existing renderer of the kind exists
-     * Try adding new ones
-     */
-    tab[0] = tab[1] = GUID_NULL;
-    while (SUCCEEDED(hr))
+    while (IEnumMediaTypes_Next(enummt, 1, &mt, NULL) == S_OK)
     {
-        hr = IEnumMediaTypes_Next(penummt, 1, &mt, &nbmt);
-        if (FAILED(hr)) {
-            WARN("IEnumMediaTypes_Next (%x)\n", hr);
-            break;
-        }
-        if (!nbmt)
-        {
-            hr = VFW_E_CANNOT_RENDER;
-            break;
-        }
-        else
+        GUID types[2] = {mt->majortype, mt->subtype};
+        IEnumMoniker *enummoniker;
+        IBaseFilter *filter;
+        IMoniker *moniker;
+
+        DeleteMediaType(mt);
+
+        if (FAILED(hr = IFilterMapper2_EnumMatchingFilters(mapper, &enummoniker, 0, FALSE,
+                MERIT_UNLIKELY, TRUE, 1, types, NULL, NULL, FALSE, FALSE, 0, NULL, NULL, NULL)))
+            goto out;
+
+        while (IEnumMoniker_Next(enummoniker, 1, &moniker, NULL) == S_OK)
         {
-            TRACE("MajorType %s\n", debugstr_guid(&mt->majortype));
-            TRACE("SubType %s\n", debugstr_guid(&mt->subtype));
+            IPropertyBag *bag;
+            VARIANT var;
 
-            /* Only enumerate once, this doesn't account for all previous ones, but this should be enough nonetheless */
-            if (IsEqualIID(&tab[0], &mt->majortype) && IsEqualIID(&tab[1], &mt->subtype))
+            VariantInit(&var);
+            IMoniker_BindToStorage(moniker, NULL, NULL, &IID_IPropertyBag, (void **)&bag);
+            hr = IPropertyBag_Read(bag, L"FriendlyName", &var, NULL);
+            IPropertyBag_Release(bag);
+            if (FAILED(hr))
             {
-                DeleteMediaType(mt);
+                IMoniker_Release(moniker);
                 continue;
             }
 
-            if (pFilterMapper2 == NULL)
+            if (callback && FAILED(hr = IAMGraphBuilderCallback_SelectedFilter(callback, moniker)))
             {
-                hr = IUnknown_QueryInterface(This->punkFilterMapper2, &IID_IFilterMapper2, (void**)&pFilterMapper2);
-                if (FAILED(hr))
-                {
-                    WARN("Unable to query IFilterMapper2 (%x)\n", hr);
-                    break;
-                }
+                TRACE("Filter rejected by IAMGraphBuilderCallback::SelectedFilter(), hr %#x.\n", hr);
+                IMoniker_Release(moniker);
+                continue;
             }
 
-            /* Try to find a suitable renderer with the same media type */
-            tab[0] = mt->majortype;
-            tab[1] = mt->subtype;
-            hr = IFilterMapper2_EnumMatchingFilters(pFilterMapper2, &pEnumMoniker, 0, FALSE, MERIT_UNLIKELY, TRUE, 1, tab, NULL, NULL, FALSE, FALSE, 0, NULL, NULL, NULL);
+            hr = create_filter(graph, moniker, &filter);
+            IMoniker_Release(moniker);
             if (FAILED(hr))
             {
-                WARN("Unable to enum filters (%x)\n", hr);
-                break;
+                ERR("Failed to create filter for %s, hr %#x.\n", debugstr_w(V_BSTR(&var)), hr);
+                VariantClear(&var);
+                continue;
             }
-        }
-        hr = E_FAIL;
 
-        while (IEnumMoniker_Next(pEnumMoniker, 1, &pMoniker, &nb) == S_OK)
-        {
-            VARIANT var;
-            IPin* ppinfilter;
-            IBaseFilter* pfilter = NULL;
-            IEnumPins* penumpins = NULL;
-            ULONG pin;
-
-            hr = GetFilterInfo(pMoniker, &var);
-            if (FAILED(hr)) {
-                WARN("Unable to retrieve filter info (%x)\n", hr);
-                goto error;
+            if (callback && FAILED(hr = IAMGraphBuilderCallback_CreatedFilter(callback, filter)))
+            {
+                TRACE("Filter rejected by IAMGraphBuilderCallback::CreatedFilter(), hr %#x.\n", hr);
+                IBaseFilter_Release(filter);
+                continue;
             }
 
-            hr = create_filter(This, pMoniker, &pfilter);
-            IMoniker_Release(pMoniker);
+            hr = IFilterGraph2_AddFilter(&graph->IFilterGraph2_iface, filter, V_BSTR(&var));
+            VariantClear(&var);
             if (FAILED(hr))
             {
-                WARN("Unable to create filter (%x), trying next one\n", hr);
-                goto error;
-            }
-
-            hr = IFilterGraph2_AddFilter(iface, pfilter, V_BSTR(&var));
-            if (FAILED(hr)) {
-                WARN("Unable to add filter (%x)\n", hr);
-                IBaseFilter_Release(pfilter);
-                pfilter = NULL;
-                goto error;
+                ERR("Failed to add filter, hr %#x.\n", hr);
+                IBaseFilter_Release(filter);
+                continue;
             }
 
-            hr = IBaseFilter_EnumPins(pfilter, &penumpins);
-            if (FAILED(hr)) {
-                WARN("Splitter Enumpins (%x)\n", hr);
-                goto error;
+            hr = autoplug_through_filter(graph, source, filter, sink, recursion_depth);
+            if (SUCCEEDED(hr))
+            {
+                IBaseFilter_Release(filter);
+                goto out;
             }
 
-            while ((hr = IEnumPins_Next(penumpins, 1, &ppinfilter, &pin)) == S_OK)
-            {
-                PIN_DIRECTION dir;
+            IFilterGraph2_RemoveFilter(&graph->IFilterGraph2_iface, filter);
+            IBaseFilter_Release(filter);
+        }
+        IEnumMoniker_Release(enummoniker);
+    }
 
-                if (pin == 0) {
-                    WARN("No Pin\n");
-                    hr = E_FAIL;
-                    goto error;
-                }
+    hr = VFW_E_CANNOT_CONNECT;
 
-                hr = IPin_QueryDirection(ppinfilter, &dir);
-                if (FAILED(hr)) {
-                    IPin_Release(ppinfilter);
-                    WARN("QueryDirection failed (%x)\n", hr);
-                    goto error;
-                }
-                if (dir != PINDIR_INPUT) {
-                    IPin_Release(ppinfilter);
-                    continue; /* Wrong direction */
-                }
+out:
+    if (callback) IAMGraphBuilderCallback_Release(callback);
+    IEnumMediaTypes_Release(enummt);
+    IFilterMapper2_Release(mapper);
+    return hr;
+}
 
-                /* Connect the pin to the "Renderer" */
-                hr = IFilterGraph2_ConnectDirect(iface, ppinOut, ppinfilter, NULL);
-                IPin_Release(ppinfilter);
+static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *source, IPin *sink)
+{
+    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    PIN_DIRECTION dir;
+    HRESULT hr;
 
-                if (FAILED(hr)) {
-                    WARN("Unable to connect %s to renderer (%x)\n", debugstr_w(V_BSTR(&var)), hr);
-                    goto error;
-                }
-                TRACE("Connected, recursing %s\n",  debugstr_w(V_BSTR(&var)));
+    TRACE("graph %p, source %p, sink %p.\n", graph, source, sink);
 
-                VariantClear(&var);
+    if (!source || !sink)
+        return E_POINTER;
 
-                hr = render_output_pins(This, pfilter);
-                if (FAILED(hr)) {
-                    WARN("Unable to connect recursively (%x)\n", hr);
-                    goto error;
-                }
-                IBaseFilter_Release(pfilter);
-                break;
-            }
-            if (SUCCEEDED(hr)) {
-                IEnumPins_Release(penumpins);
-                break; /* out of IEnumMoniker_Next loop */
-            }
+    if (FAILED(hr = IPin_QueryDirection(source, &dir)))
+        return hr;
 
-            /* IEnumPins_Next failed, all other failure case caught by goto error */
-            WARN("IEnumPins_Next (%x)\n", hr);
-            /* goto error */
+    if (dir == PINDIR_INPUT)
+    {
+        IPin *temp;
 
-error:
-            VariantClear(&var);
-            if (penumpins)
-                IEnumPins_Release(penumpins);
-            if (pfilter) {
-                IFilterGraph2_RemoveFilter(iface, pfilter);
-                IBaseFilter_Release(pfilter);
-            }
-            if (SUCCEEDED(hr)) DebugBreak();
-        }
+        TRACE("Directions seem backwards, swapping pins\n");
 
-        IEnumMoniker_Release(pEnumMoniker);
-        if (nbmt)
-            DeleteMediaType(mt);
-        if (SUCCEEDED(hr))
-            break;
-        hr = S_OK;
+        temp = sink;
+        sink = source;
+        source = temp;
     }
 
-    if (pFilterMapper2)
-        IFilterMapper2_Release(pFilterMapper2);
+    EnterCriticalSection(&graph->cs);
+
+    hr = autoplug(graph, source, sink, 0);
+
+    LeaveCriticalSection(&graph->cs);
+
+    TRACE("Returning %#x.\n", hr);
+    return hr;
+}
+
+static HRESULT WINAPI FilterGraph2_Render(IFilterGraph2 *iface, IPin *source)
+{
+    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    HRESULT hr;
+
+    TRACE("graph %p, source %p.\n", graph, source);
+
+    EnterCriticalSection(&graph->cs);
+    hr = autoplug(graph, source, NULL, 0);
+    LeaveCriticalSection(&graph->cs);
+    if (hr == VFW_E_CANNOT_CONNECT)
+        hr = VFW_E_CANNOT_RENDER;
 
-    IEnumMediaTypes_Release(penummt);
+    TRACE("Returning %#x.\n", hr);
     return hr;
 }
 
@@ -5755,7 +5404,6 @@ static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL
     memcpy(&fimpl->timeformatseek, &TIME_FORMAT_MEDIA_TIME, sizeof(GUID));
     fimpl->stream_start = fimpl->stream_elapsed = 0;
     fimpl->punkFilterMapper2 = NULL;
-    fimpl->recursioncount = 0;
     fimpl->version = 0;
     fimpl->current_pos = 0;
 
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 22ed37cd307..5a61b754648 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -2110,7 +2110,7 @@ static void test_graph_builder_connect(void)
 {
     static const GUID parser1_clsid = {0x12345678};
     static const GUID parser2_clsid = {0x87654321};
-    AM_MEDIA_TYPE source_type = {{0}}, sink_type = {{0}}, parser3_type = {{0}};
+    AM_MEDIA_TYPE source_types[2] = {{{0}}}, sink_type = {{0}}, parser3_type = {{0}};
     struct testpin source_pin, sink_pin, sink2_pin, parser1_pins[3], parser2_pins[2], parser3_pins[2];
     struct testfilter source, sink, sink2, parser1, parser2, parser3;
     struct testfilter_cf parser1_cf = { {&testfilter_cf_vtbl}, &parser1 };
@@ -2125,10 +2125,11 @@ static void test_graph_builder_connect(void)
     HRESULT hr;
     ULONG ref;
 
-    memset(&source_type.majortype, 0xcc, sizeof(GUID));
+    memset(&source_types[0].majortype, 0xcc, sizeof(GUID));
+    memset(&source_types[1].majortype, 0xdd, sizeof(GUID));
     memset(&sink_type.majortype, 0x66, sizeof(GUID));
-    testsource_init(&source_pin, &source_type, 1);
-    source_pin.request_mt = &source_type;
+    testsource_init(&source_pin, source_types, 2);
+    source_pin.request_mt = &source_types[1];
     testfilter_init(&source, &source_pin, 1);
     testsink_init(&sink_pin);
     testfilter_init(&sink, &sink_pin, 1);
@@ -2398,7 +2399,7 @@ todo_wine
     regpins[1].cInstances = 1;
     regpins[1].nMediaTypes = 1;
     regpins[1].lpMediaType = &regtypes;
-    regtypes.clsMajorType = &source_type.majortype;
+    regtypes.clsMajorType = &source_types[1].majortype;
     regtypes.clsMinorType = &MEDIASUBTYPE_NULL;
     hr = IFilterMapper2_RegisterFilter(mapper, &parser1_clsid, L"test", NULL, NULL, NULL, &regfilter);
     if (hr == E_ACCESSDENIED)
From 15303e54016ef92e583d98386c8dcbefe52d9b74 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 15 Jun 2020 22:51:26 -0500
Subject: [PATCH] quartz: Implement IFilterGraph2::RenderEx().

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=35215
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 49 ++++++++++++++++++++++-----------
 dlls/quartz/tests/filtergraph.c | 28 +++++++++++++++----
 2 files changed, 56 insertions(+), 21 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index e3faf64fb82..a23e35d6a1c 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -1119,10 +1119,12 @@ static HRESULT create_filter(IFilterGraphImpl *graph, IMoniker *moniker, IBaseFi
         return IMoniker_BindToObject(moniker, NULL, NULL, &IID_IBaseFilter, (void **)filter);
 }
 
-static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink, unsigned int recursion_depth);
+static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink,
+        BOOL render_to_existing, unsigned int recursion_depth);
 
 static HRESULT autoplug_through_sink(IFilterGraphImpl *graph, IPin *source,
-        IBaseFilter *filter, IPin *middle_sink, IPin *sink, unsigned int recursion_depth)
+        IBaseFilter *filter, IPin *middle_sink, IPin *sink,
+        BOOL render_to_existing, BOOL allow_renderers, unsigned int recursion_depth)
 {
     BOOL any = FALSE, all = TRUE;
     IPin *middle_source, *peer;
@@ -1171,7 +1173,7 @@ static HRESULT autoplug_through_sink(IFilterGraphImpl *graph, IPin *source,
             continue;
         }
 
-        hr = autoplug(graph, middle_source, sink, recursion_depth + 1);
+        hr = autoplug(graph, middle_source, sink, render_to_existing, recursion_depth + 1);
         IPin_Release(middle_source);
         if (SUCCEEDED(hr) && sink)
         {
@@ -1187,7 +1189,7 @@ static HRESULT autoplug_through_sink(IFilterGraphImpl *graph, IPin *source,
 
     if (!sink)
     {
-        if (all)
+        if (all && (any || allow_renderers))
             return S_OK;
         if (any)
             return VFW_S_PARTIAL_RENDER;
@@ -1200,7 +1202,8 @@ static HRESULT autoplug_through_sink(IFilterGraphImpl *graph, IPin *source,
 }
 
 static HRESULT autoplug_through_filter(IFilterGraphImpl *graph, IPin *source,
-        IBaseFilter *filter, IPin *sink, unsigned int recursion_depth)
+        IBaseFilter *filter, IPin *sink, BOOL render_to_existing,
+        BOOL allow_renderers, unsigned int recursion_depth)
 {
     IEnumPins *sink_enum;
     IPin *filter_sink;
@@ -1213,7 +1216,8 @@ static HRESULT autoplug_through_filter(IFilterGraphImpl *graph, IPin *source,
 
     while (IEnumPins_Next(sink_enum, 1, &filter_sink, NULL) == S_OK)
     {
-        hr = autoplug_through_sink(graph, source, filter, filter_sink, sink, recursion_depth);
+        hr = autoplug_through_sink(graph, source, filter, filter_sink, sink,
+                render_to_existing, allow_renderers, recursion_depth);
         IPin_Release(filter_sink);
         if (SUCCEEDED(hr))
         {
@@ -1227,7 +1231,8 @@ static HRESULT autoplug_through_filter(IFilterGraphImpl *graph, IPin *source,
 
 /* Common helper for IGraphBuilder::Connect() and IGraphBuilder::Render(), which
  * share most of the same code. Render() calls this with a NULL sink. */
-static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink, unsigned int recursion_depth)
+static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink,
+        BOOL render_to_existing, unsigned int recursion_depth)
 {
     IAMGraphBuilderCallback *callback = NULL;
     IEnumMediaTypes *enummt;
@@ -1259,7 +1264,8 @@ static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink, unsig
     /* Always prefer filters in the graph. */
     LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
-        if (SUCCEEDED(hr = autoplug_through_filter(graph, source, filter->filter, sink, recursion_depth)))
+        if (SUCCEEDED(hr = autoplug_through_filter(graph, source, filter->filter,
+                sink, render_to_existing, TRUE, recursion_depth)))
             return hr;
     }
 
@@ -1334,7 +1340,8 @@ static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink, unsig
                 continue;
             }
 
-            hr = autoplug_through_filter(graph, source, filter, sink, recursion_depth);
+            hr = autoplug_through_filter(graph, source, filter, sink,
+                    render_to_existing, !render_to_existing, recursion_depth);
             if (SUCCEEDED(hr))
             {
                 IBaseFilter_Release(filter);
@@ -1383,7 +1390,7 @@ static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *source, I
 
     EnterCriticalSection(&graph->cs);
 
-    hr = autoplug(graph, source, sink, 0);
+    hr = autoplug(graph, source, sink, FALSE, 0);
 
     LeaveCriticalSection(&graph->cs);
 
@@ -1399,7 +1406,7 @@ static HRESULT WINAPI FilterGraph2_Render(IFilterGraph2 *iface, IPin *source)
     TRACE("graph %p, source %p.\n", graph, source);
 
     EnterCriticalSection(&graph->cs);
-    hr = autoplug(graph, source, NULL, 0);
+    hr = autoplug(graph, source, NULL, FALSE, 0);
     LeaveCriticalSection(&graph->cs);
     if (hr == VFW_E_CANNOT_CONNECT)
         hr = VFW_E_CANNOT_RENDER;
@@ -1598,14 +1605,24 @@ static HRESULT WINAPI FilterGraph2_ReconnectEx(IFilterGraph2 *iface, IPin *pin,
     return hr;
 }
 
-static HRESULT WINAPI FilterGraph2_RenderEx(IFilterGraph2 *iface, IPin *pPinOut, DWORD dwFlags,
-        DWORD *pvContext)
+static HRESULT WINAPI FilterGraph2_RenderEx(IFilterGraph2 *iface, IPin *source, DWORD flags, DWORD *context)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
+    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    HRESULT hr;
 
-    TRACE("(%p/%p)->(%p %08x %p): stub !!!\n", This, iface, pPinOut, dwFlags, pvContext);
+    TRACE("graph %p, source %p, flags %#x, context %p.\n", graph, source, flags, context);
 
-    return S_OK;
+    if (flags & ~AM_RENDEREX_RENDERTOEXISTINGRENDERERS)
+        FIXME("Unknown flags %#x.\n", flags);
+
+    EnterCriticalSection(&graph->cs);
+    hr = autoplug(graph, source, NULL, !!(flags & AM_RENDEREX_RENDERTOEXISTINGRENDERERS), 0);
+    LeaveCriticalSection(&graph->cs);
+    if (hr == VFW_E_CANNOT_CONNECT)
+        hr = VFW_E_CANNOT_RENDER;
+
+    TRACE("Returning %#x.\n", hr);
+    return hr;
 }
 
 
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 5a61b754648..de8e32034f8 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -1978,9 +1978,6 @@ static void test_graph_builder_render(void)
 
     /* Test enumeration of filters from the registry. */
 
-    graph = create_graph();
-    IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
-
     CoRegisterClassObject(&sink1_clsid, (IUnknown *)&sink1_cf.IClassFactory_iface,
             CLSCTX_INPROC_SERVER, REGCLS_MULTIPLEUSE, &cookie1);
     CoRegisterClassObject(&sink2_clsid, (IUnknown *)&sink2_cf.IClassFactory_iface,
@@ -2007,6 +2004,9 @@ static void test_graph_builder_render(void)
     }
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
+    graph = create_graph();
+    IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
+
     regpins.dwFlags = REG_PINFLAG_B_RENDERER;
     IFilterMapper2_RegisterFilter(mapper, &sink2_clsid, L"test", NULL, NULL, NULL, &regfilter);
 
@@ -2086,6 +2086,26 @@ static void test_graph_builder_render(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink1_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
 
+    ref = IFilterGraph2_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+    /* Test AM_RENDEREX_RENDERTOEXISTINGRENDERERS. */
+
+    graph = create_graph();
+    IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
+
+    hr = IFilterGraph2_RenderEx(graph, &source_pin.IPin_iface, AM_RENDEREX_RENDERTOEXISTINGRENDERERS, NULL);
+    ok(hr == VFW_E_CANNOT_RENDER, "Got hr %#x.\n", hr);
+
+    IFilterGraph2_AddFilter(graph, &sink1.IBaseFilter_iface, NULL);
+
+    hr = IFilterGraph2_RenderEx(graph, &source_pin.IPin_iface, AM_RENDEREX_RENDERTOEXISTINGRENDERERS, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(source_pin.peer == &sink1_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
+
+    ref = IFilterGraph2_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
     IFilterMapper2_UnregisterFilter(mapper, NULL, NULL, &sink1_clsid);
     IFilterMapper2_UnregisterFilter(mapper, NULL, NULL, &sink2_clsid);
 
@@ -2093,8 +2113,6 @@ static void test_graph_builder_render(void)
     CoRevokeClassObject(cookie1);
     CoRevokeClassObject(cookie2);
     IFilterMapper2_Release(mapper);
-    ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ok(source.ref == 1, "Got outstanding refcount %d.\n", source.ref);
     ok(source_pin.ref == 1, "Got outstanding refcount %d.\n", source_pin.ref);
     ok(sink1.ref == 1, "Got outstanding refcount %d.\n", sink1.ref);
From 57b627fba69d633042201f7d9c26b2545afa186d Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 18 Jun 2020 01:18:29 +0700
Subject: [PATCH] amstream: Implement MediaStreamFilter::GetCurrentStreamTime.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/filter.c         |  28 ++++++-
 dlls/amstream/tests/amstream.c | 137 +++++++++++++++++++++++++++++++++
 2 files changed, 162 insertions(+), 3 deletions(-)

diff --git a/dlls/amstream/filter.c b/dlls/amstream/filter.c
index 05a02e3f666..3dff686b213 100644
--- a/dlls/amstream/filter.c
+++ b/dlls/amstream/filter.c
@@ -174,6 +174,7 @@ struct filter
     IAMMediaStream **streams;
     IAMMediaStream *seekable_stream;
     FILTER_STATE state;
+    REFERENCE_TIME start_time;
 };
 
 static inline struct filter *impl_from_IMediaStreamFilter(IMediaStreamFilter *iface)
@@ -295,6 +296,7 @@ static HRESULT WINAPI filter_Run(IMediaStreamFilter *iface, REFERENCE_TIME start
 
     EnterCriticalSection(&filter->cs);
 
+    filter->start_time = start;
     set_state(filter, State_Running);
 
     LeaveCriticalSection(&filter->cs);
@@ -614,11 +616,31 @@ static HRESULT WINAPI filter_ReferenceTimeToStreamTime(IMediaStreamFilter *iface
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI filter_GetCurrentStreamTime(IMediaStreamFilter *iface, REFERENCE_TIME *pCurrentStreamTime)
+static HRESULT WINAPI filter_GetCurrentStreamTime(IMediaStreamFilter *iface, REFERENCE_TIME *time)
 {
-    FIXME("(%p)->(%p): Stub!\n", iface, pCurrentStreamTime);
+    struct filter *filter = impl_from_IMediaStreamFilter(iface);
 
-    return E_NOTIMPL;
+    TRACE("filter %p, time %p.\n", filter, time);
+
+    if (!time)
+        return E_POINTER;
+
+    EnterCriticalSection(&filter->cs);
+
+    if (filter->state != State_Running || !filter->clock)
+    {
+        *time = 0;
+        LeaveCriticalSection(&filter->cs);
+        return S_FALSE;
+    }
+
+    IReferenceClock_GetTime(filter->clock, time);
+
+    *time -= filter->start_time;
+
+    LeaveCriticalSection(&filter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI filter_WaitUntil(IMediaStreamFilter *iface, REFERENCE_TIME WaitStreamTime)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 2bc1310a96b..e1f6a15ad38 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -2641,6 +2641,87 @@ static const IMediaSeekingVtbl testsource_seeking_vtbl =
     testsource_seeking_GetPreroll,
 };
 
+struct testclock
+{
+    IReferenceClock IReferenceClock_iface;
+    LONG refcount;
+    LONGLONG time;
+    HRESULT get_time_hr;
+};
+
+static inline struct testclock *impl_from_IReferenceClock(IReferenceClock *iface)
+{
+    return CONTAINING_RECORD(iface, struct testclock, IReferenceClock_iface);
+}
+
+static HRESULT WINAPI testclock_QueryInterface(IReferenceClock *iface, REFIID iid, void **out)
+{
+    if (winetest_debug > 1) trace("QueryInterface(%s)\n", wine_dbgstr_guid(iid));
+    if (IsEqualGUID(iid, &IID_IReferenceClock)
+            || IsEqualGUID(iid, &IID_IUnknown))
+    {
+        *out = iface;
+        IReferenceClock_AddRef(iface);
+        return S_OK;
+    }
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI testclock_AddRef(IReferenceClock *iface)
+{
+    struct testclock *clock = impl_from_IReferenceClock(iface);
+    return InterlockedIncrement(&clock->refcount);
+}
+
+static ULONG WINAPI testclock_Release(IReferenceClock *iface)
+{
+    struct testclock *clock = impl_from_IReferenceClock(iface);
+    return InterlockedDecrement(&clock->refcount);
+}
+
+static HRESULT WINAPI testclock_GetTime(IReferenceClock *iface, REFERENCE_TIME *time)
+{
+    struct testclock *clock = impl_from_IReferenceClock(iface);
+    if (SUCCEEDED(clock->get_time_hr))
+        *time = clock->time;
+    return clock->get_time_hr;
+}
+
+static HRESULT WINAPI testclock_AdviseTime(IReferenceClock *iface, REFERENCE_TIME base, REFERENCE_TIME offset, HEVENT event, DWORD_PTR *cookie)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testclock_AdvisePeriodic(IReferenceClock *iface, REFERENCE_TIME start, REFERENCE_TIME period, HSEMAPHORE semaphore, DWORD_PTR *cookie)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testclock_Unadvise(IReferenceClock *iface, DWORD_PTR cookie)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static IReferenceClockVtbl testclock_vtbl =
+{
+    testclock_QueryInterface,
+    testclock_AddRef,
+    testclock_Release,
+    testclock_GetTime,
+    testclock_AdviseTime,
+    testclock_AdvisePeriodic,
+    testclock_Unadvise,
+};
+
+static void testclock_init(struct testclock *clock)
+{
+    memset(clock, 0, sizeof(*clock));
+    clock->IReferenceClock_iface.lpVtbl = &testclock_vtbl;
+}
+
 static void test_audiostream_get_format(void)
 {
     static const WAVEFORMATEX pin_format =
@@ -4330,6 +4411,61 @@ static void test_mediastreamfilter_set_positions(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_mediastreamfilter_get_current_stream_time(void)
+{
+    IMediaStreamFilter *filter;
+    struct testclock clock;
+    REFERENCE_TIME time;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&CLSID_MediaStreamFilter, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IMediaStreamFilter, (void **)&filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    testclock_init(&clock);
+
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IMediaStreamFilter_GetCurrentStreamTime(filter, NULL);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+    }
+
+    time = 0xdeadbeefdeadbeef;
+    hr = IMediaStreamFilter_GetCurrentStreamTime(filter, &time);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(time == 0, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    hr = IMediaStreamFilter_SetSyncSource(filter, &clock.IReferenceClock_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    clock.get_time_hr = E_FAIL;
+
+    time = 0xdeadbeefdeadbeef;
+    hr = IMediaStreamFilter_GetCurrentStreamTime(filter, &time);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(time == 0, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    hr = IMediaStreamFilter_Run(filter, 23456789);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    time = 0xdeadbeefdeadbeef;
+    hr = IMediaStreamFilter_GetCurrentStreamTime(filter, &time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(time == 0xdeadbeefdd47d2da, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    clock.time = 34567890;
+    clock.get_time_hr = S_OK;
+
+    time = 0xdeadbeefdeadbeef;
+    hr = IMediaStreamFilter_GetCurrentStreamTime(filter, &time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(time == 11111101, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(amstream)
 {
     HANDLE file;
@@ -4383,6 +4519,7 @@ START_TEST(amstream)
     test_mediastreamfilter_stop_pause_run();
     test_mediastreamfilter_support_seeking();
     test_mediastreamfilter_set_positions();
+    test_mediastreamfilter_get_current_stream_time();
 
     CoUninitialize();
 }
From b12ac596fdb6cadff2d77ff34a234bf73be3dfb0 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Fri, 19 Jun 2020 16:10:28 +0200
Subject: [PATCH] amstream: Get rid of the IDirectDrawStreamSampleImpl typedef.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c | 73 +++++++++++++++++++------------------
 1 file changed, 37 insertions(+), 36 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 1c924e40a20..e2f24c3b4c8 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -952,21 +952,22 @@ HRESULT ddraw_stream_create(IUnknown *outer, void **out)
     return S_OK;
 }
 
-typedef struct {
+struct ddraw_sample
+{
     IDirectDrawStreamSample IDirectDrawStreamSample_iface;
     LONG ref;
     IMediaStream *parent;
     IDirectDrawSurface *surface;
     RECT rect;
-} IDirectDrawStreamSampleImpl;
+};
 
-static inline IDirectDrawStreamSampleImpl *impl_from_IDirectDrawStreamSample(IDirectDrawStreamSample *iface)
+static inline struct ddraw_sample *impl_from_IDirectDrawStreamSample(IDirectDrawStreamSample *iface)
 {
-    return CONTAINING_RECORD(iface, IDirectDrawStreamSampleImpl, IDirectDrawStreamSample_iface);
+    return CONTAINING_RECORD(iface, struct ddraw_sample, IDirectDrawStreamSample_iface);
 }
 
 /*** IUnknown methods ***/
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_QueryInterface(IDirectDrawStreamSample *iface,
+static HRESULT WINAPI ddraw_sample_QueryInterface(IDirectDrawStreamSample *iface,
         REFIID riid, void **ret_iface)
 {
     TRACE("(%p)->(%s,%p)\n", iface, debugstr_guid(riid), ret_iface);
@@ -986,43 +987,43 @@ static HRESULT WINAPI IDirectDrawStreamSampleImpl_QueryInterface(IDirectDrawStre
     return E_NOINTERFACE;
 }
 
-static ULONG WINAPI IDirectDrawStreamSampleImpl_AddRef(IDirectDrawStreamSample *iface)
+static ULONG WINAPI ddraw_sample_AddRef(IDirectDrawStreamSample *iface)
 {
-    IDirectDrawStreamSampleImpl *This = impl_from_IDirectDrawStreamSample(iface);
-    ULONG ref = InterlockedIncrement(&This->ref);
+    struct ddraw_sample *sample = impl_from_IDirectDrawStreamSample(iface);
+    ULONG ref = InterlockedIncrement(&sample->ref);
 
     TRACE("(%p)->(): new ref = %u\n", iface, ref);
 
     return ref;
 }
 
-static ULONG WINAPI IDirectDrawStreamSampleImpl_Release(IDirectDrawStreamSample *iface)
+static ULONG WINAPI ddraw_sample_Release(IDirectDrawStreamSample *iface)
 {
-    IDirectDrawStreamSampleImpl *This = impl_from_IDirectDrawStreamSample(iface);
-    ULONG ref = InterlockedDecrement(&This->ref);
+    struct ddraw_sample *sample = impl_from_IDirectDrawStreamSample(iface);
+    ULONG ref = InterlockedDecrement(&sample->ref);
 
     TRACE("(%p)->(): new ref = %u\n", iface, ref);
 
     if (!ref)
     {
-        if (This->surface)
-            IDirectDrawSurface_Release(This->surface);
-        IMediaStream_Release(This->parent);
-        HeapFree(GetProcessHeap(), 0, This);
+        if (sample->surface)
+            IDirectDrawSurface_Release(sample->surface);
+        IMediaStream_Release(sample->parent);
+        HeapFree(GetProcessHeap(), 0, sample);
     }
 
     return ref;
 }
 
 /*** IStreamSample methods ***/
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_GetMediaStream(IDirectDrawStreamSample *iface, IMediaStream **media_stream)
+static HRESULT WINAPI ddraw_sample_GetMediaStream(IDirectDrawStreamSample *iface, IMediaStream **media_stream)
 {
     FIXME("(%p)->(%p): stub\n", iface, media_stream);
 
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_GetSampleTimes(IDirectDrawStreamSample *iface, STREAM_TIME *start_time,
+static HRESULT WINAPI ddraw_sample_GetSampleTimes(IDirectDrawStreamSample *iface, STREAM_TIME *start_time,
                                                                  STREAM_TIME *end_time, STREAM_TIME *current_time)
 {
     FIXME("(%p)->(%p,%p,%p): stub\n", iface, start_time, end_time, current_time);
@@ -1030,7 +1031,7 @@ static HRESULT WINAPI IDirectDrawStreamSampleImpl_GetSampleTimes(IDirectDrawStre
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_SetSampleTimes(IDirectDrawStreamSample *iface, const STREAM_TIME *start_time,
+static HRESULT WINAPI ddraw_sample_SetSampleTimes(IDirectDrawStreamSample *iface, const STREAM_TIME *start_time,
                                                                  const STREAM_TIME *end_time)
 {
     FIXME("(%p)->(%p,%p): stub\n", iface, start_time, end_time);
@@ -1038,7 +1039,7 @@ static HRESULT WINAPI IDirectDrawStreamSampleImpl_SetSampleTimes(IDirectDrawStre
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_Update(IDirectDrawStreamSample *iface, DWORD flags, HANDLE event,
+static HRESULT WINAPI ddraw_sample_Update(IDirectDrawStreamSample *iface, DWORD flags, HANDLE event,
                                                          PAPCFUNC func_APC, DWORD APC_data)
 {
     FIXME("(%p)->(%x,%p,%p,%u): stub\n", iface, flags, event, func_APC, APC_data);
@@ -1046,7 +1047,7 @@ static HRESULT WINAPI IDirectDrawStreamSampleImpl_Update(IDirectDrawStreamSample
     return S_OK;
 }
 
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_CompletionStatus(IDirectDrawStreamSample *iface, DWORD flags, DWORD milliseconds)
+static HRESULT WINAPI ddraw_sample_CompletionStatus(IDirectDrawStreamSample *iface, DWORD flags, DWORD milliseconds)
 {
     FIXME("(%p)->(%x,%u): stub\n", iface, flags, milliseconds);
 
@@ -1054,27 +1055,27 @@ static HRESULT WINAPI IDirectDrawStreamSampleImpl_CompletionStatus(IDirectDrawSt
 }
 
 /*** IDirectDrawStreamSample methods ***/
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_GetSurface(IDirectDrawStreamSample *iface, IDirectDrawSurface **ddraw_surface,
+static HRESULT WINAPI ddraw_sample_GetSurface(IDirectDrawStreamSample *iface, IDirectDrawSurface **ddraw_surface,
                                                              RECT *rect)
 {
-    IDirectDrawStreamSampleImpl *This = impl_from_IDirectDrawStreamSample(iface);
+    struct ddraw_sample *sample = impl_from_IDirectDrawStreamSample(iface);
 
     TRACE("(%p)->(%p,%p)\n", iface, ddraw_surface, rect);
 
     if (ddraw_surface)
     {
-        *ddraw_surface = This->surface;
+        *ddraw_surface = sample->surface;
         if (*ddraw_surface)
             IDirectDrawSurface_AddRef(*ddraw_surface);
     }
 
     if (rect)
-        *rect = This->rect;
+        *rect = sample->rect;
 
     return S_OK;
 }
 
-static HRESULT WINAPI IDirectDrawStreamSampleImpl_SetRect(IDirectDrawStreamSample *iface, const RECT *rect)
+static HRESULT WINAPI ddraw_sample_SetRect(IDirectDrawStreamSample *iface, const RECT *rect)
 {
     FIXME("(%p)->(%p): stub\n", iface, rect);
 
@@ -1084,24 +1085,24 @@ static HRESULT WINAPI IDirectDrawStreamSampleImpl_SetRect(IDirectDrawStreamSampl
 static const struct IDirectDrawStreamSampleVtbl DirectDrawStreamSample_Vtbl =
 {
     /*** IUnknown methods ***/
-    IDirectDrawStreamSampleImpl_QueryInterface,
-    IDirectDrawStreamSampleImpl_AddRef,
-    IDirectDrawStreamSampleImpl_Release,
+    ddraw_sample_QueryInterface,
+    ddraw_sample_AddRef,
+    ddraw_sample_Release,
     /*** IStreamSample methods ***/
-    IDirectDrawStreamSampleImpl_GetMediaStream,
-    IDirectDrawStreamSampleImpl_GetSampleTimes,
-    IDirectDrawStreamSampleImpl_SetSampleTimes,
-    IDirectDrawStreamSampleImpl_Update,
-    IDirectDrawStreamSampleImpl_CompletionStatus,
+    ddraw_sample_GetMediaStream,
+    ddraw_sample_GetSampleTimes,
+    ddraw_sample_SetSampleTimes,
+    ddraw_sample_Update,
+    ddraw_sample_CompletionStatus,
     /*** IDirectDrawStreamSample methods ***/
-    IDirectDrawStreamSampleImpl_GetSurface,
-    IDirectDrawStreamSampleImpl_SetRect
+    ddraw_sample_GetSurface,
+    ddraw_sample_SetRect
 };
 
 static HRESULT ddrawstreamsample_create(IDirectDrawMediaStream *parent, IDirectDrawSurface *surface,
     const RECT *rect, IDirectDrawStreamSample **ddraw_stream_sample)
 {
-    IDirectDrawStreamSampleImpl *object;
+    struct ddraw_sample *object;
     HRESULT hr;
 
     TRACE("(%p)\n", ddraw_stream_sample);
From b80907047662004f5f370d1a244adfceb22be39b Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Fri, 19 Jun 2020 16:10:29 +0200
Subject: [PATCH] amstream/tests: Add IDirectDrawStreamSample::GetMediaStream()
 tests.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 64 ++++++++++++++++++++--------------
 1 file changed, 38 insertions(+), 26 deletions(-)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index e1f6a15ad38..72ef7912aa9 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -2006,44 +2006,44 @@ static void test_media_types(void)
 
 static void test_IDirectDrawStreamSample(void)
 {
+    IDirectDrawMediaStream *ddraw_stream = NULL;
+    IDirectDrawStreamSample *sample = NULL;
+    IDirectDrawSurface *surface, *surface2;
+    IMediaStream *stream2, *stream = NULL;
     DDSURFACEDESC desc = { sizeof(desc) };
-    IAMMultiMediaStream *pams;
-    HRESULT hr;
-    IMediaStream *pvidstream = NULL;
-    IDirectDrawMediaStream *pddstream = NULL;
-    IDirectDrawStreamSample *pddsample = NULL;
+    IAMMultiMediaStream *mmstream;
     IDirectDrawSurface7 *surface7;
-    IDirectDrawSurface *surface, *surface2;
     IDirectDraw *ddraw, *ddraw2;
     IDirectDraw7 *ddraw7;
+    HRESULT hr;
     RECT rect;
 
-    if (!(pams = create_ammultimediastream()))
+    if (!(mmstream = create_ammultimediastream()))
         return;
     if (!create_directdraw())
     {
-        IAMMultiMediaStream_Release(pams);
+        IAMMultiMediaStream_Release(mmstream);
         return;
     }
 
-    hr = IAMMultiMediaStream_Initialize(pams, STREAMTYPE_READ, 0, NULL);
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
-    hr = IAMMultiMediaStream_AddMediaStream(pams, (IUnknown*)pdd7, &MSPID_PrimaryVideo, 0, NULL);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown*)pdd7, &MSPID_PrimaryVideo, 0, NULL);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
-    hr = IAMMultiMediaStream_GetMediaStream(pams, &MSPID_PrimaryVideo, &pvidstream);
+    hr = IAMMultiMediaStream_GetMediaStream(mmstream, &MSPID_PrimaryVideo, &stream);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     if (FAILED(hr)) goto error;
 
-    hr = IMediaStream_QueryInterface(pvidstream, &IID_IDirectDrawMediaStream, (LPVOID*)&pddstream);
+    hr = IMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (LPVOID*)&ddraw_stream);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     if (FAILED(hr)) goto error;
 
-    hr = IDirectDrawMediaStream_GetDirectDraw(pddstream, &ddraw);
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
-    hr = IDirectDrawMediaStream_GetDirectDraw(pddstream, &ddraw2);
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw2);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(ddraw == ddraw2, "got %p, %p\n", ddraw, ddraw2);
 
@@ -2055,14 +2055,26 @@ static void test_IDirectDrawStreamSample(void)
     IDirectDraw_Release(ddraw2);
     IDirectDraw_Release(ddraw);
 
-    hr = IDirectDrawMediaStream_CreateSample(pddstream, NULL, NULL, 0, &pddsample);
+    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, &sample);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
     surface = NULL;
-    hr = IDirectDrawStreamSample_GetSurface(pddsample, &surface, &rect);
+    hr = IDirectDrawStreamSample_GetSurface(sample, &surface, &rect);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(surface != NULL, "got %p\n", surface);
 
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IDirectDrawStreamSample_GetMediaStream(sample, NULL);
+        ok(hr == E_POINTER, "got 0x%08x\n", hr);
+    }
+
+    hr = IDirectDrawStreamSample_GetMediaStream(sample, &stream2);
+    todo_wine ok(hr == S_OK, "got 0x%08x\n", hr);
+    todo_wine ok(stream2 == stream, "Expected stream %p, got %p.\n", stream, stream2);
+    if (hr == S_OK) IMediaStream_Release(stream2);
+
     hr = IDirectDrawSurface_QueryInterface(surface, &IID_IDirectDrawSurface7, (void **)&surface7);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     IDirectDrawSurface7_Release(surface7);
@@ -2074,39 +2086,39 @@ static void test_IDirectDrawStreamSample(void)
     ok(desc.ddpfPixelFormat.dwFlags == DDPF_RGB, "format flags %08x\n", desc.ddpfPixelFormat.dwFlags);
     ok(desc.ddpfPixelFormat.dwRGBBitCount, "dwRGBBitCount %d\n", desc.ddpfPixelFormat.dwRGBBitCount);
     IDirectDrawSurface_Release(surface);
-    IDirectDrawStreamSample_Release(pddsample);
+    IDirectDrawStreamSample_Release(sample);
 
     hr = IDirectDrawSurface7_QueryInterface(pdds7, &IID_IDirectDrawSurface, (void **)&surface);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
     EXPECT_REF(surface, 1);
-    hr = IDirectDrawMediaStream_CreateSample(pddstream, surface, NULL, 0, &pddsample);
+    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, surface, NULL, 0, &sample);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     EXPECT_REF(surface, 2);
 
     surface2 = NULL;
     SetRectEmpty(&rect);
-    hr = IDirectDrawStreamSample_GetSurface(pddsample, &surface2, &rect);
+    hr = IDirectDrawStreamSample_GetSurface(sample, &surface2, &rect);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(surface == surface2, "got %p\n", surface2);
     ok(rect.right > 0 && rect.bottom > 0, "got %d, %d\n", rect.right, rect.bottom);
     EXPECT_REF(surface, 3);
     IDirectDrawSurface_Release(surface2);
 
-    hr = IDirectDrawStreamSample_GetSurface(pddsample, NULL, NULL);
+    hr = IDirectDrawStreamSample_GetSurface(sample, NULL, NULL);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
-    IDirectDrawStreamSample_Release(pddsample);
+    IDirectDrawStreamSample_Release(sample);
     IDirectDrawSurface_Release(surface);
 
 error:
-    if (pddstream)
-        IDirectDrawMediaStream_Release(pddstream);
-    if (pvidstream)
-        IMediaStream_Release(pvidstream);
+    if (ddraw_stream)
+        IDirectDrawMediaStream_Release(ddraw_stream);
+    if (stream)
+        IMediaStream_Release(stream);
 
     release_directdraw();
-    IAMMultiMediaStream_Release(pams);
+    IAMMultiMediaStream_Release(mmstream);
 }
 
 static IUnknown *create_audio_data(void)
From 1e81d551903d548d42d04d5076181741309d23c8 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Fri, 19 Jun 2020 16:10:30 +0200
Subject: [PATCH] amstream: Don't crash on NULL ddraw in
 IDirectDrawMediaStream::GetDirectDraw().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index e2f24c3b4c8..c471a66200d 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -377,6 +377,9 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetDirectDraw(IDirectDrawMedi
 
     TRACE("(%p)->(%p)\n", iface, ddraw);
 
+    if (!ddraw)
+        return E_POINTER;
+
     *ddraw = NULL;
     if (!This->ddraw)
     {
From 0736217336e8b84e27996c44474e49ba828cea13 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Sat, 20 Jun 2020 00:18:51 +0700
Subject: [PATCH] amstream: Implement IAudioStreamSample::GetSampleTimes.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    |  33 +++++-
 dlls/amstream/tests/amstream.c | 181 +++++++++++++++++++++++++++++++++
 2 files changed, 212 insertions(+), 2 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 8fba8777190..4c6c326d847 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -34,6 +34,7 @@ struct queued_receive
     DWORD length;
     BYTE *pointer;
     DWORD position;
+    STREAM_TIME start_time;
 };
 
 struct audio_stream
@@ -66,6 +67,8 @@ typedef struct {
     LONG ref;
     struct audio_stream *parent;
     IAudioData *audio_data;
+    STREAM_TIME start_time;
+    STREAM_TIME end_time;
     HANDLE update_event;
 
     struct list entry;
@@ -102,6 +105,12 @@ static void flush_receive_queue(struct audio_stream *stream)
         remove_queued_receive(LIST_ENTRY(entry, struct queued_receive, entry));
 }
 
+static STREAM_TIME stream_time_from_position(struct audio_stream *stream, struct queued_receive *receive)
+{
+    const WAVEFORMATEX *format = (WAVEFORMATEX *)stream->mt.pbFormat;
+    return receive->start_time + (receive->position * 10000000 + format->nAvgBytesPerSec / 2) / format->nAvgBytesPerSec;
+}
+
 static void process_update(IAudioStreamSampleImpl *sample, struct queued_receive *receive)
 {
     DWORD advance;
@@ -109,9 +118,14 @@ static void process_update(IAudioStreamSampleImpl *sample, struct queued_receive
     advance = min(receive->length - receive->position, sample->length - sample->position);
     memcpy(&sample->pointer[sample->position], &receive->pointer[receive->position], advance);
 
+    if (!sample->position)
+        sample->start_time = stream_time_from_position(sample->parent, receive);
+
     receive->position += advance;
     sample->position += advance;
 
+    sample->end_time = stream_time_from_position(sample->parent, receive);
+
     sample->update_hr = (sample->position == sample->length) ? S_OK : MS_S_PENDING;
 }
 
@@ -204,9 +218,19 @@ static HRESULT WINAPI IAudioStreamSampleImpl_GetMediaStream(IAudioStreamSample *
 static HRESULT WINAPI IAudioStreamSampleImpl_GetSampleTimes(IAudioStreamSample *iface, STREAM_TIME *start_time,
                                                                  STREAM_TIME *end_time, STREAM_TIME *current_time)
 {
-    FIXME("(%p)->(%p,%p,%p): stub\n", iface, start_time, end_time, current_time);
+    IAudioStreamSampleImpl *sample = impl_from_IAudioStreamSample(iface);
 
-    return E_NOTIMPL;
+    TRACE("sample %p, start_time %p, end_time %p, current_time %p.\n", sample, start_time, end_time, current_time);
+
+    if (current_time)
+        IMediaStreamFilter_GetCurrentStreamTime(sample->parent->filter, current_time);
+
+    if (start_time)
+        *start_time = sample->start_time;
+    if (end_time)
+        *end_time = sample->end_time;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI IAudioStreamSampleImpl_SetSampleTimes(IAudioStreamSample *iface, const STREAM_TIME *start_time,
@@ -1228,6 +1252,8 @@ static HRESULT WINAPI audio_meminput_Receive(IMemInputPin *iface, IMediaSample *
 {
     struct audio_stream *stream = impl_from_IMemInputPin(iface);
     struct queued_receive *receive;
+    REFERENCE_TIME start_time = 0;
+    REFERENCE_TIME end_time = 0;
     BYTE *pointer;
     HRESULT hr;
 
@@ -1253,6 +1279,8 @@ static HRESULT WINAPI audio_meminput_Receive(IMemInputPin *iface, IMediaSample *
         return hr;
     }
 
+    IMediaSample_GetTime(sample, &start_time, &end_time);
+
     receive = calloc(1, sizeof(*receive));
     if (!receive)
     {
@@ -1263,6 +1291,7 @@ static HRESULT WINAPI audio_meminput_Receive(IMemInputPin *iface, IMediaSample *
     receive->length = IMediaSample_GetActualDataLength(sample);
     receive->pointer = pointer;
     receive->sample = sample;
+    receive->start_time = start_time;
     IMediaSample_AddRef(receive->sample);
     list_add_tail(&stream->receive_queue, &receive->entry);
 
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 72ef7912aa9..c7510f30c4d 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -3863,6 +3863,186 @@ void test_audiostreamsample_completion_status(void)
     CloseHandle(event);
 }
 
+static void test_audiostreamsample_get_sample_times(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    static const BYTE test_data[8] = { 0 };
+    IAudioStreamSample *stream_sample;
+    IMediaFilter *graph_media_filter;
+    IAudioMediaStream *audio_stream;
+    STREAM_TIME filter_start_time;
+    IMemInputPin *mem_input_pin;
+    IMediaStreamFilter *filter;
+    IMediaSample *media_sample;
+    struct testfilter source;
+    STREAM_TIME current_time;
+    struct testclock clock;
+    IAudioData *audio_data;
+    STREAM_TIME start_time;
+    STREAM_TIME end_time;
+    IGraphBuilder *graph;
+    IMediaStream *stream;
+    HRESULT hr;
+    ULONG ref;
+    IPin *pin;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!!filter, "Expected non-null filter.\n");
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IAudioMediaStream, (void **)&audio_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IMemInputPin, (void **)&mem_input_pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    hr = IGraphBuilder_QueryInterface(graph, &IID_IMediaFilter, (void **)&graph_media_filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    testfilter_init(&source);
+    hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER, &IID_IAudioData, (void **)&audio_data);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAudioMediaStream_CreateSample(audio_stream, audio_data, 0, &stream_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAudioData_SetBuffer(audio_data, 5, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    testclock_init(&clock);
+
+    clock.time = 12345678;
+
+    current_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, NULL, NULL, &current_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(current_time == 0, "Got current time %s.\n", wine_dbgstr_longlong(current_time));
+
+    IMediaFilter_SetSyncSource(graph_media_filter, &clock.IReferenceClock_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    current_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, NULL, NULL, &current_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(current_time == 0, "Got current time %s.\n", wine_dbgstr_longlong(current_time));
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_GetCurrentStreamTime(filter, &filter_start_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    clock.get_time_hr = E_FAIL;
+
+    current_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, NULL, NULL, &current_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(current_time == 0xdeadbeefddf15da1 + filter_start_time, "Expected current time %s, got %s.\n",
+            wine_dbgstr_longlong(0xdeadbeefddf15da1 + filter_start_time), wine_dbgstr_longlong(current_time));
+
+    clock.get_time_hr = S_OK;
+
+    current_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, NULL, NULL, &current_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(current_time == filter_start_time, "Expected current time %s, got %s.\n",
+            wine_dbgstr_longlong(filter_start_time), wine_dbgstr_longlong(current_time));
+
+    clock.time = 23456789;
+
+    current_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, NULL, NULL, &current_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(current_time == filter_start_time + 11111111, "Expected current time %s, got %s.\n",
+            wine_dbgstr_longlong(filter_start_time + 11111111), wine_dbgstr_longlong(current_time));
+
+    start_time = 0xdeadbeefdeadbeef;
+    end_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, &start_time, &end_time, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(start_time == 0, "Got start time %s.\n", wine_dbgstr_longlong(start_time));
+    ok(end_time == 0, "Got end time %s.\n", wine_dbgstr_longlong(end_time));
+
+    media_sample = audiostream_allocate_sample(&source, test_data, 8);
+    start_time = 12345678;
+    end_time = 23456789;
+    hr = IMediaSample_SetTime(media_sample, &start_time, &end_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(mem_input_pin, media_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    IMediaSample_Release(media_sample);
+
+    hr = IAudioStreamSample_Update(stream_sample, 0, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    start_time = 0xdeadbeefdeadbeef;
+    end_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, &start_time, &end_time, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(start_time == 12345678, "Got start time %s.\n", wine_dbgstr_longlong(start_time));
+    ok(end_time == 12347946, "Got end time %s.\n", wine_dbgstr_longlong(end_time));
+
+    media_sample = audiostream_allocate_sample(&source, test_data, 6);
+    start_time = 12345678;
+    end_time = 23456789;
+    hr = IMediaSample_SetTime(media_sample, &start_time, &end_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(mem_input_pin, media_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    IMediaSample_Release(media_sample);
+
+    hr = IAudioStreamSample_Update(stream_sample, 0, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    start_time = 0xdeadbeefdeadbeef;
+    end_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, &start_time, &end_time, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(start_time == 12347946, "Got start time %s.\n", wine_dbgstr_longlong(start_time));
+    ok(end_time == 12346585, "Got end time %s.\n", wine_dbgstr_longlong(end_time));
+
+    hr = IPin_EndOfStream(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAudioStreamSample_Update(stream_sample, 0, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    start_time = 0xdeadbeefdeadbeef;
+    end_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, &start_time, &end_time, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(start_time == 12346585, "Got start time %s.\n", wine_dbgstr_longlong(start_time));
+    ok(end_time == 12348399, "Got end time %s.\n", wine_dbgstr_longlong(end_time));
+
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    IGraphBuilder_Disconnect(graph, pin);
+    IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
+
+    ref = IAudioStreamSample_Release(stream_sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAudioData_Release(audio_data);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IMediaFilter_Release(graph_media_filter);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin);
+    IMemInputPin_Release(mem_input_pin);
+    IAudioMediaStream_Release(audio_stream);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void test_ddrawstream_initialize(void)
 {
     IDirectDrawMediaStream *ddraw_stream;
@@ -4522,6 +4702,7 @@ START_TEST(amstream)
 
     test_audiostreamsample_update();
     test_audiostreamsample_completion_status();
+    test_audiostreamsample_get_sample_times();
 
     test_ddrawstream_initialize();
 
From b9712f2f37f6648108c608e3e33046a697ef36b4 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Sat, 20 Jun 2020 00:18:52 +0700
Subject: [PATCH] amstream: Implement AMAudioStream::NewSegment.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    |  18 +++--
 dlls/amstream/tests/amstream.c | 119 +++++++++++++++++++++++++++++++--
 2 files changed, 129 insertions(+), 8 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 4c6c326d847..a19cb4ea96f 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -56,6 +56,7 @@ struct audio_stream
     AM_MEDIA_TYPE mt;
     WAVEFORMATEX format;
     FILTER_STATE state;
+    REFERENCE_TIME segment_start;
     BOOL eos;
     BOOL flushing;
     struct list receive_queue;
@@ -1158,9 +1159,18 @@ static HRESULT WINAPI audio_sink_EndFlush(IPin *iface)
 
 static HRESULT WINAPI audio_sink_NewSegment(IPin *iface, REFERENCE_TIME start, REFERENCE_TIME stop, double rate)
 {
-    FIXME("iface %p, start %s, stop %s, rate %0.16e, stub!\n",
-            iface, wine_dbgstr_longlong(start), wine_dbgstr_longlong(stop), rate);
-    return E_NOTIMPL;
+    struct audio_stream *stream = impl_from_IPin(iface);
+
+    TRACE("stream %p, start %s, stop %s, rate %0.16e\n",
+            stream, wine_dbgstr_longlong(start), wine_dbgstr_longlong(stop), rate);
+
+    EnterCriticalSection(&stream->cs);
+
+    stream->segment_start = start;
+
+    LeaveCriticalSection(&stream->cs);
+
+    return S_OK;
 }
 
 static const IPinVtbl audio_sink_vtbl =
@@ -1291,7 +1301,7 @@ static HRESULT WINAPI audio_meminput_Receive(IMemInputPin *iface, IMediaSample *
     receive->length = IMediaSample_GetActualDataLength(sample);
     receive->pointer = pointer;
     receive->sample = sample;
-    receive->start_time = start_time;
+    receive->start_time = start_time + stream->segment_start;
     IMediaSample_AddRef(receive->sample);
     list_add_tail(&stream->receive_queue, &receive->entry);
 
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index c7510f30c4d..eb9b852ba48 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -3440,10 +3440,6 @@ static void test_audiostream_begin_flush_end_flush(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
-static void CALLBACK apc_func(ULONG_PTR param)
-{
-}
-
 static IMediaSample *audiostream_allocate_sample(struct testfilter *source, const BYTE *input_data, DWORD input_length)
 {
     IMediaSample *sample;
@@ -3464,6 +3460,120 @@ static IMediaSample *audiostream_allocate_sample(struct testfilter *source, cons
     return sample;
 }
 
+static void test_audiostream_new_segment(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    static const BYTE test_data[8] = { 0 };
+    IAudioStreamSample *stream_sample;
+    IAudioMediaStream *audio_stream;
+    IMemInputPin *mem_input_pin;
+    IMediaSample *media_sample;
+    struct testfilter source;
+    IAudioData *audio_data;
+    STREAM_TIME start_time;
+    STREAM_TIME end_time;
+    IGraphBuilder *graph;
+    IMediaStream *stream;
+    HRESULT hr;
+    ULONG ref;
+    IPin *pin;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IAudioMediaStream, (void **)&audio_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IMemInputPin, (void **)&mem_input_pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    testfilter_init(&source);
+    hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER, &IID_IAudioData, (void **)&audio_data);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAudioMediaStream_CreateSample(audio_stream, audio_data, 0, &stream_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAudioData_SetBuffer(audio_data, 5, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &audio_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_NewSegment(pin, 11111111, 22222222, 1.0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    media_sample = audiostream_allocate_sample(&source, test_data, 5);
+    start_time = 12345678;
+    end_time = 23456789;
+    hr = IMediaSample_SetTime(media_sample, &start_time, &end_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(mem_input_pin, media_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    IMediaSample_Release(media_sample);
+
+    hr = IAudioStreamSample_Update(stream_sample, 0, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    start_time = 0xdeadbeefdeadbeef;
+    end_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, &start_time, &end_time, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(start_time == 23456789, "Got start time %s.\n", wine_dbgstr_longlong(start_time));
+    ok(end_time == 23459057, "Got end time %s.\n", wine_dbgstr_longlong(end_time));
+
+    hr = IPin_NewSegment(pin, 11111111, 22222222, 2.0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    media_sample = audiostream_allocate_sample(&source, test_data, 5);
+    start_time = 12345678;
+    end_time = 23456789;
+    hr = IMediaSample_SetTime(media_sample, &start_time, &end_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemInputPin_Receive(mem_input_pin, media_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    IMediaSample_Release(media_sample);
+
+    hr = IAudioStreamSample_Update(stream_sample, 0, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    start_time = 0xdeadbeefdeadbeef;
+    end_time = 0xdeadbeefdeadbeef;
+    hr = IAudioStreamSample_GetSampleTimes(stream_sample, &start_time, &end_time, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(start_time == 23456789, "Got start time %s.\n", wine_dbgstr_longlong(start_time));
+    ok(end_time == 23459057, "Got end time %s.\n", wine_dbgstr_longlong(end_time));
+
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    IGraphBuilder_Disconnect(graph, pin);
+    IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
+
+    ref = IAudioStreamSample_Release(stream_sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAudioData_Release(audio_data);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin);
+    IMemInputPin_Release(mem_input_pin);
+    IAudioMediaStream_Release(audio_stream);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void CALLBACK apc_func(ULONG_PTR param)
+{
+}
+
 static IPin *audiostream_pin;
 static IMemInputPin *audiostream_mem_input_pin;
 static IMediaSample *audiostream_media_sample;
@@ -4699,6 +4809,7 @@ START_TEST(amstream)
     test_audiostream_receive();
     test_audiostream_initialize();
     test_audiostream_begin_flush_end_flush();
+    test_audiostream_new_segment();
 
     test_audiostreamsample_update();
     test_audiostreamsample_completion_status();
From 717784efc949da34709a44f46157cbb5b620991a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 19 Jun 2020 19:50:12 -0500
Subject: [PATCH] quartz/vmr9: Merge VMR9_SendSampleData() into
 VMR9_DoRenderSample().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 155 ++++++++++++++++++++++-----------------------
 1 file changed, 76 insertions(+), 79 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 6b653e56092..f81d8067059 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -207,89 +207,41 @@ static inline struct quartz_vmr *impl_from_IBaseFilter(IBaseFilter *iface)
     return CONTAINING_RECORD(iface, struct quartz_vmr, renderer.filter.IBaseFilter_iface);
 }
 
-static DWORD VMR9_SendSampleData(struct quartz_vmr *This, VMR9PresentationInfo *info, LPBYTE data,
-                                 DWORD size)
+static HRESULT WINAPI VMR9_DoRenderSample(struct strmbase_renderer *iface, IMediaSample *sample)
 {
-    const BITMAPINFOHEADER *bmiHeader = get_bitmap_header(&This->renderer.sink.pin.mt);
-    HRESULT hr = S_OK;
-    int width;
-    int height;
-    D3DLOCKED_RECT lock;
-
-    TRACE("%p %p %d\n", This, data, size);
-
-    width = bmiHeader->biWidth;
-    height = bmiHeader->biHeight;
-
-    hr = IDirect3DSurface9_LockRect(info->lpSurf, &lock, NULL, D3DLOCK_DISCARD);
-    if (FAILED(hr))
-    {
-        ERR("IDirect3DSurface9_LockRect failed (%x)\n",hr);
-        return hr;
-    }
-
-    if (height > 0) {
-        /* Bottom up image needs inverting */
-        lock.pBits = (char *)lock.pBits + (height * lock.Pitch);
-        while (height--)
-        {
-            lock.pBits = (char *)lock.pBits - lock.Pitch;
-            memcpy(lock.pBits, data, width * bmiHeader->biBitCount / 8);
-            data = data + width * bmiHeader->biBitCount / 8;
-        }
-    }
-    else if (lock.Pitch != width * bmiHeader->biBitCount / 8)
-    {
-        WARN("Slow path! %u/%u\n", lock.Pitch, width * bmiHeader->biBitCount/8);
-
-        while (height--)
-        {
-            memcpy(lock.pBits, data, width * bmiHeader->biBitCount / 8);
-            data = data + width * bmiHeader->biBitCount / 8;
-            lock.pBits = (char *)lock.pBits + lock.Pitch;
-        }
-    }
-    else memcpy(lock.pBits, data, size);
-
-    IDirect3DSurface9_UnlockRect(info->lpSurf);
-
-    hr = IVMRImagePresenter9_PresentImage(This->presenter, This->cookie, info);
-    return hr;
-}
-
-static HRESULT WINAPI VMR9_DoRenderSample(struct strmbase_renderer *iface, IMediaSample *pSample)
-{
-    struct quartz_vmr *This = impl_from_IBaseFilter(&iface->filter.IBaseFilter_iface);
-    const HANDLE events[2] = {This->run_event, This->renderer.flush_event};
+    struct quartz_vmr *filter = impl_from_IBaseFilter(&iface->filter.IBaseFilter_iface);
+    const HANDLE events[2] = {filter->run_event, filter->renderer.flush_event};
+    const BITMAPINFOHEADER *bitmap_header;
+    unsigned int data_size, width, depth;
+    REFERENCE_TIME start_time, end_time;
     VMR9PresentationInfo info = {};
-    LPBYTE pbSrcStream = NULL;
-    long cbSrcStream = 0;
-    REFERENCE_TIME tStart, tStop;
+    D3DLOCKED_RECT locked_rect;
+    BYTE *data = NULL;
     HRESULT hr;
+    int height;
 
-    TRACE("%p %p\n", iface, pSample);
+    TRACE("filter %p, sample %p.\n", filter, sample);
 
     /* It is possible that there is no device at this point */
 
-    if (!This->allocator || !This->presenter)
+    if (!filter->allocator || !filter->presenter)
     {
         ERR("NO PRESENTER!!\n");
         return S_FALSE;
     }
 
-    hr = IMediaSample_GetTime(pSample, &tStart, &tStop);
-    if (FAILED(hr))
-        info.dwFlags = VMR9Sample_SrcDstRectsValid;
-    else
-        info.dwFlags = VMR9Sample_SrcDstRectsValid | VMR9Sample_TimeValid;
+    info.dwFlags = VMR9Sample_SrcDstRectsValid;
 
-    if (IMediaSample_IsDiscontinuity(pSample) == S_OK)
+    if (SUCCEEDED(hr = IMediaSample_GetTime(sample, &start_time, &end_time)))
+        info.dwFlags |= VMR9Sample_TimeValid;
+
+    if (IMediaSample_IsDiscontinuity(sample) == S_OK)
         info.dwFlags |= VMR9Sample_Discontinuity;
 
-    if (IMediaSample_IsPreroll(pSample) == S_OK)
+    if (IMediaSample_IsPreroll(sample) == S_OK)
         info.dwFlags |= VMR9Sample_Preroll;
 
-    if (IMediaSample_IsSyncPoint(pSample) == S_OK)
+    if (IMediaSample_IsSyncPoint(sample) == S_OK)
         info.dwFlags |= VMR9Sample_SyncPoint;
 
     /* If we render ourselves, and this is a preroll sample, discard it */
@@ -298,28 +250,73 @@ static HRESULT WINAPI VMR9_DoRenderSample(struct strmbase_renderer *iface, IMedi
         return S_OK;
     }
 
-    hr = IMediaSample_GetPointer(pSample, &pbSrcStream);
-    if (FAILED(hr))
+    if (FAILED(hr = IMediaSample_GetPointer(sample, &data)))
     {
-        ERR("Cannot get pointer to sample data (%x)\n", hr);
+        ERR("Failed to get pointer to sample data, hr %#x.\n", hr);
         return hr;
     }
+    data_size = IMediaSample_GetActualDataLength(sample);
 
-    cbSrcStream = IMediaSample_GetActualDataLength(pSample);
+    bitmap_header = get_bitmap_header(&filter->renderer.sink.pin.mt);
+    width = bitmap_header->biWidth;
+    height = bitmap_header->biHeight;
+    depth = bitmap_header->biBitCount;
 
-    info.rtStart = tStart;
-    info.rtEnd = tStop;
-    info.szAspectRatio.cx = This->bmiheader.biWidth;
-    info.szAspectRatio.cy = This->bmiheader.biHeight;
-    info.lpSurf = This->surfaces[(++This->cur_surface) % This->num_surfaces];
+    info.rtStart = start_time;
+    info.rtEnd = end_time;
+    info.szAspectRatio.cx = width;
+    info.szAspectRatio.cy = height;
+    info.lpSurf = filter->surfaces[(++filter->cur_surface) % filter->num_surfaces];
 
-    VMR9_SendSampleData(This, &info, pbSrcStream, cbSrcStream);
+    if (FAILED(hr = IDirect3DSurface9_LockRect(info.lpSurf, &locked_rect, NULL, D3DLOCK_DISCARD)))
+    {
+        ERR("Failed to lock surface, hr %#x.\n", hr);
+        return hr;
+    }
 
-    if (This->renderer.filter.state == State_Paused)
+    if (height > 0)
+    {
+        BYTE *dst = (BYTE *)locked_rect.pBits + (height * locked_rect.Pitch);
+        const BYTE *src = data;
+
+        TRACE("Inverting image.\n");
+
+        while (height--)
+        {
+            dst -= locked_rect.Pitch;
+            memcpy(dst, src, width * depth / 8);
+            src += width * depth / 8;
+        }
+    }
+    else if (locked_rect.Pitch != width * depth / 8)
     {
-        LeaveCriticalSection(&This->renderer.csRenderLock);
+        BYTE *dst = locked_rect.pBits;
+        const BYTE *src = data;
+
+        TRACE("Source pitch %u does not match dest pitch %u; copying manually.\n",
+                width * depth / 8, locked_rect.Pitch);
+
+        while (height--)
+        {
+            memcpy(dst, src, width * depth / 8);
+            src += width * depth / 8;
+            dst += locked_rect.Pitch;
+        }
+    }
+    else
+    {
+        memcpy(locked_rect.pBits, data, data_size);
+    }
+
+    IDirect3DSurface9_UnlockRect(info.lpSurf);
+
+    hr = IVMRImagePresenter9_PresentImage(filter->presenter, filter->cookie, &info);
+
+    if (filter->renderer.filter.state == State_Paused)
+    {
+        LeaveCriticalSection(&filter->renderer.csRenderLock);
         WaitForMultipleObjects(2, events, FALSE, INFINITE);
-        EnterCriticalSection(&This->renderer.csRenderLock);
+        EnterCriticalSection(&filter->renderer.csRenderLock);
     }
 
     return hr;
From d4178020151b9c70affebc31fe354354585dbb9a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 19 Jun 2020 19:50:13 -0500
Subject: [PATCH] quartz/vmr9: Align the source pitch to a multiple of 4.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index f81d8067059..5c2cf33820d 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -211,8 +211,8 @@ static HRESULT WINAPI VMR9_DoRenderSample(struct strmbase_renderer *iface, IMedi
 {
     struct quartz_vmr *filter = impl_from_IBaseFilter(&iface->filter.IBaseFilter_iface);
     const HANDLE events[2] = {filter->run_event, filter->renderer.flush_event};
+    unsigned int data_size, width, depth, src_pitch;
     const BITMAPINFOHEADER *bitmap_header;
-    unsigned int data_size, width, depth;
     REFERENCE_TIME start_time, end_time;
     VMR9PresentationInfo info = {};
     D3DLOCKED_RECT locked_rect;
@@ -261,6 +261,7 @@ static HRESULT WINAPI VMR9_DoRenderSample(struct strmbase_renderer *iface, IMedi
     width = bitmap_header->biWidth;
     height = bitmap_header->biHeight;
     depth = bitmap_header->biBitCount;
+    src_pitch = ((width * depth / 8) + 3) & ~3;
 
     info.rtStart = start_time;
     info.rtEnd = end_time;
@@ -285,21 +286,21 @@ static HRESULT WINAPI VMR9_DoRenderSample(struct strmbase_renderer *iface, IMedi
         {
             dst -= locked_rect.Pitch;
             memcpy(dst, src, width * depth / 8);
-            src += width * depth / 8;
+            src += src_pitch;
         }
     }
-    else if (locked_rect.Pitch != width * depth / 8)
+    else if (locked_rect.Pitch != src_pitch)
     {
         BYTE *dst = locked_rect.pBits;
         const BYTE *src = data;
 
         TRACE("Source pitch %u does not match dest pitch %u; copying manually.\n",
-                width * depth / 8, locked_rect.Pitch);
+                src_pitch, locked_rect.Pitch);
 
         while (height--)
         {
             memcpy(dst, src, width * depth / 8);
-            src += width * depth / 8;
+            src += src_pitch;
             dst += locked_rect.Pitch;
         }
     }
From 46a6dd0824091ac060b81f346ac7cf0944738c8b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 19 Jun 2020 19:50:14 -0500
Subject: [PATCH] quartz/vmr9: The source pitch is the width of the Y plane for
 planar 4:2:0 formats.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 5c2cf33820d..bee5a107185 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -261,7 +261,11 @@ static HRESULT WINAPI VMR9_DoRenderSample(struct strmbase_renderer *iface, IMedi
     width = bitmap_header->biWidth;
     height = bitmap_header->biHeight;
     depth = bitmap_header->biBitCount;
-    src_pitch = ((width * depth / 8) + 3) & ~3;
+    if (bitmap_header->biCompression == mmioFOURCC('N','V','1','2')
+            || bitmap_header->biCompression == mmioFOURCC('Y','V','1','2'))
+        src_pitch = width;
+    else /* packed YUV (UYVY or YUY2) or RGB */
+        src_pitch = ((width * depth / 8) + 3) & ~3;
 
     info.rtStart = start_time;
     info.rtEnd = end_time;
From c4f92087af906e869253f1d184f414691155d3ab Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 19 Jun 2020 19:50:15 -0500
Subject: [PATCH] quartz/vmr9: Invert only RGB video.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index bee5a107185..d4331d321df 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -279,7 +279,7 @@ static HRESULT WINAPI VMR9_DoRenderSample(struct strmbase_renderer *iface, IMedi
         return hr;
     }
 
-    if (height > 0)
+    if (height > 0 && bitmap_header->biCompression == BI_RGB)
     {
         BYTE *dst = (BYTE *)locked_rect.pBits + (height * locked_rect.Pitch);
         const BYTE *src = data;
@@ -298,6 +298,8 @@ static HRESULT WINAPI VMR9_DoRenderSample(struct strmbase_renderer *iface, IMedi
         BYTE *dst = locked_rect.pBits;
         const BYTE *src = data;
 
+        height = abs(height);
+
         TRACE("Source pitch %u does not match dest pitch %u; copying manually.\n",
                 src_pitch, locked_rect.Pitch);
 
From 4eb58312d6056a21c54b0cb987439c63c796bf9e Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 19 Jun 2020 19:50:16 -0500
Subject: [PATCH] quartz/vmr9: Avoid leaking the surface array on connection
 failure.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index d4331d321df..3636d47702c 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -428,11 +428,14 @@ static HRESULT allocate_surfaces(struct quartz_vmr *filter, const AM_MEDIA_TYPE
             case 32: info.Format = D3DFMT_X8R8G8B8; break;
             default:
                 FIXME("Unhandled bit depth %u.\n", filter->bmiheader.biBitCount);
+                free(filter->surfaces);
                 return E_INVALIDARG;
         }
 
         info.dwFlags = VMR9AllocFlag_TextureSurface;
-        return initialize_device(filter, &info, count);
+        if (FAILED(hr = initialize_device(filter, &info, count)))
+            free(filter->surfaces);
+        return hr;
     }
 
     for (i = 0; i < ARRAY_SIZE(formats); ++i)
@@ -457,6 +460,7 @@ static HRESULT allocate_surfaces(struct quartz_vmr *filter, const AM_MEDIA_TYPE
         }
     }
 
+    free(filter->surfaces);
     return hr;
 }
 
From 339dbc586a75e24f5015333a16c44c8f1c1d3355 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 19 Jun 2020 19:50:17 -0500
Subject: [PATCH] quartz/vmr9: Allow connecting with YUV formats.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr9.c | 2 +-
 dlls/quartz/vmr9.c       | 2 --
 2 files changed, 1 insertion(+), 3 deletions(-)

diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 2641b7a04bb..fae824b827d 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -696,7 +696,7 @@ static void test_media_types(void)
     VIDEOINFOHEADER vih =
     {
         {0}, {0}, 0, 0, 0,
-        {sizeof(BITMAPINFOHEADER), 32, 24, 1, 0, BI_RGB}
+        {sizeof(BITMAPINFOHEADER), 32, 24, 1, 0, 0xdeadbeef}
     };
     IEnumMediaTypes *enummt;
     unsigned int i;
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 3636d47702c..b49b2b67dbb 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -338,8 +338,6 @@ static HRESULT WINAPI VMR9_CheckMediaType(struct strmbase_renderer *iface, const
             && !IsEqualGUID(&mt->formattype, &FORMAT_VideoInfo2))
         return S_FALSE;
 
-    if (get_bitmap_header(mt)->biCompression != BI_RGB)
-        return S_FALSE;
     return S_OK;
 }
 
From ceceba2ec28b8d4a8e4a1db72ce53869cdbf7b67 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 22 Jun 2020 17:56:05 -0500
Subject: [PATCH] quartz/vmr9: Remove support for 8-bit RGB from the VMR7.

This was never correct; 8-bit RGB is always palettized.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index b49b2b67dbb..318d825ac9e 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -419,7 +419,6 @@ static HRESULT allocate_surfaces(struct quartz_vmr *filter, const AM_MEDIA_TYPE
     {
         switch (filter->bmiheader.biBitCount)
         {
-            case 8: info.Format = D3DFMT_R3G3B2; break;
             case 15: info.Format = D3DFMT_X1R5G5B5; break;
             case 16: info.Format = D3DFMT_R5G6B5; break;
             case 24: info.Format = D3DFMT_R8G8B8; break;
From 530cb0da4daf0625508e4d5e0aeb1beb5f9beef1 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 22 Jun 2020 17:56:06 -0500
Subject: [PATCH] quartz/vmr9: Remove support for 15-bit RGB from the VMR7.

This was never correct; 15-bit RGB has a biBitCount of 16.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 318d825ac9e..d290d02ce7f 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -419,7 +419,6 @@ static HRESULT allocate_surfaces(struct quartz_vmr *filter, const AM_MEDIA_TYPE
     {
         switch (filter->bmiheader.biBitCount)
         {
-            case 15: info.Format = D3DFMT_X1R5G5B5; break;
             case 16: info.Format = D3DFMT_R5G6B5; break;
             case 24: info.Format = D3DFMT_R8G8B8; break;
             case 32: info.Format = D3DFMT_X8R8G8B8; break;
From 6e8b2dcc260f349a9d563806eb72681748f947be Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 22 Jun 2020 17:56:07 -0500
Subject: [PATCH] quartz/vmr9: Remove support for 16-bit RGB from the VMR7.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index d290d02ce7f..09d63b6a71c 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -419,7 +419,6 @@ static HRESULT allocate_surfaces(struct quartz_vmr *filter, const AM_MEDIA_TYPE
     {
         switch (filter->bmiheader.biBitCount)
         {
-            case 16: info.Format = D3DFMT_R5G6B5; break;
             case 24: info.Format = D3DFMT_R8G8B8; break;
             case 32: info.Format = D3DFMT_X8R8G8B8; break;
             default:
From 1bdfa9ca79b9026f4e2d3d5d3301cc08ce4f8c34 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 23 Jun 2020 11:18:01 -0500
Subject: [PATCH] amstream: Store parent as struct ddraw_stream in ddraw stream
 sample.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c | 27 ++++++++++++++-------------
 1 file changed, 14 insertions(+), 13 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index c471a66200d..0bfbe653e7e 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -28,9 +28,6 @@ WINE_DEFAULT_DEBUG_CHANNEL(amstream);
 
 static const WCHAR sink_id[] = L"I{A35FF56A-9FDA-11D0-8FDF-00C04FD9189D}";
 
-static HRESULT ddrawstreamsample_create(IDirectDrawMediaStream *parent, IDirectDrawSurface *surface,
-    const RECT *rect, IDirectDrawStreamSample **ddraw_stream_sample);
-
 struct ddraw_stream
 {
     IAMMediaStream IAMMediaStream_iface;
@@ -51,6 +48,9 @@ struct ddraw_stream
     AM_MEDIA_TYPE mt;
 };
 
+static HRESULT ddrawstreamsample_create(struct ddraw_stream *parent, IDirectDrawSurface *surface,
+    const RECT *rect, IDirectDrawStreamSample **ddraw_stream_sample);
+
 static inline struct ddraw_stream *impl_from_IAMMediaStream(IAMMediaStream *iface)
 {
     return CONTAINING_RECORD(iface, struct ddraw_stream, IAMMediaStream_iface);
@@ -401,12 +401,15 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SetDirectDraw(IDirectDrawMedi
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_CreateSample(IDirectDrawMediaStream *iface,
-        IDirectDrawSurface *surface, const RECT *rect, DWORD dwFlags,
-        IDirectDrawStreamSample **ppSample)
+        IDirectDrawSurface *surface, const RECT *rect, DWORD flags,
+        IDirectDrawStreamSample **sample)
 {
-    TRACE("(%p)->(%p,%s,%x,%p)\n", iface, surface, wine_dbgstr_rect(rect), dwFlags, ppSample);
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+
+    TRACE("stream %p, surface %p, rect %s, flags %#x, sample %p.\n",
+            stream, surface, wine_dbgstr_rect(rect), flags, sample);
 
-    return ddrawstreamsample_create(iface, surface, rect, ppSample);
+    return ddrawstreamsample_create(stream, surface, rect, sample);
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetTimePerFrame(IDirectDrawMediaStream *iface,
@@ -959,7 +962,7 @@ struct ddraw_sample
 {
     IDirectDrawStreamSample IDirectDrawStreamSample_iface;
     LONG ref;
-    IMediaStream *parent;
+    struct ddraw_stream *parent;
     IDirectDrawSurface *surface;
     RECT rect;
 };
@@ -1011,7 +1014,6 @@ static ULONG WINAPI ddraw_sample_Release(IDirectDrawStreamSample *iface)
     {
         if (sample->surface)
             IDirectDrawSurface_Release(sample->surface);
-        IMediaStream_Release(sample->parent);
         HeapFree(GetProcessHeap(), 0, sample);
     }
 
@@ -1102,7 +1104,7 @@ static const struct IDirectDrawStreamSampleVtbl DirectDrawStreamSample_Vtbl =
     ddraw_sample_SetRect
 };
 
-static HRESULT ddrawstreamsample_create(IDirectDrawMediaStream *parent, IDirectDrawSurface *surface,
+static HRESULT ddrawstreamsample_create(struct ddraw_stream *parent, IDirectDrawSurface *surface,
     const RECT *rect, IDirectDrawStreamSample **ddraw_stream_sample)
 {
     struct ddraw_sample *object;
@@ -1116,8 +1118,7 @@ static HRESULT ddrawstreamsample_create(IDirectDrawMediaStream *parent, IDirectD
 
     object->IDirectDrawStreamSample_iface.lpVtbl = &DirectDrawStreamSample_Vtbl;
     object->ref = 1;
-    object->parent = (IMediaStream*)parent;
-    IMediaStream_AddRef(object->parent);
+    object->parent = parent;
 
     if (surface)
     {
@@ -1129,7 +1130,7 @@ static HRESULT ddrawstreamsample_create(IDirectDrawMediaStream *parent, IDirectD
         DDSURFACEDESC desc;
         IDirectDraw *ddraw;
 
-        hr = IDirectDrawMediaStream_GetDirectDraw(parent, &ddraw);
+        hr = IDirectDrawMediaStream_GetDirectDraw(&parent->IDirectDrawMediaStream_iface, &ddraw);
         if (FAILED(hr))
         {
             IDirectDrawStreamSample_Release(&object->IDirectDrawStreamSample_iface);
From 3328f7f7ca121f35b6da7a4d5624d8d50be1abba Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Mon, 22 Jun 2020 17:53:33 -0500
Subject: [PATCH] amstream/tests: Add IDirectDrawMediaStream::SetDirectDraw()
 tests.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 150 +++++++++++++++++++++++++++++----
 1 file changed, 133 insertions(+), 17 deletions(-)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index eb9b852ba48..1259de927df 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -2013,8 +2013,6 @@ static void test_IDirectDrawStreamSample(void)
     DDSURFACEDESC desc = { sizeof(desc) };
     IAMMultiMediaStream *mmstream;
     IDirectDrawSurface7 *surface7;
-    IDirectDraw *ddraw, *ddraw2;
-    IDirectDraw7 *ddraw7;
     HRESULT hr;
     RECT rect;
 
@@ -2040,21 +2038,6 @@ static void test_IDirectDrawStreamSample(void)
     ok(hr == S_OK, "got 0x%08x\n", hr);
     if (FAILED(hr)) goto error;
 
-    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-
-    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw2);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-    ok(ddraw == ddraw2, "got %p, %p\n", ddraw, ddraw2);
-
-    hr = IDirectDraw_QueryInterface(ddraw, &IID_IDirectDraw7, (void **)&ddraw7);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-    ok(ddraw7 == pdd7, "Got IDirectDraw instance %p, expected %p.\n", ddraw7, pdd7);
-    IDirectDraw7_Release(ddraw7);
-
-    IDirectDraw_Release(ddraw2);
-    IDirectDraw_Release(ddraw);
-
     hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, &sample);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
@@ -4768,6 +4751,138 @@ static void test_mediastreamfilter_get_current_stream_time(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_ddrawstream_getsetdirectdraw(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IDirectDraw *ddraw, *ddraw2, *ddraw3, *ddraw4;
+    IDirectDrawMediaStream *ddraw_stream;
+    IDirectDrawStreamSample *sample;
+    IDirectDraw7 *ddraw7;
+    IMediaStream *stream;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = DirectDrawCreate(NULL, &ddraw, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IDirectDraw_QueryInterface(ddraw, &IID_IDirectDraw7, (void **)&ddraw7);
+    ok(hr == DD_OK, "Got hr %#x.\n", hr);
+    hr = IDirectDraw7_SetCooperativeLevel(ddraw7, GetDesktopWindow(), DDSCL_NORMAL);
+    ok(hr == DD_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(ddraw, 1);
+    EXPECT_REF(ddraw7, 1);
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)ddraw7, &MSPID_PrimaryVideo, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine EXPECT_REF(ddraw, 2);
+
+    hr = IMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (void **)&ddraw_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, NULL);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(ddraw2 == ddraw, "Expected ddraw %p, got %p.\n", ddraw, ddraw2);
+    todo_wine EXPECT_REF(ddraw, 3);
+
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(ddraw3 == ddraw2, "Expected ddraw %p, got %p.\n", ddraw2, ddraw3);
+    todo_wine EXPECT_REF(ddraw, 4);
+    IDirectDraw_Release(ddraw3);
+    todo_wine EXPECT_REF(ddraw, 3);
+
+    /* The current ddraw is released when SetDirectDraw() is called. */
+    hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, NULL);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(ddraw, 2);
+
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(ddraw3 == NULL, "Expected NULL, got %p.\n", ddraw3);
+    if (ddraw3) IDirectDraw_Release(ddraw3);
+
+    hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw2);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine EXPECT_REF(ddraw, 3);
+
+    if (hr == S_OK)
+    {
+        hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw3);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(ddraw3 == ddraw2, "Expected ddraw %p, got %p.\n", ddraw2, ddraw3);
+        EXPECT_REF(ddraw, 4);
+        IDirectDraw_Release(ddraw3);
+        EXPECT_REF(ddraw, 3);
+
+        hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, &sample);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+         /* SetDirectDraw() doesn't take an extra reference to the ddraw object
+          * if there are samples extant. */
+        hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw2);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        EXPECT_REF(ddraw, 3);
+
+        hr = DirectDrawCreate(NULL, &ddraw3, NULL);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        hr = IDirectDraw_SetCooperativeLevel(ddraw3, GetDesktopWindow(), DDSCL_NORMAL);
+        ok(hr == DD_OK, "Got hr %#x.\n", hr);
+        EXPECT_REF(ddraw3, 1);
+
+        hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw3);
+        ok(hr == MS_E_SAMPLEALLOC, "Got hr %#x.\n", hr);
+
+        hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw4);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(ddraw4 == ddraw2, "Expected ddraw %p, got %p.\n", ddraw2, ddraw4);
+        EXPECT_REF(ddraw, 4);
+        IDirectDraw_Release(ddraw4);
+        EXPECT_REF(ddraw, 3);
+
+        ref = IDirectDrawStreamSample_Release(sample);
+        ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+        hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw3);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        EXPECT_REF(ddraw, 2);
+        EXPECT_REF(ddraw3, 2);
+
+        hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw4);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(ddraw4 == ddraw3, "Expected ddraw %p, got %p.\n", ddraw3, ddraw4);
+        EXPECT_REF(ddraw3, 3);
+        IDirectDraw_Release(ddraw4);
+        EXPECT_REF(ddraw3, 2);
+
+        hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, NULL);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        EXPECT_REF(ddraw3, 1);
+
+        ref = IDirectDraw_Release(ddraw3);
+        ok(!ref, "Got outstanding refcount %d.\n", ref);
+    }
+
+    EXPECT_REF(stream, 3);
+    IDirectDrawMediaStream_Release(ddraw_stream);
+    EXPECT_REF(stream, 2);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    EXPECT_REF(stream, 1);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IDirectDraw7_Release(ddraw7);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IDirectDraw_Release(ddraw2);
+    EXPECT_REF(ddraw, 1);
+    ref = IDirectDraw_Release(ddraw);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(amstream)
 {
     HANDLE file;
@@ -4816,6 +4931,7 @@ START_TEST(amstream)
     test_audiostreamsample_get_sample_times();
 
     test_ddrawstream_initialize();
+    test_ddrawstream_getsetdirectdraw();
 
     test_ammediastream_join_am_multi_media_stream();
 
From 69c69143be02ce2e421fc6db384b47daa6060e7b Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 23 Jun 2020 11:18:02 -0500
Subject: [PATCH] amstream: Implement
 IDirectDrawStreamSample::GetMediaStream().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    | 12 ++++++++++--
 dlls/amstream/tests/amstream.c |  8 ++++----
 2 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 0bfbe653e7e..ca6a910f3f9 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -1023,9 +1023,17 @@ static ULONG WINAPI ddraw_sample_Release(IDirectDrawStreamSample *iface)
 /*** IStreamSample methods ***/
 static HRESULT WINAPI ddraw_sample_GetMediaStream(IDirectDrawStreamSample *iface, IMediaStream **media_stream)
 {
-    FIXME("(%p)->(%p): stub\n", iface, media_stream);
+    struct ddraw_sample *sample = impl_from_IDirectDrawStreamSample(iface);
 
-    return E_NOTIMPL;
+    TRACE("sample %p, media_stream %p.\n", sample, media_stream);
+
+    if (!media_stream)
+        return E_POINTER;
+
+    IAMMediaStream_AddRef(&sample->parent->IAMMediaStream_iface);
+    *media_stream = (IMediaStream *)&sample->parent->IAMMediaStream_iface;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI ddraw_sample_GetSampleTimes(IDirectDrawStreamSample *iface, STREAM_TIME *start_time,
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 1259de927df..03c8660a424 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -2050,13 +2050,13 @@ static void test_IDirectDrawStreamSample(void)
     if (0)
     {
         hr = IDirectDrawStreamSample_GetMediaStream(sample, NULL);
-        ok(hr == E_POINTER, "got 0x%08x\n", hr);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     }
 
     hr = IDirectDrawStreamSample_GetMediaStream(sample, &stream2);
-    todo_wine ok(hr == S_OK, "got 0x%08x\n", hr);
-    todo_wine ok(stream2 == stream, "Expected stream %p, got %p.\n", stream, stream2);
-    if (hr == S_OK) IMediaStream_Release(stream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(stream2 == stream, "Expected stream %p, got %p.\n", stream, stream2);
+    IMediaStream_Release(stream2);
 
     hr = IDirectDrawSurface_QueryInterface(surface, &IID_IDirectDrawSurface7, (void **)&surface7);
     ok(hr == S_OK, "got 0x%08x\n", hr);
From 7595461f77a58d2864d4217adba5c8019671d18a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 24 Jun 2020 16:52:41 -0500
Subject: [PATCH] quartz/vmr9: Return VFW_E_TYPE_NOT_ACCEPTED when connection
 fails.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr7.c |  8 ++------
 dlls/quartz/tests/vmr9.c | 14 ++------------
 dlls/quartz/vmr9.c       |  4 ++--
 3 files changed, 6 insertions(+), 20 deletions(-)

diff --git a/dlls/quartz/tests/vmr7.c b/dlls/quartz/tests/vmr7.c
index 1f0af817f0b..4422a1f9140 100644
--- a/dlls/quartz/tests/vmr7.c
+++ b/dlls/quartz/tests/vmr7.c
@@ -1366,12 +1366,8 @@ static void test_connect_pin(void)
 
     vih.bmiHeader.biBitCount = 16;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
-    if (hr == S_OK)
-    {
-        IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-        IFilterGraph2_Disconnect(graph, pin);
-    }
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+
     vih.bmiHeader.biBitCount = 32;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
     if (hr == VFW_E_TYPE_NOT_ACCEPTED) /* w7u */
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index fae824b827d..69065d35761 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -1618,20 +1618,10 @@ static void test_connect_pin(void)
 
     req_mt.subtype = MEDIASUBTYPE_RGB8;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
-    if (hr == S_OK)
-    {
-        IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-        IFilterGraph2_Disconnect(graph, pin);
-    }
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_WAVE;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
-    if (hr == S_OK)
-    {
-        IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-        IFilterGraph2_Disconnect(graph, pin);
-    }
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_RGB32;
 
     peer = (IPin *)0xdeadbeef;
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 09d63b6a71c..e49266c30c2 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -424,7 +424,7 @@ static HRESULT allocate_surfaces(struct quartz_vmr *filter, const AM_MEDIA_TYPE
             default:
                 FIXME("Unhandled bit depth %u.\n", filter->bmiheader.biBitCount);
                 free(filter->surfaces);
-                return E_INVALIDARG;
+                return VFW_E_TYPE_NOT_ACCEPTED;
         }
 
         info.dwFlags = VMR9AllocFlag_TextureSurface;
@@ -456,7 +456,7 @@ static HRESULT allocate_surfaces(struct quartz_vmr *filter, const AM_MEDIA_TYPE
     }
 
     free(filter->surfaces);
-    return hr;
+    return VFW_E_TYPE_NOT_ACCEPTED;
 }
 
 static void vmr_start_stream(struct strmbase_renderer *iface)
From 8fcdca9dd533b1bd74eb41bcca87e354198bef6f Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 24 Jun 2020 16:52:42 -0500
Subject: [PATCH] quartz/vmr9: Support YUV formats in the VMR7.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 36 +++++++++++++++++++++++++++---------
 1 file changed, 27 insertions(+), 9 deletions(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index e49266c30c2..e4db42223e9 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -417,17 +417,35 @@ static HRESULT allocate_surfaces(struct quartz_vmr *filter, const AM_MEDIA_TYPE
 
     if (!is_vmr9(filter))
     {
-        switch (filter->bmiheader.biBitCount)
+        switch (filter->bmiheader.biCompression)
         {
-            case 24: info.Format = D3DFMT_R8G8B8; break;
-            case 32: info.Format = D3DFMT_X8R8G8B8; break;
-            default:
-                FIXME("Unhandled bit depth %u.\n", filter->bmiheader.biBitCount);
-                free(filter->surfaces);
-                return VFW_E_TYPE_NOT_ACCEPTED;
-        }
+        case BI_RGB:
+            switch (filter->bmiheader.biBitCount)
+            {
+                case 24: info.Format = D3DFMT_R8G8B8; break;
+                case 32: info.Format = D3DFMT_X8R8G8B8; break;
+                default:
+                    FIXME("Unhandled bit depth %u.\n", filter->bmiheader.biBitCount);
+                    free(filter->surfaces);
+                    return VFW_E_TYPE_NOT_ACCEPTED;
+            }
+
+            info.dwFlags = VMR9AllocFlag_TextureSurface;
+            break;
 
-        info.dwFlags = VMR9AllocFlag_TextureSurface;
+        case mmioFOURCC('N','V','1','2'):
+        case mmioFOURCC('U','Y','V','Y'):
+        case mmioFOURCC('Y','U','Y','2'):
+        case mmioFOURCC('Y','V','1','2'):
+            info.Format = filter->bmiheader.biCompression;
+            info.dwFlags = VMR9AllocFlag_OffscreenSurface;
+            break;
+
+        default:
+            WARN("Unhandled video compression %#x.\n", filter->bmiheader.biCompression);
+            free(filter->surfaces);
+            return VFW_E_TYPE_NOT_ACCEPTED;
+        }
         if (FAILED(hr = initialize_device(filter, &info, count)))
             free(filter->surfaces);
         return hr;
From 667af9a2c2d7a084298697a20a930c008163d13d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 24 Jun 2020 16:52:43 -0500
Subject: [PATCH] quartz: Change the merit of the default video renderer to
 0x800001.

To match Windows.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/regsvr.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/quartz/regsvr.c b/dlls/quartz/regsvr.c
index 7bae46cb847..f867c4178a6 100644
--- a/dlls/quartz/regsvr.c
+++ b/dlls/quartz/regsvr.c
@@ -189,7 +189,7 @@ static struct regsvr_filter const filter_list[] = {
     {   &CLSID_VideoRendererDefault,
         &CLSID_LegacyAmFilterCategory,
         L"Video Renderer",
-        0x800000,
+        0x800001,
         {   {   REG_PINFLAG_B_RENDERER,
                 {   { &MEDIATYPE_Video, &GUID_NULL },
                     { NULL }
From 79c3a24a087b2f73fac42f5218c318fd4d4e4b06 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 24 Jun 2020 16:52:44 -0500
Subject: [PATCH] quartz: Don't register the VMR7.

Oddly, Windows doesn't either.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/regsvr.c | 12 ------------
 1 file changed, 12 deletions(-)

diff --git a/dlls/quartz/regsvr.c b/dlls/quartz/regsvr.c
index f867c4178a6..92555630e9e 100644
--- a/dlls/quartz/regsvr.c
+++ b/dlls/quartz/regsvr.c
@@ -198,18 +198,6 @@ static struct regsvr_filter const filter_list[] = {
             { 0xFFFFFFFF },
         }
     },
-    {   &CLSID_VideoMixingRenderer,
-        &CLSID_LegacyAmFilterCategory,
-        L"Video Mixing Renderer",
-        0x200000,
-        {   {   REG_PINFLAG_B_RENDERER,
-                {   { &MEDIATYPE_Video, &GUID_NULL },
-                    { NULL }
-                },
-            },
-            { 0xFFFFFFFF },
-        }
-    },
     {   &CLSID_VideoMixingRenderer9,
         &CLSID_LegacyAmFilterCategory,
         L"Video Mixing Renderer 9",
From 3667754aa2a5fb42ac01aa3820436a2d04e6089f Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 25 Jun 2020 22:21:09 +0700
Subject: [PATCH] qasf/dmowrapper: Don't crash in ::Stop when DMO wrapper is
 not initialized.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qasf/dmowrapper.c       |  3 +++
 dlls/qasf/tests/dmowrapper.c | 18 ++++++++++++++++++
 2 files changed, 21 insertions(+)

diff --git a/dlls/qasf/dmowrapper.c b/dlls/qasf/dmowrapper.c
index e2d40638283..8cf4404ece1 100644
--- a/dlls/qasf/dmowrapper.c
+++ b/dlls/qasf/dmowrapper.c
@@ -673,6 +673,9 @@ static HRESULT dmo_wrapper_cleanup_stream(struct strmbase_filter *iface)
     IMediaObject *dmo;
     DWORD i;
 
+    if (!filter->dmo)
+        return E_FAIL;
+
     IUnknown_QueryInterface(filter->dmo, &IID_IMediaObject, (void **)&dmo);
 
     for (i = 0; i < filter->source_count; ++i)
diff --git a/dlls/qasf/tests/dmowrapper.c b/dlls/qasf/tests/dmowrapper.c
index 72c05ee49c4..f76c0c3d9d5 100644
--- a/dlls/qasf/tests/dmowrapper.c
+++ b/dlls/qasf/tests/dmowrapper.c
@@ -1995,6 +1995,23 @@ static void test_connect_pin(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_uninitialized(void)
+{
+    IBaseFilter *filter = NULL;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&CLSID_DMOWrapperFilter, NULL,
+            CLSCTX_INPROC_SERVER, &IID_IBaseFilter, (void **)&filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IBaseFilter_Stop(filter);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+
+    ref = IBaseFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(dmowrapper)
 {
     DWORD cookie;
@@ -2022,6 +2039,7 @@ START_TEST(dmowrapper)
     test_media_types();
     test_enum_media_types();
     test_connect_pin();
+    test_uninitialized();
 
     CoRevokeClassObject(cookie);
     DMOUnregister(&testdmo_clsid, &DMOCATEGORY_AUDIO_DECODER);
From 117e13e05ebb5dbdc8562de13545226b08bbf14b Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 25 Jun 2020 22:21:10 +0700
Subject: [PATCH] amstream: Return E_NOTIMPL from
 AMAudioStream::QueryInterface.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    | 2 +-
 dlls/amstream/tests/amstream.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index a19cb4ea96f..60a2572b3ba 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -1073,7 +1073,7 @@ static HRESULT WINAPI audio_sink_QueryId(IPin *iface, WCHAR **id)
 static HRESULT WINAPI audio_sink_QueryAccept(IPin *iface, const AM_MEDIA_TYPE *mt)
 {
     TRACE("iface %p, mt %p.\n", iface, mt);
-    return S_OK;
+    return E_NOTIMPL;
 }
 
 static HRESULT WINAPI audio_sink_EnumMediaTypes(IPin *iface, IEnumMediaTypes **enum_media_types)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 03c8660a424..43da41ae89d 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -1989,7 +1989,7 @@ static void test_media_types(void)
     ok(!memcmp(pmt->pbFormat, &expect_wfx, pmt->cbFormat), "Format blocks didn't match.\n");
 
     hr = IPin_QueryAccept(pin, pmt);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     CoTaskMemFree(pmt);
 
From 84566a0cc17de361376c75a2ce15578feeff5ae1 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Thu, 25 Jun 2020 20:56:58 +0200
Subject: [PATCH] amstream: Use IDirectDraw instead of IDirectDraw7 internally.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    | 35 ++++++++++++++++++----------------
 dlls/amstream/tests/amstream.c | 12 ++++++------
 2 files changed, 25 insertions(+), 22 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index ca6a910f3f9..f1b6d37d08e 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -39,7 +39,7 @@ struct ddraw_stream
     IMultiMediaStream* parent;
     MSPID purpose_id;
     STREAM_TYPE stream_type;
-    IDirectDraw7 *ddraw;
+    IDirectDraw *ddraw;
     CRITICAL_SECTION cs;
     IMediaStreamFilter *filter;
 
@@ -107,17 +107,17 @@ static ULONG WINAPI ddraw_IAMMediaStream_AddRef(IAMMediaStream *iface)
 
 static ULONG WINAPI ddraw_IAMMediaStream_Release(IAMMediaStream *iface)
 {
-    struct ddraw_stream *This = impl_from_IAMMediaStream(iface);
-    ULONG ref = InterlockedDecrement(&This->ref);
+    struct ddraw_stream *stream = impl_from_IAMMediaStream(iface);
+    ULONG ref = InterlockedDecrement(&stream->ref);
 
-    TRACE("(%p/%p)->(): new ref = %u\n", iface, This, ref);
+    TRACE("%p decreasing refcount to %u.\n", stream, ref);
 
     if (!ref)
     {
-        DeleteCriticalSection(&This->cs);
-        if (This->ddraw)
-            IDirectDraw7_Release(This->ddraw);
-        HeapFree(GetProcessHeap(), 0, This);
+        DeleteCriticalSection(&stream->cs);
+        if (stream->ddraw)
+            IDirectDraw_Release(stream->ddraw);
+        HeapFree(GetProcessHeap(), 0, stream);
     }
 
     return ref;
@@ -214,8 +214,8 @@ static HRESULT WINAPI ddraw_IAMMediaStream_Initialize(IAMMediaStream *iface, IUn
     stream->stream_type = stream_type;
 
     if (source_object
-            && FAILED(hr = IUnknown_QueryInterface(source_object, &IID_IDirectDraw7, (void **)&stream->ddraw)))
-        FIXME("Stream object doesn't implement IDirectDraw7 interface, hr %#x.\n", hr);
+            && FAILED(hr = IUnknown_QueryInterface(source_object, &IID_IDirectDraw, (void **)&stream->ddraw)))
+        FIXME("Stream object doesn't implement IDirectDraw interface, hr %#x.\n", hr);
 
     return S_OK;
 }
@@ -373,23 +373,26 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SetFormat(IDirectDrawMediaStr
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetDirectDraw(IDirectDrawMediaStream *iface,
         IDirectDraw **ddraw)
 {
-    struct ddraw_stream *This = impl_from_IDirectDrawMediaStream(iface);
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
 
-    TRACE("(%p)->(%p)\n", iface, ddraw);
+    TRACE("stream %p, ddraw %p.\n", stream, ddraw);
 
     if (!ddraw)
         return E_POINTER;
 
     *ddraw = NULL;
-    if (!This->ddraw)
+    if (!stream->ddraw)
     {
-        HRESULT hr = DirectDrawCreateEx(NULL, (void**)&This->ddraw, &IID_IDirectDraw7, NULL);
+        HRESULT hr = DirectDrawCreate(NULL, &stream->ddraw, NULL);
         if (FAILED(hr))
             return hr;
-        IDirectDraw7_SetCooperativeLevel(This->ddraw, NULL, DDSCL_NORMAL);
+        IDirectDraw_SetCooperativeLevel(stream->ddraw, NULL, DDSCL_NORMAL);
     }
 
-    return IDirectDraw7_QueryInterface(This->ddraw, &IID_IDirectDraw, (void**)ddraw);
+    IDirectDraw_AddRef(stream->ddraw);
+    *ddraw = stream->ddraw;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SetDirectDraw(IDirectDrawMediaStream *iface,
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 43da41ae89d..d19174f12c0 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -4776,7 +4776,7 @@ static void test_ddrawstream_getsetdirectdraw(void)
 
     hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)ddraw7, &MSPID_PrimaryVideo, 0, &stream);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine EXPECT_REF(ddraw, 2);
+    EXPECT_REF(ddraw, 2);
 
     hr = IMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (void **)&ddraw_stream);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -4787,19 +4787,19 @@ static void test_ddrawstream_getsetdirectdraw(void)
     hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw2);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(ddraw2 == ddraw, "Expected ddraw %p, got %p.\n", ddraw, ddraw2);
-    todo_wine EXPECT_REF(ddraw, 3);
+    EXPECT_REF(ddraw, 3);
 
     hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw3);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(ddraw3 == ddraw2, "Expected ddraw %p, got %p.\n", ddraw2, ddraw3);
-    todo_wine EXPECT_REF(ddraw, 4);
+    EXPECT_REF(ddraw, 4);
     IDirectDraw_Release(ddraw3);
-    todo_wine EXPECT_REF(ddraw, 3);
+    EXPECT_REF(ddraw, 3);
 
     /* The current ddraw is released when SetDirectDraw() is called. */
     hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, NULL);
     todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
-    EXPECT_REF(ddraw, 2);
+    todo_wine EXPECT_REF(ddraw, 2);
 
     hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw3);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -4808,7 +4808,7 @@ static void test_ddrawstream_getsetdirectdraw(void)
 
     hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw2);
     todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine EXPECT_REF(ddraw, 3);
+    EXPECT_REF(ddraw, 3);
 
     if (hr == S_OK)
     {
From 51fce87c607d92300bb6b3f7674e7e6c775c86ff Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Thu, 25 Jun 2020 20:56:59 +0200
Subject: [PATCH] amstream: Implement IDirectDrawMediaStream::SetDirectDraw().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    | 40 ++++++++++++--
 dlls/amstream/tests/amstream.c | 95 ++++++++++++++++------------------
 2 files changed, 83 insertions(+), 52 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index f1b6d37d08e..15bd3af0a9b 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -35,6 +35,7 @@ struct ddraw_stream
     IMemInputPin IMemInputPin_iface;
     IPin IPin_iface;
     LONG ref;
+    LONG sample_refs;
 
     IMultiMediaStream* parent;
     MSPID purpose_id;
@@ -396,11 +397,35 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetDirectDraw(IDirectDrawMedi
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SetDirectDraw(IDirectDrawMediaStream *iface,
-        IDirectDraw *pDirectDraw)
+        IDirectDraw *ddraw)
 {
-    FIXME("(%p)->(%p) stub!\n", iface, pDirectDraw);
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
 
-    return E_NOTIMPL;
+    TRACE("stream %p, ddraw %p.\n", stream, ddraw);
+
+    EnterCriticalSection(&stream->cs);
+
+    if (stream->sample_refs)
+    {
+        HRESULT hr = (stream->ddraw == ddraw) ? S_OK : MS_E_SAMPLEALLOC;
+        LeaveCriticalSection(&stream->cs);
+        return hr;
+    }
+
+    if (stream->ddraw)
+        IDirectDraw_Release(stream->ddraw);
+
+    if (ddraw)
+    {
+        IDirectDraw_AddRef(ddraw);
+        stream->ddraw = ddraw;
+    }
+    else
+        stream->ddraw = NULL;
+
+    LeaveCriticalSection(&stream->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_CreateSample(IDirectDrawMediaStream *iface,
@@ -951,6 +976,7 @@ HRESULT ddraw_stream_create(IUnknown *outer, void **out)
     object->IMemInputPin_iface.lpVtbl = &ddraw_meminput_vtbl;
     object->IPin_iface.lpVtbl = &ddraw_sink_vtbl;
     object->ref = 1;
+    object->sample_refs = 0;
 
     InitializeCriticalSection(&object->cs);
 
@@ -1013,6 +1039,10 @@ static ULONG WINAPI ddraw_sample_Release(IDirectDrawStreamSample *iface)
 
     TRACE("(%p)->(): new ref = %u\n", iface, ref);
 
+    EnterCriticalSection(&sample->parent->cs);
+    InterlockedDecrement(&sample->parent->sample_refs);
+    LeaveCriticalSection(&sample->parent->cs);
+
     if (!ref)
     {
         if (sample->surface)
@@ -1131,6 +1161,10 @@ static HRESULT ddrawstreamsample_create(struct ddraw_stream *parent, IDirectDraw
     object->ref = 1;
     object->parent = parent;
 
+    EnterCriticalSection(&parent->cs);
+    InterlockedIncrement(&parent->sample_refs);
+    LeaveCriticalSection(&parent->cs);
+
     if (surface)
     {
         object->surface = surface;
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index d19174f12c0..5e5b9ac2f5c 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -4798,8 +4798,8 @@ static void test_ddrawstream_getsetdirectdraw(void)
 
     /* The current ddraw is released when SetDirectDraw() is called. */
     hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine EXPECT_REF(ddraw, 2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(ddraw, 2);
 
     hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw3);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -4807,65 +4807,62 @@ static void test_ddrawstream_getsetdirectdraw(void)
     if (ddraw3) IDirectDraw_Release(ddraw3);
 
     hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw2);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     EXPECT_REF(ddraw, 3);
 
-    if (hr == S_OK)
-    {
-        hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw3);
-        ok(hr == S_OK, "Got hr %#x.\n", hr);
-        ok(ddraw3 == ddraw2, "Expected ddraw %p, got %p.\n", ddraw2, ddraw3);
-        EXPECT_REF(ddraw, 4);
-        IDirectDraw_Release(ddraw3);
-        EXPECT_REF(ddraw, 3);
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(ddraw3 == ddraw2, "Expected ddraw %p, got %p.\n", ddraw2, ddraw3);
+    EXPECT_REF(ddraw, 4);
+    IDirectDraw_Release(ddraw3);
+    EXPECT_REF(ddraw, 3);
 
-        hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, &sample);
-        ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, &sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-         /* SetDirectDraw() doesn't take an extra reference to the ddraw object
-          * if there are samples extant. */
-        hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw2);
-        ok(hr == S_OK, "Got hr %#x.\n", hr);
-        EXPECT_REF(ddraw, 3);
+     /* SetDirectDraw() doesn't take an extra reference to the ddraw object
+      * if there are samples extant. */
+    hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(ddraw, 3);
 
-        hr = DirectDrawCreate(NULL, &ddraw3, NULL);
-        ok(hr == S_OK, "Got hr %#x.\n", hr);
-        hr = IDirectDraw_SetCooperativeLevel(ddraw3, GetDesktopWindow(), DDSCL_NORMAL);
-        ok(hr == DD_OK, "Got hr %#x.\n", hr);
-        EXPECT_REF(ddraw3, 1);
+    hr = DirectDrawCreate(NULL, &ddraw3, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IDirectDraw_SetCooperativeLevel(ddraw3, GetDesktopWindow(), DDSCL_NORMAL);
+    ok(hr == DD_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(ddraw3, 1);
 
-        hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw3);
-        ok(hr == MS_E_SAMPLEALLOC, "Got hr %#x.\n", hr);
+    hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw3);
+    ok(hr == MS_E_SAMPLEALLOC, "Got hr %#x.\n", hr);
 
-        hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw4);
-        ok(hr == S_OK, "Got hr %#x.\n", hr);
-        ok(ddraw4 == ddraw2, "Expected ddraw %p, got %p.\n", ddraw2, ddraw4);
-        EXPECT_REF(ddraw, 4);
-        IDirectDraw_Release(ddraw4);
-        EXPECT_REF(ddraw, 3);
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw4);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(ddraw4 == ddraw2, "Expected ddraw %p, got %p.\n", ddraw2, ddraw4);
+    EXPECT_REF(ddraw, 4);
+    IDirectDraw_Release(ddraw4);
+    EXPECT_REF(ddraw, 3);
 
-        ref = IDirectDrawStreamSample_Release(sample);
-        ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IDirectDrawStreamSample_Release(sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
-        hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw3);
-        ok(hr == S_OK, "Got hr %#x.\n", hr);
-        EXPECT_REF(ddraw, 2);
-        EXPECT_REF(ddraw3, 2);
+    hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(ddraw, 2);
+    EXPECT_REF(ddraw3, 2);
 
-        hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw4);
-        ok(hr == S_OK, "Got hr %#x.\n", hr);
-        ok(ddraw4 == ddraw3, "Expected ddraw %p, got %p.\n", ddraw3, ddraw4);
-        EXPECT_REF(ddraw3, 3);
-        IDirectDraw_Release(ddraw4);
-        EXPECT_REF(ddraw3, 2);
+    hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw4);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(ddraw4 == ddraw3, "Expected ddraw %p, got %p.\n", ddraw3, ddraw4);
+    EXPECT_REF(ddraw3, 3);
+    IDirectDraw_Release(ddraw4);
+    EXPECT_REF(ddraw3, 2);
 
-        hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, NULL);
-        ok(hr == S_OK, "Got hr %#x.\n", hr);
-        EXPECT_REF(ddraw3, 1);
+    hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(ddraw3, 1);
 
-        ref = IDirectDraw_Release(ddraw3);
-        ok(!ref, "Got outstanding refcount %d.\n", ref);
-    }
+    ref = IDirectDraw_Release(ddraw3);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     EXPECT_REF(stream, 3);
     IDirectDrawMediaStream_Release(ddraw_stream);
From b2c74e0ccac6eb6a63d27b7e1527b20d5b387101 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Thu, 25 Jun 2020 20:57:00 +0200
Subject: [PATCH] amstream: Create ddraw if no source object was specified in
 ddraw_IAMMediaStream_Initialize().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    | 14 +++++++++-----
 dlls/amstream/tests/amstream.c |  3 +--
 2 files changed, 10 insertions(+), 7 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 15bd3af0a9b..56230ca4e63 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -218,6 +218,13 @@ static HRESULT WINAPI ddraw_IAMMediaStream_Initialize(IAMMediaStream *iface, IUn
             && FAILED(hr = IUnknown_QueryInterface(source_object, &IID_IDirectDraw, (void **)&stream->ddraw)))
         FIXME("Stream object doesn't implement IDirectDraw interface, hr %#x.\n", hr);
 
+    if (!source_object)
+    {
+        if (FAILED(hr = DirectDrawCreate(NULL, &stream->ddraw, NULL)))
+            return hr;
+        IDirectDraw_SetCooperativeLevel(stream->ddraw, NULL, DDSCL_NORMAL);
+    }
+
     return S_OK;
 }
 
@@ -381,13 +388,10 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetDirectDraw(IDirectDrawMedi
     if (!ddraw)
         return E_POINTER;
 
-    *ddraw = NULL;
     if (!stream->ddraw)
     {
-        HRESULT hr = DirectDrawCreate(NULL, &stream->ddraw, NULL);
-        if (FAILED(hr))
-            return hr;
-        IDirectDraw_SetCooperativeLevel(stream->ddraw, NULL, DDSCL_NORMAL);
+        *ddraw = NULL;
+        return S_OK;
     }
 
     IDirectDraw_AddRef(stream->ddraw);
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 5e5b9ac2f5c..9a97b6be655 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -4803,8 +4803,7 @@ static void test_ddrawstream_getsetdirectdraw(void)
 
     hr = IDirectDrawMediaStream_GetDirectDraw(ddraw_stream, &ddraw3);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(ddraw3 == NULL, "Expected NULL, got %p.\n", ddraw3);
-    if (ddraw3) IDirectDraw_Release(ddraw3);
+    ok(ddraw3 == NULL, "Expected NULL, got %p.\n", ddraw3);
 
     hr = IDirectDrawMediaStream_SetDirectDraw(ddraw_stream, ddraw2);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
From 8725564f68332c9129ca701de9b85799a00ddebf Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 25 Jun 2020 17:57:38 -0500
Subject: [PATCH] quartz/videorenderer: Set the destination rect to the whole
 client area when connecting.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/videorenderer.c | 18 ++++++++++++++++++
 dlls/quartz/videorenderer.c       |  3 ++-
 2 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/dlls/quartz/tests/videorenderer.c b/dlls/quartz/tests/videorenderer.c
index ab2b4f9e0d4..b157700a92b 100644
--- a/dlls/quartz/tests/videorenderer.c
+++ b/dlls/quartz/tests/videorenderer.c
@@ -2606,6 +2606,7 @@ static void test_basic_video(void)
     UINT count;
     ULONG ref;
     IPin *pin;
+    RECT rect;
 
     IBaseFilter_QueryInterface(filter, &IID_IBasicVideo, (void **)&video);
     IBaseFilter_FindPin(filter, L"In", &pin);
@@ -2722,6 +2723,23 @@ static void test_basic_video(void)
     test_basic_video_source(video);
     test_basic_video_destination(video);
 
+    hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IFilterGraph2_Disconnect(graph, pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    vih.bmiHeader.biWidth = 16;
+    vih.bmiHeader.biHeight = 16;
+    hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    check_source_position(video, 0, 0, 16, 16);
+
+    SetRect(&rect, 0, 0, 0, 0);
+    AdjustWindowRectEx(&rect, WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW, FALSE, 0);
+    check_destination_position(video, 0, 0, max(16, GetSystemMetrics(SM_CXMIN) - (rect.right - rect.left)),
+            max(16, GetSystemMetrics(SM_CYMIN) - (rect.bottom - rect.top)));
+
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
     IBasicVideo_Release(video);
diff --git a/dlls/quartz/videorenderer.c b/dlls/quartz/videorenderer.c
index e004d0fc214..f6eebc9ef9d 100644
--- a/dlls/quartz/videorenderer.c
+++ b/dlls/quartz/videorenderer.c
@@ -225,12 +225,13 @@ static HRESULT video_renderer_connect(struct strmbase_renderer *iface, const AM_
     filter->VideoWidth = bitmap_header->biWidth;
     filter->VideoHeight = abs(bitmap_header->biHeight);
     SetRect(&rect, 0, 0, filter->VideoWidth, filter->VideoHeight);
-    filter->window.src = filter->window.dst = rect;
+    filter->window.src = rect;
 
     AdjustWindowRectEx(&rect, GetWindowLongW(window, GWL_STYLE), FALSE,
             GetWindowLongW(window, GWL_EXSTYLE));
     SetWindowPos(window, NULL, 0, 0, rect.right - rect.left, rect.bottom - rect.top,
             SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
+    GetClientRect(window, &filter->window.dst);
 
     return S_OK;
 }
From 90f8a1b876cf0d1dbd820b295239faaef1c6cda0 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 25 Jun 2020 17:57:39 -0500
Subject: [PATCH] quartz/vmr9: Set the destination rect to the whole client
 area when connecting.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr7.c | 30 ++++++++++++++++++++++++++++++
 dlls/quartz/tests/vmr9.c | 34 ++++++++++++++++++++++++++++++++--
 dlls/quartz/vmr9.c       |  3 ++-
 3 files changed, 64 insertions(+), 3 deletions(-)

diff --git a/dlls/quartz/tests/vmr7.c b/dlls/quartz/tests/vmr7.c
index 4422a1f9140..adf677535b2 100644
--- a/dlls/quartz/tests/vmr7.c
+++ b/dlls/quartz/tests/vmr7.c
@@ -2593,6 +2593,7 @@ static void test_basic_video(void)
     UINT count;
     ULONG ref;
     IPin *pin;
+    RECT rect;
 
     IBaseFilter_QueryInterface(filter, &IID_IBasicVideo, (void **)&video);
     IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
@@ -2727,6 +2728,35 @@ static void test_basic_video(void)
     test_basic_video_source(video);
     test_basic_video_destination(video);
 
+    hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IFilterGraph2_Disconnect(graph, pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    vih.bmiHeader.biWidth = 16;
+    vih.bmiHeader.biHeight = 16;
+    hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMemInputPin_GetAllocator(input, &allocator);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr == S_OK)
+    {
+        hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
+        hr = IMemAllocator_Commit(allocator);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        IMemAllocator_Release(allocator);
+    }
+
+    check_source_position(video, 0, 0, 16, 16);
+
+    SetRect(&rect, 0, 0, 0, 0);
+    AdjustWindowRectEx(&rect, WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW, FALSE, 0);
+    check_destination_position(video, 0, 0, max(16, GetSystemMetrics(SM_CXMIN) - (rect.right - rect.left)),
+            max(16, GetSystemMetrics(SM_CYMIN) - (rect.bottom - rect.top)));
+
 out:
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 69065d35761..005b10974f9 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -3591,6 +3591,7 @@ static void test_basic_video(void)
     UINT count;
     ULONG ref;
     IPin *pin;
+    RECT rect;
 
     IBaseFilter_QueryInterface(filter, &IID_IBasicVideo, (void **)&video);
     IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
@@ -3725,6 +3726,35 @@ static void test_basic_video(void)
     test_basic_video_source(video);
     test_basic_video_destination(video);
 
+    hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IFilterGraph2_Disconnect(graph, pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    vih.bmiHeader.biWidth = 16;
+    vih.bmiHeader.biHeight = 16;
+    hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMemInputPin_GetAllocator(input, &allocator);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr == S_OK)
+    {
+        hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
+        hr = IMemAllocator_Commit(allocator);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        IMemAllocator_Release(allocator);
+    }
+
+    check_source_position(video, 0, 0, 16, 16);
+
+    SetRect(&rect, 0, 0, 0, 0);
+    AdjustWindowRectEx(&rect, WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW, FALSE, 0);
+    check_destination_position(video, 0, 0, max(16, GetSystemMetrics(SM_CXMIN) - (rect.right - rect.left)),
+            max(16, GetSystemMetrics(SM_CYMIN) - (rect.bottom - rect.top)));
+
 out:
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
@@ -3831,7 +3861,7 @@ static void test_windowless_size(void)
     hr = IVMRWindowlessControl9_GetVideoPosition(windowless_control, NULL, &dst);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     SetRect(&expect, 0, 0, 0, 0);
-    todo_wine ok(EqualRect(&dst, &expect), "Got dest rect %s.\n", wine_dbgstr_rect(&dst));
+    ok(EqualRect(&dst, &expect), "Got dest rect %s.\n", wine_dbgstr_rect(&dst));
 
     SetRect(&src, 4, 6, 16, 12);
     hr = IVMRWindowlessControl9_SetVideoPosition(windowless_control, &src, NULL);
@@ -3844,7 +3874,7 @@ static void test_windowless_size(void)
     SetRect(&expect, 4, 6, 16, 12);
     ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
     SetRect(&expect, 0, 0, 0, 0);
-    todo_wine ok(EqualRect(&dst, &expect), "Got dest rect %s.\n", wine_dbgstr_rect(&dst));
+    ok(EqualRect(&dst, &expect), "Got dest rect %s.\n", wine_dbgstr_rect(&dst));
 
     SetRect(&dst, 40, 60, 120, 160);
     hr = IVMRWindowlessControl9_SetVideoPosition(windowless_control, NULL, &dst);
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index e4db42223e9..b6b55c70c5d 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -519,12 +519,13 @@ static HRESULT vmr_connect(struct strmbase_renderer *iface, const AM_MEDIA_TYPE
     filter->VideoWidth = bitmap_header->biWidth;
     filter->VideoHeight = bitmap_header->biHeight;
     SetRect(&rect, 0, 0, filter->VideoWidth, filter->VideoHeight);
-    filter->window.src = filter->window.dst = rect;
+    filter->window.src = rect;
 
     AdjustWindowRectEx(&rect, GetWindowLongW(window, GWL_STYLE), FALSE,
             GetWindowLongW(window, GWL_EXSTYLE));
     SetWindowPos(window, NULL, 0, 0, rect.right - rect.left, rect.bottom - rect.top,
             SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
+    GetClientRect(window, &filter->window.dst);
 
     if (filter->mode
             || SUCCEEDED(hr = IVMRFilterConfig9_SetRenderingMode(&filter->IVMRFilterConfig9_iface, VMR9Mode_Windowed)))
From f7265d97ee12b67adc82cff63b70ee9d70e01b32 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 25 Jun 2020 17:57:40 -0500
Subject: [PATCH] quartz: Try to create the VMR7 in
 video_renderer_default_create().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/videorenderer.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/dlls/quartz/videorenderer.c b/dlls/quartz/videorenderer.c
index f6eebc9ef9d..f635d9eaac0 100644
--- a/dlls/quartz/videorenderer.c
+++ b/dlls/quartz/videorenderer.c
@@ -542,6 +542,10 @@ HRESULT video_renderer_create(IUnknown *outer, IUnknown **out)
 
 HRESULT video_renderer_default_create(IUnknown *outer, IUnknown **out)
 {
-    /* TODO: Attempt to use the VMR-7 renderer instead when possible */
+    HRESULT hr;
+
+    if (SUCCEEDED(hr = vmr7_create(outer, out)))
+        return hr;
+
     return video_renderer_create(outer, out);
 }
From 9e035293b1265b426e2f0ee1730f60e77e656a5d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 29 Jun 2020 10:26:15 -0500
Subject: [PATCH] qcap: Combine the internal header files.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/audiorecord.c    | 15 +--------
 dlls/qcap/avico.c          | 13 +-------
 dlls/qcap/avimux.c         | 14 +--------
 dlls/qcap/capture.h        | 42 --------------------------
 dlls/qcap/capturegraph.c   | 28 +----------------
 dlls/qcap/filewriter.c     |  6 +---
 dlls/qcap/qcap_main.c      | 23 ++------------
 dlls/qcap/qcap_main.h      | 36 ----------------------
 dlls/qcap/qcap_private.h   | 62 ++++++++++++++++++++++++++++++++++++++
 dlls/qcap/smartteefilter.c | 15 +--------
 dlls/qcap/v4l.c            | 15 +--------
 dlls/qcap/vfwcapture.c     | 24 +--------------
 12 files changed, 72 insertions(+), 221 deletions(-)
 delete mode 100644 dlls/qcap/capture.h
 delete mode 100644 dlls/qcap/qcap_main.h
 create mode 100644 dlls/qcap/qcap_private.h

diff --git a/dlls/qcap/audiorecord.c b/dlls/qcap/audiorecord.c
index 48be64b63f5..7477cca6d60 100644
--- a/dlls/qcap/audiorecord.c
+++ b/dlls/qcap/audiorecord.c
@@ -17,20 +17,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include <stdarg.h>
-
-#define COBJMACROS
-
-#include "windef.h"
-#include "winbase.h"
-#include "wtypes.h"
-#include "wingdi.h"
-#include "winuser.h"
-#include "dshow.h"
-
-#include "qcap_main.h"
-
-#include "wine/debug.h"
+#include "qcap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qcap);
 
diff --git a/dlls/qcap/avico.c b/dlls/qcap/avico.c
index fc5826b16fe..7b3c1ea3697 100644
--- a/dlls/qcap/avico.c
+++ b/dlls/qcap/avico.c
@@ -16,21 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include <stdarg.h>
-
-#define COBJMACROS
-
-#include "windef.h"
-#include "winbase.h"
-#include "dshow.h"
+#include "qcap_private.h"
 #include "vfw.h"
 #include "aviriff.h"
 
-#include "qcap_main.h"
-
-#include "wine/debug.h"
-#include "wine/heap.h"
-
 WINE_DEFAULT_DEBUG_CHANNEL(qcap);
 
 typedef struct {
diff --git a/dlls/qcap/avimux.c b/dlls/qcap/avimux.c
index f1e703bfb60..ea73e420404 100644
--- a/dlls/qcap/avimux.c
+++ b/dlls/qcap/avimux.c
@@ -16,22 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include <stdarg.h>
-#include <stdio.h>
-
-#define COBJMACROS
-
-#include "windef.h"
-#include "winbase.h"
-#include "wtypes.h"
-#include "dshow.h"
+#include "qcap_private.h"
 #include "vfw.h"
 #include "aviriff.h"
 
-#include "qcap_main.h"
-
-#include "wine/debug.h"
-
 WINE_DEFAULT_DEBUG_CHANNEL(qcap);
 
 #define MAX_PIN_NO 128
diff --git a/dlls/qcap/capture.h b/dlls/qcap/capture.h
deleted file mode 100644
index 615988bda37..00000000000
--- a/dlls/qcap/capture.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/* DirectShow private capture header (QCAP.DLL)
- *
- * Copyright 2005 Maarten Lankhorst
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#ifndef __QCAP_CAPTURE_H__
-#define __QCAP_CAPTURE_H__
-
-struct _Capture;
-typedef struct _Capture Capture;
-
-Capture *qcap_driver_init(struct strmbase_source *,USHORT) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_destroy(Capture*) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_check_format(Capture*,const AM_MEDIA_TYPE*) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_set_format(Capture*,AM_MEDIA_TYPE*) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_get_caps(Capture *device, LONG index, AM_MEDIA_TYPE **pmt,
-        VIDEO_STREAM_CONFIG_CAPS *vscc) DECLSPEC_HIDDEN;
-LONG qcap_driver_get_caps_count(Capture *device) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_get_format(const Capture*,AM_MEDIA_TYPE**) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_get_prop_range(Capture*,VideoProcAmpProperty,LONG*,LONG*,LONG*,LONG*,LONG*) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_get_prop(Capture*,VideoProcAmpProperty,LONG*,LONG*) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_set_prop(Capture*,VideoProcAmpProperty,LONG,LONG) DECLSPEC_HIDDEN;
-void qcap_driver_init_stream(Capture *device) DECLSPEC_HIDDEN;
-void qcap_driver_start_stream(Capture *device) DECLSPEC_HIDDEN;
-void qcap_driver_stop_stream(Capture *device) DECLSPEC_HIDDEN;
-void qcap_driver_cleanup_stream(Capture *device) DECLSPEC_HIDDEN;
-
-#endif /* __QCAP_CAPTURE_H__ */
diff --git a/dlls/qcap/capturegraph.c b/dlls/qcap/capturegraph.c
index 822f68754e0..b4f83956f0e 100644
--- a/dlls/qcap/capturegraph.c
+++ b/dlls/qcap/capturegraph.c
@@ -17,34 +17,8 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-#include "config.h"
-
-#include <stdio.h>
-#include <stdarg.h>
-
-#define COBJMACROS
-
-#include "windef.h"
-#include "winbase.h"
-#include "wingdi.h"
-#include "winerror.h"
-#include "objbase.h"
-
-#include "evcode.h"
-#include "strmif.h"
-#include "control.h"
-#include "vfwmsgs.h"
-/*
- *#include "amvideo.h"
- *#include "mmreg.h"
- *#include "dshow.h"
- *#include "ddraw.h"
- */
-#include "uuids.h"
-#include "qcap_main.h"
 
-#include "wine/unicode.h"
-#include "wine/debug.h"
+#include "qcap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qcap);
 
diff --git a/dlls/qcap/filewriter.c b/dlls/qcap/filewriter.c
index af148d4aa1a..be1e4e773ad 100644
--- a/dlls/qcap/filewriter.c
+++ b/dlls/qcap/filewriter.c
@@ -18,11 +18,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#define COBJMACROS
-#include "dshow.h"
-#include "qcap_main.h"
-#include "wine/debug.h"
-#include "wine/unicode.h"
+#include "qcap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qcap);
 
diff --git a/dlls/qcap/qcap_main.c b/dlls/qcap/qcap_main.c
index 00e0a9671fb..411ef41ea20 100644
--- a/dlls/qcap/qcap_main.c
+++ b/dlls/qcap/qcap_main.c
@@ -19,28 +19,9 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-#include "config.h"
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdarg.h>
-
-#define COBJMACROS
-#define NONAMELESSSTRUCT
-#define NONAMELESSUNION
-#include "windef.h"
-#include "winbase.h"
-#include "wingdi.h"
-#include "winerror.h"
-#include "objbase.h"
-#include "uuids.h"
-#include "strmif.h"
-#include "rpcproxy.h"
-
-#include "qcap_main.h"
 
-#include "wine/unicode.h"
-#include "wine/debug.h"
+#include "qcap_private.h"
+#include "rpcproxy.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qcap);
 
diff --git a/dlls/qcap/qcap_main.h b/dlls/qcap/qcap_main.h
deleted file mode 100644
index 4197771c78d..00000000000
--- a/dlls/qcap/qcap_main.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Qcap main header file
- *
- * Copyright (C) 2005 Rolf Kalbermatter
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-#ifndef _QCAP_MAIN_H_DEFINED
-#define _QCAP_MAIN_H_DEFINED
-
-#include "wine/heap.h"
-#include "wine/strmbase.h"
-
-extern DWORD ObjectRefCount(BOOL increment) DECLSPEC_HIDDEN;
-
-HRESULT audio_record_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
-HRESULT avi_compressor_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
-HRESULT avi_mux_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
-HRESULT capture_graph_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
-HRESULT file_writer_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
-HRESULT smart_tee_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
-HRESULT vfw_capture_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
-
-#endif /* _QCAP_MAIN_H_DEFINED */
diff --git a/dlls/qcap/qcap_private.h b/dlls/qcap/qcap_private.h
new file mode 100644
index 00000000000..688bebb201e
--- /dev/null
+++ b/dlls/qcap/qcap_private.h
@@ -0,0 +1,62 @@
+/*
+ * DirectShow capture
+ *
+ * Copyright (C) 2005 Rolf Kalbermatter
+ * Copyright 2005 Maarten Lankhorst
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#ifndef _QCAP_PRIVATE_H_DEFINED
+#define _QCAP_PRIVATE_H_DEFINED
+
+#define COBJMACROS
+#define NONAMELESSSTRUCT
+#define NONAMELESSUNION
+#include "dshow.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+#include "wine/strmbase.h"
+#include "wine/unicode.h"
+
+extern DWORD ObjectRefCount(BOOL increment) DECLSPEC_HIDDEN;
+
+HRESULT audio_record_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT avi_compressor_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT avi_mux_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT capture_graph_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT file_writer_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT smart_tee_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT vfw_capture_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+
+typedef struct _Capture Capture;
+
+Capture *qcap_driver_init(struct strmbase_source *pin, USHORT card) DECLSPEC_HIDDEN;
+HRESULT qcap_driver_destroy(Capture *device) DECLSPEC_HIDDEN;
+HRESULT qcap_driver_check_format(Capture *device, const AM_MEDIA_TYPE *mt) DECLSPEC_HIDDEN;
+HRESULT qcap_driver_set_format(Capture *device, AM_MEDIA_TYPE *mt) DECLSPEC_HIDDEN;
+HRESULT qcap_driver_get_caps(Capture *device, LONG index, AM_MEDIA_TYPE **mt,
+        VIDEO_STREAM_CONFIG_CAPS *vscc) DECLSPEC_HIDDEN;
+LONG qcap_driver_get_caps_count(Capture *device) DECLSPEC_HIDDEN;
+HRESULT qcap_driver_get_format(const Capture *device, AM_MEDIA_TYPE **mt) DECLSPEC_HIDDEN;
+HRESULT qcap_driver_get_prop_range(Capture *device, VideoProcAmpProperty property,
+        LONG *min, LONG *max, LONG *step, LONG *default_value, LONG *flags) DECLSPEC_HIDDEN;
+HRESULT qcap_driver_get_prop(Capture *device, VideoProcAmpProperty property, LONG *value, LONG *flags) DECLSPEC_HIDDEN;
+HRESULT qcap_driver_set_prop(Capture *device, VideoProcAmpProperty property, LONG value, LONG flags) DECLSPEC_HIDDEN;
+void qcap_driver_init_stream(Capture *device) DECLSPEC_HIDDEN;
+void qcap_driver_start_stream(Capture *device) DECLSPEC_HIDDEN;
+void qcap_driver_stop_stream(Capture *device) DECLSPEC_HIDDEN;
+void qcap_driver_cleanup_stream(Capture *device) DECLSPEC_HIDDEN;
+
+#endif
diff --git a/dlls/qcap/smartteefilter.c b/dlls/qcap/smartteefilter.c
index 46ec09ca7e4..5b4add0b5db 100644
--- a/dlls/qcap/smartteefilter.c
+++ b/dlls/qcap/smartteefilter.c
@@ -18,20 +18,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include <stdarg.h>
-
-#define COBJMACROS
-
-#include "windef.h"
-#include "winbase.h"
-#include "wtypes.h"
-#include "wingdi.h"
-#include "winuser.h"
-#include "dshow.h"
-
-#include "qcap_main.h"
-
-#include "wine/debug.h"
+#include "qcap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qcap);
 
diff --git a/dlls/qcap/v4l.c b/dlls/qcap/v4l.c
index 449951ad53a..a8841272a34 100644
--- a/dlls/qcap/v4l.c
+++ b/dlls/qcap/v4l.c
@@ -24,8 +24,6 @@
 #include "config.h"
 #include "wine/port.h"
 
-#define COBJMACROS
-
 #include <stdarg.h>
 #include <stdio.h>
 #include <fcntl.h>
@@ -49,18 +47,7 @@
 #include <unistd.h>
 #endif
 
-#include "windef.h"
-#include "winbase.h"
-#include "wtypes.h"
-#include "wingdi.h"
-#include "winuser.h"
-#include "dshow.h"
-#include "vfwmsgs.h"
-#include "amvideo.h"
-#include "wine/debug.h"
-
-#include "qcap_main.h"
-#include "capture.h"
+#include "qcap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qcap);
 
diff --git a/dlls/qcap/vfwcapture.c b/dlls/qcap/vfwcapture.c
index 9430533ea19..b48b2316d79 100644
--- a/dlls/qcap/vfwcapture.c
+++ b/dlls/qcap/vfwcapture.c
@@ -18,29 +18,7 @@
  *
  */
 
-#define COBJMACROS
-
-#include "config.h"
-#include <stdarg.h>
-
-#include "windef.h"
-#include "winbase.h"
-#include "wtypes.h"
-#include "wingdi.h"
-#include "winuser.h"
-#include "dshow.h"
-
-#include "qcap_main.h"
-#include "wine/debug.h"
-
-#include "capture.h"
-#include "uuids.h"
-#include "vfwmsgs.h"
-#include "amvideo.h"
-#include "strmif.h"
-#include "ddraw.h"
-#include "ocidl.h"
-#include "oleauto.h"
+#include "qcap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qcap);
 
From 8ad370744375b32b65f87235dbe47ae71b25557a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 29 Jun 2020 10:26:16 -0500
Subject: [PATCH] qcap: Use a function table for video capture driver
 operations.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/qcap_private.h |  40 ++++----
 dlls/qcap/v4l.c          | 211 ++++++++++++++++-----------------------
 dlls/qcap/vfwcapture.c   |  78 ++++++++-------
 3 files changed, 151 insertions(+), 178 deletions(-)

diff --git a/dlls/qcap/qcap_private.h b/dlls/qcap/qcap_private.h
index 688bebb201e..823f8fed93d 100644
--- a/dlls/qcap/qcap_private.h
+++ b/dlls/qcap/qcap_private.h
@@ -40,23 +40,29 @@ HRESULT file_writer_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
 HRESULT smart_tee_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
 HRESULT vfw_capture_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
 
-typedef struct _Capture Capture;
+struct video_capture_device
+{
+    const struct video_capture_device_ops *ops;
+};
 
-Capture *qcap_driver_init(struct strmbase_source *pin, USHORT card) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_destroy(Capture *device) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_check_format(Capture *device, const AM_MEDIA_TYPE *mt) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_set_format(Capture *device, AM_MEDIA_TYPE *mt) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_get_caps(Capture *device, LONG index, AM_MEDIA_TYPE **mt,
-        VIDEO_STREAM_CONFIG_CAPS *vscc) DECLSPEC_HIDDEN;
-LONG qcap_driver_get_caps_count(Capture *device) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_get_format(const Capture *device, AM_MEDIA_TYPE **mt) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_get_prop_range(Capture *device, VideoProcAmpProperty property,
-        LONG *min, LONG *max, LONG *step, LONG *default_value, LONG *flags) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_get_prop(Capture *device, VideoProcAmpProperty property, LONG *value, LONG *flags) DECLSPEC_HIDDEN;
-HRESULT qcap_driver_set_prop(Capture *device, VideoProcAmpProperty property, LONG value, LONG flags) DECLSPEC_HIDDEN;
-void qcap_driver_init_stream(Capture *device) DECLSPEC_HIDDEN;
-void qcap_driver_start_stream(Capture *device) DECLSPEC_HIDDEN;
-void qcap_driver_stop_stream(Capture *device) DECLSPEC_HIDDEN;
-void qcap_driver_cleanup_stream(Capture *device) DECLSPEC_HIDDEN;
+struct video_capture_device_ops
+{
+    void (*destroy)(struct video_capture_device *device);
+    HRESULT (*check_format)(struct video_capture_device *device, const AM_MEDIA_TYPE *mt);
+    HRESULT (*set_format)(struct video_capture_device *device, const AM_MEDIA_TYPE *mt);
+    HRESULT (*get_format)(struct video_capture_device *device, AM_MEDIA_TYPE **mt);
+    HRESULT (*get_caps)(struct video_capture_device *device, LONG index, AM_MEDIA_TYPE **mt, VIDEO_STREAM_CONFIG_CAPS *caps);
+    LONG (*get_caps_count)(struct video_capture_device *device);
+    HRESULT (*get_prop_range)(struct video_capture_device *device, VideoProcAmpProperty property,
+            LONG *min, LONG *max, LONG *step, LONG *default_value, LONG *flags);
+    HRESULT (*get_prop)(struct video_capture_device *device, VideoProcAmpProperty property, LONG *value, LONG *flags);
+    HRESULT (*set_prop)(struct video_capture_device *device, VideoProcAmpProperty property, LONG value, LONG flags);
+    void (*init_stream)(struct video_capture_device *device);
+    void (*start_stream)(struct video_capture_device *device);
+    void (*stop_stream)(struct video_capture_device *device);
+    void (*cleanup_stream)(struct video_capture_device *device);
+};
+
+struct video_capture_device *v4l_device_create(struct strmbase_source *pin, USHORT card);
 
 #endif
diff --git a/dlls/qcap/v4l.c b/dlls/qcap/v4l.c
index a8841272a34..5c2de2e3d67 100644
--- a/dlls/qcap/v4l.c
+++ b/dlls/qcap/v4l.c
@@ -88,8 +88,10 @@ struct caps
     VIDEO_STREAM_CONFIG_CAPS config;
 };
 
-struct _Capture
+struct v4l_device
 {
+    struct video_capture_device d;
+
     const struct caps *current_caps;
     struct caps *caps;
     LONG caps_count;
@@ -101,6 +103,11 @@ struct _Capture
     HANDLE thread, run_event;
 };
 
+static inline struct v4l_device *v4l_device(struct video_capture_device *iface)
+{
+    return CONTAINING_RECORD(iface, struct v4l_device, d);
+}
+
 static int xioctl(int fd, int request, void * arg)
 {
     int r;
@@ -112,18 +119,18 @@ static int xioctl(int fd, int request, void * arg)
     return r;
 }
 
-HRESULT qcap_driver_destroy(Capture *device)
+static void v4l_device_destroy(struct video_capture_device *iface)
 {
+    struct v4l_device *device = v4l_device(iface);
+
     if (device->fd != -1)
         video_close(device->fd);
     if (device->caps_count)
         heap_free(device->caps);
     heap_free(device);
-
-    return S_OK;
 }
 
-static const struct caps *find_caps(Capture *device, const AM_MEDIA_TYPE *mt)
+static const struct caps *find_caps(struct v4l_device *device, const AM_MEDIA_TYPE *mt)
 {
     const VIDEOINFOHEADER *video_info = (VIDEOINFOHEADER *)mt->pbFormat;
     LONG index;
@@ -143,8 +150,10 @@ static const struct caps *find_caps(Capture *device, const AM_MEDIA_TYPE *mt)
     return NULL;
 }
 
-HRESULT qcap_driver_check_format(Capture *device, const AM_MEDIA_TYPE *mt)
+static HRESULT v4l_device_check_format(struct video_capture_device *iface, const AM_MEDIA_TYPE *mt)
 {
+    struct v4l_device *device = v4l_device(iface);
+
     TRACE("device %p, mt %p.\n", device, mt);
 
     if (!mt)
@@ -159,7 +168,7 @@ HRESULT qcap_driver_check_format(Capture *device, const AM_MEDIA_TYPE *mt)
     return E_FAIL;
 }
 
-static BOOL set_caps(Capture *device, const struct caps *caps)
+static BOOL set_caps(struct v4l_device *device, const struct caps *caps)
 {
     struct v4l2_format format = {0};
     LONG width, height;
@@ -185,8 +194,9 @@ static BOOL set_caps(Capture *device, const struct caps *caps)
     return TRUE;
 }
 
-HRESULT qcap_driver_set_format(Capture *device, AM_MEDIA_TYPE *mt)
+static HRESULT v4l_device_set_format(struct video_capture_device *iface, const AM_MEDIA_TYPE *mt)
 {
+    struct v4l_device *device = v4l_device(iface);
     const struct caps *caps;
 
     caps = find_caps(device, mt);
@@ -202,8 +212,10 @@ HRESULT qcap_driver_set_format(Capture *device, AM_MEDIA_TYPE *mt)
     return S_OK;
 }
 
-HRESULT qcap_driver_get_format(const Capture *device, AM_MEDIA_TYPE **mt)
+static HRESULT v4l_device_get_format(struct video_capture_device *iface, AM_MEDIA_TYPE **mt)
 {
+    struct v4l_device *device = v4l_device(iface);
+
     *mt = CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
     if (!*mt)
         return E_OUTOFMEMORY;
@@ -229,9 +241,10 @@ static __u32 v4l2_cid_from_qcap_property(VideoProcAmpProperty property)
     }
 }
 
-HRESULT qcap_driver_get_prop_range(Capture *device, VideoProcAmpProperty property,
+static HRESULT v4l_device_get_prop_range(struct video_capture_device *iface, VideoProcAmpProperty property,
         LONG *min, LONG *max, LONG *step, LONG *default_value, LONG *flags)
 {
+    struct v4l_device *device = v4l_device(iface);
     struct v4l2_queryctrl ctrl;
 
     ctrl.id = v4l2_cid_from_qcap_property(property);
@@ -250,9 +263,10 @@ HRESULT qcap_driver_get_prop_range(Capture *device, VideoProcAmpProperty propert
     return S_OK;
 }
 
-HRESULT qcap_driver_get_prop(Capture *device, VideoProcAmpProperty property,
-        LONG *value, LONG *flags)
+static HRESULT v4l_device_get_prop(struct video_capture_device *iface,
+        VideoProcAmpProperty property, LONG *value, LONG *flags)
 {
+    struct v4l_device *device = v4l_device(iface);
     struct v4l2_control ctrl;
 
     ctrl.id = v4l2_cid_from_qcap_property(property);
@@ -269,9 +283,10 @@ HRESULT qcap_driver_get_prop(Capture *device, VideoProcAmpProperty property,
     return S_OK;
 }
 
-HRESULT qcap_driver_set_prop(Capture *device, VideoProcAmpProperty property,
-        LONG value, LONG flags)
+static HRESULT v4l_device_set_prop(struct video_capture_device *iface,
+        VideoProcAmpProperty property, LONG value, LONG flags)
 {
+    struct v4l_device *device = v4l_device(iface);
     struct v4l2_control ctrl;
 
     ctrl.id = v4l2_cid_from_qcap_property(property);
@@ -286,7 +301,7 @@ HRESULT qcap_driver_set_prop(Capture *device, VideoProcAmpProperty property,
     return S_OK;
 }
 
-static void reverse_image(const Capture *device, LPBYTE output, const BYTE *input)
+static void reverse_image(struct v4l_device *device, LPBYTE output, const BYTE *input)
 {
     int inoffset, outoffset, pitch;
     UINT width, height, depth;
@@ -311,7 +326,7 @@ static void reverse_image(const Capture *device, LPBYTE output, const BYTE *inpu
 
 static DWORD WINAPI ReadThread(LPVOID lParam)
 {
-    Capture * capBox = lParam;
+    struct v4l_device *capBox = lParam;
     HRESULT hr;
     IMediaSample *pSample = NULL;
     ULONG framecount = 0;
@@ -372,8 +387,9 @@ static DWORD WINAPI ReadThread(LPVOID lParam)
     return 0;
 }
 
-void qcap_driver_init_stream(Capture *device)
+static void v4l_device_init_stream(struct video_capture_device *iface)
 {
+    struct v4l_device *device = v4l_device(iface);
     ALLOCATOR_PROPERTIES req_props, ret_props;
     HRESULT hr;
 
@@ -397,20 +413,23 @@ void qcap_driver_init_stream(Capture *device)
     device->thread = CreateThread(NULL, 0, ReadThread, device, 0, NULL);
 }
 
-void qcap_driver_start_stream(Capture *device)
+static void v4l_device_start_stream(struct video_capture_device *iface)
 {
+    struct v4l_device *device = v4l_device(iface);
     device->state = State_Running;
     SetEvent(device->run_event);
 }
 
-void qcap_driver_stop_stream(Capture *device)
+static void v4l_device_stop_stream(struct video_capture_device *iface)
 {
+    struct v4l_device *device = v4l_device(iface);
     device->state = State_Paused;
     ResetEvent(device->run_event);
 }
 
-void qcap_driver_cleanup_stream(Capture *device)
+static void v4l_device_cleanup_stream(struct video_capture_device *iface)
 {
+    struct v4l_device *device = v4l_device(iface);
     HRESULT hr;
 
     device->state = State_Stopped;
@@ -460,12 +479,53 @@ static void fill_caps(__u32 pixelformat, __u32 width, __u32 height,
     caps->pixelformat = pixelformat;
 }
 
-Capture *qcap_driver_init(struct strmbase_source *pin, USHORT card)
+static HRESULT v4l_device_get_caps(struct video_capture_device *iface, LONG index,
+        AM_MEDIA_TYPE **type, VIDEO_STREAM_CONFIG_CAPS *vscc)
+{
+    struct v4l_device *device = v4l_device(iface);
+
+    if (index >= device->caps_count)
+        return S_FALSE;
+
+    *type = CreateMediaType(&device->caps[index].media_type);
+    if (!*type)
+        return E_OUTOFMEMORY;
+
+    if (vscc)
+        memcpy(vscc, &device->caps[index].config, sizeof(VIDEO_STREAM_CONFIG_CAPS));
+    return S_OK;
+}
+
+static LONG v4l_device_get_caps_count(struct video_capture_device *iface)
+{
+    struct v4l_device *device = v4l_device(iface);
+
+    return device->caps_count;
+}
+
+static const struct video_capture_device_ops v4l_device_ops =
+{
+    .destroy = v4l_device_destroy,
+    .check_format = v4l_device_check_format,
+    .set_format = v4l_device_set_format,
+    .get_format = v4l_device_get_format,
+    .get_caps = v4l_device_get_caps,
+    .get_caps_count = v4l_device_get_caps_count,
+    .get_prop_range = v4l_device_get_prop_range,
+    .get_prop = v4l_device_get_prop,
+    .set_prop = v4l_device_set_prop,
+    .init_stream = v4l_device_init_stream,
+    .start_stream = v4l_device_start_stream,
+    .stop_stream = v4l_device_stop_stream,
+    .cleanup_stream = v4l_device_cleanup_stream,
+};
+
+struct video_capture_device *v4l_device_create(struct strmbase_source *pin, USHORT card)
 {
     struct v4l2_frmsizeenum frmsize = {0};
     struct v4l2_capability caps = {{0}};
     struct v4l2_format format = {0};
-    Capture *device = NULL;
+    struct v4l_device *device;
     BOOL have_libv4l2;
     char path[20];
     int fd, i;
@@ -597,6 +657,7 @@ Capture *qcap_driver_init(struct strmbase_source *pin, USHORT card)
         goto error;
     }
 
+    device->d.ops = &v4l_device_ops;
     device->pin = pin;
     device->state = State_Stopped;
     device->run_event = CreateEventW(NULL, TRUE, FALSE, NULL);
@@ -605,117 +666,19 @@ Capture *qcap_driver_init(struct strmbase_source *pin, USHORT card)
             device->current_caps->video_info.bmiHeader.biWidth,
             device->current_caps->video_info.bmiHeader.biHeight);
 
-    return device;
+    return &device->d;
 
 error:
-    qcap_driver_destroy(device);
+    v4l_device_destroy(&device->d);
     return NULL;
 }
 
-HRESULT qcap_driver_get_caps(Capture *device, LONG index, AM_MEDIA_TYPE **type,
-        VIDEO_STREAM_CONFIG_CAPS *vscc)
-{
-    if (index >= device->caps_count)
-        return S_FALSE;
-
-    *type = CreateMediaType(&device->caps[index].media_type);
-    if (!*type)
-        return E_OUTOFMEMORY;
-
-    if (vscc)
-        memcpy(vscc, &device->caps[index].config, sizeof(VIDEO_STREAM_CONFIG_CAPS));
-    return S_OK;
-}
-
-LONG qcap_driver_get_caps_count(Capture *device)
-{
-    return device->caps_count;
-}
-
 #else
 
-Capture *qcap_driver_init(struct strmbase_source *pin, USHORT card)
+struct video_capture_device *v4l_device_create(struct strmbase_source *pin, USHORT card)
 {
-    static const char msg[] =
-        "The v4l headers were not available at compile time,\n"
-        "so video capture support is not available.\n";
-    MESSAGE(msg);
+    ERR("v4l2 was not present at compilation time.\n");
     return NULL;
 }
 
-#define FAIL_WITH_ERR \
-    ERR("v4l absent: shouldn't be called\n"); \
-    return E_NOTIMPL
-
-HRESULT qcap_driver_destroy(Capture *capBox)
-{
-    FAIL_WITH_ERR;
-}
-
-HRESULT qcap_driver_check_format(Capture *device, const AM_MEDIA_TYPE *mt)
-{
-    FAIL_WITH_ERR;
-}
-
-HRESULT qcap_driver_set_format(Capture *capBox, AM_MEDIA_TYPE * mT)
-{
-    FAIL_WITH_ERR;
-}
-
-HRESULT qcap_driver_get_format(const Capture *capBox, AM_MEDIA_TYPE ** mT)
-{
-    FAIL_WITH_ERR;
-}
-
-HRESULT qcap_driver_get_prop_range( Capture *capBox,
-        VideoProcAmpProperty  Property, LONG *pMin, LONG *pMax,
-        LONG *pSteppingDelta, LONG *pDefault, LONG *pCapsFlags )
-{
-    FAIL_WITH_ERR;
-}
-
-HRESULT qcap_driver_get_prop(Capture *capBox,
-        VideoProcAmpProperty Property, LONG *lValue, LONG *Flags)
-{
-    FAIL_WITH_ERR;
-}
-
-HRESULT qcap_driver_set_prop(Capture *capBox, VideoProcAmpProperty Property,
-        LONG lValue, LONG Flags)
-{
-    FAIL_WITH_ERR;
-}
-
-void qcap_driver_init_stream(Capture *device)
-{
-    ERR("v4l absent: shouldn't be called\n");
-}
-
-void qcap_driver_start_stream(Capture *device)
-{
-    ERR("v4l absent: shouldn't be called\n");
-}
-
-void qcap_driver_stop_stream(Capture *device)
-{
-    ERR("v4l absent: shouldn't be called\n");
-}
-
-void qcap_driver_cleanup_stream(Capture *device)
-{
-    ERR("v4l absent: shouldn't be called\n");
-}
-
-HRESULT qcap_driver_get_caps(Capture *device, LONG index, AM_MEDIA_TYPE **type,
-        VIDEO_STREAM_CONFIG_CAPS *vscc)
-{
-    FAIL_WITH_ERR;
-}
-
-LONG qcap_driver_get_caps_count(Capture *device)
-{
-    ERR("v4l absent: shouldn't be called\n");
-    return 0;
-}
-
 #endif /* defined(VIDIOCMCAPTURE) */
diff --git a/dlls/qcap/vfwcapture.c b/dlls/qcap/vfwcapture.c
index b48b2316d79..9f4b8598638 100644
--- a/dlls/qcap/vfwcapture.c
+++ b/dlls/qcap/vfwcapture.c
@@ -31,7 +31,8 @@ typedef struct VfwCapture
     IAMFilterMiscFlags IAMFilterMiscFlags_iface;
     IPersistPropertyBag IPersistPropertyBag_iface;
     BOOL init;
-    Capture *driver_info;
+
+    struct video_capture_device *device;
 
     struct strmbase_source source;
     IKsPropertySet IKsPropertySet_iface;
@@ -84,8 +85,8 @@ static void vfw_capture_destroy(struct strmbase_filter *iface)
     if (filter->init)
     {
         if (filter->filter.state != State_Stopped)
-            qcap_driver_stop_stream(filter->driver_info);
-        qcap_driver_destroy(filter->driver_info);
+            filter->device->ops->stop_stream(filter->device);
+        filter->device->ops->destroy(filter->device);
     }
 
     if (filter->source.pin.peer)
@@ -122,7 +123,7 @@ static HRESULT vfw_capture_init_stream(struct strmbase_filter *iface)
 {
     VfwCapture *filter = impl_from_strmbase_filter(iface);
 
-    qcap_driver_init_stream(filter->driver_info);
+    filter->device->ops->init_stream(filter->device);
     return VFW_S_CANT_CUE;
 }
 
@@ -130,7 +131,7 @@ static HRESULT vfw_capture_start_stream(struct strmbase_filter *iface, REFERENCE
 {
     VfwCapture *filter = impl_from_strmbase_filter(iface);
 
-    qcap_driver_start_stream(filter->driver_info);
+    filter->device->ops->start_stream(filter->device);
     return S_OK;
 }
 
@@ -138,7 +139,7 @@ static HRESULT vfw_capture_stop_stream(struct strmbase_filter *iface)
 {
     VfwCapture *filter = impl_from_strmbase_filter(iface);
 
-    qcap_driver_stop_stream(filter->driver_info);
+    filter->device->ops->stop_stream(filter->device);
     return VFW_S_CANT_CUE;
 }
 
@@ -146,7 +147,7 @@ static HRESULT vfw_capture_cleanup_stream(struct strmbase_filter *iface)
 {
     VfwCapture *filter = impl_from_strmbase_filter(iface);
 
-    qcap_driver_cleanup_stream(filter->driver_info);
+    filter->device->ops->cleanup_stream(filter->device);
     return S_OK;
 }
 
@@ -211,7 +212,7 @@ AMStreamConfig_SetFormat(IAMStreamConfig *iface, AM_MEDIA_TYPE *pmt)
             return VFW_E_INVALIDMEDIATYPE;
     }
 
-    hr = qcap_driver_set_format(This->driver_info, pmt);
+    hr = This->device->ops->set_format(This->device, pmt);
     if (SUCCEEDED(hr) && This->filter.graph && This->source.pin.peer)
     {
         hr = IFilterGraph_Reconnect(This->filter.graph, &This->source.pin.IPin_iface);
@@ -222,14 +223,14 @@ AMStreamConfig_SetFormat(IAMStreamConfig *iface, AM_MEDIA_TYPE *pmt)
     return hr;
 }
 
-static HRESULT WINAPI
-AMStreamConfig_GetFormat( IAMStreamConfig *iface, AM_MEDIA_TYPE **pmt )
+static HRESULT WINAPI AMStreamConfig_GetFormat(IAMStreamConfig *iface, AM_MEDIA_TYPE **pmt)
 {
-    VfwCapture *This = impl_from_IAMStreamConfig(iface);
+    VfwCapture *filter = impl_from_IAMStreamConfig(iface);
     HRESULT hr;
 
-    TRACE("%p -> (%p)\n", iface, pmt);
-    hr = qcap_driver_get_format(This->driver_info, pmt);
+    TRACE("filter %p, mt %p.\n", filter, pmt);
+
+    hr = filter->device->ops->get_format(filter->device, pmt);
     if (SUCCEEDED(hr))
         strmbase_dump_media_type(*pmt);
     return hr;
@@ -245,7 +246,7 @@ static HRESULT WINAPI AMStreamConfig_GetNumberOfCapabilities(IAMStreamConfig *if
     if (!count || !size)
         return E_POINTER;
 
-    *count = qcap_driver_get_caps_count(filter->driver_info);
+    *count = filter->device->ops->get_caps_count(filter->device);
     *size = sizeof(VIDEO_STREAM_CONFIG_CAPS);
 
     return S_OK;
@@ -258,7 +259,7 @@ static HRESULT WINAPI AMStreamConfig_GetStreamCaps(IAMStreamConfig *iface,
 
     TRACE("filter %p, index %d, pmt %p, vscc %p.\n", filter, index, pmt, vscc);
 
-    return qcap_driver_get_caps(filter->driver_info, index, pmt, (VIDEO_STREAM_CONFIG_CAPS *)vscc);
+    return filter->device->ops->get_caps(filter->device, index, pmt, (VIDEO_STREAM_CONFIG_CAPS *)vscc);
 }
 
 static const IAMStreamConfigVtbl IAMStreamConfig_VTable =
@@ -294,32 +295,36 @@ static ULONG WINAPI AMVideoProcAmp_Release(IAMVideoProcAmp * iface)
     return IUnknown_Release(This->filter.outer_unk);
 }
 
-static HRESULT WINAPI
-AMVideoProcAmp_GetRange( IAMVideoProcAmp * iface, LONG Property, LONG *pMin,
-        LONG *pMax, LONG *pSteppingDelta, LONG *pDefault, LONG *pCapsFlags )
+static HRESULT WINAPI AMVideoProcAmp_GetRange(IAMVideoProcAmp *iface, LONG property,
+        LONG *min, LONG *max, LONG *step, LONG *default_value, LONG *flags)
 {
-    VfwCapture *This = impl_from_IAMVideoProcAmp(iface);
+    VfwCapture *filter = impl_from_IAMVideoProcAmp(iface);
+
+    TRACE("filter %p, property %#x, min %p, max %p, step %p, default_value %p, flags %p.\n",
+            filter, property, min, max, step, default_value, flags);
 
-    return qcap_driver_get_prop_range( This->driver_info, Property, pMin, pMax,
-                   pSteppingDelta, pDefault, pCapsFlags );
+    return filter->device->ops->get_prop_range(filter->device, property, min,
+            max, step, default_value, flags);
 }
 
-static HRESULT WINAPI
-AMVideoProcAmp_Set( IAMVideoProcAmp * iface, LONG Property, LONG lValue,
-                    LONG Flags )
+static HRESULT WINAPI AMVideoProcAmp_Set(IAMVideoProcAmp *iface, LONG property,
+        LONG value, LONG flags)
 {
-    VfwCapture *This = impl_from_IAMVideoProcAmp(iface);
+    VfwCapture *filter = impl_from_IAMVideoProcAmp(iface);
 
-    return qcap_driver_set_prop(This->driver_info, Property, lValue, Flags);
+    TRACE("filter %p, property %#x, value %d, flags %#x.\n", filter, property, value, flags);
+
+    return filter->device->ops->set_prop(filter->device, property, value, flags);
 }
 
-static HRESULT WINAPI
-AMVideoProcAmp_Get( IAMVideoProcAmp * iface, LONG Property, LONG *lValue,
-                    LONG *Flags )
+static HRESULT WINAPI AMVideoProcAmp_Get(IAMVideoProcAmp *iface, LONG property,
+        LONG *value, LONG *flags)
 {
-    VfwCapture *This = impl_from_IAMVideoProcAmp(iface);
+    VfwCapture *filter = impl_from_IAMVideoProcAmp(iface);
+
+    TRACE("filter %p, property %#x, value %p, flags %p.\n", filter, property, value, flags);
 
-    return qcap_driver_get_prop(This->driver_info, Property, lValue, Flags);
+    return filter->device->ops->get_prop(filter->device, property, value, flags);
 }
 
 static const IAMVideoProcAmpVtbl IAMVideoProcAmp_VTable =
@@ -388,8 +393,7 @@ PPB_Load( IPersistPropertyBag * iface, IPropertyBag *pPropBag,
 
     if (SUCCEEDED(hr))
     {
-        This->driver_info = qcap_driver_init(&This->source, V_I4(&var));
-        if (This->driver_info)
+        if ((This->device = v4l_device_create(&This->source, V_I4(&var))))
         {
             This->init = TRUE;
             hr = S_OK;
@@ -505,7 +509,7 @@ static inline VfwCapture *impl_from_strmbase_pin(struct strmbase_pin *pin)
 static HRESULT source_query_accept(struct strmbase_pin *pin, const AM_MEDIA_TYPE *mt)
 {
     VfwCapture *filter = impl_from_strmbase_pin(pin);
-    return qcap_driver_check_format(filter->driver_info, mt);
+    return filter->device->ops->check_format(filter->device, mt);
 }
 
 static HRESULT source_get_media_type(struct strmbase_pin *pin,
@@ -515,11 +519,11 @@ static HRESULT source_get_media_type(struct strmbase_pin *pin,
     AM_MEDIA_TYPE *vfw_pmt;
     HRESULT hr;
 
-    if (index >= qcap_driver_get_caps_count(filter->driver_info))
+    if (index >= filter->device->ops->get_caps_count(filter->device))
         return VFW_S_NO_MORE_ITEMS;
 
-    hr = qcap_driver_get_caps(filter->driver_info, index, &vfw_pmt, NULL);
-    if (SUCCEEDED(hr)) {
+    if (SUCCEEDED(hr = filter->device->ops->get_caps(filter->device, index, &vfw_pmt, NULL)))
+    {
         CopyMediaType(pmt, vfw_pmt);
         DeleteMediaType(vfw_pmt);
     }
From ebd4b38f90f00f259daf6044903967cc92a26691 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 29 Jun 2020 10:26:17 -0500
Subject: [PATCH] qcap: Pass a single AM_MEDIA_TYPE pointer to get_format().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/qcap_private.h |  2 +-
 dlls/qcap/v4l.c          |  8 ++------
 dlls/qcap/vfwcapture.c   | 12 +++++++-----
 3 files changed, 10 insertions(+), 12 deletions(-)

diff --git a/dlls/qcap/qcap_private.h b/dlls/qcap/qcap_private.h
index 823f8fed93d..70a8c85ad47 100644
--- a/dlls/qcap/qcap_private.h
+++ b/dlls/qcap/qcap_private.h
@@ -50,7 +50,7 @@ struct video_capture_device_ops
     void (*destroy)(struct video_capture_device *device);
     HRESULT (*check_format)(struct video_capture_device *device, const AM_MEDIA_TYPE *mt);
     HRESULT (*set_format)(struct video_capture_device *device, const AM_MEDIA_TYPE *mt);
-    HRESULT (*get_format)(struct video_capture_device *device, AM_MEDIA_TYPE **mt);
+    HRESULT (*get_format)(struct video_capture_device *device, AM_MEDIA_TYPE *mt);
     HRESULT (*get_caps)(struct video_capture_device *device, LONG index, AM_MEDIA_TYPE **mt, VIDEO_STREAM_CONFIG_CAPS *caps);
     LONG (*get_caps_count)(struct video_capture_device *device);
     HRESULT (*get_prop_range)(struct video_capture_device *device, VideoProcAmpProperty property,
diff --git a/dlls/qcap/v4l.c b/dlls/qcap/v4l.c
index 5c2de2e3d67..2cf50b0c280 100644
--- a/dlls/qcap/v4l.c
+++ b/dlls/qcap/v4l.c
@@ -212,15 +212,11 @@ static HRESULT v4l_device_set_format(struct video_capture_device *iface, const A
     return S_OK;
 }
 
-static HRESULT v4l_device_get_format(struct video_capture_device *iface, AM_MEDIA_TYPE **mt)
+static HRESULT v4l_device_get_format(struct video_capture_device *iface, AM_MEDIA_TYPE *mt)
 {
     struct v4l_device *device = v4l_device(iface);
 
-    *mt = CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
-    if (!*mt)
-        return E_OUTOFMEMORY;
-
-    return CopyMediaType(*mt, &device->current_caps->media_type);
+    return CopyMediaType(mt, &device->current_caps->media_type);
 }
 
 static __u32 v4l2_cid_from_qcap_property(VideoProcAmpProperty property)
diff --git a/dlls/qcap/vfwcapture.c b/dlls/qcap/vfwcapture.c
index 9f4b8598638..7d82a01109c 100644
--- a/dlls/qcap/vfwcapture.c
+++ b/dlls/qcap/vfwcapture.c
@@ -223,16 +223,18 @@ AMStreamConfig_SetFormat(IAMStreamConfig *iface, AM_MEDIA_TYPE *pmt)
     return hr;
 }
 
-static HRESULT WINAPI AMStreamConfig_GetFormat(IAMStreamConfig *iface, AM_MEDIA_TYPE **pmt)
+static HRESULT WINAPI AMStreamConfig_GetFormat(IAMStreamConfig *iface, AM_MEDIA_TYPE **mt)
 {
     VfwCapture *filter = impl_from_IAMStreamConfig(iface);
     HRESULT hr;
 
-    TRACE("filter %p, mt %p.\n", filter, pmt);
+    TRACE("filter %p, mt %p.\n", filter, mt);
 
-    hr = filter->device->ops->get_format(filter->device, pmt);
-    if (SUCCEEDED(hr))
-        strmbase_dump_media_type(*pmt);
+    if (!(*mt = CoTaskMemAlloc(sizeof(**mt))))
+        return E_OUTOFMEMORY;
+
+    if (SUCCEEDED(hr = filter->device->ops->get_format(filter->device, *mt)))
+        strmbase_dump_media_type(*mt);
     return hr;
 }
 
From 6d675064f8f9eeb873a2c91d02c3ccbbfd982d56 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 29 Jun 2020 10:26:18 -0500
Subject: [PATCH] qcap: Use a condition variable to synchronize with the video
 capture thread.

This fixes a hang that can be triggered by calling Pause() followed by Stop().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/v4l.c | 58 +++++++++++++++++++++++++++++++++----------------
 1 file changed, 39 insertions(+), 19 deletions(-)

diff --git a/dlls/qcap/v4l.c b/dlls/qcap/v4l.c
index 2cf50b0c280..d8c5e168e14 100644
--- a/dlls/qcap/v4l.c
+++ b/dlls/qcap/v4l.c
@@ -98,9 +98,11 @@ struct v4l_device
 
     struct strmbase_source *pin;
     int fd, mmap;
-    FILTER_STATE state;
 
-    HANDLE thread, run_event;
+    HANDLE thread;
+    FILTER_STATE state;
+    CONDITION_VARIABLE state_cv;
+    CRITICAL_SECTION state_cs;
 };
 
 static inline struct v4l_device *v4l_device(struct video_capture_device *iface)
@@ -123,6 +125,8 @@ static void v4l_device_destroy(struct video_capture_device *iface)
 {
     struct v4l_device *device = v4l_device(iface);
 
+    device->state_cs.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&device->state_cs);
     if (device->fd != -1)
         video_close(device->fd);
     if (device->caps_count)
@@ -320,19 +324,18 @@ static void reverse_image(struct v4l_device *device, LPBYTE output, const BYTE *
     }
 }
 
-static DWORD WINAPI ReadThread(LPVOID lParam)
+static DWORD WINAPI ReadThread(void *arg)
 {
-    struct v4l_device *capBox = lParam;
+    struct v4l_device *device = arg;
     HRESULT hr;
     IMediaSample *pSample = NULL;
-    ULONG framecount = 0;
     unsigned char *pTarget, *image_data;
     unsigned int image_size;
     UINT width, height, depth;
 
-    width = capBox->current_caps->video_info.bmiHeader.biWidth;
-    height = capBox->current_caps->video_info.bmiHeader.biHeight;
-    depth = capBox->current_caps->video_info.bmiHeader.biBitCount / 8;
+    width = device->current_caps->video_info.bmiHeader.biWidth;
+    height = device->current_caps->video_info.bmiHeader.biHeight;
+    depth = device->current_caps->video_info.bmiHeader.biBitCount / 8;
     image_size = width * height * depth;
     if (!(image_data = heap_alloc(image_size)))
     {
@@ -340,12 +343,22 @@ static DWORD WINAPI ReadThread(LPVOID lParam)
         return 0;
     }
 
-    while (capBox->state != State_Stopped)
+    for (;;)
     {
-        if (capBox->state == State_Paused)
-            WaitForSingleObject(capBox->run_event, INFINITE);
+        EnterCriticalSection(&device->state_cs);
+
+        while (device->state == State_Paused)
+            SleepConditionVariableCS(&device->state_cv, &device->state_cs, INFINITE);
 
-        hr = BaseOutputPinImpl_GetDeliveryBuffer(capBox->pin, &pSample, NULL, NULL, 0);
+        if (device->state == State_Stopped)
+        {
+            LeaveCriticalSection(&device->state_cs);
+            break;
+        }
+
+        LeaveCriticalSection(&device->state_cs);
+
+        hr = BaseOutputPinImpl_GetDeliveryBuffer(device->pin, &pSample, NULL, NULL, 0);
         if (SUCCEEDED(hr))
         {
             int len;
@@ -358,7 +371,7 @@ static DWORD WINAPI ReadThread(LPVOID lParam)
 
             IMediaSample_GetPointer(pSample, &pTarget);
 
-            while (video_read(capBox->fd, image_data, image_size) == -1)
+            while (video_read(device->fd, image_data, image_size) == -1)
             {
                 if (errno != EAGAIN)
                 {
@@ -367,11 +380,11 @@ static DWORD WINAPI ReadThread(LPVOID lParam)
                 }
             }
 
-            reverse_image(capBox, pTarget, image_data);
-            hr = IMemInputPin_Receive(capBox->pin->pMemInputPin, pSample);
-            TRACE("%p -> Frame %u: %x\n", capBox, ++framecount, hr);
+            reverse_image(device, pTarget, image_data);
+            hr = IMemInputPin_Receive(device->pin->pMemInputPin, pSample);
             IMediaSample_Release(pSample);
         }
+
         if (FAILED(hr) && hr != VFW_E_NOT_CONNECTED)
         {
             TRACE("Return %x, stop IFilterGraph\n", hr);
@@ -412,15 +425,17 @@ static void v4l_device_init_stream(struct video_capture_device *iface)
 static void v4l_device_start_stream(struct video_capture_device *iface)
 {
     struct v4l_device *device = v4l_device(iface);
+    EnterCriticalSection(&device->state_cs);
     device->state = State_Running;
-    SetEvent(device->run_event);
+    LeaveCriticalSection(&device->state_cs);
 }
 
 static void v4l_device_stop_stream(struct video_capture_device *iface)
 {
     struct v4l_device *device = v4l_device(iface);
+    EnterCriticalSection(&device->state_cs);
     device->state = State_Paused;
-    ResetEvent(device->run_event);
+    LeaveCriticalSection(&device->state_cs);
 }
 
 static void v4l_device_cleanup_stream(struct video_capture_device *iface)
@@ -428,7 +443,10 @@ static void v4l_device_cleanup_stream(struct video_capture_device *iface)
     struct v4l_device *device = v4l_device(iface);
     HRESULT hr;
 
+    EnterCriticalSection(&device->state_cs);
     device->state = State_Stopped;
+    LeaveCriticalSection(&device->state_cs);
+    WakeConditionVariable(&device->state_cv);
     WaitForSingleObject(device->thread, INFINITE);
     CloseHandle(device->thread);
     device->thread = NULL;
@@ -656,7 +674,9 @@ struct video_capture_device *v4l_device_create(struct strmbase_source *pin, USHO
     device->d.ops = &v4l_device_ops;
     device->pin = pin;
     device->state = State_Stopped;
-    device->run_event = CreateEventW(NULL, TRUE, FALSE, NULL);
+    InitializeConditionVariable(&device->state_cv);
+    InitializeCriticalSection(&device->state_cs);
+    device->state_cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": v4l_device.state_cs");
 
     TRACE("Format: %d bpp - %dx%d.\n", device->current_caps->video_info.bmiHeader.biBitCount,
             device->current_caps->video_info.bmiHeader.biWidth,
From c80d5c1507d2853e659c3647410c4cd20cc7b2d5 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 30 Jun 2020 19:57:12 -0500
Subject: [PATCH] amstream: Decrement "sample_refs" only when the object is
 being released.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 56230ca4e63..b7196d9fc9e 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -980,7 +980,6 @@ HRESULT ddraw_stream_create(IUnknown *outer, void **out)
     object->IMemInputPin_iface.lpVtbl = &ddraw_meminput_vtbl;
     object->IPin_iface.lpVtbl = &ddraw_sink_vtbl;
     object->ref = 1;
-    object->sample_refs = 0;
 
     InitializeCriticalSection(&object->cs);
 
@@ -1043,12 +1042,12 @@ static ULONG WINAPI ddraw_sample_Release(IDirectDrawStreamSample *iface)
 
     TRACE("(%p)->(): new ref = %u\n", iface, ref);
 
-    EnterCriticalSection(&sample->parent->cs);
-    InterlockedDecrement(&sample->parent->sample_refs);
-    LeaveCriticalSection(&sample->parent->cs);
-
     if (!ref)
     {
+        EnterCriticalSection(&sample->parent->cs);
+        --sample->parent->sample_refs;
+        LeaveCriticalSection(&sample->parent->cs);
+
         if (sample->surface)
             IDirectDrawSurface_Release(sample->surface);
         HeapFree(GetProcessHeap(), 0, sample);
@@ -1166,7 +1165,7 @@ static HRESULT ddrawstreamsample_create(struct ddraw_stream *parent, IDirectDraw
     object->parent = parent;
 
     EnterCriticalSection(&parent->cs);
-    InterlockedIncrement(&parent->sample_refs);
+    ++parent->sample_refs;
     LeaveCriticalSection(&parent->cs);
 
     if (surface)
From 276701e9b44b7cc789a18394bd75c3a44ed43a2e Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 30 Jun 2020 19:57:13 -0500
Subject: [PATCH] amstream: Lock the entirety of
 IDirectDrawMediaStream::CreateSample().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index b7196d9fc9e..7095e1d49ab 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -437,11 +437,16 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_CreateSample(IDirectDrawMedia
         IDirectDrawStreamSample **sample)
 {
     struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    HRESULT hr;
 
     TRACE("stream %p, surface %p, rect %s, flags %#x, sample %p.\n",
             stream, surface, wine_dbgstr_rect(rect), flags, sample);
 
-    return ddrawstreamsample_create(stream, surface, rect, sample);
+    EnterCriticalSection(&stream->cs);
+    hr = ddrawstreamsample_create(stream, surface, rect, sample);
+    LeaveCriticalSection(&stream->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetTimePerFrame(IDirectDrawMediaStream *iface,
@@ -1163,10 +1168,7 @@ static HRESULT ddrawstreamsample_create(struct ddraw_stream *parent, IDirectDraw
     object->IDirectDrawStreamSample_iface.lpVtbl = &DirectDrawStreamSample_Vtbl;
     object->ref = 1;
     object->parent = parent;
-
-    EnterCriticalSection(&parent->cs);
     ++parent->sample_refs;
-    LeaveCriticalSection(&parent->cs);
 
     if (surface)
     {
From ddcabfa2d7237ec785590ee6a6a2fe7fea3e5526 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 30 Jun 2020 19:57:14 -0500
Subject: [PATCH] amstream/tests: Add more AMVideoStream::QueryAccept() tests.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 41 ++++++++++++++++++++++++++--------
 1 file changed, 32 insertions(+), 9 deletions(-)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 9a97b6be655..5db46bbca4d 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -27,6 +27,7 @@
 #include "ks.h"
 #include "initguid.h"
 #include "ksmedia.h"
+#include "dvdmedia.h"
 #include "wine/strmbase.h"
 
 static const WAVEFORMATEX audio_format =
@@ -1859,7 +1860,11 @@ static void test_enum_media_types(void)
 
 static void test_media_types(void)
 {
-    static const VIDEOINFOHEADER req_vih = {};
+    static const VIDEOINFOHEADER2 req_vih2;
+    static const VIDEOINFOHEADER req_vih;
+    static const MPEG2VIDEOINFO req_m2vi;
+    static const MPEG1VIDEOINFO req_m1vi;
+    static const WAVEFORMATEX req_wfx;
     static const WAVEFORMATEX expect_wfx =
     {
         .wFormatTag = WAVE_FORMAT_PCM,
@@ -1879,6 +1884,23 @@ static void test_media_types(void)
     HRESULT hr;
     IPin *pin;
 
+    static const struct
+    {
+        const GUID *type;
+        BYTE *format;
+        ULONG size;
+    }
+    tests[] =
+    {
+        {&GUID_NULL, NULL, 0 },
+        {&FORMAT_None, NULL, 0 },
+        {&FORMAT_WaveFormatEx, (BYTE *)&req_wfx, sizeof(WAVEFORMATEX)},
+        {&FORMAT_MPEG2Video, (BYTE *)&req_m2vi, sizeof(MPEG2VIDEOINFO)},
+        {&FORMAT_MPEGVideo, (BYTE *)&req_m1vi, sizeof(MPEG2VIDEOINFO)},
+        {&FORMAT_VideoInfo2, (BYTE *)&req_vih2, sizeof(VIDEOINFOHEADER2)},
+        {&FORMAT_VideoInfo, (BYTE *)&req_vih, sizeof(VIDEOINFOHEADER)},
+    };
+
     static const GUID *rejected_subtypes[] =
     {
         &MEDIASUBTYPE_RGB1,
@@ -1918,14 +1940,15 @@ static void test_media_types(void)
             wine_dbgstr_guid(&pmt->formattype));
     ok(!pmt->pUnk, "Got pUnk %p.\n", pmt->pUnk);
 
-    hr = IPin_QueryAccept(pin, pmt);
-    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
-
-    pmt->formattype = FORMAT_VideoInfo;
-    pmt->cbFormat = sizeof(VIDEOINFOHEADER);
-    pmt->pbFormat = (BYTE *)&req_vih;
-    hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    for (i = 0; i < ARRAY_SIZE(tests); ++i)
+    {
+        pmt->formattype = *tests[i].type;
+        pmt->cbFormat = tests[i].size;
+        pmt->pbFormat = tests[i].format;
+        hr = IPin_QueryAccept(pin, pmt);
+        todo_wine_if (i != 6)
+            ok(hr == (i == 6) ? S_OK : VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    }
 
     pmt->bFixedSizeSamples = FALSE;
     pmt->bTemporalCompression = TRUE;
From 83bdfb780c352d428650de013492d4bfb186f976 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 30 Jun 2020 19:57:15 -0500
Subject: [PATCH] amstream: Return VFW_E_TYPE_NOT_ACCEPTED on error in
 AMVideoStream::QueryAccept().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    | 2 +-
 dlls/amstream/tests/amstream.c | 9 +++++----
 2 files changed, 6 insertions(+), 5 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 7095e1d49ab..bcb752e6bdf 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -798,7 +798,7 @@ static HRESULT WINAPI ddraw_sink_QueryId(IPin *iface, WCHAR **id)
 static HRESULT WINAPI ddraw_sink_QueryAccept(IPin *iface, const AM_MEDIA_TYPE *mt)
 {
     TRACE("iface %p, mt %p.\n", iface, mt);
-    return check_media_type(mt) ? S_OK : S_FALSE;
+    return check_media_type(mt) ? S_OK : VFW_E_TYPE_NOT_ACCEPTED;
 }
 
 static HRESULT WINAPI ddraw_sink_EnumMediaTypes(IPin *iface, IEnumMediaTypes **enum_media_types)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 5db46bbca4d..a9a9ccfed09 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -1958,20 +1958,21 @@ static void test_media_types(void)
 
     pmt->majortype = MEDIATYPE_NULL;
     hr = IPin_QueryAccept(pin, pmt);
-    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     pmt->majortype = MEDIATYPE_Audio;
     hr = IPin_QueryAccept(pin, pmt);
-    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     pmt->majortype = MEDIATYPE_Stream;
     hr = IPin_QueryAccept(pin, pmt);
-    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     pmt->majortype = MEDIATYPE_Video;
 
     for (i = 0; i < ARRAY_SIZE(rejected_subtypes); ++i)
     {
         pmt->subtype = *rejected_subtypes[i];
         hr = IPin_QueryAccept(pin, pmt);
-        todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x for subtype %s.\n",
+        todo_wine_if (i < 6)
+            ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x for subtype %s.\n",
                 hr, wine_dbgstr_guid(rejected_subtypes[i]));
     }
 
From fddae90d9b147b54a5edc8657e5f991cc26d8fbb Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 30 Jun 2020 19:57:16 -0500
Subject: [PATCH] amstream: Validate the format type in check_media_type().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    | 3 ++-
 dlls/amstream/tests/amstream.c | 3 +--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index bcb752e6bdf..9fcb6d37cee 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -634,7 +634,8 @@ static HRESULT WINAPI ddraw_sink_Connect(IPin *iface, IPin *peer, const AM_MEDIA
 
 static BOOL check_media_type(const AM_MEDIA_TYPE *media_type)
 {
-    if (IsEqualGUID(&media_type->majortype, &MEDIATYPE_Video))
+    if (IsEqualGUID(&media_type->majortype, &MEDIATYPE_Video)
+            && IsEqualGUID(&media_type->formattype, &FORMAT_VideoInfo))
     {
         if (IsEqualGUID(&media_type->subtype, &MEDIASUBTYPE_RGB1) ||
             IsEqualGUID(&media_type->subtype, &MEDIASUBTYPE_RGB4) ||
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index a9a9ccfed09..1fa1f2432c5 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -1946,8 +1946,7 @@ static void test_media_types(void)
         pmt->cbFormat = tests[i].size;
         pmt->pbFormat = tests[i].format;
         hr = IPin_QueryAccept(pin, pmt);
-        todo_wine_if (i != 6)
-            ok(hr == (i == 6) ? S_OK : VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+        ok(hr == (i == 6) ? S_OK : VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     }
 
     pmt->bFixedSizeSamples = FALSE;
From a7c515fe01c4902a3e7c6b60608a54b77e252b47 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 30 Jun 2020 19:57:17 -0500
Subject: [PATCH] amstream: Accept only MEDIASUBTYPE_RGB8 in
 check_media_type().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    | 21 +++++----------------
 dlls/amstream/tests/amstream.c |  5 ++---
 2 files changed, 7 insertions(+), 19 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 9fcb6d37cee..5530603f7aa 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -632,23 +632,12 @@ static HRESULT WINAPI ddraw_sink_Connect(IPin *iface, IPin *peer, const AM_MEDIA
     return E_UNEXPECTED;
 }
 
-static BOOL check_media_type(const AM_MEDIA_TYPE *media_type)
+static BOOL check_media_type(const AM_MEDIA_TYPE *mt)
 {
-    if (IsEqualGUID(&media_type->majortype, &MEDIATYPE_Video)
-            && IsEqualGUID(&media_type->formattype, &FORMAT_VideoInfo))
-    {
-        if (IsEqualGUID(&media_type->subtype, &MEDIASUBTYPE_RGB1) ||
-            IsEqualGUID(&media_type->subtype, &MEDIASUBTYPE_RGB4) ||
-            IsEqualGUID(&media_type->subtype, &MEDIASUBTYPE_RGB8)  ||
-            IsEqualGUID(&media_type->subtype, &MEDIASUBTYPE_RGB565) ||
-            IsEqualGUID(&media_type->subtype, &MEDIASUBTYPE_RGB555) ||
-            IsEqualGUID(&media_type->subtype, &MEDIASUBTYPE_RGB24) ||
-            IsEqualGUID(&media_type->subtype, &MEDIASUBTYPE_RGB32))
-        {
-            TRACE("Video sub-type %s matches\n", debugstr_guid(&media_type->subtype));
-            return TRUE;
-        }
-    }
+    if (IsEqualGUID(&mt->majortype, &MEDIATYPE_Video)
+            && IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB8)
+            && IsEqualGUID(&mt->formattype, &FORMAT_VideoInfo))
+        return TRUE;
 
     return FALSE;
 }
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 1fa1f2432c5..bbad585d48a 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -1970,9 +1970,8 @@ static void test_media_types(void)
     {
         pmt->subtype = *rejected_subtypes[i];
         hr = IPin_QueryAccept(pin, pmt);
-        todo_wine_if (i < 6)
-            ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x for subtype %s.\n",
-                hr, wine_dbgstr_guid(rejected_subtypes[i]));
+        ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x for subtype %s.\n",
+            hr, wine_dbgstr_guid(rejected_subtypes[i]));
     }
 
     CoTaskMemFree(pmt);
From f446bb21f29fee1aabc7e4d6fe62b55dbd359741 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Mon, 6 Jul 2020 17:42:47 +0200
Subject: [PATCH] amstream: Increment/decrement IMediaStreamFilter refcount
 twice in multimedia_stream_create/release().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/multimedia.c     | 4 ++++
 dlls/amstream/tests/amstream.c | 8 ++++----
 2 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/dlls/amstream/multimedia.c b/dlls/amstream/multimedia.c
index e058e639ddb..f615e436b18 100644
--- a/dlls/amstream/multimedia.c
+++ b/dlls/amstream/multimedia.c
@@ -92,6 +92,7 @@ static ULONG WINAPI multimedia_stream_Release(IAMMultiMediaStream *iface)
         if (This->ipin)
             IPin_Release(This->ipin);
         IMediaStreamFilter_Release(This->filter);
+        IMediaStreamFilter_Release(This->filter);
         if (This->media_seeking)
             IMediaSeeking_Release(This->media_seeking);
         if (This->media_control)
@@ -518,6 +519,9 @@ HRESULT multimedia_stream_create(IUnknown *outer, void **out)
         return hr;
     }
 
+    /* The stream takes an additional reference to the filter. */
+    IMediaStreamFilter_AddRef(object->filter);
+
     TRACE("Created multimedia stream %p.\n", object);
     *out = &object->IAMMultiMediaStream_iface;
 
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 3fb77f277a8..7ebd54f6da9 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -1140,7 +1140,7 @@ static void test_enum_pins(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ref = get_refcount(filter);
-    todo_wine ok(ref == 3, "Got unexpected refcount %d.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
 
     hr = IMediaStreamFilter_EnumPins(filter, NULL);
     ok(hr == E_POINTER, "Got hr %#x.\n", hr);
@@ -1148,7 +1148,7 @@ static void test_enum_pins(void)
     hr = IMediaStreamFilter_EnumPins(filter, &enum1);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    todo_wine ok(ref == 3, "Got unexpected refcount %d.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
     ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
@@ -1186,7 +1186,7 @@ static void test_enum_pins(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ref = get_refcount(filter);
-    todo_wine ok(ref == 4, "Got unexpected refcount %d.\n", ref);
+    ok(ref == 4, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
     ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
@@ -1196,7 +1196,7 @@ static void test_enum_pins(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pins[0] == pin, "Expected pin %p, got %p.\n", pin, pins[0]);
     ref = get_refcount(filter);
-    todo_wine ok(ref == 4, "Got unexpected refcount %d.\n", ref);
+    ok(ref == 4, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
     ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
From 6bfd79be6def16935a9a8e88c5ec3175512ed536 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Mon, 6 Jul 2020 17:42:48 +0200
Subject: [PATCH] amstream/tests: Add IAMMediaStream::JoinFilter() tests.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 62 ++++++++++++++++++++++++++++++++++
 1 file changed, 62 insertions(+)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 7ebd54f6da9..608bb2267f9 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -4262,6 +4262,67 @@ static void test_ammediastream_join_am_multi_media_stream(void)
     check_ammediastream_join_am_multi_media_stream(&CLSID_AMDirectDrawStream);
 }
 
+static void check_ammediastream_join_filter(const CLSID *clsid)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IMediaStreamFilter *filter, *filter2, *filter3;
+    IAMMediaStream *stream;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!!filter, "Expected non-null filter.\n");
+    EXPECT_REF(filter, 3);
+
+    hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(filter, 3);
+
+    hr = CoCreateInstance(&CLSID_MediaStreamFilter, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IMediaStreamFilter, (void **)&filter2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(filter, 3);
+    EXPECT_REF(filter2, 1);
+
+    hr = IAMMediaStream_JoinFilter(stream, filter2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(filter, 3);
+    EXPECT_REF(filter2, 1);
+
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IAMMediaStream_JoinFilter(stream, NULL);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+    }
+
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(filter3 == filter, "Expected filter %p, got %p.\n", filter, filter3);
+    EXPECT_REF(filter, 4);
+
+    IMediaStreamFilter_Release(filter3);
+    EXPECT_REF(filter, 3);
+
+    ref = IMediaStreamFilter_Release(filter2);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    EXPECT_REF(filter, 3);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    EXPECT_REF(filter, 1);
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_ammediastream_join_filter(void)
+{
+    check_ammediastream_join_filter(&CLSID_AMAudioStream);
+    check_ammediastream_join_filter(&CLSID_AMDirectDrawStream);
+}
+
 void test_mediastreamfilter_get_state(void)
 {
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
@@ -4956,6 +5017,7 @@ START_TEST(amstream)
     test_ddrawstream_getsetdirectdraw();
 
     test_ammediastream_join_am_multi_media_stream();
+    test_ammediastream_join_filter();
 
     test_mediastreamfilter_get_state();
     test_mediastreamfilter_stop_pause_run();
From 388c53160dff455c05e87315e6d7c986b78bad45 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 7 Jul 2020 00:58:14 +0200
Subject: [PATCH] amstream: Add graph to stream in
 IMediaStreamFilter::AddMediaStream().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/filter.c         |  4 ++++
 dlls/amstream/tests/amstream.c | 10 ++++++++--
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/dlls/amstream/filter.c b/dlls/amstream/filter.c
index 0e09e492cb7..0a06e78180c 100644
--- a/dlls/amstream/filter.c
+++ b/dlls/amstream/filter.c
@@ -497,6 +497,10 @@ static HRESULT WINAPI filter_AddMediaStream(IMediaStreamFilter *iface, IAMMediaS
     if (FAILED(hr))
         return hr;
 
+    hr = IAMMediaStream_JoinFilterGraph(pAMMediaStream, This->graph);
+    if (FAILED(hr))
+        return hr;
+
     This->streams[This->nb_streams] = pAMMediaStream;
     This->nb_streams++;
 
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 608bb2267f9..0e9c40d1180 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -686,6 +686,7 @@ static void test_add_stream(void)
     IEnumFilters *enum_filters;
     IBaseFilter *filters[3];
     IGraphBuilder *graph;
+    FILTER_INFO info;
     ULONG ref, count;
     CLSID clsid;
     HRESULT hr;
@@ -755,13 +756,18 @@ static void test_add_stream(void)
     hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)&teststream, &IID_IUnknown, 0, &stream);
     ok(hr == MS_E_PURPOSEID, "Got hr %#x.\n", hr);
 
+    hr = IMediaStreamFilter_QueryFilterInfo(stream_filter, &info);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
     hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)&teststream, &test_mspid, 0, &stream);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(stream == (IMediaStream *)&teststream, "Streams didn't match.\n");
-    if (hr == S_OK) IMediaStream_Release(stream);
+    IMediaStream_Release(stream);
     ok(teststream.mmstream == mmstream, "IAMMultiMediaStream objects didn't match.\n");
     ok(teststream.filter == stream_filter, "IMediaStreamFilter objects didn't match.\n");
-    todo_wine ok(!!teststream.graph, "Expected a non-NULL graph.\n");
+    ok(teststream.graph == info.pGraph, "IFilterGraph objects didn't match.\n");
+
+    IFilterGraph_Release(info.pGraph);
 
     check_enum_stream(mmstream, stream_filter, 0, video_stream);
     check_enum_stream(mmstream, stream_filter, 1, audio_stream);
From f7164ccfd17da8d978dbabff6eff84ce6caf1c8d Mon Sep 17 00:00:00 2001
From: Vijay Kiran Kamuju <infyquest@gmail.com>
Date: Sun, 28 Jun 2020 17:33:45 -0500
Subject: [PATCH] qdvd: Register the DvdGraphBuilder coclass.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49458
Signed-off-by: Vijay Kiran Kamuju <infyquest@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qdvd/Makefile.in      |  3 +++
 dlls/qdvd/qdvd.spec        |  4 ++--
 dlls/qdvd/qdvd_classes.idl | 26 ++++++++++++++++++++++++++
 dlls/qdvd/qdvd_main.c      | 17 +++++++++++++++++
 4 files changed, 48 insertions(+), 2 deletions(-)
 create mode 100644 dlls/qdvd/qdvd_classes.idl

diff --git a/dlls/qdvd/Makefile.in b/dlls/qdvd/Makefile.in
index c4b7dcce1f0..b3b13486ed5 100644
--- a/dlls/qdvd/Makefile.in
+++ b/dlls/qdvd/Makefile.in
@@ -4,3 +4,6 @@ EXTRADLLFLAGS = -mno-cygwin
 
 C_SRCS = \
 	qdvd_main.c
+
+IDL_SRCS = \
+	qdvd_classes.idl
diff --git a/dlls/qdvd/qdvd.spec b/dlls/qdvd/qdvd.spec
index c534b4fbf40..b16365d0c9f 100644
--- a/dlls/qdvd/qdvd.spec
+++ b/dlls/qdvd/qdvd.spec
@@ -1,4 +1,4 @@
 @ stdcall -private DllCanUnloadNow()
 @ stdcall -private DllGetClassObject(ptr ptr ptr)
-@ stub DllRegisterServer
-@ stub DllUnregisterServer
+@ stdcall -private DllRegisterServer()
+@ stdcall -private DllUnregisterServer()
diff --git a/dlls/qdvd/qdvd_classes.idl b/dlls/qdvd/qdvd_classes.idl
new file mode 100644
index 00000000000..7fd2a081baf
--- /dev/null
+++ b/dlls/qdvd/qdvd_classes.idl
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2020 Vijay Kiran Kamuju
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+[
+    helpstring("DVD Graph Builder"),
+    threading(both),
+    uuid(fcc152b7-f372-11d0-8e00-00c04fd7c08b),
+]
+coclass DvdGraphBuilder {}
diff --git a/dlls/qdvd/qdvd_main.c b/dlls/qdvd/qdvd_main.c
index 5c7368ce908..72dcda7c91e 100644
--- a/dlls/qdvd/qdvd_main.c
+++ b/dlls/qdvd/qdvd_main.c
@@ -21,17 +21,24 @@
 #include <stdarg.h>
 #include "windef.h"
 #include "winbase.h"
+#include "oleidl.h"
+#include "rpcproxy.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qdvd);
 
+static HINSTANCE qdvd_instance;
+
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
     if (reason == DLL_WINE_PREATTACH)
         return FALSE; /* prefer native version */
 
     if (reason == DLL_PROCESS_ATTACH)
+    {
+        qdvd_instance = instance;
         DisableThreadLibraryCalls(instance);
+    }
     return TRUE;
 }
 
@@ -41,6 +48,16 @@ HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **out)
     return CLASS_E_CLASSNOTAVAILABLE;
 }
 
+HRESULT WINAPI DllRegisterServer(void)
+{
+    return __wine_register_resources(qdvd_instance);
+}
+
+HRESULT WINAPI DllUnregisterServer(void)
+{
+    return __wine_unregister_resources(qdvd_instance);
+}
+
 HRESULT WINAPI DllCanUnloadNow(void)
 {
     return S_FALSE;
From 4cd2ca96c2b65acd977f7c9217e260c024e0ecbc Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 7 Jul 2020 10:14:56 -0500
Subject: [PATCH] qdvd: Add IDvdGraphBuilder stub.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=18072
Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qdvd/Makefile.in    |   2 +
 dlls/qdvd/graph.c        | 112 +++++++++++++++++++++++++++++++++++++++
 dlls/qdvd/qdvd_main.c    |  89 ++++++++++++++++++++++++++++---
 dlls/qdvd/qdvd_private.h |  30 +++++++++++
 4 files changed, 227 insertions(+), 6 deletions(-)
 create mode 100644 dlls/qdvd/graph.c
 create mode 100644 dlls/qdvd/qdvd_private.h

diff --git a/dlls/qdvd/Makefile.in b/dlls/qdvd/Makefile.in
index b3b13486ed5..8f5089b3acc 100644
--- a/dlls/qdvd/Makefile.in
+++ b/dlls/qdvd/Makefile.in
@@ -1,8 +1,10 @@
 MODULE    = qdvd.dll
+IMPORTS   = strmiids uuid ole32
 
 EXTRADLLFLAGS = -mno-cygwin
 
 C_SRCS = \
+	graph.c \
 	qdvd_main.c
 
 IDL_SRCS = \
diff --git a/dlls/qdvd/graph.c b/dlls/qdvd/graph.c
new file mode 100644
index 00000000000..f33293bfa46
--- /dev/null
+++ b/dlls/qdvd/graph.c
@@ -0,0 +1,112 @@
+/*
+ * Graph builder
+ *
+ * Copyright 2020 Gijs Vermeulen
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "qdvd_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(qdvd);
+
+struct graph_builder
+{
+    IDvdGraphBuilder IDvdGraphBuilder_iface;
+    LONG refcount;
+};
+
+static struct graph_builder *impl_from_IDvdGraphBuilder(IDvdGraphBuilder *iface)
+{
+    return CONTAINING_RECORD(iface, struct graph_builder, IDvdGraphBuilder_iface);
+}
+
+static ULONG WINAPI graph_builder_AddRef(IDvdGraphBuilder *iface)
+{
+    struct graph_builder *builder = impl_from_IDvdGraphBuilder(iface);
+    ULONG refcount = InterlockedIncrement(&builder->refcount);
+    TRACE("%p increasing refcount to %u.\n", builder, refcount);
+    return refcount;
+}
+
+static ULONG WINAPI graph_builder_Release(IDvdGraphBuilder *iface)
+{
+    struct graph_builder *builder = impl_from_IDvdGraphBuilder(iface);
+    ULONG refcount = InterlockedDecrement(&builder->refcount);
+    TRACE("%p decreasing refcount to %u.\n", builder, refcount);
+    if (!refcount)
+        free(builder);
+    return refcount;
+}
+
+static HRESULT WINAPI graph_builder_QueryInterface(IDvdGraphBuilder *iface, REFIID iid, void **out)
+{
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IDvdGraphBuilder) || IsEqualGUID(iid, &IID_IUnknown))
+        *out = iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static HRESULT WINAPI graph_builder_GetFiltergraph(IDvdGraphBuilder *iface, IGraphBuilder **graph)
+{
+    FIXME("iface %p, graph %p, stub!\n", iface, graph);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI graph_builder_GetDvdInterface(IDvdGraphBuilder *iface, REFIID iid, void **out)
+{
+    FIXME("iface %p, iid %s, out %p, stub!\n", iface, debugstr_guid(iid), out);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI graph_builder_RenderDvdVideoVolume(IDvdGraphBuilder *iface, const WCHAR *path, DWORD flags, AM_DVD_RENDERSTATUS *status)
+{
+    FIXME("iface %p, path %s, flags %#x, status %p, stub!\n", iface, debugstr_w(path), flags, status);
+    return E_NOTIMPL;
+}
+
+static const struct IDvdGraphBuilderVtbl graph_builder_vtbl =
+{
+    graph_builder_QueryInterface,
+    graph_builder_AddRef,
+    graph_builder_Release,
+    graph_builder_GetFiltergraph,
+    graph_builder_GetDvdInterface,
+    graph_builder_RenderDvdVideoVolume,
+};
+
+HRESULT graph_builder_create(IUnknown **out)
+{
+    struct graph_builder *builder;
+
+    if (!(builder = calloc(1, sizeof(*builder))))
+        return E_OUTOFMEMORY;
+
+    builder->IDvdGraphBuilder_iface.lpVtbl = &graph_builder_vtbl;
+    builder->refcount = 1;
+
+    TRACE("Created DVD graph builder %p.\n", builder);
+    *out = (IUnknown *)&builder->IDvdGraphBuilder_iface;
+    return S_OK;
+}
diff --git a/dlls/qdvd/qdvd_main.c b/dlls/qdvd/qdvd_main.c
index 72dcda7c91e..9377f248ce9 100644
--- a/dlls/qdvd/qdvd_main.c
+++ b/dlls/qdvd/qdvd_main.c
@@ -18,17 +18,89 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include <stdarg.h>
-#include "windef.h"
-#include "winbase.h"
-#include "oleidl.h"
+#include "qdvd_private.h"
 #include "rpcproxy.h"
-#include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(qdvd);
 
 static HINSTANCE qdvd_instance;
 
+struct class_factory
+{
+    IClassFactory IClassFactory_iface;
+    HRESULT (*create_instance)(IUnknown **out);
+};
+
+static struct class_factory *impl_from_IClassFactory(IClassFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct class_factory, IClassFactory_iface);
+}
+
+static HRESULT WINAPI class_factory_QueryInterface(IClassFactory *iface, REFIID iid, void **out)
+{
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IClassFactory))
+    {
+        IClassFactory_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+    *out = NULL;
+    WARN("%s not implemented, returning E_NOINTERFACE\n", debugstr_guid(iid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI class_factory_AddRef(IClassFactory *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI class_factory_Release(IClassFactory *iface)
+{
+    return 1;
+}
+
+static HRESULT WINAPI class_factory_CreateInstance(IClassFactory *iface,
+        IUnknown *outer, REFIID iid, void **out)
+{
+    struct class_factory *factory = impl_from_IClassFactory(iface);
+    IUnknown *unk;
+    HRESULT hr;
+
+    TRACE("iface %p, outer %p, iid %s, out %p.\n", iface, outer, debugstr_guid(iid), out);
+
+    *out = NULL;
+
+    if (outer)
+        return CLASS_E_NOAGGREGATION;
+
+    if (SUCCEEDED(hr = factory->create_instance(&unk)))
+    {
+        hr = IUnknown_QueryInterface(unk, iid, out);
+        IUnknown_Release(unk);
+    }
+    return hr;
+}
+
+static HRESULT WINAPI class_factory_LockServer(IClassFactory *iface, BOOL lock)
+{
+    FIXME("lock %d, stub!\n", lock);
+    return S_OK;
+}
+
+static const IClassFactoryVtbl class_factory_vtbl =
+{
+    class_factory_QueryInterface,
+    class_factory_AddRef,
+    class_factory_Release,
+    class_factory_CreateInstance,
+    class_factory_LockServer,
+};
+
+static struct class_factory graph_builder_cf = {{&class_factory_vtbl}, graph_builder_create};
+
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
     if (reason == DLL_WINE_PREATTACH)
@@ -44,7 +116,12 @@ BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 
 HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **out)
 {
-    FIXME("clsid %s, iid %s, out %p, stub!\n", debugstr_guid(clsid), debugstr_guid(iid), out);
+    TRACE("clsid %s, iid %s, out %p.\n", debugstr_guid(clsid), debugstr_guid(iid), out);
+
+    if (IsEqualGUID(clsid, &CLSID_DvdGraphBuilder))
+        return IClassFactory_QueryInterface(&graph_builder_cf.IClassFactory_iface, iid, out);
+
+    FIXME("%s not available, returning CLASS_E_CLASSNOTAVAILABLE.\n", debugstr_guid(clsid));
     return CLASS_E_CLASSNOTAVAILABLE;
 }
 
diff --git a/dlls/qdvd/qdvd_private.h b/dlls/qdvd/qdvd_private.h
new file mode 100644
index 00000000000..b54dd3ddc1c
--- /dev/null
+++ b/dlls/qdvd/qdvd_private.h
@@ -0,0 +1,30 @@
+/*
+ * DirectShow DVD filters
+ *
+ * Copyright 2020 Gijs Vermeulen
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef QDVD_PRIVATE_H
+#define QDVD_PRIVATE_H
+
+#define COBJMACROS
+#include "dshow.h"
+#include "wine/debug.h"
+
+HRESULT graph_builder_create(IUnknown **out) DECLSPEC_HIDDEN;
+
+#endif /* QDVD_PRIVATE_H */
From c8d748749ab8e08a3a18575efcc46fbcf1a70c2e Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 7 Jul 2020 17:46:47 +0200
Subject: [PATCH] amstream/tests: Fix filter leak in test_add_stream().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 0e9c40d1180..2d9f3e35f26 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -894,8 +894,6 @@ static void test_add_stream(void)
         hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
         ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!!graph, "Got graph %p.\n", graph);
-        hr = IAMMultiMediaStream_GetFilter(mmstream, &stream_filter);
-        ok(hr == S_OK, "Got hr %#x.\n", hr);
         hr = IGraphBuilder_EnumFilters(graph, &enum_filters);
         ok(hr == S_OK, "Got hr %#x.\n", hr);
         hr = IEnumFilters_Next(enum_filters, 3, filters, &count);
@@ -907,7 +905,7 @@ static void test_add_stream(void)
         ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(IsEqualGUID(&clsid, &CLSID_DSoundRender), "Got unexpected filter %s.\n", wine_dbgstr_guid(&clsid));
         IBaseFilter_Release(filters[0]);
-        IMediaStreamFilter_Release(stream_filter);
+        IBaseFilter_Release(filters[1]);
         IEnumFilters_Release(enum_filters);
         IGraphBuilder_Release(graph);
     }
@@ -919,9 +917,10 @@ static void test_add_stream(void)
             AMMSF_ADDDEFAULTRENDERER, &audio_stream);
     ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
-    IMediaStreamFilter_Release(stream_filter);
     ref = IAMMultiMediaStream_Release(mmstream);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IMediaStreamFilter_Release(stream_filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_media_streams(void)
From fb64420673012b4b26d126b3ebf8fcecff719fb7 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 10 Jul 2020 11:42:46 -0500
Subject: [PATCH] msdmo: Remove dead code associated with an older registry
 format.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/msdmo/dmoreg.c | 113 +++-----------------------------------------
 1 file changed, 6 insertions(+), 107 deletions(-)

diff --git a/dlls/msdmo/dmoreg.c b/dlls/msdmo/dmoreg.c
index 1a35b41f468..ffe64782d1c 100644
--- a/dlls/msdmo/dmoreg.c
+++ b/dlls/msdmo/dmoreg.c
@@ -32,8 +32,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msdmo);
 
-#define MSDMO_MAJOR_VERSION 6
-
 static const WCHAR szDMORootKey[] = 
 {
     'D','i','r','e','c','t','S','h','o','w','\\',
@@ -139,40 +137,8 @@ static BOOL IsMediaTypeEqual(const DMO_PARTIAL_MEDIATYPE* mt1, const DMO_PARTIAL
 
 static HRESULT write_types(HKEY hkey, LPCWSTR name, const DMO_PARTIAL_MEDIATYPE* types, DWORD count)
 {
-    LONG ret;
-
-    if (MSDMO_MAJOR_VERSION > 5)
-    {
-        ret = RegSetValueExW(hkey, name, 0, REG_BINARY, (const BYTE*) types,
-                          count* sizeof(DMO_PARTIAL_MEDIATYPE));
-    }
-    else
-    {
-        HKEY skey1,skey2,skey3;
-        DWORD index = 0;
-        WCHAR szGuidKey[64];
-
-        ret = RegCreateKeyExW(hkey, name, 0, NULL, REG_OPTION_NON_VOLATILE,
-                               KEY_WRITE, NULL, &skey1, NULL);
-        if (ret)
-            return HRESULT_FROM_WIN32(ret);
-
-        while (index < count)
-        {
-            GUIDToString(szGuidKey,&types[index].type);
-            ret = RegCreateKeyExW(skey1, szGuidKey, 0, NULL,
-                        REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &skey2, NULL);
-            GUIDToString(szGuidKey,&types[index].subtype);
-            ret = RegCreateKeyExW(skey2, szGuidKey, 0, NULL,
-                        REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &skey3, NULL);
-            RegCloseKey(skey3);
-            RegCloseKey(skey2);
-            index ++;
-        }
-        RegCloseKey(skey1);
-    }
-
-    return HRESULT_FROM_WIN32(ret);
+    return HRESULT_FROM_WIN32(RegSetValueExW(hkey, name, 0, REG_BINARY,
+            (const BYTE *)types, count * sizeof(DMO_PARTIAL_MEDIATYPE)));
 }
 
 /***************************************************************
@@ -766,78 +732,11 @@ static const IEnumDMOVtbl edmovt =
 
 HRESULT read_types(HKEY root, LPCWSTR key, ULONG *supplied, ULONG requested, DMO_PARTIAL_MEDIATYPE* types )
 {
-    HRESULT ret = S_OK;
+    DWORD len = requested * sizeof(DMO_PARTIAL_MEDIATYPE);
+    LONG ret = RegQueryValueExW(root, key, NULL, NULL, (BYTE *)types, &len);
 
-    if (MSDMO_MAJOR_VERSION > 5)
-    {
-        DWORD len;
-        LONG rc;
-
-        len = requested * sizeof(DMO_PARTIAL_MEDIATYPE);
-        rc = RegQueryValueExW(root, key, NULL, NULL, (LPBYTE) types, &len);
-        ret = HRESULT_FROM_WIN32(rc);
-
-        *supplied = len / sizeof(DMO_PARTIAL_MEDIATYPE);
-    }
-    else
-    {
-        HKEY hkey;
-        WCHAR szGuidKey[64];
-
-        *supplied = 0;
-        if (ERROR_SUCCESS == RegOpenKeyExW(root, key, 0, KEY_READ, &hkey))
-        {
-          int index = 0;
-          WCHAR szNextKey[MAX_PATH];
-          DWORD len;
-          LONG rc = ERROR_SUCCESS;
-
-          while (rc == ERROR_SUCCESS)
-          {
-            len = MAX_PATH;
-            rc = RegEnumKeyExW(hkey, index, szNextKey, &len, NULL, NULL, NULL, NULL);
-            if (rc == ERROR_SUCCESS)
-            {
-              HKEY subk;
-              int sub_index = 0;
-              LONG rcs = ERROR_SUCCESS;
-              WCHAR szSubKey[MAX_PATH];
-
-              RegOpenKeyExW(hkey, szNextKey, 0, KEY_READ, &subk);
-              while (rcs == ERROR_SUCCESS)
-              {
-                len = MAX_PATH;
-                rcs = RegEnumKeyExW(subk, sub_index, szSubKey, &len, NULL, NULL, NULL, NULL);
-                if (rcs == ERROR_SUCCESS)
-                {
-                  if (*supplied >= requested)
-                  {
-                    /* Bailing */
-                    ret = S_FALSE;
-                    rc = ERROR_MORE_DATA;
-                    rcs = ERROR_MORE_DATA;
-                    break;
-                  }
-
-                  wsprintfW(szGuidKey,szToGuidFmt,szNextKey);
-                  CLSIDFromString(szGuidKey, &types[*supplied].type);
-                  wsprintfW(szGuidKey,szToGuidFmt,szSubKey);
-                  CLSIDFromString(szGuidKey, &types[*supplied].subtype);
-                  TRACE("Adding type %s subtype %s at index %i\n",
-                    debugstr_guid(&types[*supplied].type),
-                    debugstr_guid(&types[*supplied].subtype),
-                    *supplied);
-                  (*supplied)++;
-                }
-                sub_index++;
-              }
-              index++;
-            }
-          }
-          RegCloseKey(hkey);
-        }
-    }
-    return ret;
+    *supplied = len / sizeof(DMO_PARTIAL_MEDIATYPE);
+    return HRESULT_FROM_WIN32(ret);
 }
 
 /***************************************************************
From 42a8f382ed07595ab093a4da6452814099275e16 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 10 Jul 2020 11:42:47 -0500
Subject: [PATCH] msdmo: Avoid a redundant string -> GUID conversion.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/msdmo/dmoreg.c | 12 +-----------
 1 file changed, 1 insertion(+), 11 deletions(-)

diff --git a/dlls/msdmo/dmoreg.c b/dlls/msdmo/dmoreg.c
index ffe64782d1c..3143cfc5e20 100644
--- a/dlls/msdmo/dmoreg.c
+++ b/dlls/msdmo/dmoreg.c
@@ -75,12 +75,6 @@ static const WCHAR szCat2Fmt[] =
     '%','s','\\','%','s',0
 };
 
-static const WCHAR szToGuidFmt[] =
-{
-    '{','%','s','}',0
-};
-
-
 typedef struct
 {
     IEnumDMO                    IEnumDMO_iface;
@@ -482,7 +476,6 @@ static HRESULT WINAPI IEnumDMO_fnNext(
 {
     HKEY hkey;
     WCHAR szNextKey[MAX_PATH];
-    WCHAR szGuidKey[64];
     WCHAR szKey[MAX_PATH];
     WCHAR szValue[MAX_PATH];
     DMO_PARTIAL_MEDIATYPE types[100];
@@ -490,7 +483,6 @@ static HRESULT WINAPI IEnumDMO_fnNext(
     UINT count = 0;
     HRESULT hres = S_OK;
     LONG ret;
-    GUID guid;
 
     IEnumDMOImpl *This = impl_from_IEnumDMO(iface);
 
@@ -514,7 +506,7 @@ static HRESULT WINAPI IEnumDMO_fnNext(
             break;
         }
 
-        if (string_to_guid(szNextKey, &guid) != S_OK)
+        if (string_to_guid(szNextKey, &pCLSID[count]) != S_OK)
             continue;
 
         TRACE("found %s\n", debugstr_w(szNextKey));
@@ -622,8 +614,6 @@ static HRESULT WINAPI IEnumDMO_fnNext(
                     lstrcpyW(Names[count], szValue);
             }
         }
-        wsprintfW(szGuidKey,szToGuidFmt,szNextKey);
-        CLSIDFromString(szGuidKey, &pCLSID[count]);
 
         TRACE("found match %s %s\n", debugstr_w(szValue), debugstr_w(szNextKey));
         RegCloseKey(hkey);
From 3a708d4722eba242758a43b83bc4ff6a7ca391ac Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 10 Jul 2020 11:42:48 -0500
Subject: [PATCH] msdmo: Use wide character string literals.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/msdmo/dmoreg.c | 115 +++++++++++++-------------------------------
 1 file changed, 33 insertions(+), 82 deletions(-)

diff --git a/dlls/msdmo/dmoreg.c b/dlls/msdmo/dmoreg.c
index 3143cfc5e20..7e7f0c0fb88 100644
--- a/dlls/msdmo/dmoreg.c
+++ b/dlls/msdmo/dmoreg.c
@@ -32,49 +32,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msdmo);
 
-static const WCHAR szDMORootKey[] = 
-{
-    'D','i','r','e','c','t','S','h','o','w','\\',
-    'M','e','d','i','a','O','b','j','e','c','t','s',0
-}; 
-
-static const WCHAR szDMOInputType[] =
-{
-    'I','n','p','u','t','T','y','p','e','s',0
-};
-
-static const WCHAR szDMOOutputType[] =
-{
-    'O','u','t','p','u','t','T','y','p','e','s',0
-};
-
-static const WCHAR szDMOKeyed[] =
-{
-    'K','e','y','e','d',0
-};
-
-static const WCHAR szDMOCategories[] =
-{
-    'C','a','t','e','g','o','r','i','e','s',0
-};
-
-static const WCHAR szGUIDFmt[] =
-{
-    '%','0','8','X','-','%','0','4','X','-','%','0','4','X','-','%','0',
-    '2','X','%','0','2','X','-','%','0','2','X','%','0','2','X','%','0','2',
-    'X','%','0','2','X','%','0','2','X','%','0','2','X',0
-};
-
-static const WCHAR szCat3Fmt[] =
-{
-    '%','s','\\','%','s','\\','%','s',0
-};
-
-static const WCHAR szCat2Fmt[] =
-{
-    '%','s','\\','%','s',0
-};
-
 typedef struct
 {
     IEnumDMO                    IEnumDMO_iface;
@@ -98,21 +55,20 @@ static HRESULT read_types(HKEY root, LPCWSTR key, ULONG *supplied, ULONG request
 
 static const IEnumDMOVtbl edmovt;
 
-static LPWSTR GUIDToString(LPWSTR lpwstr, REFGUID lpcguid)
+static const WCHAR *GUIDToString(WCHAR *string, const GUID *guid)
 {
-    wsprintfW(lpwstr, szGUIDFmt, lpcguid->Data1, lpcguid->Data2,
-        lpcguid->Data3, lpcguid->Data4[0], lpcguid->Data4[1],
-        lpcguid->Data4[2], lpcguid->Data4[3], lpcguid->Data4[4],
-        lpcguid->Data4[5], lpcguid->Data4[6], lpcguid->Data4[7]);
-
-    return lpwstr;
+    swprintf(string, 37, L"%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
+            guid->Data1, guid->Data2, guid->Data3,
+            guid->Data4[0], guid->Data4[1], guid->Data4[2], guid->Data4[3],
+            guid->Data4[4], guid->Data4[5], guid->Data4[6], guid->Data4[7]);
+    return string;
 }
 
 static HRESULT string_to_guid(const WCHAR *string, GUID *guid)
 {
     WCHAR buffer[39];
     buffer[0] = '{';
-    lstrcpyW(buffer + 1, string);
+    wcscpy(buffer + 1, string);
     buffer[37] = '}';
     buffer[38] = 0;
     return CLSIDFromString(buffer, guid);
@@ -164,8 +120,8 @@ HRESULT WINAPI DMORegister(
     if (IsEqualGUID(guidCategory, &GUID_NULL))
         return E_INVALIDARG;
 
-    ret = RegCreateKeyExW(HKEY_CLASSES_ROOT, szDMORootKey, 0, NULL,
-        REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hrkey, NULL);
+    ret = RegCreateKeyExW(HKEY_CLASSES_ROOT, L"DirectShow\\MediaObjects", 0,
+            NULL, 0, KEY_WRITE, NULL, &hrkey, NULL);
     if (ret)
         return E_FAIL;
 
@@ -177,27 +133,25 @@ HRESULT WINAPI DMORegister(
 
     /* Set default Name value */
     ret = RegSetValueExW(hkey, NULL, 0, REG_SZ, (const BYTE*) szName,
-        (lstrlenW(szName) + 1) * sizeof(WCHAR));
+        (wcslen(szName) + 1) * sizeof(WCHAR));
 
     /* Set InputTypes */
-    hres = write_types(hkey, szDMOInputType, pInTypes, cInTypes);
+    hres = write_types(hkey, L"InputTypes", pInTypes, cInTypes);
 
     /* Set OutputTypes */
-    hres = write_types(hkey, szDMOOutputType, pOutTypes, cOutTypes);
+    hres = write_types(hkey, L"OutputTypes", pOutTypes, cOutTypes);
 
     if (dwFlags & DMO_REGISTERF_IS_KEYED)
     {
         /* Create Keyed key */ 
-        ret = RegCreateKeyExW(hkey, szDMOKeyed, 0, NULL,
-            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hckey, NULL);
+        ret = RegCreateKeyExW(hkey, L"Keyed", 0, NULL, 0, KEY_WRITE, NULL, &hckey, NULL);
         if (ret)
             goto lend;
         RegCloseKey(hckey);
     }
 
     /* Register the category */
-    ret = RegCreateKeyExW(hrkey, szDMOCategories, 0, NULL,
-            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hckey, NULL);
+    ret = RegCreateKeyExW(hrkey, L"Categories", 0, NULL, 0, KEY_WRITE, NULL, &hckey, NULL);
     if (ret)
         goto lend;
 
@@ -256,15 +210,14 @@ HRESULT WINAPI DMOUnregister(REFCLSID dmo, REFGUID category)
 
     TRACE("%s %s\n", debugstr_guid(dmo), debugstr_guid(category));
 
-    ret = RegOpenKeyExW(HKEY_CLASSES_ROOT, szDMORootKey, 0, KEY_WRITE, &rootkey);
-    if (ret)
+    if (RegOpenKeyExW(HKEY_CLASSES_ROOT, L"DirectShow\\MediaObjects", 0, KEY_WRITE, &rootkey))
         return S_FALSE;
 
     GUIDToString(dmoW, dmo);
     RegDeleteKeyW(rootkey, dmoW);
 
     /* open 'Categories' */
-    ret = RegOpenKeyExW(rootkey, szDMOCategories, 0, KEY_WRITE|KEY_ENUMERATE_SUB_KEYS, &categorieskey);
+    ret = RegOpenKeyExW(rootkey, L"Categories", 0, KEY_WRITE|KEY_ENUMERATE_SUB_KEYS, &categorieskey);
     RegCloseKey(rootkey);
     if (ret)
     {
@@ -309,7 +262,7 @@ HRESULT WINAPI DMOGetName(REFCLSID clsidDMO, WCHAR name[])
 
     TRACE("%s %p\n", debugstr_guid(clsidDMO), name);
 
-    if (RegOpenKeyExW(HKEY_CLASSES_ROOT, szDMORootKey, 0, KEY_READ, &hrkey))
+    if (RegOpenKeyExW(HKEY_CLASSES_ROOT, L"DirectShow\\MediaObjects", 0, KEY_READ, &hrkey))
         return E_FAIL;
 
     ret = RegOpenKeyExW(hrkey, GUIDToString(szguid, clsidDMO), 0, KEY_READ, &hkey);
@@ -386,14 +339,15 @@ static HRESULT IEnumDMO_Constructor(
     /* If not filtering by category enum from media objects root */
     if (IsEqualGUID(guidCategory, &GUID_NULL))
     {
-        RegOpenKeyExW(HKEY_CLASSES_ROOT, szDMORootKey, 0, KEY_READ, &lpedmo->hkey);
+        RegOpenKeyExW(HKEY_CLASSES_ROOT, L"DirectShow\\MediaObjects", 0, KEY_READ, &lpedmo->hkey);
     }
     else
     {
         WCHAR szguid[64];
         WCHAR szKey[MAX_PATH];
 
-        wsprintfW(szKey, szCat3Fmt, szDMORootKey, szDMOCategories, GUIDToString(szguid, guidCategory));
+        swprintf(szKey, ARRAY_SIZE(szKey), L"DirectShow\\MediaObjects\\Categories\\%s",
+                GUIDToString(szguid, guidCategory));
         RegOpenKeyExW(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &lpedmo->hkey);
     }
 
@@ -476,7 +430,7 @@ static HRESULT WINAPI IEnumDMO_fnNext(
 {
     HKEY hkey;
     WCHAR szNextKey[MAX_PATH];
-    WCHAR szKey[MAX_PATH];
+    WCHAR path[MAX_PATH];
     WCHAR szValue[MAX_PATH];
     DMO_PARTIAL_MEDIATYPE types[100];
     DWORD len;
@@ -513,8 +467,8 @@ static HRESULT WINAPI IEnumDMO_fnNext(
 
         if (!(This->dwFlags & DMO_ENUMF_INCLUDE_KEYED))
         {
-            wsprintfW(szKey, szCat3Fmt, szDMORootKey, szNextKey, szDMOKeyed);
-            ret = RegOpenKeyExW(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hkey);
+            swprintf(path, ARRAY_SIZE(path), L"DirectShow\\MediaObjects\\%s\\Keyed", szNextKey);
+            ret = RegOpenKeyExW(HKEY_CLASSES_ROOT, path, 0, KEY_READ, &hkey);
             if (ERROR_SUCCESS == ret)
             {
                 RegCloseKey(hkey);
@@ -523,23 +477,22 @@ static HRESULT WINAPI IEnumDMO_fnNext(
             }
         }
 
-        wsprintfW(szKey, szCat2Fmt, szDMORootKey, szNextKey);
-        ret = RegOpenKeyExW(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hkey);
-        TRACE("testing %s\n", debugstr_w(szKey));
+        swprintf(path, ARRAY_SIZE(path), L"DirectShow\\MediaObjects\\%s", szNextKey);
+        ret = RegOpenKeyExW(HKEY_CLASSES_ROOT, path, 0, KEY_READ, &hkey);
+        TRACE("Testing %s.\n", debugstr_w(path));
 
         if (This->pInTypes)
         {
             UINT i, j;
             DWORD cInTypes;
 
-            hres = read_types(hkey, szDMOInputType, &cInTypes, ARRAY_SIZE(types), types);
+            hres = read_types(hkey, L"InputTypes", &cInTypes, ARRAY_SIZE(types), types);
             if (FAILED(hres))
             {
                 RegCloseKey(hkey);
                 continue;
             }
 
-            TRACE("read %d intypes for %s:\n", cInTypes, debugstr_w(szKey));
             for (i = 0; i < cInTypes; i++) {
                 TRACE("intype %d: type %s, subtype %s\n", i, debugstr_guid(&types[i].type),
                     debugstr_guid(&types[i].subtype));
@@ -569,14 +522,13 @@ static HRESULT WINAPI IEnumDMO_fnNext(
             UINT i, j;
             DWORD cOutTypes;
 
-            hres = read_types(hkey, szDMOOutputType, &cOutTypes, ARRAY_SIZE(types), types);
+            hres = read_types(hkey, L"OutputTypes", &cOutTypes, ARRAY_SIZE(types), types);
             if (FAILED(hres))
             {
                 RegCloseKey(hkey);
                 continue;
             }
 
-            TRACE("read %d outtypes for %s:\n", cOutTypes, debugstr_w(szKey));
             for (i = 0; i < cOutTypes; i++) {
                 TRACE("outtype %d: type %s, subtype %s\n", i, debugstr_guid(&types[i].type),
                     debugstr_guid(&types[i].subtype));
@@ -609,9 +561,9 @@ static HRESULT WINAPI IEnumDMO_fnNext(
             Names[count] = NULL;
             if (ret == ERROR_SUCCESS)
             {
-                Names[count] = CoTaskMemAlloc((lstrlenW(szValue) + 1) * sizeof(WCHAR));
+                Names[count] = CoTaskMemAlloc((wcslen(szValue) + 1) * sizeof(WCHAR));
                 if (Names[count])
-                    lstrcpyW(Names[count], szValue);
+                    wcscpy(Names[count], szValue);
             }
         }
 
@@ -748,8 +700,7 @@ HRESULT WINAPI DMOGetTypes(REFCLSID clsidDMO,
         pulInputTypesSupplied, pInputTypes, ulOutputTypesRequested, pulOutputTypesSupplied,
         pOutputTypes);
 
-  if (ERROR_SUCCESS != RegOpenKeyExW(HKEY_CLASSES_ROOT, szDMORootKey, 0,
-                                     KEY_READ, &root))
+  if (RegOpenKeyExW(HKEY_CLASSES_ROOT, L"DirectShow\\MediaObjects", 0, KEY_READ, &root))
     return E_FAIL;
 
   if (ERROR_SUCCESS != RegOpenKeyExW(root,GUIDToString(szguid,clsidDMO) , 0,
@@ -761,7 +712,7 @@ HRESULT WINAPI DMOGetTypes(REFCLSID clsidDMO,
 
   if (ulInputTypesRequested > 0)
   {
-    ret = read_types(hkey, szDMOInputType, pulInputTypesSupplied, ulInputTypesRequested, pInputTypes );
+    ret = read_types(hkey, L"InputTypes", pulInputTypesSupplied, ulInputTypesRequested, pInputTypes );
   }
   else
     *pulInputTypesSupplied = 0;
@@ -769,7 +720,7 @@ HRESULT WINAPI DMOGetTypes(REFCLSID clsidDMO,
   if (ulOutputTypesRequested > 0)
   {
     HRESULT ret2;
-    ret2 = read_types(hkey, szDMOOutputType, pulOutputTypesSupplied, ulOutputTypesRequested, pOutputTypes );
+    ret2 = read_types(hkey, L"OutputTypes", pulOutputTypesSupplied, ulOutputTypesRequested, pOutputTypes );
 
     if (ret == S_OK)
         ret = ret2;
From aa2406ecea33e511255ee3ae2d43b6cbc7dbd9cc Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 10 Jul 2020 11:42:49 -0500
Subject: [PATCH] msdmo: Factor out any_types_match().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/msdmo/dmoreg.c | 49 ++++++++++++++++++---------------------------
 1 file changed, 19 insertions(+), 30 deletions(-)

diff --git a/dlls/msdmo/dmoreg.c b/dlls/msdmo/dmoreg.c
index 7e7f0c0fb88..ab3fda743ca 100644
--- a/dlls/msdmo/dmoreg.c
+++ b/dlls/msdmo/dmoreg.c
@@ -417,6 +417,21 @@ static ULONG WINAPI IEnumDMO_fnRelease(IEnumDMO * iface)
     return refCount;
 }
 
+static BOOL any_types_match(const DMO_PARTIAL_MEDIATYPE *a, unsigned int a_count,
+        const DMO_PARTIAL_MEDIATYPE *b, unsigned int b_count)
+{
+    unsigned int i, j;
+
+    for (i = 0; i < a_count; ++i)
+    {
+        for (j = 0; j < b_count; ++j)
+        {
+            if (IsMediaTypeEqual(&a[i], &b[j]))
+                return TRUE;
+        }
+    }
+    return FALSE;
+}
 
 /******************************************************************************
  * IEnumDMO_fnNext
@@ -483,8 +498,7 @@ static HRESULT WINAPI IEnumDMO_fnNext(
 
         if (This->pInTypes)
         {
-            UINT i, j;
-            DWORD cInTypes;
+            DWORD cInTypes, i;
 
             hres = read_types(hkey, L"InputTypes", &cInTypes, ARRAY_SIZE(types), types);
             if (FAILED(hres))
@@ -498,19 +512,7 @@ static HRESULT WINAPI IEnumDMO_fnNext(
                     debugstr_guid(&types[i].subtype));
             }
 
-            for (i = 0; i < This->cInTypes; i++)
-            {
-                for (j = 0; j < cInTypes; j++) 
-                {
-                    if (IsMediaTypeEqual(&types[j], &This->pInTypes[i]))
-                        break;
-                }
-
-                if (j >= cInTypes)
-                    break;
-            }
-
-            if (i < This->cInTypes)
+            if (!any_types_match(types, cInTypes, This->pInTypes, This->cInTypes))
             {
                 RegCloseKey(hkey);
                 continue;
@@ -519,8 +521,7 @@ static HRESULT WINAPI IEnumDMO_fnNext(
 
         if (This->pOutTypes)
         {
-            UINT i, j;
-            DWORD cOutTypes;
+            DWORD cOutTypes, i;
 
             hres = read_types(hkey, L"OutputTypes", &cOutTypes, ARRAY_SIZE(types), types);
             if (FAILED(hres))
@@ -534,19 +535,7 @@ static HRESULT WINAPI IEnumDMO_fnNext(
                     debugstr_guid(&types[i].subtype));
             }
 
-            for (i = 0; i < This->cOutTypes; i++)
-            {
-                for (j = 0; j < cOutTypes; j++) 
-                {
-                    if (IsMediaTypeEqual(&types[j], &This->pOutTypes[i]))
-                        break;
-                }
-
-                if (j >= cOutTypes)
-                    break;
-            }
-
-            if (i < This->cOutTypes)
+            if (!any_types_match(types, cOutTypes, This->pOutTypes, This->cOutTypes))
             {
                 RegCloseKey(hkey);
                 continue;
From caa41d4917a84dbbeb4aa14f18cfecfd17efe71a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 10 Jul 2020 11:42:50 -0500
Subject: [PATCH] msdmo: Use a dynamically allocated buffer in
 IEnumDMO::Next().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/msdmo/dmoreg.c | 76 ++++++++++++++++++++++++++++++++++++---------
 1 file changed, 61 insertions(+), 15 deletions(-)

diff --git a/dlls/msdmo/dmoreg.c b/dlls/msdmo/dmoreg.c
index ab3fda743ca..a23bd95512d 100644
--- a/dlls/msdmo/dmoreg.c
+++ b/dlls/msdmo/dmoreg.c
@@ -32,6 +32,35 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msdmo);
 
+BOOL array_reserve(void **elements, unsigned int *capacity, unsigned int count, unsigned int size)
+{
+    unsigned int max_capacity, new_capacity;
+    void *new_elements;
+
+    if (count <= *capacity)
+        return TRUE;
+
+    max_capacity = ~0u / size;
+    if (count > max_capacity)
+        return FALSE;
+
+    new_capacity = max(8, *capacity);
+    while (new_capacity < count && new_capacity <= max_capacity / 2)
+        new_capacity *= 2;
+    if (new_capacity < count)
+        new_capacity = count;
+
+    if (!(new_elements = realloc(*elements, new_capacity * size)))
+    {
+        ERR("Failed to allocate memory.\n");
+        return FALSE;
+    }
+
+    *elements = new_elements;
+    *capacity = new_capacity;
+    return TRUE;
+}
+
 typedef struct
 {
     IEnumDMO                    IEnumDMO_iface;
@@ -51,8 +80,6 @@ static inline IEnumDMOImpl *impl_from_IEnumDMO(IEnumDMO *iface)
     return CONTAINING_RECORD(iface, IEnumDMOImpl, IEnumDMO_iface);
 }
 
-static HRESULT read_types(HKEY root, LPCWSTR key, ULONG *supplied, ULONG requested, DMO_PARTIAL_MEDIATYPE* types);
-
 static const IEnumDMOVtbl edmovt;
 
 static const WCHAR *GUIDToString(WCHAR *string, const GUID *guid)
@@ -443,11 +470,12 @@ static HRESULT WINAPI IEnumDMO_fnNext(
     WCHAR ** Names,
     DWORD * pcItemsFetched)
 {
+    DMO_PARTIAL_MEDIATYPE *types = NULL;
+    unsigned int types_size = 0;
     HKEY hkey;
     WCHAR szNextKey[MAX_PATH];
     WCHAR path[MAX_PATH];
     WCHAR szValue[MAX_PATH];
-    DMO_PARTIAL_MEDIATYPE types[100];
     DWORD len;
     UINT count = 0;
     HRESULT hres = S_OK;
@@ -498,21 +526,29 @@ static HRESULT WINAPI IEnumDMO_fnNext(
 
         if (This->pInTypes)
         {
-            DWORD cInTypes, i;
+            DWORD size = types_size, i;
 
-            hres = read_types(hkey, L"InputTypes", &cInTypes, ARRAY_SIZE(types), types);
-            if (FAILED(hres))
+            while ((ret = RegQueryValueExW(hkey, L"InputTypes", NULL, NULL,
+                    (BYTE *)types, &size)) == ERROR_MORE_DATA)
+            {
+                if (!array_reserve((void **)&types, &types_size, size, 1))
+                {
+                    RegCloseKey(hkey);
+                    free(types);
+                    return E_OUTOFMEMORY;
+                }
+            }
+            if (ret)
             {
                 RegCloseKey(hkey);
                 continue;
             }
 
-            for (i = 0; i < cInTypes; i++) {
+            for (i = 0; i < size / sizeof(DMO_PARTIAL_MEDIATYPE); ++i)
                 TRACE("intype %d: type %s, subtype %s\n", i, debugstr_guid(&types[i].type),
                     debugstr_guid(&types[i].subtype));
-            }
 
-            if (!any_types_match(types, cInTypes, This->pInTypes, This->cInTypes))
+            if (!any_types_match(types, size / sizeof(DMO_PARTIAL_MEDIATYPE), This->pInTypes, This->cInTypes))
             {
                 RegCloseKey(hkey);
                 continue;
@@ -521,21 +557,29 @@ static HRESULT WINAPI IEnumDMO_fnNext(
 
         if (This->pOutTypes)
         {
-            DWORD cOutTypes, i;
+            DWORD size = types_size, i;
 
-            hres = read_types(hkey, L"OutputTypes", &cOutTypes, ARRAY_SIZE(types), types);
-            if (FAILED(hres))
+            while ((ret = RegQueryValueExW(hkey, L"OutputTypes", NULL, NULL,
+                    (BYTE *)types, &size)) == ERROR_MORE_DATA)
+            {
+                if (!array_reserve((void **)&types, &types_size, size, 1))
+                {
+                    RegCloseKey(hkey);
+                    free(types);
+                    return E_OUTOFMEMORY;
+                }
+            }
+            if (ret)
             {
                 RegCloseKey(hkey);
                 continue;
             }
 
-            for (i = 0; i < cOutTypes; i++) {
+            for (i = 0; i < size / sizeof(DMO_PARTIAL_MEDIATYPE); ++i)
                 TRACE("outtype %d: type %s, subtype %s\n", i, debugstr_guid(&types[i].type),
                     debugstr_guid(&types[i].subtype));
-            }
 
-            if (!any_types_match(types, cOutTypes, This->pOutTypes, This->cOutTypes))
+            if (!any_types_match(types, size / sizeof(DMO_PARTIAL_MEDIATYPE), This->pOutTypes, This->cOutTypes))
             {
                 RegCloseKey(hkey);
                 continue;
@@ -561,6 +605,8 @@ static HRESULT WINAPI IEnumDMO_fnNext(
         count++;
     }
 
+    free(types);
+
     if (pcItemsFetched) *pcItemsFetched = count;
     if (count < cItemsToFetch)
         hres = S_FALSE;
From d36553f290cdaaee58e1d4c63c2848776fb65f0a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 13 Jul 2020 09:38:01 -0500
Subject: [PATCH] msdmo/tests: Add tests for DMOGetTypes().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/msdmo/tests/msdmo.c | 50 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 50 insertions(+)

diff --git a/dlls/msdmo/tests/msdmo.c b/dlls/msdmo/tests/msdmo.c
index 68de11f21ab..14653ea8d75 100644
--- a/dlls/msdmo/tests/msdmo.c
+++ b/dlls/msdmo/tests/msdmo.c
@@ -117,9 +117,59 @@ static void test_DMOEnum(void)
     IEnumDMO_Release(enum_dmo);
 }
 
+static void test_DMOGetTypes(void)
+{
+    static const DMO_PARTIAL_MEDIATYPE input_types[] =
+    {
+        {{0x1111}, {0x2222}},
+        {{0x1111}, {0x3333}},
+    };
+    ULONG input_count, output_count;
+    DMO_PARTIAL_MEDIATYPE types[3];
+    HRESULT hr;
+
+    hr = DMOGetTypes(&GUID_unknowndmo, 0, &input_count, types, 0, &output_count, NULL);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+
+    hr = DMORegister(L"testdmo", &GUID_unknowndmo, &GUID_unknowncategory, 0,
+            ARRAY_SIZE(input_types), input_types, 0, NULL);
+    if (hr != S_OK)
+        return;
+
+    hr = DMOGetTypes(&GUID_unknowndmo, 0, &input_count, types, 0, &output_count, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!input_count, "Got input count %u.\n", input_count);
+    ok(!output_count, "Got output count %u.\n", output_count);
+
+    memset(types, 0, sizeof(types));
+    hr = DMOGetTypes(&GUID_unknowndmo, 1, &input_count, types, 0, &output_count, NULL);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(input_count == 1, "Got input count %u.\n", input_count);
+    ok(!output_count, "Got output count %u.\n", output_count);
+    todo_wine ok(!memcmp(types, input_types, sizeof(DMO_PARTIAL_MEDIATYPE)), "Types didn't match.\n");
+
+    memset(types, 0, sizeof(types));
+    hr = DMOGetTypes(&GUID_unknowndmo, 2, &input_count, types, 0, &output_count, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(input_count == 2, "Got input count %u.\n", input_count);
+    ok(!output_count, "Got output count %u.\n", output_count);
+    ok(!memcmp(types, input_types, 2 * sizeof(DMO_PARTIAL_MEDIATYPE)), "Types didn't match.\n");
+
+    memset(types, 0, sizeof(types));
+    hr = DMOGetTypes(&GUID_unknowndmo, 2, &input_count, types, 0, &output_count, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(input_count == 2, "Got input count %u.\n", input_count);
+    ok(!output_count, "Got output count %u.\n", output_count);
+    ok(!memcmp(types, input_types, 2 * sizeof(DMO_PARTIAL_MEDIATYPE)), "Types didn't match.\n");
+
+    hr = DMOUnregister(&GUID_unknowndmo, &GUID_unknowncategory);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+}
+
 START_TEST(msdmo)
 {
     test_DMOUnregister();
     test_DMOGetName();
     test_DMOEnum();
+    test_DMOGetTypes();
 }
From 03a2191449ab9bbcc118e46e5bac3a7483d509dd Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 13 Jul 2020 09:38:02 -0500
Subject: [PATCH] msdmo: Return S_OK from DMOGetTypes() even if the buffer is
 too short.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/msdmo/dmoreg.c      | 92 +++++++++++++++++-----------------------
 dlls/msdmo/tests/msdmo.c |  2 +-
 2 files changed, 39 insertions(+), 55 deletions(-)

diff --git a/dlls/msdmo/dmoreg.c b/dlls/msdmo/dmoreg.c
index a23bd95512d..cd253c3e9a2 100644
--- a/dlls/msdmo/dmoreg.c
+++ b/dlls/msdmo/dmoreg.c
@@ -706,62 +706,46 @@ static const IEnumDMOVtbl edmovt =
 	IEnumDMO_fnClone,
 };
 
-
-HRESULT read_types(HKEY root, LPCWSTR key, ULONG *supplied, ULONG requested, DMO_PARTIAL_MEDIATYPE* types )
-{
-    DWORD len = requested * sizeof(DMO_PARTIAL_MEDIATYPE);
-    LONG ret = RegQueryValueExW(root, key, NULL, NULL, (BYTE *)types, &len);
-
-    *supplied = len / sizeof(DMO_PARTIAL_MEDIATYPE);
-    return HRESULT_FROM_WIN32(ret);
-}
-
 /***************************************************************
  * DMOGetTypes (MSDMO.@)
  */
-HRESULT WINAPI DMOGetTypes(REFCLSID clsidDMO,
-               ULONG ulInputTypesRequested,
-               ULONG* pulInputTypesSupplied,
-               DMO_PARTIAL_MEDIATYPE* pInputTypes,
-               ULONG ulOutputTypesRequested,
-               ULONG* pulOutputTypesSupplied,
-               DMO_PARTIAL_MEDIATYPE* pOutputTypes)
+HRESULT WINAPI DMOGetTypes(REFCLSID clsid, ULONG input_count, ULONG *ret_input_count, DMO_PARTIAL_MEDIATYPE *input,
+        ULONG output_count, ULONG *ret_output_count, DMO_PARTIAL_MEDIATYPE *output)
 {
-  HKEY root,hkey;
-  HRESULT ret = S_OK;
-  WCHAR szguid[64];
-
-  TRACE ("(%s,%u,%p,%p,%u,%p,%p)\n", debugstr_guid(clsidDMO), ulInputTypesRequested,
-        pulInputTypesSupplied, pInputTypes, ulOutputTypesRequested, pulOutputTypesSupplied,
-        pOutputTypes);
-
-  if (RegOpenKeyExW(HKEY_CLASSES_ROOT, L"DirectShow\\MediaObjects", 0, KEY_READ, &root))
-    return E_FAIL;
-
-  if (ERROR_SUCCESS != RegOpenKeyExW(root,GUIDToString(szguid,clsidDMO) , 0,
-                                     KEY_READ, &hkey))
-  {
-    RegCloseKey(root);
-    return E_FAIL;
-  }
-
-  if (ulInputTypesRequested > 0)
-  {
-    ret = read_types(hkey, L"InputTypes", pulInputTypesSupplied, ulInputTypesRequested, pInputTypes );
-  }
-  else
-    *pulInputTypesSupplied = 0;
-
-  if (ulOutputTypesRequested > 0)
-  {
-    HRESULT ret2;
-    ret2 = read_types(hkey, L"OutputTypes", pulOutputTypesSupplied, ulOutputTypesRequested, pOutputTypes );
-
-    if (ret == S_OK)
-        ret = ret2;
-  }
-  else
-    *pulOutputTypesSupplied = 0;
-
-  return ret;
+    WCHAR guidstr[64];
+    HKEY root, key;
+    LSTATUS ret;
+    DWORD size;
+
+    TRACE("clsid %s, input_count %u, ret_input_count %p, input %p, output_count %u, ret_output_count %p, output %p.\n",
+            debugstr_guid(clsid), input_count, ret_input_count, input, output_count, ret_output_count, output);
+
+    if (RegOpenKeyExW(HKEY_CLASSES_ROOT, L"DirectShow\\MediaObjects", 0, KEY_READ, &root))
+        return E_FAIL;
+
+    if (RegOpenKeyExW(root, GUIDToString(guidstr, clsid), 0, KEY_READ, &key))
+    {
+        RegCloseKey(root);
+        return E_FAIL;
+    }
+
+    *ret_input_count = 0;
+    if (input_count > 0)
+    {
+        size = input_count * sizeof(DMO_PARTIAL_MEDIATYPE);
+        ret = RegQueryValueExW(key, L"InputTypes", NULL, NULL, (BYTE *)input, &size);
+        if (!ret || ret == ERROR_MORE_DATA)
+            *ret_input_count = size / sizeof(DMO_PARTIAL_MEDIATYPE);
+    }
+
+    *ret_output_count = 0;
+    if (output_count > 0)
+    {
+        size = output_count * sizeof(DMO_PARTIAL_MEDIATYPE);
+        ret = RegQueryValueExW(key, L"OutputTypes", NULL, NULL, (BYTE *)output, &size);
+        if (!ret || ret == ERROR_MORE_DATA)
+            *ret_output_count = size / sizeof(DMO_PARTIAL_MEDIATYPE);
+    }
+
+    return S_OK;
 }
diff --git a/dlls/msdmo/tests/msdmo.c b/dlls/msdmo/tests/msdmo.c
index 14653ea8d75..2afa56e5a6c 100644
--- a/dlls/msdmo/tests/msdmo.c
+++ b/dlls/msdmo/tests/msdmo.c
@@ -143,7 +143,7 @@ static void test_DMOGetTypes(void)
 
     memset(types, 0, sizeof(types));
     hr = DMOGetTypes(&GUID_unknowndmo, 1, &input_count, types, 0, &output_count, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(input_count == 1, "Got input count %u.\n", input_count);
     ok(!output_count, "Got output count %u.\n", output_count);
     todo_wine ok(!memcmp(types, input_types, sizeof(DMO_PARTIAL_MEDIATYPE)), "Types didn't match.\n");
From 37b926b8fe57e3242b0729598f33f0ad69a2c55f Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 13 Jul 2020 09:38:03 -0500
Subject: [PATCH] msdmo: Return the number of media types retrieved from
 DMOGetTypes().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/msdmo/dmoreg.c      | 22 ++++++++--------------
 dlls/msdmo/tests/msdmo.c |  2 +-
 2 files changed, 9 insertions(+), 15 deletions(-)

diff --git a/dlls/msdmo/dmoreg.c b/dlls/msdmo/dmoreg.c
index cd253c3e9a2..8c32a8f59fb 100644
--- a/dlls/msdmo/dmoreg.c
+++ b/dlls/msdmo/dmoreg.c
@@ -730,22 +730,16 @@ HRESULT WINAPI DMOGetTypes(REFCLSID clsid, ULONG input_count, ULONG *ret_input_c
     }
 
     *ret_input_count = 0;
-    if (input_count > 0)
-    {
-        size = input_count * sizeof(DMO_PARTIAL_MEDIATYPE);
-        ret = RegQueryValueExW(key, L"InputTypes", NULL, NULL, (BYTE *)input, &size);
-        if (!ret || ret == ERROR_MORE_DATA)
-            *ret_input_count = size / sizeof(DMO_PARTIAL_MEDIATYPE);
-    }
+    size = input_count * sizeof(DMO_PARTIAL_MEDIATYPE);
+    ret = RegQueryValueExW(key, L"InputTypes", NULL, NULL, (BYTE *)input, &size);
+    if (!ret || ret == ERROR_MORE_DATA)
+        *ret_input_count = min(input_count, size / sizeof(DMO_PARTIAL_MEDIATYPE));
 
     *ret_output_count = 0;
-    if (output_count > 0)
-    {
-        size = output_count * sizeof(DMO_PARTIAL_MEDIATYPE);
-        ret = RegQueryValueExW(key, L"OutputTypes", NULL, NULL, (BYTE *)output, &size);
-        if (!ret || ret == ERROR_MORE_DATA)
-            *ret_output_count = size / sizeof(DMO_PARTIAL_MEDIATYPE);
-    }
+    size = output_count * sizeof(DMO_PARTIAL_MEDIATYPE);
+    ret = RegQueryValueExW(key, L"OutputTypes", NULL, NULL, (BYTE *)output, &size);
+    if (!ret || ret == ERROR_MORE_DATA)
+        *ret_output_count = min(output_count, size / sizeof(DMO_PARTIAL_MEDIATYPE));
 
     return S_OK;
 }
diff --git a/dlls/msdmo/tests/msdmo.c b/dlls/msdmo/tests/msdmo.c
index 2afa56e5a6c..a1ab8ee00dc 100644
--- a/dlls/msdmo/tests/msdmo.c
+++ b/dlls/msdmo/tests/msdmo.c
@@ -144,7 +144,7 @@ static void test_DMOGetTypes(void)
     memset(types, 0, sizeof(types));
     hr = DMOGetTypes(&GUID_unknowndmo, 1, &input_count, types, 0, &output_count, NULL);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(input_count == 1, "Got input count %u.\n", input_count);
+    ok(input_count == 1, "Got input count %u.\n", input_count);
     ok(!output_count, "Got output count %u.\n", output_count);
     todo_wine ok(!memcmp(types, input_types, sizeof(DMO_PARTIAL_MEDIATYPE)), "Types didn't match.\n");
 
From 78d2a0919ebf7936e424effb5f54c3ff04469330 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 13 Jul 2020 09:38:04 -0500
Subject: [PATCH] msdmo: Avoid leaking key handles in DMOGetTypes().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/msdmo/dmoreg.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/msdmo/dmoreg.c b/dlls/msdmo/dmoreg.c
index 8c32a8f59fb..8e0680931f4 100644
--- a/dlls/msdmo/dmoreg.c
+++ b/dlls/msdmo/dmoreg.c
@@ -741,5 +741,7 @@ HRESULT WINAPI DMOGetTypes(REFCLSID clsid, ULONG input_count, ULONG *ret_input_c
     if (!ret || ret == ERROR_MORE_DATA)
         *ret_output_count = min(output_count, size / sizeof(DMO_PARTIAL_MEDIATYPE));
 
+    RegCloseKey(key);
+    RegCloseKey(root);
     return S_OK;
 }
From 58c3b5c100046395670ee986b99d5be849c29048 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 13 Jul 2020 09:38:05 -0500
Subject: [PATCH] devenum: Call DMOGetTypes() until less types are returned
 than were allocated.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/devenum/mediacatenum.c | 25 ++++++++++++-------------
 1 file changed, 12 insertions(+), 13 deletions(-)

diff --git a/dlls/devenum/mediacatenum.c b/dlls/devenum/mediacatenum.c
index 16b729ab1fd..ab675b5656f 100644
--- a/dlls/devenum/mediacatenum.c
+++ b/dlls/devenum/mediacatenum.c
@@ -147,28 +147,27 @@ static HRESULT WINAPI property_bag_Read(IPropertyBag *iface,
             };
 
             unsigned int count = 1, input_count, output_count, i;
-            DMO_PARTIAL_MEDIATYPE *types = NULL;
+            DMO_PARTIAL_MEDIATYPE *types = NULL, *new_array;
             REGPINTYPES *reg_types;
             HRESULT hr;
 
-            if (!(types = malloc(2 * count * sizeof(*types))))
-                return E_OUTOFMEMORY;
-
-            while ((hr = DMOGetTypes(&moniker->clsid, count, &input_count, types,
-                    count, &output_count, types + count)) == S_FALSE)
+            do
             {
                 count *= 2;
-                if (!(types = realloc(types, count * sizeof(*types))))
+                if (!(new_array = realloc(types, 2 * count * sizeof(*types))))
                 {
                     free(types);
                     return E_OUTOFMEMORY;
                 }
-            }
-            if (hr != S_OK)
-            {
-                free(types);
-                return hr;
-            }
+                types = new_array;
+
+                if (FAILED(hr = DMOGetTypes(&moniker->clsid, count, &input_count, types,
+                        count, &output_count, types + count)))
+                {
+                    free(types);
+                    return hr;
+                }
+            } while (input_count == count || output_count == count);
 
             if (!(reg_types = malloc(2 * count * sizeof(*reg_types))))
             {
From 02485967d6b8e66a5321e419bf9d92763fd370a8 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 13 Jul 2020 17:37:15 -0500
Subject: [PATCH] quartz: Use calloc() in filter_graph_common_create().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c | 110 ++++++++++++++++----------------------
 1 file changed, 47 insertions(+), 63 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index a23e35d6a1c..8c206789897 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -510,7 +510,7 @@ static ULONG WINAPI FilterGraphInner_Release(IUnknown *iface)
             CloseHandle(This->message_thread_ret);
         }
 	DeleteCriticalSection(&This->cs);
-	CoTaskMemFree(This);
+        free(This);
 
         InterlockedDecrement(&object_locks);
     }
@@ -5377,80 +5377,64 @@ static const IUnknownVtbl IInner_VTable =
 
 static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL threaded)
 {
-    IFilterGraphImpl *fimpl;
+    IFilterGraphImpl *object;
     HRESULT hr;
 
     *out = NULL;
 
-    fimpl = CoTaskMemAlloc(sizeof(*fimpl));
-    fimpl->defaultclock = TRUE;
-    fimpl->IUnknown_inner.lpVtbl = &IInner_VTable;
-    fimpl->IFilterGraph2_iface.lpVtbl = &IFilterGraph2_VTable;
-    fimpl->IMediaControl_iface.lpVtbl = &IMediaControl_VTable;
-    fimpl->IMediaSeeking_iface.lpVtbl = &IMediaSeeking_VTable;
-    fimpl->IBasicAudio_iface.lpVtbl = &IBasicAudio_VTable;
-    fimpl->IBasicVideo2_iface.lpVtbl = &IBasicVideo_VTable;
-    fimpl->IVideoWindow_iface.lpVtbl = &IVideoWindow_VTable;
-    fimpl->IMediaEventEx_iface.lpVtbl = &IMediaEventEx_VTable;
-    fimpl->IMediaFilter_iface.lpVtbl = &IMediaFilter_VTable;
-    fimpl->IMediaEventSink_iface.lpVtbl = &IMediaEventSink_VTable;
-    fimpl->IGraphConfig_iface.lpVtbl = &IGraphConfig_VTable;
-    fimpl->IMediaPosition_iface.lpVtbl = &IMediaPosition_VTable;
-    fimpl->IObjectWithSite_iface.lpVtbl = &IObjectWithSite_VTable;
-    fimpl->IGraphVersion_iface.lpVtbl = &IGraphVersion_VTable;
-    fimpl->IVideoFrameStep_iface.lpVtbl = &VideoFrameStep_vtbl;
-    fimpl->ref = 1;
-    list_init(&fimpl->filters);
-    fimpl->name_index = 1;
-    fimpl->refClock = NULL;
-    fimpl->hEventCompletion = CreateEventW(0, TRUE, FALSE, 0);
-    fimpl->HandleEcComplete = TRUE;
-    fimpl->HandleEcRepaint = TRUE;
-    fimpl->HandleEcClockChanged = TRUE;
-    fimpl->notif.hWnd = 0;
-    fimpl->notif.disabled = FALSE;
-    fimpl->nRenderers = 0;
-    fimpl->EcCompleteCount = 0;
-    fimpl->refClockProvider = NULL;
-    fimpl->state = State_Stopped;
-    fimpl->pSite = NULL;
-    EventsQueue_Init(&fimpl->evqueue);
-    InitializeCriticalSection(&fimpl->cs);
-    fimpl->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": IFilterGraphImpl.cs");
-    fimpl->nItfCacheEntries = 0;
-    memcpy(&fimpl->timeformatseek, &TIME_FORMAT_MEDIA_TIME, sizeof(GUID));
-    fimpl->stream_start = fimpl->stream_elapsed = 0;
-    fimpl->punkFilterMapper2 = NULL;
-    fimpl->version = 0;
-    fimpl->current_pos = 0;
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
 
-    if (threaded)
+    object->IBasicAudio_iface.lpVtbl = &IBasicAudio_VTable;
+    object->IBasicVideo2_iface.lpVtbl = &IBasicVideo_VTable;
+    object->IFilterGraph2_iface.lpVtbl = &IFilterGraph2_VTable;
+    object->IGraphConfig_iface.lpVtbl = &IGraphConfig_VTable;
+    object->IGraphVersion_iface.lpVtbl = &IGraphVersion_VTable;
+    object->IMediaControl_iface.lpVtbl = &IMediaControl_VTable;
+    object->IMediaEventEx_iface.lpVtbl = &IMediaEventEx_VTable;
+    object->IMediaEventSink_iface.lpVtbl = &IMediaEventSink_VTable;
+    object->IMediaFilter_iface.lpVtbl = &IMediaFilter_VTable;
+    object->IMediaPosition_iface.lpVtbl = &IMediaPosition_VTable;
+    object->IMediaSeeking_iface.lpVtbl = &IMediaSeeking_VTable;
+    object->IObjectWithSite_iface.lpVtbl = &IObjectWithSite_VTable;
+    object->IUnknown_inner.lpVtbl = &IInner_VTable;
+    object->IVideoFrameStep_iface.lpVtbl = &VideoFrameStep_vtbl;
+    object->IVideoWindow_iface.lpVtbl = &IVideoWindow_VTable;
+    object->ref = 1;
+    object->outer_unk = outer ? outer : &object->IUnknown_inner;
+
+    if (FAILED(hr = CoCreateInstance(&CLSID_FilterMapper2, object->outer_unk,
+            CLSCTX_INPROC_SERVER, &IID_IUnknown, (void **)&object->punkFilterMapper2)))
     {
-        fimpl->message_thread_ret = CreateEventW(NULL, FALSE, FALSE, NULL);
-        fimpl->message_thread = CreateThread(NULL, 0, message_thread_run, fimpl, 0, &fimpl->message_thread_id);
-        WaitForSingleObject(fimpl->message_thread_ret, INFINITE);
+        ERR("Failed to create filter mapper, hr %#x.\n", hr);
+        free(object);
+        return hr;
     }
-    else
-        fimpl->message_thread = NULL;
 
-    fimpl->outer_unk = outer ? outer : &fimpl->IUnknown_inner;
+    InitializeCriticalSection(&object->cs);
+    object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": IFilterGraphImpl.cs");
 
-    /* create Filtermapper aggregated. */
-    hr = CoCreateInstance(&CLSID_FilterMapper2, fimpl->outer_unk, CLSCTX_INPROC_SERVER,
-            &IID_IUnknown, (void**)&fimpl->punkFilterMapper2);
+    object->defaultclock = TRUE;
+    EventsQueue_Init(&object->evqueue);
+    list_init(&object->filters);
+    object->HandleEcClockChanged = TRUE;
+    object->HandleEcComplete = TRUE;
+    object->HandleEcRepaint = TRUE;
+    object->hEventCompletion = CreateEventW(0, TRUE, FALSE, 0);
+    object->name_index = 1;
+    object->timeformatseek = TIME_FORMAT_MEDIA_TIME;
 
-    if (FAILED(hr)) {
-        ERR("Unable to create filter mapper (%x)\n", hr);
-        if (fimpl->punkFilterMapper2) IUnknown_Release(fimpl->punkFilterMapper2);
-        CloseHandle(fimpl->hEventCompletion);
-        EventsQueue_Destroy(&fimpl->evqueue);
-        fimpl->cs.DebugInfo->Spare[0] = 0;
-        DeleteCriticalSection(&fimpl->cs);
-        CoTaskMemFree(fimpl);
-        return hr;
+    if (threaded)
+    {
+        object->message_thread_ret = CreateEventW(NULL, FALSE, FALSE, NULL);
+        object->message_thread = CreateThread(NULL, 0, message_thread_run, object, 0, &object->message_thread_id);
+        WaitForSingleObject(object->message_thread_ret, INFINITE);
     }
+    else
+        object->message_thread = NULL;
 
-    *out = &fimpl->IUnknown_inner;
+    TRACE("Created %sthreaded filter graph %p.\n", threaded ? "" : "non-", object);
+    *out = &object->IUnknown_inner;
     return S_OK;
 }
 
From d93137e2e07e0fea56e0c5148c27b1c7e9cb5a65 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 13 Jul 2020 17:37:16 -0500
Subject: [PATCH] quartz: Get rid of the IFilterGraphImpl typedef.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c | 559 +++++++++++++++++++-------------------
 1 file changed, 280 insertions(+), 279 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 8c206789897..6a29b5d7484 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -158,7 +158,8 @@ struct filter
     BOOL sorting;
 };
 
-typedef struct _IFilterGraphImpl {
+struct filter_graph
+{
     IUnknown IUnknown_inner;
     IFilterGraph2 IFilterGraph2_iface;
     IMediaControl IMediaControl_iface;
@@ -218,18 +219,18 @@ typedef struct _IFilterGraphImpl {
     REFERENCE_TIME stream_start, stream_elapsed;
 
     LONGLONG current_pos;
-} IFilterGraphImpl;
+};
 
 struct enum_filters
 {
     IEnumFilters IEnumFilters_iface;
     LONG ref;
-    IFilterGraphImpl *graph;
+    struct filter_graph *graph;
     LONG version;
     struct list *cursor;
 };
 
-static HRESULT create_enum_filters(IFilterGraphImpl *graph, struct list *cursor, IEnumFilters **out);
+static HRESULT create_enum_filters(struct filter_graph *graph, struct list *cursor, IEnumFilters **out);
 
 static inline struct enum_filters *impl_from_IEnumFilters(IEnumFilters *iface)
 {
@@ -359,7 +360,7 @@ static const IEnumFiltersVtbl EnumFilters_vtbl =
     EnumFilters_Clone,
 };
 
-static HRESULT create_enum_filters(IFilterGraphImpl *graph, struct list *cursor, IEnumFilters **out)
+static HRESULT create_enum_filters(struct filter_graph *graph, struct list *cursor, IEnumFilters **out)
 {
     struct enum_filters *enum_filters;
 
@@ -377,14 +378,14 @@ static HRESULT create_enum_filters(IFilterGraphImpl *graph, struct list *cursor,
     return S_OK;
 }
 
-static inline IFilterGraphImpl *impl_from_IUnknown(IUnknown *iface)
+static struct filter_graph *impl_from_IUnknown(IUnknown *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IUnknown_inner);
+    return CONTAINING_RECORD(iface, struct filter_graph, IUnknown_inner);
 }
 
 static HRESULT WINAPI FilterGraphInner_QueryInterface(IUnknown *iface, REFIID riid, void **ppvObj)
 {
-    IFilterGraphImpl *This = impl_from_IUnknown(iface);
+    struct filter_graph *This = impl_from_IUnknown(iface);
     TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppvObj);
 
     if (IsEqualGUID(&IID_IUnknown, riid)) {
@@ -458,7 +459,7 @@ static HRESULT WINAPI FilterGraphInner_QueryInterface(IUnknown *iface, REFIID ri
 
 static ULONG WINAPI FilterGraphInner_AddRef(IUnknown *iface)
 {
-    IFilterGraphImpl *This = impl_from_IUnknown(iface);
+    struct filter_graph *This = impl_from_IUnknown(iface);
     ULONG ref = InterlockedIncrement(&This->ref);
 
     TRACE("(%p)->(): new ref = %d\n", This, ref);
@@ -468,7 +469,7 @@ static ULONG WINAPI FilterGraphInner_AddRef(IUnknown *iface)
 
 static ULONG WINAPI FilterGraphInner_Release(IUnknown *iface)
 {
-    IFilterGraphImpl *This = impl_from_IUnknown(iface);
+    struct filter_graph *This = impl_from_IUnknown(iface);
     ULONG ref = InterlockedDecrement(&This->ref);
     struct filter *filter, *next;
 
@@ -517,30 +518,30 @@ static ULONG WINAPI FilterGraphInner_Release(IUnknown *iface)
     return ref;
 }
 
-static inline IFilterGraphImpl *impl_from_IFilterGraph2(IFilterGraph2 *iface)
+static struct filter_graph *impl_from_IFilterGraph2(IFilterGraph2 *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IFilterGraph2_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IFilterGraph2_iface);
 }
 
 static HRESULT WINAPI FilterGraph2_QueryInterface(IFilterGraph2 *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
     return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI FilterGraph2_AddRef(IFilterGraph2 *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
     return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI FilterGraph2_Release(IFilterGraph2 *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
     return IUnknown_Release(graph->outer_unk);
 }
 
-static IBaseFilter *find_filter_by_name(IFilterGraphImpl *graph, const WCHAR *name)
+static IBaseFilter *find_filter_by_name(struct filter_graph *graph, const WCHAR *name)
 {
     struct filter *filter;
 
@@ -616,7 +617,7 @@ static BOOL is_renderer(struct filter *filter)
 static HRESULT WINAPI FilterGraph2_AddFilter(IFilterGraph2 *iface,
         IBaseFilter *filter, const WCHAR *name)
 {
-    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
     BOOL duplicate_name = FALSE;
     struct filter *entry;
     unsigned int i;
@@ -684,7 +685,7 @@ static HRESULT WINAPI FilterGraph2_AddFilter(IFilterGraph2 *iface,
 
 static HRESULT WINAPI FilterGraph2_RemoveFilter(IFilterGraph2 *iface, IBaseFilter *pFilter)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
+    struct filter_graph *This = impl_from_IFilterGraph2(iface);
     struct filter *entry;
     int i;
     HRESULT hr = E_FAIL;
@@ -778,7 +779,7 @@ static HRESULT WINAPI FilterGraph2_RemoveFilter(IFilterGraph2 *iface, IBaseFilte
 
 static HRESULT WINAPI FilterGraph2_EnumFilters(IFilterGraph2 *iface, IEnumFilters **out)
 {
-    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
 
     TRACE("graph %p, out %p.\n", graph, out);
 
@@ -788,7 +789,7 @@ static HRESULT WINAPI FilterGraph2_EnumFilters(IFilterGraph2 *iface, IEnumFilter
 static HRESULT WINAPI FilterGraph2_FindFilterByName(IFilterGraph2 *iface,
         const WCHAR *name, IBaseFilter **filter)
 {
-    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
 
     TRACE("graph %p, name %s, filter %p.\n", graph, debugstr_w(name), filter);
 
@@ -807,7 +808,7 @@ static HRESULT WINAPI FilterGraph2_FindFilterByName(IFilterGraph2 *iface,
 /* Don't allow a circular connection to form, return VFW_E_CIRCULAR_GRAPH if this would be the case.
  * A circular connection will be formed if from the filter of the output pin, the input pin can be reached
  */
-static HRESULT CheckCircularConnection(IFilterGraphImpl *This, IPin *out, IPin *in)
+static HRESULT CheckCircularConnection(struct filter_graph *This, IPin *out, IPin *in)
 {
 #if 1
     HRESULT hr;
@@ -880,7 +881,7 @@ static HRESULT CheckCircularConnection(IFilterGraphImpl *This, IPin *out, IPin *
 #endif
 }
 
-static struct filter *find_sorted_filter(IFilterGraphImpl *graph, IBaseFilter *iface)
+static struct filter *find_sorted_filter(struct filter_graph *graph, IBaseFilter *iface)
 {
     struct filter *filter;
 
@@ -893,7 +894,7 @@ static struct filter *find_sorted_filter(IFilterGraphImpl *graph, IBaseFilter *i
     return NULL;
 }
 
-static void sort_filter_recurse(IFilterGraphImpl *graph, struct filter *filter, struct list *sorted)
+static void sort_filter_recurse(struct filter_graph *graph, struct filter *filter, struct list *sorted)
 {
     struct filter *peer_filter;
     IEnumPins *enumpins;
@@ -932,7 +933,7 @@ static void sort_filter_recurse(IFilterGraphImpl *graph, struct filter *filter,
     list_add_head(sorted, &filter->entry);
 }
 
-static void sort_filters(IFilterGraphImpl *graph)
+static void sort_filters(struct filter_graph *graph)
 {
     struct list sorted = LIST_INIT(sorted), *cursor;
 
@@ -950,7 +951,7 @@ static void sort_filters(IFilterGraphImpl *graph)
 static HRESULT WINAPI FilterGraph2_ConnectDirect(IFilterGraph2 *iface, IPin *ppinIn, IPin *ppinOut,
         const AM_MEDIA_TYPE *pmt)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
+    struct filter_graph *This = impl_from_IFilterGraph2(iface);
     PIN_DIRECTION dir;
     HRESULT hr;
 
@@ -1000,7 +1001,7 @@ static HRESULT WINAPI FilterGraph2_ConnectDirect(IFilterGraph2 *iface, IPin *ppi
 
 static HRESULT WINAPI FilterGraph2_Reconnect(IFilterGraph2 *iface, IPin *pin)
 {
-    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
 
     TRACE("graph %p, pin %p.\n", graph, pin);
 
@@ -1009,7 +1010,7 @@ static HRESULT WINAPI FilterGraph2_Reconnect(IFilterGraph2 *iface, IPin *pin)
 
 static HRESULT WINAPI FilterGraph2_Disconnect(IFilterGraph2 *iface, IPin *ppin)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
+    struct filter_graph *This = impl_from_IFilterGraph2(iface);
 
     TRACE("(%p/%p)->(%p)\n", This, iface, ppin);
 
@@ -1021,7 +1022,7 @@ static HRESULT WINAPI FilterGraph2_Disconnect(IFilterGraph2 *iface, IPin *ppin)
 
 static HRESULT WINAPI FilterGraph2_SetDefaultSyncSource(IFilterGraph2 *iface)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
+    struct filter_graph *This = impl_from_IFilterGraph2(iface);
     IReferenceClock *pClock = NULL;
     struct filter *filter;
     HRESULT hr = S_OK;
@@ -1067,7 +1068,7 @@ struct filter_create_params
 
 static DWORD WINAPI message_thread_run(void *ctx)
 {
-    IFilterGraphImpl *graph = ctx;
+    struct filter_graph *graph = ctx;
     MSG msg;
 
     /* Make sure we have a message queue. */
@@ -1103,7 +1104,7 @@ static DWORD WINAPI message_thread_run(void *ctx)
     return 0;
 }
 
-static HRESULT create_filter(IFilterGraphImpl *graph, IMoniker *moniker, IBaseFilter **filter)
+static HRESULT create_filter(struct filter_graph *graph, IMoniker *moniker, IBaseFilter **filter)
 {
     if (graph->message_thread)
     {
@@ -1119,10 +1120,10 @@ static HRESULT create_filter(IFilterGraphImpl *graph, IMoniker *moniker, IBaseFi
         return IMoniker_BindToObject(moniker, NULL, NULL, &IID_IBaseFilter, (void **)filter);
 }
 
-static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink,
+static HRESULT autoplug(struct filter_graph *graph, IPin *source, IPin *sink,
         BOOL render_to_existing, unsigned int recursion_depth);
 
-static HRESULT autoplug_through_sink(IFilterGraphImpl *graph, IPin *source,
+static HRESULT autoplug_through_sink(struct filter_graph *graph, IPin *source,
         IBaseFilter *filter, IPin *middle_sink, IPin *sink,
         BOOL render_to_existing, BOOL allow_renderers, unsigned int recursion_depth)
 {
@@ -1201,7 +1202,7 @@ static HRESULT autoplug_through_sink(IFilterGraphImpl *graph, IPin *source,
     return E_FAIL;
 }
 
-static HRESULT autoplug_through_filter(IFilterGraphImpl *graph, IPin *source,
+static HRESULT autoplug_through_filter(struct filter_graph *graph, IPin *source,
         IBaseFilter *filter, IPin *sink, BOOL render_to_existing,
         BOOL allow_renderers, unsigned int recursion_depth)
 {
@@ -1231,7 +1232,7 @@ static HRESULT autoplug_through_filter(IFilterGraphImpl *graph, IPin *source,
 
 /* Common helper for IGraphBuilder::Connect() and IGraphBuilder::Render(), which
  * share most of the same code. Render() calls this with a NULL sink. */
-static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink,
+static HRESULT autoplug(struct filter_graph *graph, IPin *source, IPin *sink,
         BOOL render_to_existing, unsigned int recursion_depth)
 {
     IAMGraphBuilderCallback *callback = NULL;
@@ -1365,7 +1366,7 @@ static HRESULT autoplug(IFilterGraphImpl *graph, IPin *source, IPin *sink,
 
 static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *source, IPin *sink)
 {
-    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
     PIN_DIRECTION dir;
     HRESULT hr;
 
@@ -1400,7 +1401,7 @@ static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *source, I
 
 static HRESULT WINAPI FilterGraph2_Render(IFilterGraph2 *iface, IPin *source)
 {
-    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
     HRESULT hr;
 
     TRACE("graph %p, source %p.\n", graph, source);
@@ -1418,7 +1419,7 @@ static HRESULT WINAPI FilterGraph2_Render(IFilterGraph2 *iface, IPin *source)
 static HRESULT WINAPI FilterGraph2_RenderFile(IFilterGraph2 *iface, LPCWSTR lpcwstrFile,
         LPCWSTR lpcwstrPlayList)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
+    struct filter_graph *This = impl_from_IFilterGraph2(iface);
     IBaseFilter* preader = NULL;
     IPin* ppinreader = NULL;
     IEnumPins* penumpins = NULL;
@@ -1477,7 +1478,7 @@ static HRESULT WINAPI FilterGraph2_RenderFile(IFilterGraph2 *iface, LPCWSTR lpcw
 static HRESULT WINAPI FilterGraph2_AddSourceFilter(IFilterGraph2 *iface,
         const WCHAR *filename, const WCHAR *filter_name, IBaseFilter **ret_filter)
 {
-    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
     IFileSourceFilter *filesource;
     IBaseFilter *filter;
     HRESULT hr;
@@ -1525,7 +1526,7 @@ static HRESULT WINAPI FilterGraph2_AddSourceFilter(IFilterGraph2 *iface,
 
 static HRESULT WINAPI FilterGraph2_SetLogFile(IFilterGraph2 *iface, DWORD_PTR hFile)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
+    struct filter_graph *This = impl_from_IFilterGraph2(iface);
 
     TRACE("(%p/%p)->(%08x): stub !!!\n", This, iface, (DWORD) hFile);
 
@@ -1534,7 +1535,7 @@ static HRESULT WINAPI FilterGraph2_SetLogFile(IFilterGraph2 *iface, DWORD_PTR hF
 
 static HRESULT WINAPI FilterGraph2_Abort(IFilterGraph2 *iface)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
+    struct filter_graph *This = impl_from_IFilterGraph2(iface);
 
     TRACE("(%p/%p)->(): stub !!!\n", This, iface);
 
@@ -1543,7 +1544,7 @@ static HRESULT WINAPI FilterGraph2_Abort(IFilterGraph2 *iface)
 
 static HRESULT WINAPI FilterGraph2_ShouldOperationContinue(IFilterGraph2 *iface)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
+    struct filter_graph *This = impl_from_IFilterGraph2(iface);
 
     TRACE("(%p/%p)->(): stub !!!\n", This, iface);
 
@@ -1554,7 +1555,7 @@ static HRESULT WINAPI FilterGraph2_ShouldOperationContinue(IFilterGraph2 *iface)
 static HRESULT WINAPI FilterGraph2_AddSourceFilterForMoniker(IFilterGraph2 *iface,
         IMoniker *pMoniker, IBindCtx *pCtx, LPCWSTR lpcwstrFilterName, IBaseFilter **ppFilter)
 {
-    IFilterGraphImpl *This = impl_from_IFilterGraph2(iface);
+    struct filter_graph *This = impl_from_IFilterGraph2(iface);
     HRESULT hr;
     IBaseFilter* pfilter;
 
@@ -1582,7 +1583,7 @@ static HRESULT WINAPI FilterGraph2_AddSourceFilterForMoniker(IFilterGraph2 *ifac
 
 static HRESULT WINAPI FilterGraph2_ReconnectEx(IFilterGraph2 *iface, IPin *pin, const AM_MEDIA_TYPE *mt)
 {
-    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
     PIN_DIRECTION dir;
     HRESULT hr;
     IPin *peer;
@@ -1607,7 +1608,7 @@ static HRESULT WINAPI FilterGraph2_ReconnectEx(IFilterGraph2 *iface, IPin *pin,
 
 static HRESULT WINAPI FilterGraph2_RenderEx(IFilterGraph2 *iface, IPin *source, DWORD flags, DWORD *context)
 {
-    IFilterGraphImpl *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
     HRESULT hr;
 
     TRACE("graph %p, source %p, flags %#x, context %p.\n", graph, source, flags, context);
@@ -1651,26 +1652,26 @@ static const IFilterGraph2Vtbl IFilterGraph2_VTable =
     FilterGraph2_RenderEx
 };
 
-static inline IFilterGraphImpl *impl_from_IMediaControl(IMediaControl *iface)
+static struct filter_graph *impl_from_IMediaControl(IMediaControl *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IMediaControl_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IMediaControl_iface);
 }
 
 static HRESULT WINAPI MediaControl_QueryInterface(IMediaControl *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaControl(iface);
+    struct filter_graph *graph = impl_from_IMediaControl(iface);
     return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI MediaControl_AddRef(IMediaControl *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaControl(iface);
+    struct filter_graph *graph = impl_from_IMediaControl(iface);
     return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI MediaControl_Release(IMediaControl *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaControl(iface);
+    struct filter_graph *graph = impl_from_IMediaControl(iface);
     return IUnknown_Release(graph->outer_unk);
 
 }
@@ -1678,7 +1679,7 @@ static ULONG WINAPI MediaControl_Release(IMediaControl *iface)
 /*** IDispatch methods ***/
 static HRESULT WINAPI MediaControl_GetTypeInfoCount(IMediaControl *iface, UINT *pctinfo)
 {
-    IFilterGraphImpl *This = impl_from_IMediaControl(iface);
+    struct filter_graph *This = impl_from_IMediaControl(iface);
 
     TRACE("(%p/%p)->(%p): stub !!!\n", This, iface, pctinfo);
 
@@ -1688,7 +1689,7 @@ static HRESULT WINAPI MediaControl_GetTypeInfoCount(IMediaControl *iface, UINT *
 static HRESULT WINAPI MediaControl_GetTypeInfo(IMediaControl *iface, UINT iTInfo, LCID lcid,
         ITypeInfo **ppTInfo)
 {
-    IFilterGraphImpl *This = impl_from_IMediaControl(iface);
+    struct filter_graph *This = impl_from_IMediaControl(iface);
 
     TRACE("(%p/%p)->(%d, %d, %p): stub !!!\n", This, iface, iTInfo, lcid, ppTInfo);
 
@@ -1698,7 +1699,7 @@ static HRESULT WINAPI MediaControl_GetTypeInfo(IMediaControl *iface, UINT iTInfo
 static HRESULT WINAPI MediaControl_GetIDsOfNames(IMediaControl *iface, REFIID riid,
         LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
 {
-    IFilterGraphImpl *This = impl_from_IMediaControl(iface);
+    struct filter_graph *This = impl_from_IMediaControl(iface);
 
     TRACE("(%p/%p)->(%s, %p, %d, %d, %p): stub !!!\n", This, iface, debugstr_guid(riid), rgszNames,
             cNames, lcid, rgDispId);
@@ -1710,7 +1711,7 @@ static HRESULT WINAPI MediaControl_Invoke(IMediaControl *iface, DISPID dispIdMem
         LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExepInfo,
         UINT *puArgErr)
 {
-    IFilterGraphImpl *This = impl_from_IMediaControl(iface);
+    struct filter_graph *This = impl_from_IMediaControl(iface);
 
     TRACE("(%p/%p)->(%d, %s, %d, %04x, %p, %p, %p, %p): stub !!!\n", This, iface, dispIdMember,
             debugstr_guid(riid), lcid, wFlags, pDispParams, pVarResult, pExepInfo, puArgErr);
@@ -1720,28 +1721,28 @@ static HRESULT WINAPI MediaControl_Invoke(IMediaControl *iface, DISPID dispIdMem
 
 static HRESULT WINAPI MediaControl_Run(IMediaControl *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaControl(iface);
+    struct filter_graph *graph = impl_from_IMediaControl(iface);
 
     return IMediaFilter_Run(&graph->IMediaFilter_iface, 0);
 }
 
 static HRESULT WINAPI MediaControl_Pause(IMediaControl *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaControl(iface);
+    struct filter_graph *graph = impl_from_IMediaControl(iface);
 
     return IMediaFilter_Pause(&graph->IMediaFilter_iface);
 }
 
 static HRESULT WINAPI MediaControl_Stop(IMediaControl *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaControl(iface);
+    struct filter_graph *graph = impl_from_IMediaControl(iface);
 
     return IMediaFilter_Stop(&graph->IMediaFilter_iface);
 }
 
 static HRESULT WINAPI MediaControl_GetState(IMediaControl *iface, LONG timeout, OAFilterState *state)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaControl(iface);
+    struct filter_graph *graph = impl_from_IMediaControl(iface);
 
     if (timeout < 0) timeout = INFINITE;
 
@@ -1750,7 +1751,7 @@ static HRESULT WINAPI MediaControl_GetState(IMediaControl *iface, LONG timeout,
 
 static HRESULT WINAPI MediaControl_RenderFile(IMediaControl *iface, BSTR strFilename)
 {
-    IFilterGraphImpl *This = impl_from_IMediaControl(iface);
+    struct filter_graph *This = impl_from_IMediaControl(iface);
 
     TRACE("(%p/%p)->(%s (%p))\n", This, iface, debugstr_w(strFilename), strFilename);
 
@@ -1760,7 +1761,7 @@ static HRESULT WINAPI MediaControl_RenderFile(IMediaControl *iface, BSTR strFile
 static HRESULT WINAPI MediaControl_AddSourceFilter(IMediaControl *iface, BSTR strFilename,
         IDispatch **ppUnk)
 {
-    IFilterGraphImpl *This = impl_from_IMediaControl(iface);
+    struct filter_graph *This = impl_from_IMediaControl(iface);
 
     FIXME("(%p/%p)->(%s (%p), %p): stub !!!\n", This, iface, debugstr_w(strFilename), strFilename, ppUnk);
 
@@ -1769,7 +1770,7 @@ static HRESULT WINAPI MediaControl_AddSourceFilter(IMediaControl *iface, BSTR st
 
 static HRESULT WINAPI MediaControl_get_FilterCollection(IMediaControl *iface, IDispatch **ppUnk)
 {
-    IFilterGraphImpl *This = impl_from_IMediaControl(iface);
+    struct filter_graph *This = impl_from_IMediaControl(iface);
 
     FIXME("(%p/%p)->(%p): stub !!!\n", This, iface, ppUnk);
 
@@ -1778,7 +1779,7 @@ static HRESULT WINAPI MediaControl_get_FilterCollection(IMediaControl *iface, ID
 
 static HRESULT WINAPI MediaControl_get_RegFilterCollection(IMediaControl *iface, IDispatch **ppUnk)
 {
-    IFilterGraphImpl *This = impl_from_IMediaControl(iface);
+    struct filter_graph *This = impl_from_IMediaControl(iface);
 
     FIXME("(%p/%p)->(%p): stub !!!\n", This, iface, ppUnk);
 
@@ -1817,7 +1818,7 @@ static void CALLBACK wait_stop_cb(TP_CALLBACK_INSTANCE *instance, void *context)
 
 static HRESULT WINAPI MediaControl_StopWhenReady(IMediaControl *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaControl(iface);
+    struct filter_graph *graph = impl_from_IMediaControl(iface);
     HRESULT hr;
 
     TRACE("graph %p.\n", graph);
@@ -1867,32 +1868,32 @@ static const IMediaControlVtbl IMediaControl_VTable =
     MediaControl_StopWhenReady
 };
 
-static inline IFilterGraphImpl *impl_from_IMediaSeeking(IMediaSeeking *iface)
+static struct filter_graph *impl_from_IMediaSeeking(IMediaSeeking *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IMediaSeeking_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IMediaSeeking_iface);
 }
 
 static HRESULT WINAPI MediaSeeking_QueryInterface(IMediaSeeking *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaSeeking(iface);
+    struct filter_graph *graph = impl_from_IMediaSeeking(iface);
     return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI MediaSeeking_AddRef(IMediaSeeking *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaSeeking(iface);
+    struct filter_graph *graph = impl_from_IMediaSeeking(iface);
     return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI MediaSeeking_Release(IMediaSeeking *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaSeeking(iface);
+    struct filter_graph *graph = impl_from_IMediaSeeking(iface);
     return IUnknown_Release(graph->outer_unk);
 }
 
-typedef HRESULT (WINAPI *fnFoundSeek)(IFilterGraphImpl *This, IMediaSeeking*, DWORD_PTR arg);
+typedef HRESULT (WINAPI *fnFoundSeek)(struct filter_graph *This, IMediaSeeking*, DWORD_PTR arg);
 
-static HRESULT all_renderers_seek(IFilterGraphImpl *This, fnFoundSeek FoundSeek, DWORD_PTR arg) {
+static HRESULT all_renderers_seek(struct filter_graph *This, fnFoundSeek FoundSeek, DWORD_PTR arg) {
     BOOL allnotimpl = TRUE;
     HRESULT hr, hr_return = S_OK;
     struct filter *filter;
@@ -1917,7 +1918,7 @@ static HRESULT all_renderers_seek(IFilterGraphImpl *This, fnFoundSeek FoundSeek,
     return hr_return;
 }
 
-static HRESULT WINAPI FoundCapabilities(IFilterGraphImpl *This, IMediaSeeking *seek, DWORD_PTR pcaps)
+static HRESULT WINAPI FoundCapabilities(struct filter_graph *This, IMediaSeeking *seek, DWORD_PTR pcaps)
 {
     HRESULT hr;
     DWORD caps = 0;
@@ -1935,7 +1936,7 @@ static HRESULT WINAPI FoundCapabilities(IFilterGraphImpl *This, IMediaSeeking *s
 /*** IMediaSeeking methods ***/
 static HRESULT WINAPI MediaSeeking_GetCapabilities(IMediaSeeking *iface, DWORD *pCapabilities)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
     HRESULT hr;
 
     TRACE("(%p/%p)->(%p)\n", This, iface, pCapabilities);
@@ -1954,7 +1955,7 @@ static HRESULT WINAPI MediaSeeking_GetCapabilities(IMediaSeeking *iface, DWORD *
 
 static HRESULT WINAPI MediaSeeking_CheckCapabilities(IMediaSeeking *iface, DWORD *pCapabilities)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
     DWORD originalcaps;
     HRESULT hr;
 
@@ -1980,7 +1981,7 @@ static HRESULT WINAPI MediaSeeking_CheckCapabilities(IMediaSeeking *iface, DWORD
 
 static HRESULT WINAPI MediaSeeking_IsFormatSupported(IMediaSeeking *iface, const GUID *pFormat)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
 
     if (!pFormat)
         return E_POINTER;
@@ -1998,7 +1999,7 @@ static HRESULT WINAPI MediaSeeking_IsFormatSupported(IMediaSeeking *iface, const
 
 static HRESULT WINAPI MediaSeeking_QueryPreferredFormat(IMediaSeeking *iface, GUID *pFormat)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
 
     if (!pFormat)
         return E_POINTER;
@@ -2011,7 +2012,7 @@ static HRESULT WINAPI MediaSeeking_QueryPreferredFormat(IMediaSeeking *iface, GU
 
 static HRESULT WINAPI MediaSeeking_GetTimeFormat(IMediaSeeking *iface, GUID *pFormat)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
 
     if (!pFormat)
         return E_POINTER;
@@ -2024,7 +2025,7 @@ static HRESULT WINAPI MediaSeeking_GetTimeFormat(IMediaSeeking *iface, GUID *pFo
 
 static HRESULT WINAPI MediaSeeking_IsUsingTimeFormat(IMediaSeeking *iface, const GUID *pFormat)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
 
     TRACE("(%p/%p)->(%p)\n", This, iface, pFormat);
     if (!pFormat)
@@ -2038,7 +2039,7 @@ static HRESULT WINAPI MediaSeeking_IsUsingTimeFormat(IMediaSeeking *iface, const
 
 static HRESULT WINAPI MediaSeeking_SetTimeFormat(IMediaSeeking *iface, const GUID *pFormat)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
 
     if (!pFormat)
         return E_POINTER;
@@ -2057,7 +2058,7 @@ static HRESULT WINAPI MediaSeeking_SetTimeFormat(IMediaSeeking *iface, const GUI
     return S_OK;
 }
 
-static HRESULT WINAPI FoundDuration(IFilterGraphImpl *This, IMediaSeeking *seek, DWORD_PTR pduration)
+static HRESULT WINAPI FoundDuration(struct filter_graph *This, IMediaSeeking *seek, DWORD_PTR pduration)
 {
     HRESULT hr;
     LONGLONG duration = 0, *pdur = (LONGLONG*)pduration;
@@ -2073,7 +2074,7 @@ static HRESULT WINAPI FoundDuration(IFilterGraphImpl *This, IMediaSeeking *seek,
 
 static HRESULT WINAPI MediaSeeking_GetDuration(IMediaSeeking *iface, LONGLONG *pDuration)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
     HRESULT hr;
 
     TRACE("(%p/%p)->(%p)\n", This, iface, pDuration);
@@ -2092,7 +2093,7 @@ static HRESULT WINAPI MediaSeeking_GetDuration(IMediaSeeking *iface, LONGLONG *p
 
 static HRESULT WINAPI MediaSeeking_GetStopPosition(IMediaSeeking *iface, LONGLONG *stop)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaSeeking(iface);
+    struct filter_graph *graph = impl_from_IMediaSeeking(iface);
     HRESULT hr = E_NOTIMPL, filter_hr;
     struct filter *filter;
     LONGLONG filter_stop;
@@ -2133,7 +2134,7 @@ static HRESULT WINAPI MediaSeeking_GetStopPosition(IMediaSeeking *iface, LONGLON
 
 static HRESULT WINAPI MediaSeeking_GetCurrentPosition(IMediaSeeking *iface, LONGLONG *current)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaSeeking(iface);
+    struct filter_graph *graph = impl_from_IMediaSeeking(iface);
     LONGLONG ret = graph->current_pos;
 
     TRACE("graph %p, current %p.\n", graph, current);
@@ -2162,7 +2163,7 @@ static HRESULT WINAPI MediaSeeking_GetCurrentPosition(IMediaSeeking *iface, LONG
 static HRESULT WINAPI MediaSeeking_ConvertTimeFormat(IMediaSeeking *iface, LONGLONG *pTarget,
         const GUID *pTargetFormat, LONGLONG Source, const GUID *pSourceFormat)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
 
     TRACE("(%p/%p)->(%p, %s, 0x%s, %s)\n", This, iface, pTarget,
         debugstr_guid(pTargetFormat), wine_dbgstr_longlong(Source), debugstr_guid(pSourceFormat));
@@ -2184,7 +2185,7 @@ static HRESULT WINAPI MediaSeeking_ConvertTimeFormat(IMediaSeeking *iface, LONGL
 static HRESULT WINAPI MediaSeeking_SetPositions(IMediaSeeking *iface, LONGLONG *current_ptr,
         DWORD current_flags, LONGLONG *stop_ptr, DWORD stop_flags)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaSeeking(iface);
+    struct filter_graph *graph = impl_from_IMediaSeeking(iface);
     HRESULT hr = E_NOTIMPL, filter_hr;
     struct filter *filter;
     FILTER_STATE state;
@@ -2256,7 +2257,7 @@ static HRESULT WINAPI MediaSeeking_SetPositions(IMediaSeeking *iface, LONGLONG *
 static HRESULT WINAPI MediaSeeking_GetPositions(IMediaSeeking *iface, LONGLONG *pCurrent,
         LONGLONG *pStop)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
     HRESULT hr;
 
     TRACE("(%p/%p)->(%p, %p)\n", This, iface, pCurrent, pStop);
@@ -2270,7 +2271,7 @@ static HRESULT WINAPI MediaSeeking_GetPositions(IMediaSeeking *iface, LONGLONG *
 static HRESULT WINAPI MediaSeeking_GetAvailable(IMediaSeeking *iface, LONGLONG *pEarliest,
         LONGLONG *pLatest)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
 
     FIXME("(%p/%p)->(%p, %p): stub !!!\n", This, iface, pEarliest, pLatest);
 
@@ -2279,7 +2280,7 @@ static HRESULT WINAPI MediaSeeking_GetAvailable(IMediaSeeking *iface, LONGLONG *
 
 static HRESULT WINAPI MediaSeeking_SetRate(IMediaSeeking *iface, double dRate)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
 
     FIXME("(%p/%p)->(%f): stub !!!\n", This, iface, dRate);
 
@@ -2288,7 +2289,7 @@ static HRESULT WINAPI MediaSeeking_SetRate(IMediaSeeking *iface, double dRate)
 
 static HRESULT WINAPI MediaSeeking_GetRate(IMediaSeeking *iface, double *pdRate)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
 
     FIXME("(%p/%p)->(%p): stub !!!\n", This, iface, pdRate);
 
@@ -2302,7 +2303,7 @@ static HRESULT WINAPI MediaSeeking_GetRate(IMediaSeeking *iface, double *pdRate)
 
 static HRESULT WINAPI MediaSeeking_GetPreroll(IMediaSeeking *iface, LONGLONG *pllPreroll)
 {
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct filter_graph *This = impl_from_IMediaSeeking(iface);
 
     FIXME("(%p/%p)->(%p): stub !!!\n", This, iface, pllPreroll);
 
@@ -2334,27 +2335,27 @@ static const IMediaSeekingVtbl IMediaSeeking_VTable =
     MediaSeeking_GetPreroll
 };
 
-static inline IFilterGraphImpl *impl_from_IMediaPosition(IMediaPosition *iface)
+static struct filter_graph *impl_from_IMediaPosition(IMediaPosition *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IMediaPosition_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IMediaPosition_iface);
 }
 
 /*** IUnknown methods ***/
 static HRESULT WINAPI MediaPosition_QueryInterface(IMediaPosition *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaPosition(iface);
+    struct filter_graph *graph = impl_from_IMediaPosition(iface);
     return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI MediaPosition_AddRef(IMediaPosition *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaPosition(iface);
+    struct filter_graph *graph = impl_from_IMediaPosition(iface);
     return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI MediaPosition_Release(IMediaPosition *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaPosition(iface);
+    struct filter_graph *graph = impl_from_IMediaPosition(iface);
     return IUnknown_Release(graph->outer_unk);
 }
 
@@ -2423,7 +2424,7 @@ static HRESULT ConvertToREFTIME(IMediaSeeking *seek, LONGLONG time_in, REFTIME *
 static HRESULT WINAPI MediaPosition_get_Duration(IMediaPosition * iface, REFTIME *plength)
 {
     LONGLONG duration;
-    IFilterGraphImpl *This = impl_from_IMediaPosition( iface );
+    struct filter_graph *This = impl_from_IMediaPosition( iface );
     HRESULT hr = IMediaSeeking_GetDuration(&This->IMediaSeeking_iface, &duration);
     if (FAILED(hr))
         return hr;
@@ -2432,7 +2433,7 @@ static HRESULT WINAPI MediaPosition_get_Duration(IMediaPosition * iface, REFTIME
 
 static HRESULT WINAPI MediaPosition_put_CurrentPosition(IMediaPosition * iface, REFTIME llTime)
 {
-    IFilterGraphImpl *This = impl_from_IMediaPosition( iface );
+    struct filter_graph *This = impl_from_IMediaPosition( iface );
     LONGLONG reftime;
     HRESULT hr;
 
@@ -2445,7 +2446,7 @@ static HRESULT WINAPI MediaPosition_put_CurrentPosition(IMediaPosition * iface,
 
 static HRESULT WINAPI MediaPosition_get_CurrentPosition(IMediaPosition * iface, REFTIME *pllTime)
 {
-    IFilterGraphImpl *This = impl_from_IMediaPosition( iface );
+    struct filter_graph *This = impl_from_IMediaPosition( iface );
     LONGLONG pos;
     HRESULT hr;
 
@@ -2457,7 +2458,7 @@ static HRESULT WINAPI MediaPosition_get_CurrentPosition(IMediaPosition * iface,
 
 static HRESULT WINAPI MediaPosition_get_StopTime(IMediaPosition * iface, REFTIME *pllTime)
 {
-    IFilterGraphImpl *This = impl_from_IMediaPosition( iface );
+    struct filter_graph *This = impl_from_IMediaPosition( iface );
     LONGLONG pos;
     HRESULT hr = IMediaSeeking_GetStopPosition(&This->IMediaSeeking_iface, &pos);
     if (FAILED(hr))
@@ -2467,7 +2468,7 @@ static HRESULT WINAPI MediaPosition_get_StopTime(IMediaPosition * iface, REFTIME
 
 static HRESULT WINAPI MediaPosition_put_StopTime(IMediaPosition * iface, REFTIME llTime)
 {
-    IFilterGraphImpl *This = impl_from_IMediaPosition( iface );
+    struct filter_graph *This = impl_from_IMediaPosition( iface );
     LONGLONG reftime;
     HRESULT hr;
 
@@ -2492,13 +2493,13 @@ static HRESULT WINAPI MediaPosition_put_PrerollTime(IMediaPosition * iface, REFT
 
 static HRESULT WINAPI MediaPosition_put_Rate(IMediaPosition * iface, double dRate)
 {
-    IFilterGraphImpl *This = impl_from_IMediaPosition( iface );
+    struct filter_graph *This = impl_from_IMediaPosition( iface );
     return IMediaSeeking_SetRate(&This->IMediaSeeking_iface, dRate);
 }
 
 static HRESULT WINAPI MediaPosition_get_Rate(IMediaPosition * iface, double *pdRate)
 {
-    IFilterGraphImpl *This = impl_from_IMediaPosition( iface );
+    struct filter_graph *This = impl_from_IMediaPosition( iface );
     return IMediaSeeking_GetRate(&This->IMediaSeeking_iface, pdRate);
 }
 
@@ -2537,27 +2538,27 @@ static const IMediaPositionVtbl IMediaPosition_VTable =
     MediaPosition_CanSeekBackward
 };
 
-static inline IFilterGraphImpl *impl_from_IObjectWithSite(IObjectWithSite *iface)
+static struct filter_graph *impl_from_IObjectWithSite(IObjectWithSite *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IObjectWithSite_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IObjectWithSite_iface);
 }
 
 /*** IUnknown methods ***/
 static HRESULT WINAPI ObjectWithSite_QueryInterface(IObjectWithSite *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *graph = impl_from_IObjectWithSite(iface);
+    struct filter_graph *graph = impl_from_IObjectWithSite(iface);
     return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI ObjectWithSite_AddRef(IObjectWithSite *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IObjectWithSite(iface);
+    struct filter_graph *graph = impl_from_IObjectWithSite(iface);
     return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI ObjectWithSite_Release(IObjectWithSite *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IObjectWithSite(iface);
+    struct filter_graph *graph = impl_from_IObjectWithSite(iface);
     return IUnknown_Release(graph->outer_unk);
 }
 
@@ -2565,7 +2566,7 @@ static ULONG WINAPI ObjectWithSite_Release(IObjectWithSite *iface)
 
 static HRESULT WINAPI ObjectWithSite_SetSite(IObjectWithSite *iface, IUnknown *pUnkSite)
 {
-    IFilterGraphImpl *This = impl_from_IObjectWithSite( iface );
+    struct filter_graph *This = impl_from_IObjectWithSite( iface );
 
     TRACE("(%p/%p)->()\n", This, iface);
     if (This->pSite) IUnknown_Release(This->pSite);
@@ -2576,7 +2577,7 @@ static HRESULT WINAPI ObjectWithSite_SetSite(IObjectWithSite *iface, IUnknown *p
 
 static HRESULT WINAPI ObjectWithSite_GetSite(IObjectWithSite *iface, REFIID riid, PVOID *ppvSite)
 {
-    IFilterGraphImpl *This = impl_from_IObjectWithSite( iface );
+    struct filter_graph *This = impl_from_IObjectWithSite( iface );
 
     TRACE("(%p/%p)->(%s)\n", This, iface,debugstr_guid(riid));
 
@@ -2596,7 +2597,7 @@ static const IObjectWithSiteVtbl IObjectWithSite_VTable =
     ObjectWithSite_GetSite,
 };
 
-static HRESULT GetTargetInterface(IFilterGraphImpl* pGraph, REFIID riid, LPVOID* ppvObj)
+static HRESULT GetTargetInterface(struct filter_graph* pGraph, REFIID riid, LPVOID* ppvObj)
 {
     struct filter *filter;
     HRESULT hr;
@@ -2641,26 +2642,26 @@ static HRESULT GetTargetInterface(IFilterGraphImpl* pGraph, REFIID riid, LPVOID*
     return IsEqualGUID(riid, &IID_IBasicAudio) ? E_NOTIMPL : E_NOINTERFACE;
 }
 
-static inline IFilterGraphImpl *impl_from_IBasicAudio(IBasicAudio *iface)
+static struct filter_graph *impl_from_IBasicAudio(IBasicAudio *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IBasicAudio_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IBasicAudio_iface);
 }
 
 static HRESULT WINAPI BasicAudio_QueryInterface(IBasicAudio *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *graph = impl_from_IBasicAudio(iface);
+    struct filter_graph *graph = impl_from_IBasicAudio(iface);
     return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI BasicAudio_AddRef(IBasicAudio *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IBasicAudio(iface);
+    struct filter_graph *graph = impl_from_IBasicAudio(iface);
     return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI BasicAudio_Release(IBasicAudio *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IBasicAudio(iface);
+    struct filter_graph *graph = impl_from_IBasicAudio(iface);
     return IUnknown_Release(graph->outer_unk);
 }
 
@@ -2715,7 +2716,7 @@ static HRESULT WINAPI BasicAudio_Invoke(IBasicAudio *iface, DISPID id, REFIID ii
 /*** IBasicAudio methods ***/
 static HRESULT WINAPI BasicAudio_put_Volume(IBasicAudio *iface, LONG lVolume)
 {
-    IFilterGraphImpl *This = impl_from_IBasicAudio(iface);
+    struct filter_graph *This = impl_from_IBasicAudio(iface);
     IBasicAudio* pBasicAudio;
     HRESULT hr;
 
@@ -2735,7 +2736,7 @@ static HRESULT WINAPI BasicAudio_put_Volume(IBasicAudio *iface, LONG lVolume)
 
 static HRESULT WINAPI BasicAudio_get_Volume(IBasicAudio *iface, LONG *plVolume)
 {
-    IFilterGraphImpl *This = impl_from_IBasicAudio(iface);
+    struct filter_graph *This = impl_from_IBasicAudio(iface);
     IBasicAudio* pBasicAudio;
     HRESULT hr;
 
@@ -2755,7 +2756,7 @@ static HRESULT WINAPI BasicAudio_get_Volume(IBasicAudio *iface, LONG *plVolume)
 
 static HRESULT WINAPI BasicAudio_put_Balance(IBasicAudio *iface, LONG lBalance)
 {
-    IFilterGraphImpl *This = impl_from_IBasicAudio(iface);
+    struct filter_graph *This = impl_from_IBasicAudio(iface);
     IBasicAudio* pBasicAudio;
     HRESULT hr;
 
@@ -2775,7 +2776,7 @@ static HRESULT WINAPI BasicAudio_put_Balance(IBasicAudio *iface, LONG lBalance)
 
 static HRESULT WINAPI BasicAudio_get_Balance(IBasicAudio *iface, LONG *plBalance)
 {
-    IFilterGraphImpl *This = impl_from_IBasicAudio(iface);
+    struct filter_graph *This = impl_from_IBasicAudio(iface);
     IBasicAudio* pBasicAudio;
     HRESULT hr;
 
@@ -2808,26 +2809,26 @@ static const IBasicAudioVtbl IBasicAudio_VTable =
     BasicAudio_get_Balance
 };
 
-static inline IFilterGraphImpl *impl_from_IBasicVideo2(IBasicVideo2 *iface)
+static struct filter_graph *impl_from_IBasicVideo2(IBasicVideo2 *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IBasicVideo2_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IBasicVideo2_iface);
 }
 
 static HRESULT WINAPI BasicVideo_QueryInterface(IBasicVideo2 *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *graph = impl_from_IBasicVideo2(iface);
+    struct filter_graph *graph = impl_from_IBasicVideo2(iface);
     return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI BasicVideo_AddRef(IBasicVideo2 *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IBasicVideo2(iface);
+    struct filter_graph *graph = impl_from_IBasicVideo2(iface);
     return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI BasicVideo_Release(IBasicVideo2 *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IBasicVideo2(iface);
+    struct filter_graph *graph = impl_from_IBasicVideo2(iface);
     return IUnknown_Release(graph->outer_unk);
 }
 
@@ -2882,7 +2883,7 @@ static HRESULT WINAPI BasicVideo_Invoke(IBasicVideo2 *iface, DISPID id, REFIID i
 /*** IBasicVideo methods ***/
 static HRESULT WINAPI BasicVideo_get_AvgTimePerFrame(IBasicVideo2 *iface, REFTIME *pAvgTimePerFrame)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -2902,7 +2903,7 @@ static HRESULT WINAPI BasicVideo_get_AvgTimePerFrame(IBasicVideo2 *iface, REFTIM
 
 static HRESULT WINAPI BasicVideo_get_BitRate(IBasicVideo2 *iface, LONG *pBitRate)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -2922,7 +2923,7 @@ static HRESULT WINAPI BasicVideo_get_BitRate(IBasicVideo2 *iface, LONG *pBitRate
 
 static HRESULT WINAPI BasicVideo_get_BitErrorRate(IBasicVideo2 *iface, LONG *pBitErrorRate)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -2942,7 +2943,7 @@ static HRESULT WINAPI BasicVideo_get_BitErrorRate(IBasicVideo2 *iface, LONG *pBi
 
 static HRESULT WINAPI BasicVideo_get_VideoWidth(IBasicVideo2 *iface, LONG *pVideoWidth)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -2962,7 +2963,7 @@ static HRESULT WINAPI BasicVideo_get_VideoWidth(IBasicVideo2 *iface, LONG *pVide
 
 static HRESULT WINAPI BasicVideo_get_VideoHeight(IBasicVideo2 *iface, LONG *pVideoHeight)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -2982,7 +2983,7 @@ static HRESULT WINAPI BasicVideo_get_VideoHeight(IBasicVideo2 *iface, LONG *pVid
 
 static HRESULT WINAPI BasicVideo_put_SourceLeft(IBasicVideo2 *iface, LONG SourceLeft)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3002,7 +3003,7 @@ static HRESULT WINAPI BasicVideo_put_SourceLeft(IBasicVideo2 *iface, LONG Source
 
 static HRESULT WINAPI BasicVideo_get_SourceLeft(IBasicVideo2 *iface, LONG *pSourceLeft)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3022,7 +3023,7 @@ static HRESULT WINAPI BasicVideo_get_SourceLeft(IBasicVideo2 *iface, LONG *pSour
 
 static HRESULT WINAPI BasicVideo_put_SourceWidth(IBasicVideo2 *iface, LONG SourceWidth)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3042,7 +3043,7 @@ static HRESULT WINAPI BasicVideo_put_SourceWidth(IBasicVideo2 *iface, LONG Sourc
 
 static HRESULT WINAPI BasicVideo_get_SourceWidth(IBasicVideo2 *iface, LONG *pSourceWidth)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3062,7 +3063,7 @@ static HRESULT WINAPI BasicVideo_get_SourceWidth(IBasicVideo2 *iface, LONG *pSou
 
 static HRESULT WINAPI BasicVideo_put_SourceTop(IBasicVideo2 *iface, LONG SourceTop)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3082,7 +3083,7 @@ static HRESULT WINAPI BasicVideo_put_SourceTop(IBasicVideo2 *iface, LONG SourceT
 
 static HRESULT WINAPI BasicVideo_get_SourceTop(IBasicVideo2 *iface, LONG *pSourceTop)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3102,7 +3103,7 @@ static HRESULT WINAPI BasicVideo_get_SourceTop(IBasicVideo2 *iface, LONG *pSourc
 
 static HRESULT WINAPI BasicVideo_put_SourceHeight(IBasicVideo2 *iface, LONG SourceHeight)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3122,7 +3123,7 @@ static HRESULT WINAPI BasicVideo_put_SourceHeight(IBasicVideo2 *iface, LONG Sour
 
 static HRESULT WINAPI BasicVideo_get_SourceHeight(IBasicVideo2 *iface, LONG *pSourceHeight)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3142,7 +3143,7 @@ static HRESULT WINAPI BasicVideo_get_SourceHeight(IBasicVideo2 *iface, LONG *pSo
 
 static HRESULT WINAPI BasicVideo_put_DestinationLeft(IBasicVideo2 *iface, LONG DestinationLeft)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3162,7 +3163,7 @@ static HRESULT WINAPI BasicVideo_put_DestinationLeft(IBasicVideo2 *iface, LONG D
 
 static HRESULT WINAPI BasicVideo_get_DestinationLeft(IBasicVideo2 *iface, LONG *pDestinationLeft)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3182,7 +3183,7 @@ static HRESULT WINAPI BasicVideo_get_DestinationLeft(IBasicVideo2 *iface, LONG *
 
 static HRESULT WINAPI BasicVideo_put_DestinationWidth(IBasicVideo2 *iface, LONG DestinationWidth)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3202,7 +3203,7 @@ static HRESULT WINAPI BasicVideo_put_DestinationWidth(IBasicVideo2 *iface, LONG
 
 static HRESULT WINAPI BasicVideo_get_DestinationWidth(IBasicVideo2 *iface, LONG *pDestinationWidth)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3222,7 +3223,7 @@ static HRESULT WINAPI BasicVideo_get_DestinationWidth(IBasicVideo2 *iface, LONG
 
 static HRESULT WINAPI BasicVideo_put_DestinationTop(IBasicVideo2 *iface, LONG DestinationTop)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3242,7 +3243,7 @@ static HRESULT WINAPI BasicVideo_put_DestinationTop(IBasicVideo2 *iface, LONG De
 
 static HRESULT WINAPI BasicVideo_get_DestinationTop(IBasicVideo2 *iface, LONG *pDestinationTop)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3262,7 +3263,7 @@ static HRESULT WINAPI BasicVideo_get_DestinationTop(IBasicVideo2 *iface, LONG *p
 
 static HRESULT WINAPI BasicVideo_put_DestinationHeight(IBasicVideo2 *iface, LONG DestinationHeight)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3283,7 +3284,7 @@ static HRESULT WINAPI BasicVideo_put_DestinationHeight(IBasicVideo2 *iface, LONG
 static HRESULT WINAPI BasicVideo_get_DestinationHeight(IBasicVideo2 *iface,
         LONG *pDestinationHeight)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3304,7 +3305,7 @@ static HRESULT WINAPI BasicVideo_get_DestinationHeight(IBasicVideo2 *iface,
 static HRESULT WINAPI BasicVideo_SetSourcePosition(IBasicVideo2 *iface, LONG Left, LONG Top,
         LONG Width, LONG Height)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3325,7 +3326,7 @@ static HRESULT WINAPI BasicVideo_SetSourcePosition(IBasicVideo2 *iface, LONG Lef
 static HRESULT WINAPI BasicVideo_GetSourcePosition(IBasicVideo2 *iface, LONG *pLeft, LONG *pTop,
         LONG *pWidth, LONG *pHeight)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3345,7 +3346,7 @@ static HRESULT WINAPI BasicVideo_GetSourcePosition(IBasicVideo2 *iface, LONG *pL
 
 static HRESULT WINAPI BasicVideo_SetDefaultSourcePosition(IBasicVideo2 *iface)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3366,7 +3367,7 @@ static HRESULT WINAPI BasicVideo_SetDefaultSourcePosition(IBasicVideo2 *iface)
 static HRESULT WINAPI BasicVideo_SetDestinationPosition(IBasicVideo2 *iface, LONG Left, LONG Top,
         LONG Width, LONG Height)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3387,7 +3388,7 @@ static HRESULT WINAPI BasicVideo_SetDestinationPosition(IBasicVideo2 *iface, LON
 static HRESULT WINAPI BasicVideo_GetDestinationPosition(IBasicVideo2 *iface, LONG *pLeft,
         LONG *pTop, LONG *pWidth, LONG *pHeight)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3407,7 +3408,7 @@ static HRESULT WINAPI BasicVideo_GetDestinationPosition(IBasicVideo2 *iface, LON
 
 static HRESULT WINAPI BasicVideo_SetDefaultDestinationPosition(IBasicVideo2 *iface)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3427,7 +3428,7 @@ static HRESULT WINAPI BasicVideo_SetDefaultDestinationPosition(IBasicVideo2 *ifa
 
 static HRESULT WINAPI BasicVideo_GetVideoSize(IBasicVideo2 *iface, LONG *pWidth, LONG *pHeight)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3448,7 +3449,7 @@ static HRESULT WINAPI BasicVideo_GetVideoSize(IBasicVideo2 *iface, LONG *pWidth,
 static HRESULT WINAPI BasicVideo_GetVideoPaletteEntries(IBasicVideo2 *iface, LONG StartIndex,
         LONG Entries, LONG *pRetrieved, LONG *pPalette)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3469,7 +3470,7 @@ static HRESULT WINAPI BasicVideo_GetVideoPaletteEntries(IBasicVideo2 *iface, LON
 static HRESULT WINAPI BasicVideo_GetCurrentImage(IBasicVideo2 *iface, LONG *pBufferSize,
         LONG *pDIBImage)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3489,7 +3490,7 @@ static HRESULT WINAPI BasicVideo_GetCurrentImage(IBasicVideo2 *iface, LONG *pBuf
 
 static HRESULT WINAPI BasicVideo_IsUsingDefaultSource(IBasicVideo2 *iface)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3509,7 +3510,7 @@ static HRESULT WINAPI BasicVideo_IsUsingDefaultSource(IBasicVideo2 *iface)
 
 static HRESULT WINAPI BasicVideo_IsUsingDefaultDestination(IBasicVideo2 *iface)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
@@ -3530,7 +3531,7 @@ static HRESULT WINAPI BasicVideo_IsUsingDefaultDestination(IBasicVideo2 *iface)
 static HRESULT WINAPI BasicVideo2_GetPreferredAspectRatio(IBasicVideo2 *iface, LONG *plAspectX,
         LONG *plAspectY)
 {
-    IFilterGraphImpl *This = impl_from_IBasicVideo2(iface);
+    struct filter_graph *This = impl_from_IBasicVideo2(iface);
     IBasicVideo2 *pBasicVideo2;
     HRESULT hr;
 
@@ -3592,26 +3593,26 @@ static const IBasicVideo2Vtbl IBasicVideo_VTable =
     BasicVideo2_GetPreferredAspectRatio
 };
 
-static inline IFilterGraphImpl *impl_from_IVideoWindow(IVideoWindow *iface)
+static struct filter_graph *impl_from_IVideoWindow(IVideoWindow *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IVideoWindow_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IVideoWindow_iface);
 }
 
 static HRESULT WINAPI VideoWindow_QueryInterface(IVideoWindow *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *graph = impl_from_IVideoWindow(iface);
+    struct filter_graph *graph = impl_from_IVideoWindow(iface);
     return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI VideoWindow_AddRef(IVideoWindow *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IVideoWindow(iface);
+    struct filter_graph *graph = impl_from_IVideoWindow(iface);
     return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI VideoWindow_Release(IVideoWindow *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IVideoWindow(iface);
+    struct filter_graph *graph = impl_from_IVideoWindow(iface);
     return IUnknown_Release(graph->outer_unk);
 }
 
@@ -3666,7 +3667,7 @@ static HRESULT WINAPI VideoWindow_Invoke(IVideoWindow *iface, DISPID id, REFIID
 /*** IVideoWindow methods ***/
 static HRESULT WINAPI VideoWindow_put_Caption(IVideoWindow *iface, BSTR strCaption)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3686,7 +3687,7 @@ static HRESULT WINAPI VideoWindow_put_Caption(IVideoWindow *iface, BSTR strCapti
 
 static HRESULT WINAPI VideoWindow_get_Caption(IVideoWindow *iface, BSTR *strCaption)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3706,7 +3707,7 @@ static HRESULT WINAPI VideoWindow_get_Caption(IVideoWindow *iface, BSTR *strCapt
 
 static HRESULT WINAPI VideoWindow_put_WindowStyle(IVideoWindow *iface, LONG WindowStyle)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3726,7 +3727,7 @@ static HRESULT WINAPI VideoWindow_put_WindowStyle(IVideoWindow *iface, LONG Wind
 
 static HRESULT WINAPI VideoWindow_get_WindowStyle(IVideoWindow *iface, LONG *WindowStyle)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3746,7 +3747,7 @@ static HRESULT WINAPI VideoWindow_get_WindowStyle(IVideoWindow *iface, LONG *Win
 
 static HRESULT WINAPI VideoWindow_put_WindowStyleEx(IVideoWindow *iface, LONG WindowStyleEx)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3766,7 +3767,7 @@ static HRESULT WINAPI VideoWindow_put_WindowStyleEx(IVideoWindow *iface, LONG Wi
 
 static HRESULT WINAPI VideoWindow_get_WindowStyleEx(IVideoWindow *iface, LONG *WindowStyleEx)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3786,7 +3787,7 @@ static HRESULT WINAPI VideoWindow_get_WindowStyleEx(IVideoWindow *iface, LONG *W
 
 static HRESULT WINAPI VideoWindow_put_AutoShow(IVideoWindow *iface, LONG AutoShow)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3806,7 +3807,7 @@ static HRESULT WINAPI VideoWindow_put_AutoShow(IVideoWindow *iface, LONG AutoSho
 
 static HRESULT WINAPI VideoWindow_get_AutoShow(IVideoWindow *iface, LONG *AutoShow)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3826,7 +3827,7 @@ static HRESULT WINAPI VideoWindow_get_AutoShow(IVideoWindow *iface, LONG *AutoSh
 
 static HRESULT WINAPI VideoWindow_put_WindowState(IVideoWindow *iface, LONG WindowState)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3846,7 +3847,7 @@ static HRESULT WINAPI VideoWindow_put_WindowState(IVideoWindow *iface, LONG Wind
 
 static HRESULT WINAPI VideoWindow_get_WindowState(IVideoWindow *iface, LONG *WindowState)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3866,7 +3867,7 @@ static HRESULT WINAPI VideoWindow_get_WindowState(IVideoWindow *iface, LONG *Win
 
 static HRESULT WINAPI VideoWindow_put_BackgroundPalette(IVideoWindow *iface, LONG BackgroundPalette)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3887,7 +3888,7 @@ static HRESULT WINAPI VideoWindow_put_BackgroundPalette(IVideoWindow *iface, LON
 static HRESULT WINAPI VideoWindow_get_BackgroundPalette(IVideoWindow *iface,
         LONG *pBackgroundPalette)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3907,7 +3908,7 @@ static HRESULT WINAPI VideoWindow_get_BackgroundPalette(IVideoWindow *iface,
 
 static HRESULT WINAPI VideoWindow_put_Visible(IVideoWindow *iface, LONG Visible)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3927,7 +3928,7 @@ static HRESULT WINAPI VideoWindow_put_Visible(IVideoWindow *iface, LONG Visible)
 
 static HRESULT WINAPI VideoWindow_get_Visible(IVideoWindow *iface, LONG *pVisible)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3947,7 +3948,7 @@ static HRESULT WINAPI VideoWindow_get_Visible(IVideoWindow *iface, LONG *pVisibl
 
 static HRESULT WINAPI VideoWindow_put_Left(IVideoWindow *iface, LONG Left)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3967,7 +3968,7 @@ static HRESULT WINAPI VideoWindow_put_Left(IVideoWindow *iface, LONG Left)
 
 static HRESULT WINAPI VideoWindow_get_Left(IVideoWindow *iface, LONG *pLeft)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -3987,7 +3988,7 @@ static HRESULT WINAPI VideoWindow_get_Left(IVideoWindow *iface, LONG *pLeft)
 
 static HRESULT WINAPI VideoWindow_put_Width(IVideoWindow *iface, LONG Width)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4007,7 +4008,7 @@ static HRESULT WINAPI VideoWindow_put_Width(IVideoWindow *iface, LONG Width)
 
 static HRESULT WINAPI VideoWindow_get_Width(IVideoWindow *iface, LONG *pWidth)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4027,7 +4028,7 @@ static HRESULT WINAPI VideoWindow_get_Width(IVideoWindow *iface, LONG *pWidth)
 
 static HRESULT WINAPI VideoWindow_put_Top(IVideoWindow *iface, LONG Top)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4047,7 +4048,7 @@ static HRESULT WINAPI VideoWindow_put_Top(IVideoWindow *iface, LONG Top)
 
 static HRESULT WINAPI VideoWindow_get_Top(IVideoWindow *iface, LONG *pTop)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4067,7 +4068,7 @@ static HRESULT WINAPI VideoWindow_get_Top(IVideoWindow *iface, LONG *pTop)
 
 static HRESULT WINAPI VideoWindow_put_Height(IVideoWindow *iface, LONG Height)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4087,7 +4088,7 @@ static HRESULT WINAPI VideoWindow_put_Height(IVideoWindow *iface, LONG Height)
 
 static HRESULT WINAPI VideoWindow_get_Height(IVideoWindow *iface, LONG *pHeight)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4107,7 +4108,7 @@ static HRESULT WINAPI VideoWindow_get_Height(IVideoWindow *iface, LONG *pHeight)
 
 static HRESULT WINAPI VideoWindow_put_Owner(IVideoWindow *iface, OAHWND Owner)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4127,7 +4128,7 @@ static HRESULT WINAPI VideoWindow_put_Owner(IVideoWindow *iface, OAHWND Owner)
 
 static HRESULT WINAPI VideoWindow_get_Owner(IVideoWindow *iface, OAHWND *Owner)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4147,7 +4148,7 @@ static HRESULT WINAPI VideoWindow_get_Owner(IVideoWindow *iface, OAHWND *Owner)
 
 static HRESULT WINAPI VideoWindow_put_MessageDrain(IVideoWindow *iface, OAHWND Drain)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4167,7 +4168,7 @@ static HRESULT WINAPI VideoWindow_put_MessageDrain(IVideoWindow *iface, OAHWND D
 
 static HRESULT WINAPI VideoWindow_get_MessageDrain(IVideoWindow *iface, OAHWND *Drain)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4187,7 +4188,7 @@ static HRESULT WINAPI VideoWindow_get_MessageDrain(IVideoWindow *iface, OAHWND *
 
 static HRESULT WINAPI VideoWindow_get_BorderColor(IVideoWindow *iface, LONG *Color)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4207,7 +4208,7 @@ static HRESULT WINAPI VideoWindow_get_BorderColor(IVideoWindow *iface, LONG *Col
 
 static HRESULT WINAPI VideoWindow_put_BorderColor(IVideoWindow *iface, LONG Color)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4227,7 +4228,7 @@ static HRESULT WINAPI VideoWindow_put_BorderColor(IVideoWindow *iface, LONG Colo
 
 static HRESULT WINAPI VideoWindow_get_FullScreenMode(IVideoWindow *iface, LONG *FullScreenMode)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4247,7 +4248,7 @@ static HRESULT WINAPI VideoWindow_get_FullScreenMode(IVideoWindow *iface, LONG *
 
 static HRESULT WINAPI VideoWindow_put_FullScreenMode(IVideoWindow *iface, LONG FullScreenMode)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4267,7 +4268,7 @@ static HRESULT WINAPI VideoWindow_put_FullScreenMode(IVideoWindow *iface, LONG F
 
 static HRESULT WINAPI VideoWindow_SetWindowForeground(IVideoWindow *iface, LONG Focus)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4288,7 +4289,7 @@ static HRESULT WINAPI VideoWindow_SetWindowForeground(IVideoWindow *iface, LONG
 static HRESULT WINAPI VideoWindow_NotifyOwnerMessage(IVideoWindow *iface, OAHWND hwnd, LONG uMsg,
         LONG_PTR wParam, LONG_PTR lParam)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4309,7 +4310,7 @@ static HRESULT WINAPI VideoWindow_NotifyOwnerMessage(IVideoWindow *iface, OAHWND
 static HRESULT WINAPI VideoWindow_SetWindowPosition(IVideoWindow *iface, LONG Left, LONG Top,
         LONG Width, LONG Height)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4330,7 +4331,7 @@ static HRESULT WINAPI VideoWindow_SetWindowPosition(IVideoWindow *iface, LONG Le
 static HRESULT WINAPI VideoWindow_GetWindowPosition(IVideoWindow *iface, LONG *pLeft, LONG *pTop,
         LONG *pWidth, LONG *pHeight)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4351,7 +4352,7 @@ static HRESULT WINAPI VideoWindow_GetWindowPosition(IVideoWindow *iface, LONG *p
 static HRESULT WINAPI VideoWindow_GetMinIdealImageSize(IVideoWindow *iface, LONG *pWidth,
         LONG *pHeight)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4372,7 +4373,7 @@ static HRESULT WINAPI VideoWindow_GetMinIdealImageSize(IVideoWindow *iface, LONG
 static HRESULT WINAPI VideoWindow_GetMaxIdealImageSize(IVideoWindow *iface, LONG *pWidth,
         LONG *pHeight)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4393,7 +4394,7 @@ static HRESULT WINAPI VideoWindow_GetMaxIdealImageSize(IVideoWindow *iface, LONG
 static HRESULT WINAPI VideoWindow_GetRestorePosition(IVideoWindow *iface, LONG *pLeft, LONG *pTop,
         LONG *pWidth, LONG *pHeight)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4413,7 +4414,7 @@ static HRESULT WINAPI VideoWindow_GetRestorePosition(IVideoWindow *iface, LONG *
 
 static HRESULT WINAPI VideoWindow_HideCursor(IVideoWindow *iface, LONG HideCursor)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4433,7 +4434,7 @@ static HRESULT WINAPI VideoWindow_HideCursor(IVideoWindow *iface, LONG HideCurso
 
 static HRESULT WINAPI VideoWindow_IsCursorHidden(IVideoWindow *iface, LONG *CursorHidden)
 {
-    IFilterGraphImpl *This = impl_from_IVideoWindow(iface);
+    struct filter_graph *This = impl_from_IVideoWindow(iface);
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
@@ -4502,33 +4503,33 @@ static const IVideoWindowVtbl IVideoWindow_VTable =
     VideoWindow_IsCursorHidden
 };
 
-static inline IFilterGraphImpl *impl_from_IMediaEventEx(IMediaEventEx *iface)
+static struct filter_graph *impl_from_IMediaEventEx(IMediaEventEx *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IMediaEventEx_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IMediaEventEx_iface);
 }
 
 static HRESULT WINAPI MediaEvent_QueryInterface(IMediaEventEx *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaEventEx(iface);
+    struct filter_graph *graph = impl_from_IMediaEventEx(iface);
     return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI MediaEvent_AddRef(IMediaEventEx *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaEventEx(iface);
+    struct filter_graph *graph = impl_from_IMediaEventEx(iface);
     return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI MediaEvent_Release(IMediaEventEx *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaEventEx(iface);
+    struct filter_graph *graph = impl_from_IMediaEventEx(iface);
     return IUnknown_Release(graph->outer_unk);
 }
 
 /*** IDispatch methods ***/
 static HRESULT WINAPI MediaEvent_GetTypeInfoCount(IMediaEventEx *iface, UINT *pctinfo)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
     TRACE("(%p/%p)->(%p): stub !!!\n", This, iface, pctinfo);
 
@@ -4538,7 +4539,7 @@ static HRESULT WINAPI MediaEvent_GetTypeInfoCount(IMediaEventEx *iface, UINT *pc
 static HRESULT WINAPI MediaEvent_GetTypeInfo(IMediaEventEx *iface, UINT iTInfo, LCID lcid,
         ITypeInfo **ppTInfo)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
     TRACE("(%p/%p)->(%d, %d, %p): stub !!!\n", This, iface, iTInfo, lcid, ppTInfo);
 
@@ -4548,7 +4549,7 @@ static HRESULT WINAPI MediaEvent_GetTypeInfo(IMediaEventEx *iface, UINT iTInfo,
 static HRESULT WINAPI MediaEvent_GetIDsOfNames(IMediaEventEx *iface, REFIID riid,
         LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
     TRACE("(%p/%p)->(%s, %p, %d, %d, %p): stub !!!\n", This, iface, debugstr_guid(riid), rgszNames,
             cNames, lcid, rgDispId);
@@ -4560,7 +4561,7 @@ static HRESULT WINAPI MediaEvent_Invoke(IMediaEventEx *iface, DISPID dispIdMembe
         LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExepInfo,
         UINT *puArgErr)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
     TRACE("(%p/%p)->(%d, %s, %d, %04x, %p, %p, %p, %p): stub !!!\n", This, iface, dispIdMember,
             debugstr_guid(riid), lcid, wFlags, pDispParams, pVarResult, pExepInfo, puArgErr);
@@ -4571,7 +4572,7 @@ static HRESULT WINAPI MediaEvent_Invoke(IMediaEventEx *iface, DISPID dispIdMembe
 /*** IMediaEvent methods ***/
 static HRESULT WINAPI MediaEvent_GetEventHandle(IMediaEventEx *iface, OAEVENT *hEvent)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
     TRACE("(%p/%p)->(%p)\n", This, iface, hEvent);
 
@@ -4583,7 +4584,7 @@ static HRESULT WINAPI MediaEvent_GetEventHandle(IMediaEventEx *iface, OAEVENT *h
 static HRESULT WINAPI MediaEvent_GetEvent(IMediaEventEx *iface, LONG *lEventCode, LONG_PTR *lParam1,
         LONG_PTR *lParam2, LONG msTimeout)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
     Event evt;
 
     TRACE("(%p/%p)->(%p, %p, %p, %d)\n", This, iface, lEventCode, lParam1, lParam2, msTimeout);
@@ -4603,7 +4604,7 @@ static HRESULT WINAPI MediaEvent_GetEvent(IMediaEventEx *iface, LONG *lEventCode
 static HRESULT WINAPI MediaEvent_WaitForCompletion(IMediaEventEx *iface, LONG msTimeout,
         LONG *pEvCode)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
     TRACE("(%p/%p)->(%d, %p)\n", This, iface, msTimeout, pEvCode);
 
@@ -4622,7 +4623,7 @@ static HRESULT WINAPI MediaEvent_WaitForCompletion(IMediaEventEx *iface, LONG ms
 
 static HRESULT WINAPI MediaEvent_CancelDefaultHandling(IMediaEventEx *iface, LONG lEvCode)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
     TRACE("(%p/%p)->(%d)\n", This, iface, lEvCode);
 
@@ -4640,7 +4641,7 @@ static HRESULT WINAPI MediaEvent_CancelDefaultHandling(IMediaEventEx *iface, LON
 
 static HRESULT WINAPI MediaEvent_RestoreDefaultHandling(IMediaEventEx *iface, LONG lEvCode)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
     TRACE("(%p/%p)->(%d)\n", This, iface, lEvCode);
 
@@ -4659,7 +4660,7 @@ static HRESULT WINAPI MediaEvent_RestoreDefaultHandling(IMediaEventEx *iface, LO
 static HRESULT WINAPI MediaEvent_FreeEventParams(IMediaEventEx *iface, LONG lEvCode,
         LONG_PTR lParam1, LONG_PTR lParam2)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
     TRACE("(%p/%p)->(%d, %08lx, %08lx): stub !!!\n", This, iface, lEvCode, lParam1, lParam2);
 
@@ -4670,7 +4671,7 @@ static HRESULT WINAPI MediaEvent_FreeEventParams(IMediaEventEx *iface, LONG lEvC
 static HRESULT WINAPI MediaEvent_SetNotifyWindow(IMediaEventEx *iface, OAHWND hwnd, LONG lMsg,
         LONG_PTR lInstanceData)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
     TRACE("(%p/%p)->(%08lx, %d, %08lx)\n", This, iface, hwnd, lMsg, lInstanceData);
 
@@ -4683,7 +4684,7 @@ static HRESULT WINAPI MediaEvent_SetNotifyWindow(IMediaEventEx *iface, OAHWND hw
 
 static HRESULT WINAPI MediaEvent_SetNotifyFlags(IMediaEventEx *iface, LONG lNoNotifyFlags)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
     TRACE("(%p/%p)->(%d)\n", This, iface, lNoNotifyFlags);
 
@@ -4697,7 +4698,7 @@ static HRESULT WINAPI MediaEvent_SetNotifyFlags(IMediaEventEx *iface, LONG lNoNo
 
 static HRESULT WINAPI MediaEvent_GetNotifyFlags(IMediaEventEx *iface, LONG *lplNoNotifyFlags)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
     TRACE("(%p/%p)->(%p)\n", This, iface, lplNoNotifyFlags);
 
@@ -4731,30 +4732,30 @@ static const IMediaEventExVtbl IMediaEventEx_VTable =
 };
 
 
-static inline IFilterGraphImpl *impl_from_IMediaFilter(IMediaFilter *iface)
+static struct filter_graph *impl_from_IMediaFilter(IMediaFilter *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IMediaFilter_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IMediaFilter_iface);
 }
 
-static HRESULT WINAPI MediaFilter_QueryInterface(IMediaFilter *iface, REFIID riid, void **ppv)
+static HRESULT WINAPI MediaFilter_QueryInterface(IMediaFilter *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *This = impl_from_IMediaFilter(iface);
+    struct filter_graph *graph = impl_from_IMediaFilter(iface);
 
-    return IUnknown_QueryInterface(This->outer_unk, riid, ppv);
+    return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI MediaFilter_AddRef(IMediaFilter *iface)
 {
-    IFilterGraphImpl *This = impl_from_IMediaFilter(iface);
+    struct filter_graph *graph = impl_from_IMediaFilter(iface);
 
-    return IUnknown_AddRef(This->outer_unk);
+    return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI MediaFilter_Release(IMediaFilter *iface)
 {
-    IFilterGraphImpl *This = impl_from_IMediaFilter(iface);
+    struct filter_graph *graph = impl_from_IMediaFilter(iface);
 
-    return IUnknown_Release(This->outer_unk);
+    return IUnknown_Release(graph->outer_unk);
 }
 
 static HRESULT WINAPI MediaFilter_GetClassID(IMediaFilter *iface, CLSID * pClassID)
@@ -4766,7 +4767,7 @@ static HRESULT WINAPI MediaFilter_GetClassID(IMediaFilter *iface, CLSID * pClass
 
 static HRESULT WINAPI MediaFilter_Stop(IMediaFilter *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaFilter(iface);
+    struct filter_graph *graph = impl_from_IMediaFilter(iface);
     HRESULT hr = S_OK, filter_hr;
     struct filter *filter;
 
@@ -4809,7 +4810,7 @@ static HRESULT WINAPI MediaFilter_Stop(IMediaFilter *iface)
     return hr;
 }
 
-static void update_render_count(IFilterGraphImpl *graph)
+static void update_render_count(struct filter_graph *graph)
 {
     /* Some filters (e.g. MediaStreamFilter) can become renderers when they are
      * already in the graph. */
@@ -4824,7 +4825,7 @@ static void update_render_count(IFilterGraphImpl *graph)
 
 static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaFilter(iface);
+    struct filter_graph *graph = impl_from_IMediaFilter(iface);
     HRESULT hr = S_OK, filter_hr;
     struct filter *filter;
 
@@ -4867,7 +4868,7 @@ static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
 
 static HRESULT WINAPI MediaFilter_Run(IMediaFilter *iface, REFERENCE_TIME start)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaFilter(iface);
+    struct filter_graph *graph = impl_from_IMediaFilter(iface);
     REFERENCE_TIME stream_start = start;
     HRESULT hr = S_OK, filter_hr;
     struct filter *filter;
@@ -4912,7 +4913,7 @@ static HRESULT WINAPI MediaFilter_Run(IMediaFilter *iface, REFERENCE_TIME start)
 
 static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, FILTER_STATE *state)
 {
-    IFilterGraphImpl *graph = impl_from_IMediaFilter(iface);
+    struct filter_graph *graph = impl_from_IMediaFilter(iface);
     DWORD end = GetTickCount() + timeout;
     HRESULT hr = S_OK, filter_hr;
     struct filter *filter;
@@ -4955,7 +4956,7 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
 
 static HRESULT WINAPI MediaFilter_SetSyncSource(IMediaFilter *iface, IReferenceClock *pClock)
 {
-    IFilterGraphImpl *This = impl_from_IMediaFilter(iface);
+    struct filter_graph *This = impl_from_IMediaFilter(iface);
     struct filter *filter;
     HRESULT hr = S_OK;
 
@@ -5005,7 +5006,7 @@ static HRESULT WINAPI MediaFilter_SetSyncSource(IMediaFilter *iface, IReferenceC
 
 static HRESULT WINAPI MediaFilter_GetSyncSource(IMediaFilter *iface, IReferenceClock **ppClock)
 {
-    IFilterGraphImpl *This = impl_from_IMediaFilter(iface);
+    struct filter_graph *This = impl_from_IMediaFilter(iface);
 
     TRACE("(%p/%p)->(%p)\n", This, iface, ppClock);
 
@@ -5037,36 +5038,36 @@ static const IMediaFilterVtbl IMediaFilter_VTable =
     MediaFilter_GetSyncSource
 };
 
-static inline IFilterGraphImpl *impl_from_IMediaEventSink(IMediaEventSink *iface)
+static struct filter_graph *impl_from_IMediaEventSink(IMediaEventSink *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IMediaEventSink_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IMediaEventSink_iface);
 }
 
-static HRESULT WINAPI MediaEventSink_QueryInterface(IMediaEventSink *iface, REFIID riid, void **ppv)
+static HRESULT WINAPI MediaEventSink_QueryInterface(IMediaEventSink *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventSink(iface);
+    struct filter_graph *graph = impl_from_IMediaEventSink(iface);
 
-    return IUnknown_QueryInterface(This->outer_unk, riid, ppv);
+    return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI MediaEventSink_AddRef(IMediaEventSink *iface)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventSink(iface);
+    struct filter_graph *graph = impl_from_IMediaEventSink(iface);
 
-    return IUnknown_AddRef(This->outer_unk);
+    return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI MediaEventSink_Release(IMediaEventSink *iface)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventSink(iface);
+    struct filter_graph *graph = impl_from_IMediaEventSink(iface);
 
-    return IUnknown_Release(This->outer_unk);
+    return IUnknown_Release(graph->outer_unk);
 }
 
 static HRESULT WINAPI MediaEventSink_Notify(IMediaEventSink *iface, LONG EventCode,
         LONG_PTR EventParam1, LONG_PTR EventParam2)
 {
-    IFilterGraphImpl *This = impl_from_IMediaEventSink(iface);
+    struct filter_graph *This = impl_from_IMediaEventSink(iface);
     Event evt;
 
     TRACE("(%p/%p)->(%d, %ld, %ld)\n", This, iface, EventCode, EventParam1, EventParam2);
@@ -5119,37 +5120,37 @@ static const IMediaEventSinkVtbl IMediaEventSink_VTable =
     MediaEventSink_Notify
 };
 
-static inline IFilterGraphImpl *impl_from_IGraphConfig(IGraphConfig *iface)
+static struct filter_graph *impl_from_IGraphConfig(IGraphConfig *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IGraphConfig_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IGraphConfig_iface);
 }
 
-static HRESULT WINAPI GraphConfig_QueryInterface(IGraphConfig *iface, REFIID riid, void **ppv)
+static HRESULT WINAPI GraphConfig_QueryInterface(IGraphConfig *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *graph = impl_from_IGraphConfig(iface);
 
-    return IUnknown_QueryInterface(This->outer_unk, riid, ppv);
+    return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI GraphConfig_AddRef(IGraphConfig *iface)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *graph = impl_from_IGraphConfig(iface);
 
-    return IUnknown_AddRef(This->outer_unk);
+    return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI GraphConfig_Release(IGraphConfig *iface)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *graph = impl_from_IGraphConfig(iface);
 
-    return IUnknown_Release(This->outer_unk);
+    return IUnknown_Release(graph->outer_unk);
 }
 
 static HRESULT WINAPI GraphConfig_Reconnect(IGraphConfig *iface, IPin *pOutputPin, IPin *pInputPin,
         const AM_MEDIA_TYPE *pmtFirstConnection, IBaseFilter *pUsingFilter, HANDLE hAbortEvent,
         DWORD dwFlags)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
 
     FIXME("(%p)->(%p, %p, %p, %p, %p, %x): stub!\n", This, pOutputPin, pInputPin, pmtFirstConnection, pUsingFilter, hAbortEvent, dwFlags);
     strmbase_dump_media_type(pmtFirstConnection);
@@ -5160,7 +5161,7 @@ static HRESULT WINAPI GraphConfig_Reconnect(IGraphConfig *iface, IPin *pOutputPi
 static HRESULT WINAPI GraphConfig_Reconfigure(IGraphConfig *iface, IGraphConfigCallback *pCallback,
         void *pvContext, DWORD dwFlags, HANDLE hAbortEvent)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
     HRESULT hr;
 
     WARN("(%p)->(%p, %p, %x, %p): partial stub!\n", This, pCallback, pvContext, dwFlags, hAbortEvent);
@@ -5179,7 +5180,7 @@ static HRESULT WINAPI GraphConfig_Reconfigure(IGraphConfig *iface, IGraphConfigC
 
 static HRESULT WINAPI GraphConfig_AddFilterToCache(IGraphConfig *iface, IBaseFilter *pFilter)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
 
     FIXME("(%p)->(%p): stub!\n", This, pFilter);
 
@@ -5188,7 +5189,7 @@ static HRESULT WINAPI GraphConfig_AddFilterToCache(IGraphConfig *iface, IBaseFil
 
 static HRESULT WINAPI GraphConfig_EnumCacheFilter(IGraphConfig *iface, IEnumFilters **pEnum)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
 
     FIXME("(%p)->(%p): stub!\n", This, pEnum);
 
@@ -5197,7 +5198,7 @@ static HRESULT WINAPI GraphConfig_EnumCacheFilter(IGraphConfig *iface, IEnumFilt
 
 static HRESULT WINAPI GraphConfig_RemoveFilterFromCache(IGraphConfig *iface, IBaseFilter *pFilter)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
 
     FIXME("(%p)->(%p): stub!\n", This, pFilter);
 
@@ -5206,7 +5207,7 @@ static HRESULT WINAPI GraphConfig_RemoveFilterFromCache(IGraphConfig *iface, IBa
 
 static HRESULT WINAPI GraphConfig_GetStartTime(IGraphConfig *iface, REFERENCE_TIME *prtStart)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
 
     FIXME("(%p)->(%p): stub!\n", This, prtStart);
 
@@ -5216,7 +5217,7 @@ static HRESULT WINAPI GraphConfig_GetStartTime(IGraphConfig *iface, REFERENCE_TI
 static HRESULT WINAPI GraphConfig_PushThroughData(IGraphConfig *iface, IPin *pOutputPin,
         IPinConnection *pConnection, HANDLE hEventAbort)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
 
     FIXME("(%p)->(%p, %p, %p): stub!\n", This, pOutputPin, pConnection, hEventAbort);
 
@@ -5226,7 +5227,7 @@ static HRESULT WINAPI GraphConfig_PushThroughData(IGraphConfig *iface, IPin *pOu
 static HRESULT WINAPI GraphConfig_SetFilterFlags(IGraphConfig *iface, IBaseFilter *pFilter,
         DWORD dwFlags)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
 
     FIXME("(%p)->(%p, %x): stub!\n", This, pFilter, dwFlags);
 
@@ -5236,7 +5237,7 @@ static HRESULT WINAPI GraphConfig_SetFilterFlags(IGraphConfig *iface, IBaseFilte
 static HRESULT WINAPI GraphConfig_GetFilterFlags(IGraphConfig *iface, IBaseFilter *pFilter,
         DWORD *dwFlags)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
 
     FIXME("(%p)->(%p, %p): stub!\n", This, pFilter, dwFlags);
 
@@ -5246,7 +5247,7 @@ static HRESULT WINAPI GraphConfig_GetFilterFlags(IGraphConfig *iface, IBaseFilte
 static HRESULT WINAPI GraphConfig_RemoveFilterEx(IGraphConfig *iface, IBaseFilter *pFilter,
         DWORD dwFlags)
 {
-    IFilterGraphImpl *This = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
 
     FIXME("(%p)->(%p, %x): stub!\n", This, pFilter, dwFlags);
 
@@ -5270,35 +5271,35 @@ static const IGraphConfigVtbl IGraphConfig_VTable =
     GraphConfig_RemoveFilterEx
 };
 
-static inline IFilterGraphImpl *impl_from_IGraphVersion(IGraphVersion *iface)
+static struct filter_graph *impl_from_IGraphVersion(IGraphVersion *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IGraphVersion_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IGraphVersion_iface);
 }
 
-static HRESULT WINAPI GraphVersion_QueryInterface(IGraphVersion *iface, REFIID riid, void **ppv)
+static HRESULT WINAPI GraphVersion_QueryInterface(IGraphVersion *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *This = impl_from_IGraphVersion(iface);
+    struct filter_graph *graph = impl_from_IGraphVersion(iface);
 
-    return IUnknown_QueryInterface(This->outer_unk, riid, ppv);
+    return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI GraphVersion_AddRef(IGraphVersion *iface)
 {
-    IFilterGraphImpl *This = impl_from_IGraphVersion(iface);
+    struct filter_graph *graph = impl_from_IGraphVersion(iface);
 
-    return IUnknown_AddRef(This->outer_unk);
+    return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI GraphVersion_Release(IGraphVersion *iface)
 {
-    IFilterGraphImpl *This = impl_from_IGraphVersion(iface);
+    struct filter_graph *graph = impl_from_IGraphVersion(iface);
 
-    return IUnknown_Release(This->outer_unk);
+    return IUnknown_Release(graph->outer_unk);
 }
 
 static HRESULT WINAPI GraphVersion_QueryVersion(IGraphVersion *iface, LONG *pVersion)
 {
-    IFilterGraphImpl *This = impl_from_IGraphVersion(iface);
+    struct filter_graph *This = impl_from_IGraphVersion(iface);
 
     if(!pVersion)
         return E_POINTER;
@@ -5317,26 +5318,26 @@ static const IGraphVersionVtbl IGraphVersion_VTable =
     GraphVersion_QueryVersion,
 };
 
-static IFilterGraphImpl *impl_from_IVideoFrameStep(IVideoFrameStep *iface)
+static struct filter_graph *impl_from_IVideoFrameStep(IVideoFrameStep *iface)
 {
-    return CONTAINING_RECORD(iface, IFilterGraphImpl, IVideoFrameStep_iface);
+    return CONTAINING_RECORD(iface, struct filter_graph, IVideoFrameStep_iface);
 }
 
 static HRESULT WINAPI VideoFrameStep_QueryInterface(IVideoFrameStep *iface, REFIID iid, void **out)
 {
-    IFilterGraphImpl *graph = impl_from_IVideoFrameStep(iface);
+    struct filter_graph *graph = impl_from_IVideoFrameStep(iface);
     return IUnknown_QueryInterface(graph->outer_unk, iid, out);
 }
 
 static ULONG WINAPI VideoFrameStep_AddRef(IVideoFrameStep *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IVideoFrameStep(iface);
+    struct filter_graph *graph = impl_from_IVideoFrameStep(iface);
     return IUnknown_AddRef(graph->outer_unk);
 }
 
 static ULONG WINAPI VideoFrameStep_Release(IVideoFrameStep *iface)
 {
-    IFilterGraphImpl *graph = impl_from_IVideoFrameStep(iface);
+    struct filter_graph *graph = impl_from_IVideoFrameStep(iface);
     return IUnknown_Release(graph->outer_unk);
 }
 
@@ -5377,7 +5378,7 @@ static const IUnknownVtbl IInner_VTable =
 
 static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL threaded)
 {
-    IFilterGraphImpl *object;
+    struct filter_graph *object;
     HRESULT hr;
 
     *out = NULL;
@@ -5412,7 +5413,7 @@ static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL
     }
 
     InitializeCriticalSection(&object->cs);
-    object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": IFilterGraphImpl.cs");
+    object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": filter_graph.cs");
 
     object->defaultclock = TRUE;
     EventsQueue_Init(&object->evqueue);
From 4d580796bc64106e8105df458cbc938fbac3988a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 13 Jul 2020 17:37:17 -0500
Subject: [PATCH] quartz/vmr9: Show the window only if auto-show is enabled.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index b6b55c70c5d..a540feb2374 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -482,7 +482,7 @@ static void vmr_start_stream(struct strmbase_renderer *iface)
     struct quartz_vmr *filter = impl_from_IBaseFilter(&iface->filter.IBaseFilter_iface);
 
     IVMRImagePresenter9_StartPresenting(filter->presenter, filter->cookie);
-    if (filter->window.hwnd)
+    if (filter->window.hwnd && filter->window.AutoShow)
         ShowWindow(filter->window.hwnd, SW_SHOW);
     SetEvent(filter->run_event);
 }
From 44c0e691379afeba50e39c81624702af89a10e00 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 13 Jul 2020 17:37:18 -0500
Subject: [PATCH] quartz/vmr9: Auto-show the window when pausing, not when
 running.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr7.c |  4 ++--
 dlls/quartz/tests/vmr9.c |  4 ++--
 dlls/quartz/vmr9.c       | 11 +++++++++--
 3 files changed, 13 insertions(+), 6 deletions(-)

diff --git a/dlls/quartz/tests/vmr7.c b/dlls/quartz/tests/vmr7.c
index adf677535b2..cf4675ce069 100644
--- a/dlls/quartz/tests/vmr7.c
+++ b/dlls/quartz/tests/vmr7.c
@@ -2130,14 +2130,14 @@ static void test_video_window_autoshow(IVideoWindow *window, IFilterGraph2 *grap
 
     hr = IVideoWindow_get_Visible(window, &l);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(l == OATRUE, "Got %d.\n", l);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IMediaControl_Stop(control);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &l);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(l == OATRUE, "Got %d.\n", l);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IVideoWindow_put_AutoShow(window, OAFALSE);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 005b10974f9..e953c05dd1e 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -2376,14 +2376,14 @@ static void test_video_window_autoshow(IVideoWindow *window, IFilterGraph2 *grap
 
     hr = IVideoWindow_get_Visible(window, &l);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(l == OATRUE, "Got %d.\n", l);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IMediaControl_Stop(control);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &l);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(l == OATRUE, "Got %d.\n", l);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IVideoWindow_put_AutoShow(window, OAFALSE);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index a540feb2374..aeaefd52c6b 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -477,13 +477,19 @@ static HRESULT allocate_surfaces(struct quartz_vmr *filter, const AM_MEDIA_TYPE
     return VFW_E_TYPE_NOT_ACCEPTED;
 }
 
-static void vmr_start_stream(struct strmbase_renderer *iface)
+static void vmr_init_stream(struct strmbase_renderer *iface)
 {
     struct quartz_vmr *filter = impl_from_IBaseFilter(&iface->filter.IBaseFilter_iface);
 
-    IVMRImagePresenter9_StartPresenting(filter->presenter, filter->cookie);
     if (filter->window.hwnd && filter->window.AutoShow)
         ShowWindow(filter->window.hwnd, SW_SHOW);
+}
+
+static void vmr_start_stream(struct strmbase_renderer *iface)
+{
+    struct quartz_vmr *filter = impl_from_IBaseFilter(&iface->filter.IBaseFilter_iface);
+
+    IVMRImagePresenter9_StartPresenting(filter->presenter, filter->cookie);
     SetEvent(filter->run_event);
 }
 
@@ -659,6 +665,7 @@ static const struct strmbase_renderer_ops renderer_ops =
 {
     .pfnCheckMediaType = VMR9_CheckMediaType,
     .pfnDoRenderSample = VMR9_DoRenderSample,
+    .renderer_init_stream = vmr_init_stream,
     .renderer_start_stream = vmr_start_stream,
     .renderer_stop_stream = vmr_stop_stream,
     .pfnShouldDrawSampleNow = VMR9_ShouldDrawSampleNow,
From 44cd11ef4ab3675dd8a7598d2ee66eb658092eb7 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 13 Jul 2020 17:37:19 -0500
Subject: [PATCH] qcap/smartteefilter: Return VFW_S_CANT_CUE from GetState() if
 paused.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/smartteefilter.c       | 6 ++++++
 dlls/qcap/tests/smartteefilter.c | 4 ++--
 2 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/dlls/qcap/smartteefilter.c b/dlls/qcap/smartteefilter.c
index 5b4add0b5db..2f6f3ab2b79 100644
--- a/dlls/qcap/smartteefilter.c
+++ b/dlls/qcap/smartteefilter.c
@@ -62,10 +62,16 @@ static void smart_tee_destroy(struct strmbase_filter *iface)
     CoTaskMemFree(filter);
 }
 
+static HRESULT smart_tee_wait_state(struct strmbase_filter *iface, DWORD timeout)
+{
+    return iface->state == State_Paused ? VFW_S_CANT_CUE : S_OK;
+}
+
 static const struct strmbase_filter_ops filter_ops =
 {
     .filter_get_pin = smart_tee_get_pin,
     .filter_destroy = smart_tee_destroy,
+    .filter_wait_state = smart_tee_wait_state,
 };
 
 static HRESULT sink_query_accept(struct strmbase_pin *base, const AM_MEDIA_TYPE *pmt)
diff --git a/dlls/qcap/tests/smartteefilter.c b/dlls/qcap/tests/smartteefilter.c
index 2f8fa6c4b5e..f3a44c67c1f 100644
--- a/dlls/qcap/tests/smartteefilter.c
+++ b/dlls/qcap/tests/smartteefilter.c
@@ -2232,7 +2232,7 @@ static void test_unconnected_filter_state(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    todo_wine ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
+    ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
@@ -2246,7 +2246,7 @@ static void test_unconnected_filter_state(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    todo_wine ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
+    ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
From 3572a7f44004a9ebd16e2b1e8164b3477f0d5227 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Mon, 13 Jul 2020 19:08:44 +0200
Subject: [PATCH] amstream: Add AMMediaStream::JoinFilterGraph() tests.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 84 ++++++++++++++++++++++++++++++++++
 1 file changed, 84 insertions(+)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 2d9f3e35f26..a0876d62421 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -4328,6 +4328,89 @@ static void test_ammediastream_join_filter(void)
     check_ammediastream_join_filter(&CLSID_AMDirectDrawStream);
 }
 
+static void check_ammediastream_join_filter_graph(const MSPID *id)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IGraphBuilder *builder, *builder2;
+    IMediaStreamFilter *filter;
+    IAMMediaStream *stream;
+    IFilterGraph *graph;
+    FILTER_INFO info;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!!filter, "Expected non-null filter.\n");
+
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, id, 0, (IMediaStream **)&stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &builder);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!!builder, "Expected non-null graph.\n");
+    EXPECT_REF(builder, 4);
+
+    hr = IMediaStreamFilter_QueryFilterInfo(filter, &info);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(info.pGraph == (IFilterGraph *)builder, "Expected graph %p, got %p.\n", (IFilterGraph *)builder, info.pGraph);
+    EXPECT_REF(builder, 5);
+    IFilterGraph_Release(info.pGraph);
+    EXPECT_REF(builder, 4);
+
+    hr = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, &IID_IFilterGraph, (void **)&graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(builder, 4);
+    EXPECT_REF(graph, 1);
+
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IAMMediaStream_JoinFilterGraph(stream, NULL);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+    }
+
+    hr = IAMMediaStream_JoinFilterGraph(stream, graph);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(builder, 4);
+    EXPECT_REF(graph, 1);
+
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &builder2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(builder2 == builder, "Expected graph %p, got %p.\n", builder, builder2);
+    EXPECT_REF(builder, 5);
+    EXPECT_REF(graph, 1);
+    IGraphBuilder_Release(builder2);
+    EXPECT_REF(builder, 4);
+    EXPECT_REF(graph, 1);
+
+    hr = IMediaStreamFilter_QueryFilterInfo(filter, &info);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(info.pGraph == (IFilterGraph *)builder, "Expected graph %p, got %p.\n", (IFilterGraph *)builder, info.pGraph);
+    EXPECT_REF(builder, 5);
+    EXPECT_REF(graph, 1);
+    IFilterGraph_Release(info.pGraph);
+    EXPECT_REF(builder, 4);
+    EXPECT_REF(graph, 1);
+
+    ref = IFilterGraph_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(builder);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_ammediastream_join_filter_graph(void)
+{
+    check_ammediastream_join_filter_graph(&MSPID_PrimaryAudio);
+    check_ammediastream_join_filter_graph(&MSPID_PrimaryVideo);
+}
+
 void test_mediastreamfilter_get_state(void)
 {
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
@@ -5023,6 +5106,7 @@ START_TEST(amstream)
 
     test_ammediastream_join_am_multi_media_stream();
     test_ammediastream_join_filter();
+    test_ammediastream_join_filter_graph();
 
     test_mediastreamfilter_get_state();
     test_mediastreamfilter_stop_pause_run();
From c6b437284554a77c9510873c90cd1c7055e845f2 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Mon, 13 Jul 2020 19:08:45 +0200
Subject: [PATCH] amstream: Implement AMMediaStream::JoinFilterGraph.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    | 6 +++---
 dlls/amstream/ddrawstream.c    | 6 +++---
 dlls/amstream/tests/amstream.c | 2 +-
 3 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 60a2572b3ba..112891eeb74 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -593,11 +593,11 @@ static HRESULT WINAPI audio_IAMMediaStream_JoinFilter(IAMMediaStream *iface, IMe
 
 static HRESULT WINAPI audio_IAMMediaStream_JoinFilterGraph(IAMMediaStream *iface, IFilterGraph *filtergraph)
 {
-    struct audio_stream *This = impl_from_IAMMediaStream(iface);
+    struct audio_stream *stream = impl_from_IAMMediaStream(iface);
 
-    FIXME("(%p/%p)->(%p) stub!\n", This, iface, filtergraph);
+    TRACE("stream %p, filtergraph %p.\n", stream, filtergraph);
 
-    return S_FALSE;
+    return S_OK;
 }
 
 static const struct IAMMediaStreamVtbl audio_IAMMediaStream_vtbl =
diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 5530603f7aa..9f74eaf91ab 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -261,11 +261,11 @@ static HRESULT WINAPI ddraw_IAMMediaStream_JoinFilter(IAMMediaStream *iface, IMe
 
 static HRESULT WINAPI ddraw_IAMMediaStream_JoinFilterGraph(IAMMediaStream *iface, IFilterGraph *filtergraph)
 {
-    struct ddraw_stream *This = impl_from_IAMMediaStream(iface);
+    struct ddraw_stream *stream = impl_from_IAMMediaStream(iface);
 
-    FIXME("(%p/%p)->(%p) stub!\n", This, iface, filtergraph);
+    TRACE("stream %p, filtergraph %p.\n", stream, filtergraph);
 
-    return S_FALSE;
+    return S_OK;
 }
 
 static const struct IAMMediaStreamVtbl ddraw_IAMMediaStream_vtbl =
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index a0876d62421..a81cdba3f35 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -4371,7 +4371,7 @@ static void check_ammediastream_join_filter_graph(const MSPID *id)
     }
 
     hr = IAMMediaStream_JoinFilterGraph(stream, graph);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     EXPECT_REF(builder, 4);
     EXPECT_REF(graph, 1);
 
From 0bad9529996f18aed62469547d2fac79ad82173d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 14 Jul 2020 19:56:19 -0500
Subject: [PATCH] quartz: Add more tracing to state change methods.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 6a29b5d7484..e035b8f0ed1 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -1723,6 +1723,8 @@ static HRESULT WINAPI MediaControl_Run(IMediaControl *iface)
 {
     struct filter_graph *graph = impl_from_IMediaControl(iface);
 
+    TRACE("graph %p.\n", graph);
+
     return IMediaFilter_Run(&graph->IMediaFilter_iface, 0);
 }
 
@@ -1730,6 +1732,8 @@ static HRESULT WINAPI MediaControl_Pause(IMediaControl *iface)
 {
     struct filter_graph *graph = impl_from_IMediaControl(iface);
 
+    TRACE("graph %p.\n", graph);
+
     return IMediaFilter_Pause(&graph->IMediaFilter_iface);
 }
 
@@ -1737,6 +1741,8 @@ static HRESULT WINAPI MediaControl_Stop(IMediaControl *iface)
 {
     struct filter_graph *graph = impl_from_IMediaControl(iface);
 
+    TRACE("graph %p.\n", graph);
+
     return IMediaFilter_Stop(&graph->IMediaFilter_iface);
 }
 
@@ -1744,6 +1750,8 @@ static HRESULT WINAPI MediaControl_GetState(IMediaControl *iface, LONG timeout,
 {
     struct filter_graph *graph = impl_from_IMediaControl(iface);
 
+    TRACE("graph %p, timeout %u, state %p.\n", graph, timeout, state);
+
     if (timeout < 0) timeout = INFINITE;
 
     return IMediaFilter_GetState(&graph->IMediaFilter_iface, timeout, (FILTER_STATE *)state);
@@ -4951,6 +4959,7 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
     }
 
     LeaveCriticalSection(&graph->cs);
+    TRACE("Returning %#x, state %u.\n", hr, *state);
     return hr;
 }
 
From ac0eb57274b8ec8ebe30651fb87118ec504c45dc Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 14 Jul 2020 19:56:20 -0500
Subject: [PATCH] quartz: Don't sort the graph in IMediaFilter::GetState().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index e035b8f0ed1..5a10df9db2b 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -4933,8 +4933,6 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
 
     EnterCriticalSection(&graph->cs);
 
-    sort_filters(graph);
-
     *state = graph->state;
 
     LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
From 23ef26866338844f106f65d574a7d624729a5d78 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 14 Jul 2020 19:56:21 -0500
Subject: [PATCH] quartz/tests: Add more tests for asynchronous state change.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/filtergraph.c | 199 ++++++++++++++++++++++++++++++--
 1 file changed, 190 insertions(+), 9 deletions(-)

diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index de8e32034f8..c0076191a87 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -1173,7 +1173,7 @@ struct testfilter
     struct testpin *pins;
     unsigned int pin_count, enum_idx;
 
-    HRESULT state_hr, seek_hr;
+    HRESULT state_hr, GetState_hr, seek_hr;
 
     IAMFilterMiscFlags IAMFilterMiscFlags_iface;
     ULONG misc_flags;
@@ -1393,7 +1393,7 @@ static HRESULT WINAPI testfilter_GetState(IBaseFilter *iface, DWORD timeout, FIL
     if (winetest_debug > 1) trace("%p->GetState(%u)\n", filter, timeout);
 
     *state = filter->state;
-    return filter->state_hr;
+    return filter->GetState_hr;
 }
 
 static HRESULT WINAPI testfilter_SetSyncSource(IBaseFilter *iface, IReferenceClock *clock)
@@ -3199,6 +3199,7 @@ static void test_filter_state(void)
     REFERENCE_TIME start_time;
     IReferenceClock *clock;
     IMediaControl *control;
+    FILTER_STATE mf_state;
     IMediaFilter *filter;
     OAFilterState state;
     HRESULT hr;
@@ -3402,33 +3403,213 @@ todo_wine
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
 
+    /* Test asynchronous state change. */
+
     sink.state_hr = S_FALSE;
+    sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaControl_Pause(control);
     ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
-    sink.state_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaControl_GetState(control, 0, &state);
     ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
-    sink.state_hr = VFW_S_CANT_CUE;
+    sink.state_hr = sink.GetState_hr = S_OK;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
+
+    sink.state_hr = S_FALSE;
+    sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
+    hr = IMediaControl_Stop(control);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
+
+    sink.state_hr = sink.GetState_hr = S_OK;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
+
+    /* Renderers are expected to block completing a state change into paused
+     * until they receive a sample. Because the graph can transition from
+     * stopped -> paused -> running in one call, which itself needs to be
+     * asynchronous, it actually waits on a separate thread for all filters
+     * to be ready, then calls IMediaFilter::Run() once they are.
+     *
+     * However, IMediaControl::GetState() will return VFW_S_STATE_INTERMEDIATE
+     * if filters haven't caught up to the graph yet. To make matters worse, it
+     * doesn't take the above into account, meaning that it'll gladly return
+     * VFW_S_STATE_INTERMEDIATE even if passed an infinite timeout. */
+
+    sink.state_hr = S_FALSE;
+    sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
+    hr = IMediaControl_Run(control);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
+    todo_wine ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
+    todo_wine ok(source.state == State_Paused, "Got state %u.\n", source.state);
+
+    hr = IMediaControl_Run(control);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
+    todo_wine ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
+    todo_wine ok(source.state == State_Paused, "Got state %u.\n", source.state);
+
+    sink.state_hr = sink.GetState_hr = S_OK;
+
+    while ((hr = IMediaControl_GetState(control, INFINITE, &state)) == VFW_S_STATE_INTERMEDIATE)
+    {
+        ok(state == State_Running, "Got state %u.\n", state);
+        todo_wine ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
+        todo_wine ok(source.state == State_Paused, "Got state %u.\n", source.state);
+        Sleep(10);
+    }
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
+    ok(sink.state == State_Running, "Got state %u.\n", sink.state);
+    ok(source.state == State_Running, "Got state %u.\n", source.state);
+
+    /* The above logic does not apply to the running -> paused -> stopped
+     * transition. The filter graph will stop a filter regardless of whether
+     * it's completely paused. Inasmuch as stopping the filter is like flushing
+     * it—i.e. it has to succeed—this makes sense. */
+
+    sink.state_hr = S_FALSE;
+    sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
+    hr = IMediaControl_Stop(control);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(sink.state == State_Stopped, "Got state %u.\n", sink.state);
+    ok(source.state == State_Stopped, "Got state %u.\n", source.state);
+
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
+
+    hr = IMediaControl_Stop(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    sink.state_hr = sink.GetState_hr = S_OK;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
+
+    /* Try an asynchronous stopped->paused->running transition, but pause or
+     * stop the graph before our filter is completely paused. */
+
+    sink.state_hr = S_FALSE;
+    sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
+    hr = IMediaControl_Run(control);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_Pause(control);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    sink.state_hr = sink.GetState_hr = S_OK;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
+    ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
+    ok(source.state == State_Paused, "Got state %u.\n", source.state);
+
+    hr = IMediaControl_Stop(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    sink.state_hr = S_FALSE;
+    sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
+    hr = IMediaControl_Run(control);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_Stop(control);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(sink.state == State_Stopped, "Got state %u.\n", sink.state);
+    ok(source.state == State_Stopped, "Got state %u.\n", source.state);
+
+    sink.state_hr = sink.GetState_hr = S_OK;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
+    ok(sink.state == State_Stopped, "Got state %u.\n", sink.state);
+    ok(source.state == State_Stopped, "Got state %u.\n", source.state);
+
+    /* This logic doesn't apply when using IMediaFilter methods directly. */
+
+    sink.state_hr = S_FALSE;
+    sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
+    hr = IMediaFilter_Run(filter, 0);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    hr = IMediaFilter_GetState(filter, 0, &mf_state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(mf_state == State_Running, "Got state %u.\n", mf_state);
+    ok(sink.state == State_Running, "Got state %u.\n", sink.state);
+    ok(source.state == State_Running, "Got state %u.\n", source.state);
+
+    sink.state_hr = sink.GetState_hr = S_OK;
+    hr = IMediaFilter_GetState(filter, 0, &mf_state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mf_state == State_Running, "Got state %u.\n", mf_state);
+    ok(sink.state == State_Running, "Got state %u.\n", sink.state);
+    ok(source.state == State_Running, "Got state %u.\n", source.state);
+
+    hr = IMediaFilter_Stop(filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(sink.state == State_Stopped, "Got state %u.\n", sink.state);
+    ok(source.state == State_Stopped, "Got state %u.\n", source.state);
+
+    /* Test VFW_S_CANT_CUE. */
+
+    sink.GetState_hr = VFW_S_CANT_CUE;
+    hr = IMediaControl_Pause(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
     hr = IMediaControl_GetState(control, 0, &state);
     ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
-    sink.state_hr = VFW_S_STATE_INTERMEDIATE;
-    source.state_hr = VFW_S_CANT_CUE;
+    sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
+    source.GetState_hr = VFW_S_CANT_CUE;
     hr = IMediaControl_GetState(control, 0, &state);
     ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
-    sink.state_hr = VFW_S_CANT_CUE;
-    source.state_hr = VFW_S_STATE_INTERMEDIATE;
+    sink.GetState_hr = VFW_S_CANT_CUE;
+    source.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaControl_GetState(control, 0, &state);
     ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
-    sink.state_hr = source.state_hr = S_OK;
+    sink.GetState_hr = source.GetState_hr = S_OK;
+
+    hr = IMediaControl_Stop(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    sink.state_hr = S_FALSE;
+    sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
+    source.GetState_hr = VFW_S_CANT_CUE;
+    hr = IMediaControl_Run(control);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(sink.state == State_Running, "Got state %u.\n", sink.state);
+    ok(source.state == State_Running, "Got state %u.\n", source.state);
+
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
+    ok(sink.state == State_Running, "Got state %u.\n", sink.state);
+    ok(source.state == State_Running, "Got state %u.\n", source.state);
+
+    sink.state_hr = sink.GetState_hr = source.GetState_hr = S_OK;
+
+    hr = IMediaControl_Stop(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Destroying the graph while it's running stops all filters. */
 
From df8eabc00a0807cf89f528bb6bce10427c300407 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 14 Jul 2020 19:56:22 -0500
Subject: [PATCH] quartz: Poll in IMediaFilter::GetState().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c | 55 +++++++++++++++++++++++++--------------
 1 file changed, 36 insertions(+), 19 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 5a10df9db2b..17963c2b757 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -4923,40 +4923,57 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
 {
     struct filter_graph *graph = impl_from_IMediaFilter(iface);
     DWORD end = GetTickCount() + timeout;
-    HRESULT hr = S_OK, filter_hr;
-    struct filter *filter;
+    HRESULT hr;
 
     TRACE("graph %p, timeout %u, state %p.\n", graph, timeout, state);
 
     if (!state)
         return E_POINTER;
 
-    EnterCriticalSection(&graph->cs);
+    /* Thread safety is a little tricky here. GetState() shouldn't block other
+     * functions from being called on the filter graph. However, we can't just
+     * call IBaseFilter::GetState() in one loop and drop the lock on every
+     * iteration, since the filter list might change beneath us. So instead we
+     * do what native does, and poll for it every 10 ms. */
 
+    EnterCriticalSection(&graph->cs);
     *state = graph->state;
 
-    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
+    for (;;)
     {
+        IBaseFilter *async_filter = NULL;
         FILTER_STATE filter_state;
-        int wait;
+        struct filter *filter;
 
-        if (timeout == INFINITE)
-            wait = INFINITE;
-        else if (!timeout)
-            wait = 0;
-        else
-            wait = max(end - GetTickCount(), 0);
+        hr = S_OK;
 
-        filter_hr = IBaseFilter_GetState(filter->filter, wait, &filter_state);
-        if (hr == S_OK && filter_hr == VFW_S_STATE_INTERMEDIATE)
-            hr = VFW_S_STATE_INTERMEDIATE;
-        else if (filter_hr != S_OK && filter_hr != VFW_S_STATE_INTERMEDIATE)
-            hr = filter_hr;
-        if (filter_state != graph->state)
-            ERR("Filter %p reported incorrect state %u.\n", filter->filter, filter_state);
+        LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
+        {
+            HRESULT filter_hr = IBaseFilter_GetState(filter->filter, 0, &filter_state);
+
+            TRACE("Filter %p returned hr %#x, state %u.\n", filter->filter, filter_hr, filter_state);
+
+            if (filter_hr == VFW_S_STATE_INTERMEDIATE)
+                async_filter = filter->filter;
+
+            if (hr == S_OK && filter_hr == VFW_S_STATE_INTERMEDIATE)
+                hr = VFW_S_STATE_INTERMEDIATE;
+            else if (filter_hr != S_OK && filter_hr != VFW_S_STATE_INTERMEDIATE)
+                hr = filter_hr;
+            if (filter_state != graph->state)
+                ERR("Filter %p reported incorrect state %u.\n", filter->filter, filter_state);
+        }
+
+        LeaveCriticalSection(&graph->cs);
+
+        if (hr != VFW_S_STATE_INTERMEDIATE || (timeout != INFINITE && GetTickCount() >= end))
+            break;
+
+        IBaseFilter_GetState(async_filter, 10, &filter_state);
+
+        EnterCriticalSection(&graph->cs);
     }
 
-    LeaveCriticalSection(&graph->cs);
     TRACE("Returning %#x, state %u.\n", hr, *state);
     return hr;
 }
From 735c8272f5ad0ceeea726e902a3df17c9d3853c7 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 14 Jul 2020 19:56:23 -0500
Subject: [PATCH] quartz: Increase the initial streaming delay to 200 ms.

This matches native, and gstreamer can be slow enough to start up that a bit of
extra time would be useful.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 17963c2b757..ff0f159c131 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -4903,7 +4903,7 @@ static HRESULT WINAPI MediaFilter_Run(IMediaFilter *iface, REFERENCE_TIME start)
         IReferenceClock_GetTime(graph->refClock, &graph->stream_start);
         stream_start = graph->stream_start - graph->stream_elapsed;
         if (graph->state == State_Stopped)
-            stream_start += 500000;
+            stream_start += 200 * 10000;
     }
 
     LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
From a8a644c1b8a0efff477405cc981f8977ddc8e88d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 14 Jul 2020 19:56:24 -0500
Subject: [PATCH] quartz: Always apply the 200 ms delay to presentation time.

This matches native (actually, native goes one step further and increases the
delay by 100 ms every time the filter is paused). Generally this makes sense,
too, as otherwise a graph that is paused and then resumed will suddenly find
itself 200 ms behind.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index ff0f159c131..7319345931e 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -4902,8 +4902,9 @@ static HRESULT WINAPI MediaFilter_Run(IMediaFilter *iface, REFERENCE_TIME start)
     {
         IReferenceClock_GetTime(graph->refClock, &graph->stream_start);
         stream_start = graph->stream_start - graph->stream_elapsed;
-        if (graph->state == State_Stopped)
-            stream_start += 200 * 10000;
+        /* Delay presentation time by 200 ms, to give filters time to
+         * initialize. */
+        stream_start += 200 * 10000;
     }
 
     LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
From 9dd5aa17a0d1e53299599eb0f79800feb70cd8d6 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 14 Jul 2020 19:56:25 -0500
Subject: [PATCH] quartz: Return an error code if a filter reports an incorrect
 state.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       |  9 +++++++
 dlls/quartz/tests/filtergraph.c | 45 +++++++++++++++++++++++++++++++++
 2 files changed, 54 insertions(+)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 7319345931e..273cd021109 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -4961,6 +4961,15 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
                 hr = VFW_S_STATE_INTERMEDIATE;
             else if (filter_hr != S_OK && filter_hr != VFW_S_STATE_INTERMEDIATE)
                 hr = filter_hr;
+
+            if (hr == S_OK && filter_state == State_Paused && graph->state != State_Paused)
+            {
+                async_filter = filter->filter;
+                hr = VFW_S_STATE_INTERMEDIATE;
+            }
+            else if (filter_state != graph->state && filter_state != State_Paused)
+                hr = E_FAIL;
+
             if (filter_state != graph->state)
                 ERR("Filter %p reported incorrect state %u.\n", filter->filter, filter_state);
         }
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index c0076191a87..99120133bb6 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -3254,6 +3254,21 @@ static void test_filter_state(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Paused);
 
+    sink.state = State_Stopped;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
+
+    sink.state = State_Running;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
+
+    sink.state = State_Paused;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
+
     hr = IMediaControl_Stop(control);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
@@ -3262,10 +3277,40 @@ static void test_filter_state(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
 
+    sink.state = State_Stopped;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
+
+    sink.state = State_Paused;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
+
+    sink.state = State_Running;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
+
     hr = IMediaControl_Stop(control);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
 
+    sink.state = State_Running;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
+
+    sink.state = State_Paused;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
+
+    sink.state = State_Stopped;
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
+
     hr = IMediaControl_Pause(control);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Paused);
From 114832224fc5babd1417562dbd64d489fabe1e01 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 14 Jul 2020 19:56:26 -0500
Subject: [PATCH] quartz: Run the graph asynchronously if necessary.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c         | 236 +++++++++++++++++++++++++-----
 dlls/quartz/tests/filtergraph.c   |  12 +-
 dlls/quartz/tests/videorenderer.c |   6 +-
 dlls/quartz/tests/vmr9.c          |   6 +-
 4 files changed, 208 insertions(+), 52 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 273cd021109..22d7f7b4450 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -191,6 +191,9 @@ struct filter_graph
     struct list filters;
     unsigned int name_index;
 
+    OAFilterState state;
+    TP_WORK *async_run_work;
+
     IReferenceClock *refClock;
     IBaseFilter *refClockProvider;
     EventsQueue evqueue;
@@ -202,7 +205,6 @@ struct filter_graph
     int HandleEcComplete;
     int HandleEcRepaint;
     int HandleEcClockChanged;
-    OAFilterState state;
     CRITICAL_SECTION cs;
     ITF_CACHE_ENTRY ItfCacheEntries[MAX_ITF_CACHE_ENTRIES];
     int nItfCacheEntries;
@@ -219,6 +221,8 @@ struct filter_graph
     REFERENCE_TIME stream_start, stream_elapsed;
 
     LONGLONG current_pos;
+
+    unsigned int needs_async_run : 1;
 };
 
 struct enum_filters
@@ -1719,13 +1723,179 @@ static HRESULT WINAPI MediaControl_Invoke(IMediaControl *iface, DISPID dispIdMem
     return S_OK;
 }
 
+static void update_render_count(struct filter_graph *graph)
+{
+    /* Some filters (e.g. MediaStreamFilter) can become renderers when they are
+     * already in the graph. */
+    struct filter *filter;
+    graph->nRenderers = 0;
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
+    {
+        if (is_renderer(filter))
+            ++graph->nRenderers;
+    }
+}
+
+/* Perform the paused -> running transition. The caller must hold graph->cs. */
+static HRESULT graph_start(struct filter_graph *graph, REFERENCE_TIME stream_start)
+{
+    struct filter *filter;
+    HRESULT hr = S_OK;
+
+    graph->EcCompleteCount = 0;
+    update_render_count(graph);
+
+    if (graph->defaultclock && !graph->refClock)
+        IFilterGraph2_SetDefaultSyncSource(&graph->IFilterGraph2_iface);
+
+    if (!stream_start && graph->refClock)
+    {
+        IReferenceClock_GetTime(graph->refClock, &graph->stream_start);
+        stream_start = graph->stream_start - graph->stream_elapsed;
+        /* Delay presentation time by 200 ms, to give filters time to
+         * initialize. */
+        stream_start += 200 * 10000;
+    }
+
+    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
+    {
+        HRESULT filter_hr = IBaseFilter_Run(filter->filter, stream_start);
+        if (hr == S_OK)
+            hr = filter_hr;
+        TRACE("Filter %p returned %#x.\n", filter->filter, filter_hr);
+    }
+
+    if (FAILED(hr))
+        WARN("Failed to start stream, hr %#x.\n", hr);
+
+    return hr;
+}
+
+static void CALLBACK async_run_cb(TP_CALLBACK_INSTANCE *instance, void *context, TP_WORK *work)
+{
+    struct filter_graph *graph = context;
+    struct filter *filter;
+    FILTER_STATE state;
+    HRESULT hr;
+
+    TRACE("Performing asynchronous state change.\n");
+
+    /* We can't just call GetState(), since that will return State_Running and
+     * VFW_S_STATE_INTERMEDIATE regardless of whether we're done pausing yet.
+     * Instead replicate it here. */
+
+    for (;;)
+    {
+        IBaseFilter *async_filter = NULL;
+
+        hr = S_OK;
+
+        EnterCriticalSection(&graph->cs);
+
+        if (!graph->needs_async_run)
+            break;
+
+        LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
+        {
+            hr = IBaseFilter_GetState(filter->filter, 0, &state);
+
+            if (hr == VFW_S_STATE_INTERMEDIATE)
+                async_filter = filter->filter;
+
+            if (SUCCEEDED(hr) && state != State_Paused)
+                ERR("Filter %p reported incorrect state %u.\n", filter->filter, state);
+
+            if (hr != S_OK)
+                break;
+        }
+
+        if (hr != VFW_S_STATE_INTERMEDIATE)
+            break;
+
+        LeaveCriticalSection(&graph->cs);
+
+        IBaseFilter_GetState(async_filter, 10, &state);
+    }
+
+    if (hr == S_OK && graph->needs_async_run)
+    {
+        sort_filters(graph);
+        graph_start(graph, 0);
+        graph->needs_async_run = 0;
+    }
+
+    LeaveCriticalSection(&graph->cs);
+    IUnknown_Release(graph->outer_unk);
+}
+
 static HRESULT WINAPI MediaControl_Run(IMediaControl *iface)
 {
     struct filter_graph *graph = impl_from_IMediaControl(iface);
+    BOOL need_async_run = TRUE;
+    struct filter *filter;
+    FILTER_STATE state;
+    HRESULT hr = S_OK;
 
     TRACE("graph %p.\n", graph);
 
-    return IMediaFilter_Run(&graph->IMediaFilter_iface, 0);
+    EnterCriticalSection(&graph->cs);
+
+    if (graph->state == State_Running)
+    {
+        LeaveCriticalSection(&graph->cs);
+        return S_OK;
+    }
+
+    sort_filters(graph);
+    update_render_count(graph);
+
+    if (graph->state == State_Stopped)
+    {
+        if (graph->defaultclock && !graph->refClock)
+            IFilterGraph2_SetDefaultSyncSource(&graph->IFilterGraph2_iface);
+
+        LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
+        {
+            HRESULT filter_hr = IBaseFilter_Pause(filter->filter);
+            if (hr == S_OK)
+                hr = filter_hr;
+            TRACE("Filter %p returned %#x.\n", filter->filter, filter_hr);
+
+            /* If a filter returns VFW_S_CANT_CUE, we shouldn't wait for a
+             * paused state. */
+            filter_hr = IBaseFilter_GetState(filter->filter, 0, &state);
+            if (filter_hr != S_OK && filter_hr != VFW_S_STATE_INTERMEDIATE)
+                need_async_run = FALSE;
+        }
+
+        if (FAILED(hr))
+        {
+            LeaveCriticalSection(&graph->cs);
+            WARN("Failed to pause, hr %#x.\n", hr);
+            return hr;
+        }
+    }
+
+    graph->state = State_Running;
+
+    if (SUCCEEDED(hr))
+    {
+        if (hr != S_OK && need_async_run)
+        {
+            if (!graph->async_run_work)
+                graph->async_run_work = CreateThreadpoolWork(async_run_cb, graph, NULL);
+            graph->needs_async_run = 1;
+            IUnknown_AddRef(graph->outer_unk);
+            SubmitThreadpoolWork(graph->async_run_work);
+        }
+        else
+        {
+            graph_start(graph, 0);
+        }
+    }
+
+    LeaveCriticalSection(&graph->cs);
+    return hr;
 }
 
 static HRESULT WINAPI MediaControl_Pause(IMediaControl *iface)
@@ -4778,6 +4948,7 @@ static HRESULT WINAPI MediaFilter_Stop(IMediaFilter *iface)
     struct filter_graph *graph = impl_from_IMediaFilter(iface);
     HRESULT hr = S_OK, filter_hr;
     struct filter *filter;
+    TP_WORK *work;
 
     TRACE("graph %p.\n", graph);
 
@@ -4809,26 +4980,20 @@ static HRESULT WINAPI MediaFilter_Stop(IMediaFilter *iface)
     }
 
     graph->state = State_Stopped;
+    graph->needs_async_run = 0;
+    work = graph->async_run_work;
 
     /* Update the current position, probably to synchronize multiple streams. */
     IMediaSeeking_SetPositions(&graph->IMediaSeeking_iface, &graph->current_pos,
             AM_SEEKING_AbsolutePositioning, NULL, AM_SEEKING_NoPositioning);
 
     LeaveCriticalSection(&graph->cs);
-    return hr;
-}
 
-static void update_render_count(struct filter_graph *graph)
-{
-    /* Some filters (e.g. MediaStreamFilter) can become renderers when they are
-     * already in the graph. */
-    struct filter *filter;
-    graph->nRenderers = 0;
-    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
-    {
-        if (is_renderer(filter))
-            ++graph->nRenderers;
-    }
+    /* Don't cancel the callback; it's holding a reference to the graph. */
+    if (work)
+        WaitForThreadpoolWorkCallbacks(work, FALSE);
+
+    return hr;
 }
 
 static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
@@ -4836,6 +5001,7 @@ static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
     struct filter_graph *graph = impl_from_IMediaFilter(iface);
     HRESULT hr = S_OK, filter_hr;
     struct filter *filter;
+    TP_WORK *work;
 
     TRACE("graph %p.\n", graph);
 
@@ -4869,17 +5035,22 @@ static HRESULT WINAPI MediaFilter_Pause(IMediaFilter *iface)
     }
 
     graph->state = State_Paused;
+    graph->needs_async_run = 0;
+    work = graph->async_run_work;
 
     LeaveCriticalSection(&graph->cs);
+
+    /* Don't cancel the callback; it's holding a reference to the graph. */
+    if (work)
+        WaitForThreadpoolWorkCallbacks(work, FALSE);
+
     return hr;
 }
 
 static HRESULT WINAPI MediaFilter_Run(IMediaFilter *iface, REFERENCE_TIME start)
 {
     struct filter_graph *graph = impl_from_IMediaFilter(iface);
-    REFERENCE_TIME stream_start = start;
-    HRESULT hr = S_OK, filter_hr;
-    struct filter *filter;
+    HRESULT hr;
 
     TRACE("graph %p, start %s.\n", graph, debugstr_time(start));
 
@@ -4890,31 +5061,13 @@ static HRESULT WINAPI MediaFilter_Run(IMediaFilter *iface, REFERENCE_TIME start)
         LeaveCriticalSection(&graph->cs);
         return S_OK;
     }
-    graph->EcCompleteCount = 0;
 
     sort_filters(graph);
-    update_render_count(graph);
-
-    if (graph->defaultclock && !graph->refClock)
-        IFilterGraph2_SetDefaultSyncSource(&graph->IFilterGraph2_iface);
-
-    if (!start && graph->refClock)
-    {
-        IReferenceClock_GetTime(graph->refClock, &graph->stream_start);
-        stream_start = graph->stream_start - graph->stream_elapsed;
-        /* Delay presentation time by 200 ms, to give filters time to
-         * initialize. */
-        stream_start += 200 * 10000;
-    }
 
-    LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
-    {
-        filter_hr = IBaseFilter_Run(filter->filter, stream_start);
-        if (hr == S_OK)
-            hr = filter_hr;
-    }
+    hr = graph_start(graph, start);
 
     graph->state = State_Running;
+    graph->needs_async_run = 0;
 
     LeaveCriticalSection(&graph->cs);
     return hr;
@@ -4924,6 +5077,7 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
 {
     struct filter_graph *graph = impl_from_IMediaFilter(iface);
     DWORD end = GetTickCount() + timeout;
+    FILTER_STATE expect_state;
     HRESULT hr;
 
     TRACE("graph %p, timeout %u, state %p.\n", graph, timeout, state);
@@ -4939,6 +5093,7 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
 
     EnterCriticalSection(&graph->cs);
     *state = graph->state;
+    expect_state = graph->needs_async_run ? State_Paused : graph->state;
 
     for (;;)
     {
@@ -4970,8 +5125,9 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
             else if (filter_state != graph->state && filter_state != State_Paused)
                 hr = E_FAIL;
 
-            if (filter_state != graph->state)
-                ERR("Filter %p reported incorrect state %u.\n", filter->filter, filter_state);
+            if (filter_state != expect_state)
+                ERR("Filter %p reported incorrect state %u (expected %u).\n",
+                        filter->filter, filter_state, expect_state);
         }
 
         LeaveCriticalSection(&graph->cs);
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 99120133bb6..0c627aaeafb 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -3497,8 +3497,8 @@ todo_wine
     hr = IMediaControl_GetState(control, 0, &state);
     ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
-    todo_wine ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
-    todo_wine ok(source.state == State_Paused, "Got state %u.\n", source.state);
+    ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
+    ok(source.state == State_Paused, "Got state %u.\n", source.state);
 
     hr = IMediaControl_Run(control);
     todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
@@ -3506,16 +3506,16 @@ todo_wine
     hr = IMediaControl_GetState(control, 0, &state);
     ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
-    todo_wine ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
-    todo_wine ok(source.state == State_Paused, "Got state %u.\n", source.state);
+    ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
+    ok(source.state == State_Paused, "Got state %u.\n", source.state);
 
     sink.state_hr = sink.GetState_hr = S_OK;
 
     while ((hr = IMediaControl_GetState(control, INFINITE, &state)) == VFW_S_STATE_INTERMEDIATE)
     {
         ok(state == State_Running, "Got state %u.\n", state);
-        todo_wine ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
-        todo_wine ok(source.state == State_Paused, "Got state %u.\n", source.state);
+        ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
+        ok(source.state == State_Paused, "Got state %u.\n", source.state);
         Sleep(10);
     }
     ok(hr == S_OK, "Got hr %#x.\n", hr);
diff --git a/dlls/quartz/tests/videorenderer.c b/dlls/quartz/tests/videorenderer.c
index b157700a92b..4ae320e0225 100644
--- a/dlls/quartz/tests/videorenderer.c
+++ b/dlls/quartz/tests/videorenderer.c
@@ -1172,7 +1172,7 @@ static void test_eos(IPin *pin, IMemInputPin *input, IFilterGraph2 *graph)
      * done rendering. */
 
     hr = IMediaControl_Run(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
@@ -1195,7 +1195,7 @@ static void test_eos(IPin *pin, IMemInputPin *input, IFilterGraph2 *graph)
     /* Test sending EOS while flushing. */
 
     hr = IMediaControl_Run(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
@@ -1214,7 +1214,7 @@ static void test_eos(IPin *pin, IMemInputPin *input, IFilterGraph2 *graph)
     /* Test sending EOS and then flushing or stopping. */
 
     hr = IMediaControl_Run(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index e953c05dd1e..cd4df58f791 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -1308,7 +1308,7 @@ static void test_eos(IPin *pin, IMemInputPin *input, IMediaControl *control)
 
     commit_allocator(input);
     hr = IMediaControl_Run(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
@@ -1332,7 +1332,7 @@ static void test_eos(IPin *pin, IMemInputPin *input, IMediaControl *control)
 
     commit_allocator(input);
     hr = IMediaControl_Run(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
@@ -1352,7 +1352,7 @@ static void test_eos(IPin *pin, IMemInputPin *input, IMediaControl *control)
 
     commit_allocator(input);
     hr = IMediaControl_Run(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
From 88d2afb79cc416108179d5f44b52f158c8f882a0 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 15 Jul 2020 22:57:14 -0500
Subject: [PATCH] quartz/tests: Test previous filter states.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/filtergraph.c | 22 +++++++++++++++++++---
 1 file changed, 19 insertions(+), 3 deletions(-)

diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 0c627aaeafb..bd6562b0ed5 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -1166,14 +1166,15 @@ struct testfilter
     IFilterGraph *graph;
     WCHAR *name;
     IReferenceClock *clock;
-    FILTER_STATE state;
-    REFERENCE_TIME start_time;
 
     IEnumPins IEnumPins_iface;
     struct testpin *pins;
     unsigned int pin_count, enum_idx;
 
+    FILTER_STATE state;
+    REFERENCE_TIME start_time;
     HRESULT state_hr, GetState_hr, seek_hr;
+    FILTER_STATE expect_stop_prev, expect_run_prev;
 
     IAMFilterMiscFlags IAMFilterMiscFlags_iface;
     ULONG misc_flags;
@@ -1358,6 +1359,10 @@ static HRESULT WINAPI testfilter_Stop(IBaseFilter *iface)
     struct testfilter *filter = impl_from_IBaseFilter(iface);
     if (winetest_debug > 1) trace("%p->Stop()\n", filter);
 
+    todo_wine_if (filter->expect_stop_prev == State_Running)
+        ok(filter->state == filter->expect_stop_prev, "Expected previous state %#x, got %#x.\n",
+                filter->expect_stop_prev, filter->state);
+
     check_state_transition(filter, State_Stopped);
 
     filter->state = State_Stopped;
@@ -1380,6 +1385,9 @@ static HRESULT WINAPI testfilter_Run(IBaseFilter *iface, REFERENCE_TIME start)
     struct testfilter *filter = impl_from_IBaseFilter(iface);
     if (winetest_debug > 1) trace("%p->Run(%s)\n", filter, wine_dbgstr_longlong(start));
 
+    ok(filter->state == filter->expect_run_prev, "Expected previous state %#x, got %#x.\n",
+            filter->expect_run_prev, filter->state);
+
     check_state_transition(filter, State_Running);
 
     filter->state = State_Running;
@@ -1831,7 +1839,9 @@ static void testfilter_init(struct testfilter *filter, struct testpin *pins, int
     filter->pin_count = pin_count;
     for (i = 0; i < pin_count; i++)
         pins[i].filter = &filter->IBaseFilter_iface;
+
     filter->state = State_Stopped;
+    filter->expect_stop_prev = filter->expect_run_prev = State_Paused;
 }
 
 static HRESULT WINAPI testfilter_cf_QueryInterface(IClassFactory *iface, REFIID iid, void **out)
@@ -3383,6 +3393,7 @@ static void test_filter_state(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
 
+    source.expect_run_prev = sink.expect_run_prev = State_Stopped;
     hr = IReferenceClock_GetTime(clock, &start_time);
     ok(SUCCEEDED(hr), "Got hr %#x.\n", hr);
     hr = IMediaFilter_Run(filter, 0);
@@ -3400,6 +3411,7 @@ static void test_filter_state(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Paused);
 
+    source.expect_run_prev = sink.expect_run_prev = State_Paused;
     hr = IMediaFilter_Run(filter, 0);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
@@ -3587,6 +3599,7 @@ todo_wine
 
     /* This logic doesn't apply when using IMediaFilter methods directly. */
 
+    source.expect_run_prev = sink.expect_run_prev = State_Stopped;
     sink.state_hr = S_FALSE;
     sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaFilter_Run(filter, 0);
@@ -3610,6 +3623,8 @@ todo_wine
     ok(sink.state == State_Stopped, "Got state %u.\n", sink.state);
     ok(source.state == State_Stopped, "Got state %u.\n", source.state);
 
+    source.expect_run_prev = sink.expect_run_prev = State_Paused;
+
     /* Test VFW_S_CANT_CUE. */
 
     sink.GetState_hr = VFW_S_CANT_CUE;
@@ -3658,7 +3673,7 @@ todo_wine
 
     /* Destroying the graph while it's running stops all filters. */
 
-    hr = IMediaFilter_Run(filter, 0);
+    hr = IMediaControl_Run(control);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
 todo_wine
@@ -3667,6 +3682,7 @@ todo_wine
     ok(sink.start_time == source.start_time, "Expected time %s, got %s.\n",
         wine_dbgstr_longlong(source.start_time), wine_dbgstr_longlong(sink.start_time));
 
+    source.expect_stop_prev = sink.expect_stop_prev = State_Running;
     IMediaFilter_Release(filter);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
From 1af01ac91717223adf09c4b61d7d0217ec0ccec5 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 15 Jul 2020 22:57:15 -0500
Subject: [PATCH] quartz/tests: Add some tests for media types for the
 DirectSound renderer.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/Makefile.in    |   2 +-
 dlls/quartz/tests/dsoundrender.c | 118 +++++++++++++++++++++++++++++++
 2 files changed, 119 insertions(+), 1 deletion(-)

diff --git a/dlls/quartz/tests/Makefile.in b/dlls/quartz/tests/Makefile.in
index 7652baf274e..b4a372d4d3e 100644
--- a/dlls/quartz/tests/Makefile.in
+++ b/dlls/quartz/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = quartz.dll
-IMPORTS   = strmbase advapi32 d3d9 msdmo msvfw32 ole32 oleaut32 user32 uuid
+IMPORTS   = strmbase advapi32 d3d9 dsound msdmo msvfw32 ole32 oleaut32 user32 uuid
 
 C_SRCS = \
 	acmwrapper.c \
diff --git a/dlls/quartz/tests/dsoundrender.c b/dlls/quartz/tests/dsoundrender.c
index ecff4b7c882..3add14d0437 100644
--- a/dlls/quartz/tests/dsoundrender.c
+++ b/dlls/quartz/tests/dsoundrender.c
@@ -24,6 +24,7 @@
 #include "initguid.h"
 #include "dsound.h"
 #include "amaudio.h"
+#include "mmreg.h"
 #include "wine/test.h"
 
 static const WCHAR sink_id[] = L"Audio Input pin (rendered)";
@@ -685,6 +686,122 @@ static void test_unconnected_filter_state(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static HRESULT does_dsound_support_format(WAVEFORMATEX *format)
+{
+    const DSBUFFERDESC desc =
+    {
+        .dwSize = sizeof(DSBUFFERDESC),
+        .dwBufferBytes = format->nAvgBytesPerSec,
+        .lpwfxFormat = format,
+    };
+    IDirectSoundBuffer *buffer;
+    IDirectSound *dsound;
+    HRESULT hr;
+
+    hr = DirectSoundCreate(NULL, &dsound, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectSound_CreateSoundBuffer(dsound, &desc, &buffer, NULL);
+    if (hr == S_OK)
+        IDirectSoundBuffer_Release(buffer);
+    IDirectSound_Release(dsound);
+
+    return hr == S_OK ? S_OK : S_FALSE;
+}
+
+static void test_media_types(void)
+{
+    IBaseFilter *filter = create_dsound_render();
+    AM_MEDIA_TYPE *mt, req_mt = {{0}};
+    IEnumMediaTypes *enummt;
+    WAVEFORMATEX wfx = {0};
+    HRESULT hr, expect_hr;
+    unsigned int i, j;
+    WORD channels;
+    ULONG ref;
+    IPin *pin;
+
+    static const DWORD sample_rates[] = {8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 96000};
+
+    static const struct
+    {
+        WORD tag;
+        WORD depth;
+    } formats[] =
+    {
+        {WAVE_FORMAT_PCM, 8},
+        {WAVE_FORMAT_PCM, 16},
+        {WAVE_FORMAT_PCM, 24},
+        {WAVE_FORMAT_PCM, 32},
+        {WAVE_FORMAT_IEEE_FLOAT, 32},
+        {WAVE_FORMAT_IEEE_FLOAT, 64},
+    };
+
+    IBaseFilter_FindPin(filter, sink_id, &pin);
+
+    hr = IPin_EnumMediaTypes(pin, &enummt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IEnumMediaTypes_Next(enummt, 1, &mt, NULL);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr == S_OK)
+    {
+        ok(IsEqualGUID(&mt->majortype, &MEDIATYPE_Audio), "Got major type %s.\n", wine_dbgstr_guid(&mt->majortype));
+        ok(IsEqualGUID(&mt->subtype, &GUID_NULL), "Got subtype %s.\n", wine_dbgstr_guid(&mt->subtype));
+        ok(mt->bFixedSizeSamples == TRUE, "Got fixed size %d.\n", mt->bFixedSizeSamples);
+        ok(!mt->bTemporalCompression, "Got temporal compression %d.\n", mt->bTemporalCompression);
+        ok(mt->lSampleSize == 1, "Got sample size %u.\n", mt->lSampleSize);
+        ok(IsEqualGUID(&mt->formattype, &GUID_NULL), "Got format type %s.\n", wine_dbgstr_guid(&mt->formattype));
+        ok(!mt->pUnk, "Got pUnk %p.\n", mt->pUnk);
+        ok(!mt->cbFormat, "Got format size %u.\n", mt->cbFormat);
+        ok(!mt->pbFormat, "Got unexpected format block.\n");
+
+        hr = IPin_QueryAccept(pin, mt);
+        ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+        CoTaskMemFree(mt);
+    }
+
+    hr = IEnumMediaTypes_Next(enummt, 1, &mt, NULL);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    req_mt.majortype = MEDIATYPE_Audio;
+    req_mt.formattype = FORMAT_WaveFormatEx;
+    req_mt.cbFormat = sizeof(WAVEFORMATEX);
+    req_mt.pbFormat = (BYTE *)&wfx;
+
+    IEnumMediaTypes_Release(enummt);
+
+    for (channels = 1; channels <= 2; ++channels)
+    {
+        wfx.nChannels = channels;
+
+        for (i = 0; i < ARRAY_SIZE(formats); ++i)
+        {
+            wfx.wFormatTag = formats[i].tag;
+            wfx.wBitsPerSample = formats[i].depth;
+            wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;
+            for (j = 0; j < ARRAY_SIZE(sample_rates); ++j)
+            {
+                wfx.nSamplesPerSec = sample_rates[j];
+                wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
+
+                expect_hr = does_dsound_support_format(&wfx);
+
+                hr = IPin_QueryAccept(pin, &req_mt);
+                todo_wine_if (expect_hr == S_OK)
+                    ok(hr == expect_hr, "Expected hr %#x, got %#x, for %d channels, %d-bit %s, %d Hz.\n",
+                            expect_hr, hr, channels, formats[i].depth,
+                            formats[i].tag == WAVE_FORMAT_PCM ? "integer" : "float", sample_rates[j]);
+            }
+        }
+    }
+
+    IPin_Release(pin);
+    ref = IBaseFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(dsoundrender)
 {
     IBaseFilter *filter;
@@ -712,6 +829,7 @@ START_TEST(dsoundrender)
     test_basic_audio();
     test_enum_media_types();
     test_unconnected_filter_state();
+    test_media_types();
     test_basefilter();
 
     CoUninitialize();
From 3d54a77af8c7fbc1aefb3182fc6e3d902314a38a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 15 Jul 2020 22:57:16 -0500
Subject: [PATCH] quartz/dsoundrender: Don't check the subtype in
 DSoundRender_CheckMediaType().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/dsoundrender.c       | 3 ---
 dlls/quartz/tests/dsoundrender.c | 7 +++----
 2 files changed, 3 insertions(+), 7 deletions(-)

diff --git a/dlls/quartz/dsoundrender.c b/dlls/quartz/dsoundrender.c
index 8e6379da8ce..225c1e07b96 100644
--- a/dlls/quartz/dsoundrender.c
+++ b/dlls/quartz/dsoundrender.c
@@ -384,9 +384,6 @@ static HRESULT WINAPI DSoundRender_CheckMediaType(struct strmbase_renderer *ifac
     if (!IsEqualIID(&pmt->majortype, &MEDIATYPE_Audio))
         return S_FALSE;
 
-    if (!IsEqualIID(&pmt->subtype, &MEDIASUBTYPE_PCM))
-        return S_FALSE;
-
     return S_OK;
 }
 
diff --git a/dlls/quartz/tests/dsoundrender.c b/dlls/quartz/tests/dsoundrender.c
index 3add14d0437..0b45d712dc0 100644
--- a/dlls/quartz/tests/dsoundrender.c
+++ b/dlls/quartz/tests/dsoundrender.c
@@ -789,10 +789,9 @@ static void test_media_types(void)
                 expect_hr = does_dsound_support_format(&wfx);
 
                 hr = IPin_QueryAccept(pin, &req_mt);
-                todo_wine_if (expect_hr == S_OK)
-                    ok(hr == expect_hr, "Expected hr %#x, got %#x, for %d channels, %d-bit %s, %d Hz.\n",
-                            expect_hr, hr, channels, formats[i].depth,
-                            formats[i].tag == WAVE_FORMAT_PCM ? "integer" : "float", sample_rates[j]);
+                ok(hr == expect_hr, "Expected hr %#x, got %#x, for %d channels, %d-bit %s, %d Hz.\n",
+                        expect_hr, hr, channels, formats[i].depth,
+                        formats[i].tag == WAVE_FORMAT_PCM ? "integer" : "float", sample_rates[j]);
             }
         }
     }
From 52862838db98b462ae6db8fec220b7903f8bf7b6 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 15 Jul 2020 22:57:17 -0500
Subject: [PATCH] quartz/tests: Add some tests for pin connection on the
 DirectSound renderer.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/dsoundrender.c | 138 +++++++++++++++++++++++++++++++
 1 file changed, 138 insertions(+)

diff --git a/dlls/quartz/tests/dsoundrender.c b/dlls/quartz/tests/dsoundrender.c
index 0b45d712dc0..22d5bf62824 100644
--- a/dlls/quartz/tests/dsoundrender.c
+++ b/dlls/quartz/tests/dsoundrender.c
@@ -25,6 +25,7 @@
 #include "dsound.h"
 #include "amaudio.h"
 #include "mmreg.h"
+#include "wine/strmbase.h"
 #include "wine/test.h"
 
 static const WCHAR sink_id[] = L"Audio Input pin (rendered)";
@@ -38,6 +39,12 @@ static IBaseFilter *create_dsound_render(void)
     return filter;
 }
 
+static inline BOOL compare_media_types(const AM_MEDIA_TYPE *a, const AM_MEDIA_TYPE *b)
+{
+    return !memcmp(a, b, offsetof(AM_MEDIA_TYPE, pbFormat))
+        && !memcmp(a->pbFormat, b->pbFormat, a->cbFormat);
+}
+
 static ULONG get_refcount(void *iface)
 {
     IUnknown *unknown = iface;
@@ -573,6 +580,136 @@ static void test_enum_media_types(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+struct testfilter
+{
+    struct strmbase_filter filter;
+    struct strmbase_source source;
+};
+
+static inline struct testfilter *impl_from_strmbase_filter(struct strmbase_filter *iface)
+{
+    return CONTAINING_RECORD(iface, struct testfilter, filter);
+}
+
+static struct strmbase_pin *testfilter_get_pin(struct strmbase_filter *iface, unsigned int index)
+{
+    struct testfilter *filter = impl_from_strmbase_filter(iface);
+    if (!index)
+        return &filter->source.pin;
+    return NULL;
+}
+
+static void testfilter_destroy(struct strmbase_filter *iface)
+{
+    struct testfilter *filter = impl_from_strmbase_filter(iface);
+    strmbase_source_cleanup(&filter->source);
+    strmbase_filter_cleanup(&filter->filter);
+}
+
+static const struct strmbase_filter_ops testfilter_ops =
+{
+    .filter_get_pin = testfilter_get_pin,
+    .filter_destroy = testfilter_destroy,
+};
+
+static HRESULT WINAPI testsource_DecideAllocator(struct strmbase_source *iface,
+        IMemInputPin *peer, IMemAllocator **allocator)
+{
+    return S_OK;
+}
+
+static const struct strmbase_source_ops testsource_ops =
+{
+    .pfnAttemptConnection = BaseOutputPinImpl_AttemptConnection,
+    .pfnDecideAllocator = testsource_DecideAllocator,
+};
+
+static void testfilter_init(struct testfilter *filter)
+{
+    static const GUID clsid = {0xabacab};
+    strmbase_filter_init(&filter->filter, NULL, &clsid, &testfilter_ops);
+    strmbase_source_init(&filter->source, &filter->filter, L"", &testsource_ops);
+}
+
+static void test_connect_pin(void)
+{
+    WAVEFORMATEX wfx =
+    {
+        .wFormatTag = WAVE_FORMAT_PCM,
+        .nChannels = 2,
+        .nSamplesPerSec = 44100,
+        .nAvgBytesPerSec = 44100 * 4,
+        .nBlockAlign = 4,
+        .wBitsPerSample = 16,
+    };
+    AM_MEDIA_TYPE req_mt =
+    {
+        .majortype = MEDIATYPE_Audio,
+        .subtype = MEDIASUBTYPE_PCM,
+        .formattype = FORMAT_WaveFormatEx,
+        .cbFormat = sizeof(wfx),
+        .pbFormat = (BYTE *)&wfx,
+    };
+    IBaseFilter *filter = create_dsound_render();
+    struct testfilter source;
+    IFilterGraph2 *graph;
+    AM_MEDIA_TYPE mt;
+    IPin *pin, *peer;
+    HRESULT hr;
+    ULONG ref;
+
+    testfilter_init(&source);
+
+    CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, &IID_IFilterGraph2, (void **)&graph);
+    IFilterGraph2_AddFilter(graph, &source.filter.IBaseFilter_iface, L"source");
+    IFilterGraph2_AddFilter(graph, filter, L"sink");
+
+    IBaseFilter_FindPin(filter, sink_id, &pin);
+
+    peer = (IPin *)0xdeadbeef;
+    hr = IPin_ConnectedTo(pin, &peer);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
+    ok(!peer, "Got peer %p.\n", peer);
+
+    hr = IPin_ConnectionMediaType(pin, &mt);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
+
+    hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_ConnectedTo(pin, &peer);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(peer == &source.source.pin.IPin_iface, "Got peer %p.\n", peer);
+    IPin_Release(peer);
+
+    hr = IPin_ConnectionMediaType(pin, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
+
+    hr = IFilterGraph2_Disconnect(graph, pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IFilterGraph2_Disconnect(graph, pin);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(source.source.pin.peer == pin, "Got peer %p.\n", source.source.pin.peer);
+    IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
+
+    peer = (IPin *)0xdeadbeef;
+    hr = IPin_ConnectedTo(pin, &peer);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
+    ok(!peer, "Got peer %p.\n", peer);
+
+    hr = IPin_ConnectionMediaType(pin, &mt);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
+
+    IPin_Release(pin);
+    ref = IFilterGraph2_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IBaseFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void test_pin(IPin *pin)
 {
     IMemInputPin *mpin = NULL;
@@ -829,6 +966,7 @@ START_TEST(dsoundrender)
     test_enum_media_types();
     test_unconnected_filter_state();
     test_media_types();
+    test_connect_pin();
     test_basefilter();
 
     CoUninitialize();
From aca967b8a5a6ce7a839990fcd85c7517f3a1e46c Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 15 Jul 2020 22:57:18 -0500
Subject: [PATCH] quartz/tests: Add some tests for allocator negotiation on the
 DirectSound renderer.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/dsoundrender.c | 49 ++++++++++++++++++++++++++++++++
 1 file changed, 49 insertions(+)

diff --git a/dlls/quartz/tests/dsoundrender.c b/dlls/quartz/tests/dsoundrender.c
index 22d5bf62824..d5c18d389a4 100644
--- a/dlls/quartz/tests/dsoundrender.c
+++ b/dlls/quartz/tests/dsoundrender.c
@@ -631,6 +631,49 @@ static void testfilter_init(struct testfilter *filter)
     strmbase_source_init(&filter->source, &filter->filter, L"", &testsource_ops);
 }
 
+static void test_allocator(IMemInputPin *input)
+{
+    IMemAllocator *req_allocator, *ret_allocator;
+    ALLOCATOR_PROPERTIES props;
+    HRESULT hr;
+
+    hr = IMemInputPin_GetAllocatorRequirements(input, &props);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+
+    hr = IMemInputPin_GetAllocator(input, &ret_allocator);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    if (hr == S_OK)
+    {
+        hr = IMemAllocator_GetProperties(ret_allocator, &props);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(!props.cBuffers, "Got %d buffers.\n", props.cBuffers);
+        ok(!props.cbBuffer, "Got size %d.\n", props.cbBuffer);
+        ok(!props.cbAlign, "Got alignment %d.\n", props.cbAlign);
+        ok(!props.cbPrefix, "Got prefix %d.\n", props.cbPrefix);
+
+        hr = IMemInputPin_NotifyAllocator(input, ret_allocator, TRUE);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        IMemAllocator_Release(ret_allocator);
+    }
+
+    hr = IMemInputPin_NotifyAllocator(input, NULL, TRUE);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+
+    CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IMemAllocator, (void **)&req_allocator);
+
+    hr = IMemInputPin_NotifyAllocator(input, req_allocator, TRUE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMemInputPin_GetAllocator(input, &ret_allocator);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(ret_allocator == req_allocator, "Allocators didn't match.\n");
+
+    IMemAllocator_Release(req_allocator);
+    IMemAllocator_Release(ret_allocator);
+}
+
 static void test_connect_pin(void)
 {
     WAVEFORMATEX wfx =
@@ -653,6 +696,7 @@ static void test_connect_pin(void)
     IBaseFilter *filter = create_dsound_render();
     struct testfilter source;
     IFilterGraph2 *graph;
+    IMemInputPin *input;
     AM_MEDIA_TYPE mt;
     IPin *pin, *peer;
     HRESULT hr;
@@ -686,6 +730,10 @@ static void test_connect_pin(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
 
+    IPin_QueryInterface(pin, &IID_IMemInputPin, (void **)&input);
+
+    test_allocator(input);
+
     hr = IFilterGraph2_Disconnect(graph, pin);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
@@ -701,6 +749,7 @@ static void test_connect_pin(void)
     hr = IPin_ConnectionMediaType(pin, &mt);
     ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
+    IMemInputPin_Release(input);
     IPin_Release(pin);
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
From c37e2ccceb80a12aedc8cd2590e1e8acd96c72c7 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Thu, 16 Jul 2020 06:16:33 +0200
Subject: [PATCH] qdvd: Support aggregation.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 configure                   |   1 +
 configure.ac                |   1 +
 dlls/qdvd/graph.c           |  61 ++++++++++---
 dlls/qdvd/qdvd_main.c       |   8 +-
 dlls/qdvd/qdvd_private.h    |   2 +-
 dlls/qdvd/tests/Makefile.in |   5 ++
 dlls/qdvd/tests/graph.c     | 171 ++++++++++++++++++++++++++++++++++++
 7 files changed, 233 insertions(+), 16 deletions(-)
 create mode 100644 dlls/qdvd/tests/Makefile.in
 create mode 100644 dlls/qdvd/tests/graph.c

diff --git a/configure b/configure
index 1eafbace7fa..24d0a1d8b47 100755
--- a/configure
+++ b/configure
@@ -21051,6 +21051,7 @@ wine_fn_config_makefile dlls/qasf/tests enable_tests
 wine_fn_config_makefile dlls/qcap enable_qcap
 wine_fn_config_makefile dlls/qcap/tests enable_tests
 wine_fn_config_makefile dlls/qdvd enable_qdvd
+wine_fn_config_makefile dlls/qdvd/tests enable_tests
 wine_fn_config_makefile dlls/qedit enable_qedit
 wine_fn_config_makefile dlls/qedit/tests enable_tests
 wine_fn_config_makefile dlls/qmgr enable_qmgr
diff --git a/configure.ac b/configure.ac
index 4829648c3a5..d914e3eca88 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3634,6 +3634,7 @@ WINE_CONFIG_MAKEFILE(dlls/qasf/tests)
 WINE_CONFIG_MAKEFILE(dlls/qcap)
 WINE_CONFIG_MAKEFILE(dlls/qcap/tests)
 WINE_CONFIG_MAKEFILE(dlls/qdvd)
+WINE_CONFIG_MAKEFILE(dlls/qdvd/tests)
 WINE_CONFIG_MAKEFILE(dlls/qedit)
 WINE_CONFIG_MAKEFILE(dlls/qedit/tests)
 WINE_CONFIG_MAKEFILE(dlls/qmgr)
diff --git a/dlls/qdvd/graph.c b/dlls/qdvd/graph.c
index f33293bfa46..986fcc0db04 100644
--- a/dlls/qdvd/graph.c
+++ b/dlls/qdvd/graph.c
@@ -24,26 +24,29 @@ WINE_DEFAULT_DEBUG_CHANNEL(qdvd);
 
 struct graph_builder
 {
+    IUnknown IUnknown_inner;
     IDvdGraphBuilder IDvdGraphBuilder_iface;
+
+    IUnknown *outer_unk;
     LONG refcount;
 };
 
-static struct graph_builder *impl_from_IDvdGraphBuilder(IDvdGraphBuilder *iface)
+static struct graph_builder *impl_from_IUnknown(IUnknown *iface)
 {
-    return CONTAINING_RECORD(iface, struct graph_builder, IDvdGraphBuilder_iface);
+    return CONTAINING_RECORD(iface, struct graph_builder, IUnknown_inner);
 }
 
-static ULONG WINAPI graph_builder_AddRef(IDvdGraphBuilder *iface)
+static ULONG WINAPI inner_AddRef(IUnknown *iface)
 {
-    struct graph_builder *builder = impl_from_IDvdGraphBuilder(iface);
+    struct graph_builder *builder = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedIncrement(&builder->refcount);
     TRACE("%p increasing refcount to %u.\n", builder, refcount);
     return refcount;
 }
 
-static ULONG WINAPI graph_builder_Release(IDvdGraphBuilder *iface)
+static ULONG WINAPI inner_Release(IUnknown *iface)
 {
-    struct graph_builder *builder = impl_from_IDvdGraphBuilder(iface);
+    struct graph_builder *builder = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedDecrement(&builder->refcount);
     TRACE("%p decreasing refcount to %u.\n", builder, refcount);
     if (!refcount)
@@ -51,12 +54,16 @@ static ULONG WINAPI graph_builder_Release(IDvdGraphBuilder *iface)
     return refcount;
 }
 
-static HRESULT WINAPI graph_builder_QueryInterface(IDvdGraphBuilder *iface, REFIID iid, void **out)
+static HRESULT WINAPI inner_QueryInterface(IUnknown *iface, REFIID iid, void **out)
 {
+    struct graph_builder *builder = impl_from_IUnknown(iface);
+
     TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
 
-    if (IsEqualGUID(iid, &IID_IDvdGraphBuilder) || IsEqualGUID(iid, &IID_IUnknown))
-        *out = iface;
+    if (IsEqualGUID(iid, &IID_IUnknown))
+        *out = &builder->IUnknown_inner;
+    else if (IsEqualGUID(iid, &IID_IDvdGraphBuilder))
+        *out = &builder->IDvdGraphBuilder_iface;
     else
     {
         *out = NULL;
@@ -68,6 +75,36 @@ static HRESULT WINAPI graph_builder_QueryInterface(IDvdGraphBuilder *iface, REFI
     return S_OK;
 }
 
+static const IUnknownVtbl inner_vtbl =
+{
+    inner_QueryInterface,
+    inner_AddRef,
+    inner_Release,
+};
+
+static struct graph_builder *impl_from_IDvdGraphBuilder(IDvdGraphBuilder *iface)
+{
+    return CONTAINING_RECORD(iface, struct graph_builder, IDvdGraphBuilder_iface);
+}
+
+static ULONG WINAPI graph_builder_AddRef(IDvdGraphBuilder *iface)
+{
+    struct graph_builder *builder = impl_from_IDvdGraphBuilder(iface);
+    return IUnknown_AddRef(builder->outer_unk);
+}
+
+static ULONG WINAPI graph_builder_Release(IDvdGraphBuilder *iface)
+{
+    struct graph_builder *builder = impl_from_IDvdGraphBuilder(iface);
+    return IUnknown_Release(builder->outer_unk);
+}
+
+static HRESULT WINAPI graph_builder_QueryInterface(IDvdGraphBuilder *iface, REFIID iid, void **out)
+{
+    struct graph_builder *builder = impl_from_IDvdGraphBuilder(iface);
+    return IUnknown_QueryInterface(builder->outer_unk, iid, out);
+}
+
 static HRESULT WINAPI graph_builder_GetFiltergraph(IDvdGraphBuilder *iface, IGraphBuilder **graph)
 {
     FIXME("iface %p, graph %p, stub!\n", iface, graph);
@@ -96,7 +133,7 @@ static const struct IDvdGraphBuilderVtbl graph_builder_vtbl =
     graph_builder_RenderDvdVideoVolume,
 };
 
-HRESULT graph_builder_create(IUnknown **out)
+HRESULT graph_builder_create(IUnknown *outer, IUnknown **out)
 {
     struct graph_builder *builder;
 
@@ -104,9 +141,11 @@ HRESULT graph_builder_create(IUnknown **out)
         return E_OUTOFMEMORY;
 
     builder->IDvdGraphBuilder_iface.lpVtbl = &graph_builder_vtbl;
+    builder->IUnknown_inner.lpVtbl = &inner_vtbl;
     builder->refcount = 1;
+    builder->outer_unk = outer ? outer : &builder->IUnknown_inner;
 
     TRACE("Created DVD graph builder %p.\n", builder);
-    *out = (IUnknown *)&builder->IDvdGraphBuilder_iface;
+    *out = &builder->IUnknown_inner;
     return S_OK;
 }
diff --git a/dlls/qdvd/qdvd_main.c b/dlls/qdvd/qdvd_main.c
index 9377f248ce9..c529533e44d 100644
--- a/dlls/qdvd/qdvd_main.c
+++ b/dlls/qdvd/qdvd_main.c
@@ -28,7 +28,7 @@ static HINSTANCE qdvd_instance;
 struct class_factory
 {
     IClassFactory IClassFactory_iface;
-    HRESULT (*create_instance)(IUnknown **out);
+    HRESULT (*create_instance)(IUnknown *outer, IUnknown **out);
 };
 
 static struct class_factory *impl_from_IClassFactory(IClassFactory *iface)
@@ -73,10 +73,10 @@ static HRESULT WINAPI class_factory_CreateInstance(IClassFactory *iface,
 
     *out = NULL;
 
-    if (outer)
-        return CLASS_E_NOAGGREGATION;
+    if (outer && !IsEqualGUID(iid, &IID_IUnknown))
+        return E_NOINTERFACE;
 
-    if (SUCCEEDED(hr = factory->create_instance(&unk)))
+    if (SUCCEEDED(hr = factory->create_instance(outer, &unk)))
     {
         hr = IUnknown_QueryInterface(unk, iid, out);
         IUnknown_Release(unk);
diff --git a/dlls/qdvd/qdvd_private.h b/dlls/qdvd/qdvd_private.h
index b54dd3ddc1c..297949ee60d 100644
--- a/dlls/qdvd/qdvd_private.h
+++ b/dlls/qdvd/qdvd_private.h
@@ -25,6 +25,6 @@
 #include "dshow.h"
 #include "wine/debug.h"
 
-HRESULT graph_builder_create(IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT graph_builder_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
 
 #endif /* QDVD_PRIVATE_H */
diff --git a/dlls/qdvd/tests/Makefile.in b/dlls/qdvd/tests/Makefile.in
new file mode 100644
index 00000000000..35d65e224c4
--- /dev/null
+++ b/dlls/qdvd/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL   = qdvd.dll
+IMPORTS   = strmiids uuid ole32
+
+C_SRCS = \
+	graph.c
diff --git a/dlls/qdvd/tests/graph.c b/dlls/qdvd/tests/graph.c
new file mode 100644
index 00000000000..93dc4e66a99
--- /dev/null
+++ b/dlls/qdvd/tests/graph.c
@@ -0,0 +1,171 @@
+/*
+ * Graph builder unit tests
+ *
+ * Copyright 2020 Gijs Vermeulen
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+#include "dshow.h"
+#include "wine/strmbase.h"
+#include "wine/test.h"
+
+static IDvdGraphBuilder *create_graph_builder(void)
+{
+    IDvdGraphBuilder *graph = NULL;
+    HRESULT hr = CoCreateInstance(&CLSID_DvdGraphBuilder, NULL,
+            CLSCTX_INPROC_SERVER, &IID_IDvdGraphBuilder, (void **)&graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    return graph;
+}
+
+static ULONG get_refcount(void *iface)
+{
+    IUnknown *unknown = iface;
+    IUnknown_AddRef(unknown);
+    return IUnknown_Release(unknown);
+}
+
+#define check_interface(a, b, c) check_interface_(__LINE__, a, b, c)
+static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOOL supported)
+{
+    IUnknown *iface = iface_ptr;
+    HRESULT hr, expected_hr;
+    IUnknown *unk;
+
+    expected_hr = supported ? S_OK : E_NOINTERFACE;
+
+    hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
+    if (SUCCEEDED(hr))
+        IUnknown_Release(unk);
+}
+
+static void test_interfaces(void)
+{
+    IDvdGraphBuilder *graph = create_graph_builder();
+
+    check_interface(graph, &IID_IDvdGraphBuilder, TRUE);
+    check_interface(graph, &IID_IUnknown, TRUE);
+
+    check_interface(graph, &IID_IBaseFilter, FALSE);
+
+    IDvdGraphBuilder_Release(graph);
+}
+
+static const GUID test_iid = {0x33333333};
+static LONG outer_ref = 1;
+
+static HRESULT WINAPI outer_QueryInterface(IUnknown *iface, REFIID iid, void **out)
+{
+    if (IsEqualGUID(iid, &IID_IUnknown)
+            || IsEqualGUID(iid, &IID_IDvdGraphBuilder)
+            || IsEqualGUID(iid, &test_iid))
+    {
+        *out = (IUnknown *)0xdeadbeef;
+        return S_OK;
+    }
+    ok(0, "unexpected call %s\n", wine_dbgstr_guid(iid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI outer_AddRef(IUnknown *iface)
+{
+    return InterlockedIncrement(&outer_ref);
+}
+
+static ULONG WINAPI outer_Release(IUnknown *iface)
+{
+    return InterlockedDecrement(&outer_ref);
+}
+
+static const IUnknownVtbl outer_vtbl =
+{
+    outer_QueryInterface,
+    outer_AddRef,
+    outer_Release,
+};
+
+static IUnknown test_outer = {&outer_vtbl};
+
+static void test_aggregation(void)
+{
+    IDvdGraphBuilder *graph, *graph2;
+    IUnknown *unk, *unk2;
+    HRESULT hr;
+    ULONG ref;
+
+    graph = (IDvdGraphBuilder *)0xdeadbeef;
+    hr = CoCreateInstance(&CLSID_DvdGraphBuilder, &test_outer, CLSCTX_INPROC_SERVER,
+            &IID_IDvdGraphBuilder, (void **)&graph);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+    ok(!graph, "Got interface %p.\n", graph);
+
+    hr = CoCreateInstance(&CLSID_DvdGraphBuilder, &test_outer, CLSCTX_INPROC_SERVER,
+            &IID_IUnknown, (void **)&unk);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+    ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
+    ref = get_refcount(unk);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+
+    ref = IUnknown_AddRef(unk);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+
+    ref = IUnknown_Release(unk);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+
+    hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
+    IUnknown_Release(unk2);
+
+    hr = IUnknown_QueryInterface(unk, &IID_IDvdGraphBuilder, (void **)&graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDvdGraphBuilder_QueryInterface(graph, &IID_IUnknown, (void **)&unk2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
+
+    hr = IDvdGraphBuilder_QueryInterface(graph, &IID_IDvdGraphBuilder, (void **)&graph2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph2 == (IDvdGraphBuilder *)0xdeadbeef, "Got unexpected IDvdGraphBuilder %p.\n", graph2);
+
+    hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+    ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
+
+    hr = IDvdGraphBuilder_QueryInterface(graph, &test_iid, (void **)&unk2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
+
+    IDvdGraphBuilder_Release(graph);
+    ref = IUnknown_Release(unk);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+}
+
+START_TEST(graph)
+{
+    CoInitializeEx(NULL, COINIT_MULTITHREADED);
+
+    test_interfaces();
+    test_aggregation();
+
+    CoUninitialize();
+}
From 36d5ec90572ec4691ade99b97600a1ab54b3c9b7 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Fri, 17 Jul 2020 21:50:19 +0200
Subject: [PATCH] qdvd: Add a stub dvd navigator filter.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qdvd/Makefile.in       |   3 +-
 dlls/qdvd/navigator.c       |  67 +++++++++++++
 dlls/qdvd/qdvd_classes.idl  |   7 ++
 dlls/qdvd/qdvd_main.c       |   3 +
 dlls/qdvd/qdvd_private.h    |   1 +
 dlls/qdvd/tests/Makefile.in |   3 +-
 dlls/qdvd/tests/navigator.c | 191 ++++++++++++++++++++++++++++++++++++
 7 files changed, 273 insertions(+), 2 deletions(-)
 create mode 100644 dlls/qdvd/navigator.c
 create mode 100644 dlls/qdvd/tests/navigator.c

diff --git a/dlls/qdvd/Makefile.in b/dlls/qdvd/Makefile.in
index 8f5089b3acc..364a81e6378 100644
--- a/dlls/qdvd/Makefile.in
+++ b/dlls/qdvd/Makefile.in
@@ -1,10 +1,11 @@
 MODULE    = qdvd.dll
-IMPORTS   = strmiids uuid ole32
+IMPORTS   = strmbase strmiids uuid ole32
 
 EXTRADLLFLAGS = -mno-cygwin
 
 C_SRCS = \
 	graph.c \
+	navigator.c \
 	qdvd_main.c
 
 IDL_SRCS = \
diff --git a/dlls/qdvd/navigator.c b/dlls/qdvd/navigator.c
new file mode 100644
index 00000000000..1e121dde601
--- /dev/null
+++ b/dlls/qdvd/navigator.c
@@ -0,0 +1,67 @@
+/*
+ * Navigator filter
+ *
+ * Copyright 2020 Gijs Vermeulen
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "qdvd_private.h"
+#include "wine/strmbase.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(qdvd);
+
+struct navigator
+{
+    struct strmbase_filter filter;
+};
+
+static inline struct navigator *impl_from_strmbase_filter(struct strmbase_filter *filter)
+{
+    return CONTAINING_RECORD(filter, struct navigator, filter);
+}
+
+static struct strmbase_pin *navigator_get_pin(struct strmbase_filter *iface, unsigned int index)
+{
+    return NULL;
+}
+
+static void navigator_destroy(struct strmbase_filter *iface)
+{
+    struct navigator *filter = impl_from_strmbase_filter(iface);
+
+    strmbase_filter_cleanup(&filter->filter);
+    free(filter);
+}
+
+static const struct strmbase_filter_ops filter_ops =
+{
+    .filter_get_pin = navigator_get_pin,
+    .filter_destroy = navigator_destroy,
+};
+
+HRESULT navigator_create(IUnknown *outer, IUnknown **out)
+{
+    struct navigator *object;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    strmbase_filter_init(&object->filter, outer, &CLSID_DVDNavigator, &filter_ops);
+
+    TRACE("Created DVD Navigator filter %p.\n", object);
+    *out = &object->filter.IUnknown_inner;
+    return S_OK;
+}
diff --git a/dlls/qdvd/qdvd_classes.idl b/dlls/qdvd/qdvd_classes.idl
index 7fd2a081baf..c55c7e39441 100644
--- a/dlls/qdvd/qdvd_classes.idl
+++ b/dlls/qdvd/qdvd_classes.idl
@@ -24,3 +24,10 @@
     uuid(fcc152b7-f372-11d0-8e00-00c04fd7c08b),
 ]
 coclass DvdGraphBuilder {}
+
+[
+    helpstring("DVD Navigator Filter"),
+    threading(both),
+    uuid(9b8c4620-2c1a-11d0-8493-00a02438ad48),
+]
+coclass DVDNavigator {}
diff --git a/dlls/qdvd/qdvd_main.c b/dlls/qdvd/qdvd_main.c
index c529533e44d..2fdb108877d 100644
--- a/dlls/qdvd/qdvd_main.c
+++ b/dlls/qdvd/qdvd_main.c
@@ -100,6 +100,7 @@ static const IClassFactoryVtbl class_factory_vtbl =
 };
 
 static struct class_factory graph_builder_cf = {{&class_factory_vtbl}, graph_builder_create};
+static struct class_factory navigator_cf = {{&class_factory_vtbl}, navigator_create};
 
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
@@ -120,6 +121,8 @@ HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **out)
 
     if (IsEqualGUID(clsid, &CLSID_DvdGraphBuilder))
         return IClassFactory_QueryInterface(&graph_builder_cf.IClassFactory_iface, iid, out);
+    if (IsEqualGUID(clsid, &CLSID_DVDNavigator))
+        return IClassFactory_QueryInterface(&navigator_cf.IClassFactory_iface, iid, out);
 
     FIXME("%s not available, returning CLASS_E_CLASSNOTAVAILABLE.\n", debugstr_guid(clsid));
     return CLASS_E_CLASSNOTAVAILABLE;
diff --git a/dlls/qdvd/qdvd_private.h b/dlls/qdvd/qdvd_private.h
index 297949ee60d..48fced46f10 100644
--- a/dlls/qdvd/qdvd_private.h
+++ b/dlls/qdvd/qdvd_private.h
@@ -26,5 +26,6 @@
 #include "wine/debug.h"
 
 HRESULT graph_builder_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT navigator_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
 
 #endif /* QDVD_PRIVATE_H */
diff --git a/dlls/qdvd/tests/Makefile.in b/dlls/qdvd/tests/Makefile.in
index 35d65e224c4..fdd769b73e0 100644
--- a/dlls/qdvd/tests/Makefile.in
+++ b/dlls/qdvd/tests/Makefile.in
@@ -2,4 +2,5 @@ TESTDLL   = qdvd.dll
 IMPORTS   = strmiids uuid ole32
 
 C_SRCS = \
-	graph.c
+	graph.c \
+	navigator.c
diff --git a/dlls/qdvd/tests/navigator.c b/dlls/qdvd/tests/navigator.c
new file mode 100644
index 00000000000..f01e428b4ed
--- /dev/null
+++ b/dlls/qdvd/tests/navigator.c
@@ -0,0 +1,191 @@
+/*
+ * Navigator filter unit tests
+ *
+ * Copyright 2020 Gijs Vermeulen
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+#include "dshow.h"
+#include "wine/strmbase.h"
+#include "wine/test.h"
+
+static IBaseFilter *create_navigator(void)
+{
+    IBaseFilter *filter = NULL;
+    HRESULT hr = CoCreateInstance(&CLSID_DVDNavigator, NULL,
+            CLSCTX_INPROC_SERVER, &IID_IBaseFilter, (void **)&filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    return filter;
+}
+
+static ULONG get_refcount(void *iface)
+{
+    IUnknown *unknown = iface;
+    IUnknown_AddRef(unknown);
+    return IUnknown_Release(unknown);
+}
+
+#define check_interface(a, b, c) check_interface_(__LINE__, a, b, c)
+static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOOL supported)
+{
+    IUnknown *iface = iface_ptr;
+    HRESULT hr, expected_hr;
+    IUnknown *unk;
+
+    expected_hr = supported ? S_OK : E_NOINTERFACE;
+
+    hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
+    if (SUCCEEDED(hr))
+        IUnknown_Release(unk);
+}
+
+static void test_interfaces(void)
+{
+    IBaseFilter *filter = create_navigator();
+
+    check_interface(filter, &IID_IBaseFilter, TRUE);
+    todo_wine check_interface(filter, &IID_IDvdControl, TRUE);
+    todo_wine check_interface(filter, &IID_IDvdControl2, TRUE);
+    todo_wine check_interface(filter, &IID_IDvdInfo, TRUE);
+    todo_wine check_interface(filter, &IID_IDvdInfo2, TRUE);
+    check_interface(filter, &IID_IMediaFilter, TRUE);
+    check_interface(filter, &IID_IPersist, TRUE);
+    todo_wine check_interface(filter, &IID_ISpecifyPropertyPages, TRUE);
+    check_interface(filter, &IID_IUnknown, TRUE);
+
+    check_interface(filter, &IID_IAMFilterMiscFlags, FALSE);
+    check_interface(filter, &IID_IBasicAudio, FALSE);
+    check_interface(filter, &IID_IBasicVideo, FALSE);
+    check_interface(filter, &IID_IFileSourceFilter, FALSE);
+    check_interface(filter, &IID_IKsPropertySet, FALSE);
+    check_interface(filter, &IID_IMediaPosition, FALSE);
+    check_interface(filter, &IID_IMediaSeeking, FALSE);
+    check_interface(filter, &IID_IPersistPropertyBag, FALSE);
+    check_interface(filter, &IID_IPersistStream, FALSE);
+    check_interface(filter, &IID_IPin, FALSE);
+    check_interface(filter, &IID_IQualityControl, FALSE);
+    check_interface(filter, &IID_IQualProp, FALSE);
+    check_interface(filter, &IID_IReferenceClock, FALSE);
+    check_interface(filter, &IID_IVideoWindow, FALSE);
+
+    IBaseFilter_Release(filter);
+}
+
+static const GUID test_iid = {0x33333333};
+static LONG outer_ref = 1;
+
+static HRESULT WINAPI outer_QueryInterface(IUnknown *iface, REFIID iid, void **out)
+{
+    if (IsEqualGUID(iid, &IID_IUnknown)
+            || IsEqualGUID(iid, &IID_IBaseFilter)
+            || IsEqualGUID(iid, &test_iid))
+    {
+        *out = (IUnknown *)0xdeadbeef;
+        return S_OK;
+    }
+    ok(0, "unexpected call %s\n", wine_dbgstr_guid(iid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI outer_AddRef(IUnknown *iface)
+{
+    return InterlockedIncrement(&outer_ref);
+}
+
+static ULONG WINAPI outer_Release(IUnknown *iface)
+{
+    return InterlockedDecrement(&outer_ref);
+}
+
+static const IUnknownVtbl outer_vtbl =
+{
+    outer_QueryInterface,
+    outer_AddRef,
+    outer_Release,
+};
+
+static IUnknown test_outer = {&outer_vtbl};
+
+static void test_aggregation(void)
+{
+    IBaseFilter *filter, *filter2;
+    IUnknown *unk, *unk2;
+    HRESULT hr;
+    ULONG ref;
+
+    filter = (IBaseFilter *)0xdeadbeef;
+    hr = CoCreateInstance(&CLSID_DVDNavigator, &test_outer, CLSCTX_INPROC_SERVER,
+            &IID_IBaseFilter, (void **)&filter);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+    ok(!filter, "Got interface %p.\n", filter);
+
+    hr = CoCreateInstance(&CLSID_DVDNavigator, &test_outer, CLSCTX_INPROC_SERVER,
+            &IID_IUnknown, (void **)&unk);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+    ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
+    ref = get_refcount(unk);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+
+    ref = IUnknown_AddRef(unk);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+
+    ref = IUnknown_Release(unk);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+
+    hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
+    IUnknown_Release(unk2);
+
+    hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
+
+    hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
+
+    hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+    ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
+
+    hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
+
+    IBaseFilter_Release(filter);
+    ref = IUnknown_Release(unk);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+}
+
+START_TEST(navigator)
+{
+    CoInitializeEx(NULL, COINIT_MULTITHREADED);
+
+    test_interfaces();
+    test_aggregation();
+
+    CoUninitialize();
+}
From b9261c0f7822edc9d4284a35a518eb4811cb3b2d Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Fri, 17 Jul 2020 21:50:20 +0200
Subject: [PATCH] qdvd: Add a stub IDvdControl2 interface.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qdvd/navigator.c       | 453 ++++++++++++++++++++++++++++++++++++
 dlls/qdvd/tests/navigator.c |   2 +-
 2 files changed, 454 insertions(+), 1 deletion(-)

diff --git a/dlls/qdvd/navigator.c b/dlls/qdvd/navigator.c
index 1e121dde601..00cb0af995b 100644
--- a/dlls/qdvd/navigator.c
+++ b/dlls/qdvd/navigator.c
@@ -26,6 +26,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(qdvd);
 struct navigator
 {
     struct strmbase_filter filter;
+    IDvdControl2 IDvdControl2_iface;
 };
 
 static inline struct navigator *impl_from_strmbase_filter(struct strmbase_filter *filter)
@@ -33,6 +34,19 @@ static inline struct navigator *impl_from_strmbase_filter(struct strmbase_filter
     return CONTAINING_RECORD(filter, struct navigator, filter);
 }
 
+static HRESULT navigator_query_interface(struct strmbase_filter *iface, REFIID iid, void **out)
+{
+    struct navigator *filter = impl_from_strmbase_filter(iface);
+
+    if (IsEqualGUID(iid, &IID_IDvdControl2))
+        *out = &filter->IDvdControl2_iface;
+    else
+        return E_NOINTERFACE;
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
 static struct strmbase_pin *navigator_get_pin(struct strmbase_filter *iface, unsigned int index)
 {
     return NULL;
@@ -48,10 +62,448 @@ static void navigator_destroy(struct strmbase_filter *iface)
 
 static const struct strmbase_filter_ops filter_ops =
 {
+    .filter_query_interface = navigator_query_interface,
     .filter_get_pin = navigator_get_pin,
     .filter_destroy = navigator_destroy,
 };
 
+static struct navigator *impl_from_IDvdControl2(IDvdControl2 *iface)
+{
+    return CONTAINING_RECORD(iface, struct navigator, IDvdControl2_iface);
+}
+
+static HRESULT WINAPI dvd_control2_QueryInterface(IDvdControl2 *iface, REFIID iid, void **out)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+    return IUnknown_QueryInterface(filter->filter.outer_unk, iid, out);
+}
+
+static ULONG WINAPI dvd_control2_AddRef(IDvdControl2 *iface)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+    return IUnknown_AddRef(filter->filter.outer_unk);
+}
+
+static ULONG WINAPI dvd_control2_Release(IDvdControl2 *iface)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+    return IUnknown_Release(filter->filter.outer_unk);
+}
+
+static HRESULT WINAPI dvd_control2_PlayTitle(IDvdControl2 *iface, ULONG title, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, title %u, flags %#x, cmd %p.\n", filter, title, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_PlayChapterInTitle(IDvdControl2 *iface, ULONG title, ULONG chapter,
+        DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, title %u, chapter %u, flags %#x, cmd %p.\n", filter, title, chapter, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_PlayTimeInTitle(IDvdControl2 *iface, ULONG title, DVD_HMSF_TIMECODE *time,
+        DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, title %u, time %p, flags %#x, cmd %p.\n", filter, title, time, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_Stop(IDvdControl2 *iface)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p.\n", filter);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_ReturnFromSubmenu(IDvdControl2 *iface, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, flags %#x, cmd %p.\n", filter, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_PlayAtTime(IDvdControl2 *iface, DVD_HMSF_TIMECODE *time, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, time %p, flags %#x, cmd %p.\n", filter, time, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_PlayChapter(IDvdControl2 *iface, ULONG chapter, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, chapter %u, flags %#x, cmd %p.\n", filter, chapter, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_PlayPrevChapter(IDvdControl2 *iface, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, flags %#x, cmd %p.\n", filter, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_ReplayChapter(IDvdControl2 *iface, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, flags %#x, cmd %p.\n", filter, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_PlayNextChapter(IDvdControl2 *iface, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, flags %#x, cmd %p.\n", filter, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_PlayForwards(IDvdControl2 *iface, double speed, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, speed %f, flags %#x, cmd %p.\n", filter, speed, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_PlayBackwards(IDvdControl2 *iface, double speed, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, speed %f, flags %#x, cmd %p.\n", filter, speed, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_ShowMenu(IDvdControl2 *iface, DVD_MENU_ID id, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, id %d, flags %#x, cmd %p.\n", filter, id, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_Resume(IDvdControl2 *iface, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, flags %#x, cmd %p.\n", filter, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectRelativeButton(IDvdControl2 *iface, DVD_RELATIVE_BUTTON button)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, button %d.\n", filter, button);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_ActivateButton(IDvdControl2 *iface)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p.\n", filter);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectButton(IDvdControl2 *iface, ULONG button)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, button %u.\n", filter, button);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectAndActivateButton(IDvdControl2 *iface, ULONG button)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, button %u.\n", filter, button);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_StillOff(IDvdControl2 *iface)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p.\n", filter);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_Pause(IDvdControl2 *iface, BOOL enable)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, enable %d.\n", filter, enable);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectAudioStream(IDvdControl2 *iface, ULONG stream, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, stream %u, flags %#x, cmd %p.\n", filter, stream, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectSubpictureStream(IDvdControl2 *iface, ULONG stream, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, stream %u, flags %#x, cmd %p.\n", filter, stream, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SetSubpictureState(IDvdControl2 *iface, BOOL enable, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, enable %d, flags %#x, cmd %p.\n", filter, enable, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectAngle(IDvdControl2 *iface, ULONG angle, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, angle %u, flags %#x, cmd %p.\n", filter, angle, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectParentalLevel(IDvdControl2 *iface, ULONG level)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, level %u.\n", filter, level);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectParentalCountry(IDvdControl2 *iface, BYTE country[2])
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, country %p.\n", filter, country);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectKaraokeAudioPresentationMode(IDvdControl2 *iface, ULONG mode)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, mode %u.\n", filter, mode);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectVideoModePreference(IDvdControl2 *iface, ULONG mode)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, mode %u.\n", filter, mode);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SetDVDDirectory(IDvdControl2 *iface, const WCHAR *path)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, path %s.\n", filter, debugstr_w(path));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_ActivateAtPosition(IDvdControl2 *iface, POINT point)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, point %s.\n", filter, wine_dbgstr_point(&point));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectAtPosition(IDvdControl2 *iface, POINT point)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, point %s.\n", filter, wine_dbgstr_point(&point));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_PlayChaptersAutoStop(IDvdControl2 *iface, ULONG title, ULONG chapter, ULONG count,
+        DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, title %u, chapter %u, count %u, flags %#x, cmd %p.\n", filter, title, chapter, count, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_AcceptParentalLevelChange(IDvdControl2 *iface, BOOL accept)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, accept %d.\n", filter, accept);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SetOption(IDvdControl2 *iface, DVD_OPTION_FLAG flag, BOOL option)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, flag %d, option %d.\n", filter, flag, option);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SetState(IDvdControl2 *iface, IDvdState *state, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, state %p, flags %#x, cmd %p.\n", filter, state, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_PlayPeriodInTitleAutoStop(IDvdControl2 *iface, ULONG title,
+        DVD_HMSF_TIMECODE *start_time, DVD_HMSF_TIMECODE *end_time, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, title %u, start_time %p, end_time %p, flags %#x, cmd %p.\n",
+            filter, title, start_time, end_time, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SetGRPM(IDvdControl2 *iface, ULONG index, WORD value, DWORD flags, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, index %u, value %i, flags %#x, cmd %p.\n", filter, index, value, flags, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectDefaultMenuLanguage(IDvdControl2 *iface, LCID language)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, language %#x.\n", filter, language);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectDefaultAudioLanguage(IDvdControl2 *iface, LCID language,
+        DVD_AUDIO_LANG_EXT extension)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, language %#x, extension %d.\n", filter, language, extension);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_control2_SelectDefaultSubpictureLanguage(IDvdControl2 *iface, LCID language,
+        DVD_SUBPICTURE_LANG_EXT extension)
+{
+    struct navigator *filter = impl_from_IDvdControl2(iface);
+
+    FIXME("filter %p, language %#x, extension %d.\n", filter, language, extension);
+
+    return E_NOTIMPL;
+}
+
+static const struct IDvdControl2Vtbl dvd_control2_vtbl =
+{
+    dvd_control2_QueryInterface,
+    dvd_control2_AddRef,
+    dvd_control2_Release,
+    dvd_control2_PlayTitle,
+    dvd_control2_PlayChapterInTitle,
+    dvd_control2_PlayTimeInTitle,
+    dvd_control2_Stop,
+    dvd_control2_ReturnFromSubmenu,
+    dvd_control2_PlayAtTime,
+    dvd_control2_PlayChapter,
+    dvd_control2_PlayPrevChapter,
+    dvd_control2_ReplayChapter,
+    dvd_control2_PlayNextChapter,
+    dvd_control2_PlayForwards,
+    dvd_control2_PlayBackwards,
+    dvd_control2_ShowMenu,
+    dvd_control2_Resume,
+    dvd_control2_SelectRelativeButton,
+    dvd_control2_ActivateButton,
+    dvd_control2_SelectButton,
+    dvd_control2_SelectAndActivateButton,
+    dvd_control2_StillOff,
+    dvd_control2_Pause,
+    dvd_control2_SelectAudioStream,
+    dvd_control2_SelectSubpictureStream,
+    dvd_control2_SetSubpictureState,
+    dvd_control2_SelectAngle,
+    dvd_control2_SelectParentalLevel,
+    dvd_control2_SelectParentalCountry,
+    dvd_control2_SelectKaraokeAudioPresentationMode,
+    dvd_control2_SelectVideoModePreference,
+    dvd_control2_SetDVDDirectory,
+    dvd_control2_ActivateAtPosition,
+    dvd_control2_SelectAtPosition,
+    dvd_control2_PlayChaptersAutoStop,
+    dvd_control2_AcceptParentalLevelChange,
+    dvd_control2_SetOption,
+    dvd_control2_SetState,
+    dvd_control2_PlayPeriodInTitleAutoStop,
+    dvd_control2_SetGRPM,
+    dvd_control2_SelectDefaultMenuLanguage,
+    dvd_control2_SelectDefaultAudioLanguage,
+    dvd_control2_SelectDefaultSubpictureLanguage,
+};
+
 HRESULT navigator_create(IUnknown *outer, IUnknown **out)
 {
     struct navigator *object;
@@ -60,6 +512,7 @@ HRESULT navigator_create(IUnknown *outer, IUnknown **out)
         return E_OUTOFMEMORY;
 
     strmbase_filter_init(&object->filter, outer, &CLSID_DVDNavigator, &filter_ops);
+    object->IDvdControl2_iface.lpVtbl = &dvd_control2_vtbl;
 
     TRACE("Created DVD Navigator filter %p.\n", object);
     *out = &object->filter.IUnknown_inner;
diff --git a/dlls/qdvd/tests/navigator.c b/dlls/qdvd/tests/navigator.c
index f01e428b4ed..db2ba392dc5 100644
--- a/dlls/qdvd/tests/navigator.c
+++ b/dlls/qdvd/tests/navigator.c
@@ -60,7 +60,7 @@ static void test_interfaces(void)
 
     check_interface(filter, &IID_IBaseFilter, TRUE);
     todo_wine check_interface(filter, &IID_IDvdControl, TRUE);
-    todo_wine check_interface(filter, &IID_IDvdControl2, TRUE);
+    check_interface(filter, &IID_IDvdControl2, TRUE);
     todo_wine check_interface(filter, &IID_IDvdInfo, TRUE);
     todo_wine check_interface(filter, &IID_IDvdInfo2, TRUE);
     check_interface(filter, &IID_IMediaFilter, TRUE);
From 98390d9c2d2ce53239d3fa2d71c961e2c7ce5a84 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 17 Jul 2020 14:51:20 -0500
Subject: [PATCH] quartz/tests: Add tests for DirectSound renderer filter
 state.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/dsoundrender.c | 233 +++++++++++++++++++++++--------
 1 file changed, 176 insertions(+), 57 deletions(-)

diff --git a/dlls/quartz/tests/dsoundrender.c b/dlls/quartz/tests/dsoundrender.c
index d5c18d389a4..35f935bcad5 100644
--- a/dlls/quartz/tests/dsoundrender.c
+++ b/dlls/quartz/tests/dsoundrender.c
@@ -20,6 +20,7 @@
  */
 
 #define COBJMACROS
+#include <math.h>
 #include "dshow.h"
 #include "initguid.h"
 #include "dsound.h"
@@ -674,8 +675,164 @@ static void test_allocator(IMemInputPin *input)
     IMemAllocator_Release(ret_allocator);
 }
 
+struct frame_thread_params
+{
+    IMemInputPin *sink;
+    IMediaSample *sample;
+};
+
+static DWORD WINAPI frame_thread(void *arg)
+{
+    struct frame_thread_params *params = arg;
+    HRESULT hr;
+
+    if (winetest_debug > 1) trace("%04x: Sending frame.\n", GetCurrentThreadId());
+    hr = IMemInputPin_Receive(params->sink, params->sample);
+    if (winetest_debug > 1) trace("%04x: Returned %#x.\n", GetCurrentThreadId(), hr);
+    IMediaSample_Release(params->sample);
+    free(params);
+    return hr;
+}
+
+static HRESULT send_frame(IMemInputPin *sink)
+{
+    struct frame_thread_params *params = malloc(sizeof(*params));
+    REFERENCE_TIME start_time, end_time;
+    IMemAllocator *allocator;
+    unsigned short *words;
+    IMediaSample *sample;
+    unsigned int i;
+    HANDLE thread;
+    HRESULT hr;
+    BYTE *data;
+    DWORD ret;
+
+    hr = IMemInputPin_GetAllocator(sink, &allocator);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaSample_GetPointer(sample, &data);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    words = (unsigned short *)data;
+    for (i = 0; i < 44100 * 2; i += 2)
+        words[i] = words[i+1] = sinf(i / 20.0f) * 0x7fff;
+
+    hr = IMediaSample_SetActualDataLength(sample, 44100 * 4);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    start_time = 0;
+    end_time = start_time + 10000000;
+    hr = IMediaSample_SetTime(sample, &start_time, &end_time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    params->sink = sink;
+    params->sample = sample;
+    thread = CreateThread(NULL, 0, frame_thread, params, 0, NULL);
+    ret = WaitForSingleObject(thread, 500);
+    todo_wine_if (ret) ok(!ret, "Wait failed.\n");
+    GetExitCodeThread(thread, &ret);
+    CloseHandle(thread);
+
+    IMemAllocator_Release(allocator);
+    return ret;
+}
+
+static void test_filter_state(IMemInputPin *input, IFilterGraph2 *graph)
+{
+    IMediaControl *control;
+    OAFilterState state;
+    HRESULT hr;
+
+    IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
+
+    hr = send_frame(input);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
+
+    /* The renderer is not fully paused until it receives a sample. The
+     * DirectSound renderer never blocks in Receive(), despite returning S_OK
+     * from ReceiveCanBlock(). Instead it holds on to each sample until its
+     * presentation time, then writes it into the buffer. This is more work
+     * than it's worth to emulate, so for now, we'll ignore this behaviour. */
+
+    hr = IMediaControl_Pause(control);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    /* It's possible to queue multiple samples while paused. The number of
+     * samples that can be queued depends on the length of each sample, but
+     * it's not particularly clear how. */
+
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+
+    hr = send_frame(input);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_GetState(control, 1000, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_Stop(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = send_frame(input);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_Pause(control);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+
+    hr = send_frame(input);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_GetState(control, 1000, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_Run(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = send_frame(input);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = send_frame(input);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_Run(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_Pause(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_Stop(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaControl_GetState(control, 0, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    /* The DirectSound renderer will silently refuse to transition to running
+     * if it hasn't finished pausing yet. Once it does it reports itself as
+     * completely paused. */
+
+    IMediaControl_Release(control);
+}
+
 static void test_connect_pin(void)
 {
+    ALLOCATOR_PROPERTIES req_props = {1, 4 * 44100, 1, 0}, ret_props;
     WAVEFORMATEX wfx =
     {
         .wFormatTag = WAVE_FORMAT_PCM,
@@ -695,6 +852,7 @@ static void test_connect_pin(void)
     };
     IBaseFilter *filter = create_dsound_render();
     struct testfilter source;
+    IMemAllocator *allocator;
     IFilterGraph2 *graph;
     IMemInputPin *input;
     AM_MEDIA_TYPE mt;
@@ -734,6 +892,22 @@ static void test_connect_pin(void)
 
     test_allocator(input);
 
+    hr = CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IMemAllocator, (void **)&allocator);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
+    hr = IMemInputPin_NotifyAllocator(input, allocator, TRUE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMemAllocator_Commit(allocator);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMemInputPin_ReceiveCanBlock(input);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    test_filter_state(input, graph);
+
     hr = IFilterGraph2_Disconnect(graph, pin);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
@@ -749,6 +923,8 @@ static void test_connect_pin(void)
     hr = IPin_ConnectionMediaType(pin, &mt);
     ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
+    ref = IMemAllocator_Release(allocator);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IMemInputPin_Release(input);
     IPin_Release(pin);
     ref = IFilterGraph2_Release(graph);
@@ -759,62 +935,6 @@ static void test_connect_pin(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
-static void test_pin(IPin *pin)
-{
-    IMemInputPin *mpin = NULL;
-
-    IPin_QueryInterface(pin, &IID_IMemInputPin, (void **)&mpin);
-
-    ok(mpin != NULL, "No IMemInputPin found!\n");
-    if (mpin)
-    {
-        ok(IMemInputPin_ReceiveCanBlock(mpin) == S_OK, "Receive can't block for pin!\n");
-        ok(IMemInputPin_NotifyAllocator(mpin, NULL, 0) == E_POINTER, "NotifyAllocator likes a NULL pointer argument\n");
-        IMemInputPin_Release(mpin);
-    }
-    /* TODO */
-}
-
-static void test_basefilter(void)
-{
-    IEnumPins *pin_enum = NULL;
-    IBaseFilter *base = create_dsound_render();
-    IPin *pins[2];
-    ULONG ref;
-    HRESULT hr;
-
-    hr = IBaseFilter_EnumPins(base, NULL);
-    ok(hr == E_POINTER, "hr = %08x and not E_POINTER\n", hr);
-
-    hr= IBaseFilter_EnumPins(base, &pin_enum);
-    ok(hr == S_OK, "hr = %08x and not S_OK\n", hr);
-
-    hr = IEnumPins_Next(pin_enum, 1, NULL, NULL);
-    ok(hr == E_POINTER, "hr = %08x and not E_POINTER\n", hr);
-
-    hr = IEnumPins_Next(pin_enum, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "hr = %08x and not E_INVALIDARG\n", hr);
-
-    pins[0] = (void *)0xdead;
-    pins[1] = (void *)0xdeed;
-
-    hr = IEnumPins_Next(pin_enum, 2, pins, &ref);
-    ok(hr == S_FALSE, "hr = %08x instead of S_FALSE\n", hr);
-    ok(pins[0] != (void *)0xdead && pins[0] != NULL, "pins[0] = %p\n", pins[0]);
-    if (pins[0] != (void *)0xdead && pins[0] != NULL)
-    {
-        test_pin(pins[0]);
-        IPin_Release(pins[0]);
-    }
-
-    ok(pins[1] == (void *)0xdeed, "pins[1] = %p\n", pins[1]);
-
-    ref = IEnumPins_Release(pin_enum);
-    ok(ref == 0, "ref is %u and not 0!\n", ref);
-
-    IBaseFilter_Release(base);
-}
-
 static void test_unconnected_filter_state(void)
 {
     IBaseFilter *filter = create_dsound_render();
@@ -1016,7 +1136,6 @@ START_TEST(dsoundrender)
     test_unconnected_filter_state();
     test_media_types();
     test_connect_pin();
-    test_basefilter();
 
     CoUninitialize();
 }
From f6f1983be8c332911bf45277650f9f401a56e7f1 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 17 Jul 2020 14:51:21 -0500
Subject: [PATCH] quartz/dsoundrender: Do not send quality messages.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/dsoundrender.c       | 18 +-----------------
 dlls/quartz/tests/dsoundrender.c |  8 ++++++++
 2 files changed, 9 insertions(+), 17 deletions(-)

diff --git a/dlls/quartz/dsoundrender.c b/dlls/quartz/dsoundrender.c
index 225c1e07b96..fba206ecb60 100644
--- a/dlls/quartz/dsoundrender.c
+++ b/dlls/quartz/dsoundrender.c
@@ -360,23 +360,7 @@ static HRESULT WINAPI DSoundRender_DoRenderSample(struct strmbase_renderer *ifac
     cbSrcStream = IMediaSample_GetActualDataLength(pSample);
     TRACE("Sample data ptr = %p, size = %d\n", pbSrcStream, cbSrcStream);
 
-    hr = DSoundRender_SendSampleData(This, tStart, tStop, pbSrcStream, cbSrcStream);
-    if (This->renderer.filter.state == State_Running && This->renderer.filter.clock && tStart >= 0) {
-        REFERENCE_TIME jitter, now = 0;
-        Quality q;
-        IReferenceClock_GetTime(This->renderer.filter.clock, &now);
-        jitter = now - This->renderer.stream_start - tStart;
-        if (jitter <= -DSoundRenderer_Max_Fill)
-            jitter += DSoundRenderer_Max_Fill;
-        else if (jitter < 0)
-            jitter = 0;
-        q.Type = (jitter > 0 ? Famine : Flood);
-        q.Proportion = 1000;
-        q.Late = jitter;
-        q.TimeStamp = tStart;
-        IQualityControl_Notify((IQualityControl *)This->renderer.qcimpl, &This->renderer.filter.IBaseFilter_iface, q);
-    }
-    return hr;
+    return DSoundRender_SendSampleData(This, tStart, tStop, pbSrcStream, cbSrcStream);
 }
 
 static HRESULT WINAPI DSoundRender_CheckMediaType(struct strmbase_renderer *iface, const AM_MEDIA_TYPE * pmt)
diff --git a/dlls/quartz/tests/dsoundrender.c b/dlls/quartz/tests/dsoundrender.c
index 35f935bcad5..0e7fed4c259 100644
--- a/dlls/quartz/tests/dsoundrender.c
+++ b/dlls/quartz/tests/dsoundrender.c
@@ -613,6 +613,13 @@ static const struct strmbase_filter_ops testfilter_ops =
     .filter_destroy = testfilter_destroy,
 };
 
+static HRESULT testsource_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
+{
+    todo_wine_if (IsEqualGUID(iid, &IID_IQualityControl))
+        ok(!IsEqualGUID(iid, &IID_IQualityControl), "Unexpected query for IQualityControl.\n");
+    return E_NOINTERFACE;
+}
+
 static HRESULT WINAPI testsource_DecideAllocator(struct strmbase_source *iface,
         IMemInputPin *peer, IMemAllocator **allocator)
 {
@@ -621,6 +628,7 @@ static HRESULT WINAPI testsource_DecideAllocator(struct strmbase_source *iface,
 
 static const struct strmbase_source_ops testsource_ops =
 {
+    .base.pin_query_interface = testsource_query_interface,
     .pfnAttemptConnection = BaseOutputPinImpl_AttemptConnection,
     .pfnDecideAllocator = testsource_DecideAllocator,
 };
From a881a730b0624637814a419e30215dde94b7a81d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 17 Jul 2020 14:51:22 -0500
Subject: [PATCH] strmbase: Get rid of the QualityControlImpl typedef.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/strmbase/qualitycontrol.c   | 32 ++++++++++++++++----------------
 dlls/strmbase/strmbase_private.h | 17 +++++++++--------
 include/wine/strmbase.h          |  2 +-
 3 files changed, 26 insertions(+), 25 deletions(-)

diff --git a/dlls/strmbase/qualitycontrol.c b/dlls/strmbase/qualitycontrol.c
index 763108d46ac..918757caa81 100644
--- a/dlls/strmbase/qualitycontrol.c
+++ b/dlls/strmbase/qualitycontrol.c
@@ -27,10 +27,10 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(strmbase_qc);
 
-HRESULT QualityControlImpl_Create(struct strmbase_pin *pin, QualityControlImpl **ppv)
+HRESULT QualityControlImpl_Create(struct strmbase_pin *pin, struct strmbase_qc **ppv)
 {
-    QualityControlImpl *This;
-    *ppv = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(QualityControlImpl));
+    struct strmbase_qc *This;
+    *ppv = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(struct strmbase_qc));
     if (!*ppv)
         return E_OUTOFMEMORY;
     This = *ppv;
@@ -41,37 +41,37 @@ HRESULT QualityControlImpl_Create(struct strmbase_pin *pin, QualityControlImpl *
     return S_OK;
 }
 
-void QualityControlImpl_Destroy(QualityControlImpl *This)
+void QualityControlImpl_Destroy(struct strmbase_qc *This)
 {
     HeapFree(GetProcessHeap(),0,This);
 }
 
-static inline QualityControlImpl *impl_from_IQualityControl(IQualityControl *iface)
+static inline struct strmbase_qc *impl_from_IQualityControl(IQualityControl *iface)
 {
-    return CONTAINING_RECORD(iface, QualityControlImpl, IQualityControl_iface);
+    return CONTAINING_RECORD(iface, struct strmbase_qc, IQualityControl_iface);
 }
 
 HRESULT WINAPI QualityControlImpl_QueryInterface(IQualityControl *iface, REFIID riid, void **ppv)
 {
-    QualityControlImpl *This = impl_from_IQualityControl(iface);
+    struct strmbase_qc *This = impl_from_IQualityControl(iface);
     return IBaseFilter_QueryInterface(&This->pin->filter->IBaseFilter_iface, riid, ppv);
 }
 
 ULONG WINAPI QualityControlImpl_AddRef(IQualityControl *iface)
 {
-    QualityControlImpl *This = impl_from_IQualityControl(iface);
+    struct strmbase_qc *This = impl_from_IQualityControl(iface);
     return IBaseFilter_AddRef(&This->pin->filter->IBaseFilter_iface);
 }
 
 ULONG WINAPI QualityControlImpl_Release(IQualityControl *iface)
 {
-    QualityControlImpl *This = impl_from_IQualityControl(iface);
+    struct strmbase_qc *This = impl_from_IQualityControl(iface);
     return IBaseFilter_Release(&This->pin->filter->IBaseFilter_iface);
 }
 
 HRESULT WINAPI QualityControlImpl_Notify(IQualityControl *iface, IBaseFilter *sender, Quality qm)
 {
-    QualityControlImpl *This = impl_from_IQualityControl(iface);
+    struct strmbase_qc *This = impl_from_IQualityControl(iface);
     HRESULT hr = S_FALSE;
 
     TRACE("iface %p, sender %p, type %#x, proportion %u, late %s, timestamp %s.\n",
@@ -96,7 +96,7 @@ HRESULT WINAPI QualityControlImpl_Notify(IQualityControl *iface, IBaseFilter *se
 
 HRESULT WINAPI QualityControlImpl_SetSink(IQualityControl *iface, IQualityControl *tonotify)
 {
-    QualityControlImpl *This = impl_from_IQualityControl(iface);
+    struct strmbase_qc *This = impl_from_IQualityControl(iface);
     TRACE("%p %p\n", This, tonotify);
     This->tonotify = tonotify;
     return S_OK;
@@ -114,7 +114,7 @@ HRESULT WINAPI QualityControlImpl_SetSink(IQualityControl *iface, IQualityContro
 #define UPDATE_RUNNING_AVG_P(avg,val) DO_RUNNING_AVG(avg,val,16)
 #define UPDATE_RUNNING_AVG_N(avg,val) DO_RUNNING_AVG(avg,val,4)
 
-void QualityControlRender_Start(QualityControlImpl *This, REFERENCE_TIME tStart)
+void QualityControlRender_Start(struct strmbase_qc *This, REFERENCE_TIME tStart)
 {
     This->avg_render = This->last_in_time = This->last_left = This->avg_duration = This->avg_pt = -1;
     This->clockstart = tStart;
@@ -124,7 +124,7 @@ void QualityControlRender_Start(QualityControlImpl *This, REFERENCE_TIME tStart)
     This->qos_handled = TRUE; /* Lie that will be corrected on first adjustment */
 }
 
-static BOOL QualityControlRender_IsLate(QualityControlImpl *This, REFERENCE_TIME jitter,
+static BOOL QualityControlRender_IsLate(struct strmbase_qc *This, REFERENCE_TIME jitter,
                                         REFERENCE_TIME start, REFERENCE_TIME stop)
 {
     REFERENCE_TIME max_lateness = 200000;
@@ -153,7 +153,7 @@ static BOOL QualityControlRender_IsLate(QualityControlImpl *This, REFERENCE_TIME
     return FALSE;
 }
 
-void QualityControlRender_DoQOS(QualityControlImpl *priv)
+void QualityControlRender_DoQOS(struct strmbase_qc *priv)
 {
     REFERENCE_TIME start, stop, jitter, pt, entered, left, duration;
     double rate;
@@ -266,7 +266,7 @@ void QualityControlRender_DoQOS(QualityControlImpl *priv)
 }
 
 
-void QualityControlRender_BeginRender(QualityControlImpl *This, REFERENCE_TIME start, REFERENCE_TIME stop)
+void QualityControlRender_BeginRender(struct strmbase_qc *This, REFERENCE_TIME start, REFERENCE_TIME stop)
 {
     This->start = -1;
 
@@ -299,7 +299,7 @@ void QualityControlRender_BeginRender(QualityControlImpl *This, REFERENCE_TIME s
     TRACE("Starting at %s.\n", debugstr_time(This->start));
 }
 
-void QualityControlRender_EndRender(QualityControlImpl *This)
+void QualityControlRender_EndRender(struct strmbase_qc *This)
 {
     REFERENCE_TIME elapsed;
 
diff --git a/dlls/strmbase/strmbase_private.h b/dlls/strmbase/strmbase_private.h
index 0a23592bd28..8df1cac71eb 100644
--- a/dlls/strmbase/strmbase_private.h
+++ b/dlls/strmbase/strmbase_private.h
@@ -54,7 +54,8 @@ static inline const char *debugstr_time(REFERENCE_TIME time)
 }
 
 /* Quality Control */
-typedef struct QualityControlImpl {
+struct strmbase_qc
+{
     IQualityControl IQualityControl_iface;
     struct strmbase_pin *pin;
     IQualityControl *tonotify;
@@ -65,20 +66,20 @@ typedef struct QualityControlImpl {
     double avg_rate;
     LONG64 rendered, dropped;
     BOOL qos_handled, is_dropped;
-} QualityControlImpl;
+};
 
-HRESULT QualityControlImpl_Create(struct strmbase_pin *pin, QualityControlImpl **out);
-void QualityControlImpl_Destroy(QualityControlImpl *This);
+HRESULT QualityControlImpl_Create(struct strmbase_pin *pin, struct strmbase_qc **out);
+void QualityControlImpl_Destroy(struct strmbase_qc *qc);
 HRESULT WINAPI QualityControlImpl_QueryInterface(IQualityControl *iface, REFIID riid, void **ppv);
 ULONG WINAPI QualityControlImpl_AddRef(IQualityControl *iface);
 ULONG WINAPI QualityControlImpl_Release(IQualityControl *iface);
 HRESULT WINAPI QualityControlImpl_Notify(IQualityControl *iface, IBaseFilter *sender, Quality qm);
 HRESULT WINAPI QualityControlImpl_SetSink(IQualityControl *iface, IQualityControl *tonotify);
 
-void QualityControlRender_Start(QualityControlImpl *This, REFERENCE_TIME tStart);
-void QualityControlRender_DoQOS(QualityControlImpl *priv);
-void QualityControlRender_BeginRender(QualityControlImpl *This, REFERENCE_TIME start, REFERENCE_TIME stop);
-void QualityControlRender_EndRender(QualityControlImpl *This);
+void QualityControlRender_Start(struct strmbase_qc *This, REFERENCE_TIME tStart);
+void QualityControlRender_DoQOS(struct strmbase_qc *priv);
+void QualityControlRender_BeginRender(struct strmbase_qc *This, REFERENCE_TIME start, REFERENCE_TIME stop);
+void QualityControlRender_EndRender(struct strmbase_qc *This);
 
 void strmbase_passthrough_update_time(struct strmbase_passthrough *passthrough, REFERENCE_TIME time);
 void strmbase_passthrough_invalidate_time(struct strmbase_passthrough *passthrough);
diff --git a/include/wine/strmbase.h b/include/wine/strmbase.h
index 02a5469de17..b0fa68ecf10 100644
--- a/include/wine/strmbase.h
+++ b/include/wine/strmbase.h
@@ -291,7 +291,7 @@ struct strmbase_renderer
     REFERENCE_TIME stream_start;
 
     IQualityControl *pQSink;
-    struct QualityControlImpl *qcimpl;
+    struct strmbase_qc *qcimpl;
 
     const struct strmbase_renderer_ops *pFuncsTable;
 
From 461a928f14fffe74c3de0adb626212c315b504de Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 17 Jul 2020 14:51:23 -0500
Subject: [PATCH] strmbase: Set the IQualityControl vtbl in
 QualityControlImpl_Create().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/strmbase/qualitycontrol.c   | 48 +++++++++++++++++++-------------
 dlls/strmbase/renderer.c         |  9 ------
 dlls/strmbase/strmbase_private.h |  5 ----
 3 files changed, 29 insertions(+), 33 deletions(-)

diff --git a/dlls/strmbase/qualitycontrol.c b/dlls/strmbase/qualitycontrol.c
index 918757caa81..c4e055858ef 100644
--- a/dlls/strmbase/qualitycontrol.c
+++ b/dlls/strmbase/qualitycontrol.c
@@ -27,20 +27,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(strmbase_qc);
 
-HRESULT QualityControlImpl_Create(struct strmbase_pin *pin, struct strmbase_qc **ppv)
-{
-    struct strmbase_qc *This;
-    *ppv = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(struct strmbase_qc));
-    if (!*ppv)
-        return E_OUTOFMEMORY;
-    This = *ppv;
-    This->pin = pin;
-    This->tonotify = NULL;
-    This->current_rstart = This->current_rstop = -1;
-    TRACE("-> %p\n", This);
-    return S_OK;
-}
-
 void QualityControlImpl_Destroy(struct strmbase_qc *This)
 {
     HeapFree(GetProcessHeap(),0,This);
@@ -51,25 +37,25 @@ static inline struct strmbase_qc *impl_from_IQualityControl(IQualityControl *ifa
     return CONTAINING_RECORD(iface, struct strmbase_qc, IQualityControl_iface);
 }
 
-HRESULT WINAPI QualityControlImpl_QueryInterface(IQualityControl *iface, REFIID riid, void **ppv)
+static HRESULT WINAPI quality_control_QueryInterface(IQualityControl *iface, REFIID riid, void **ppv)
 {
     struct strmbase_qc *This = impl_from_IQualityControl(iface);
     return IBaseFilter_QueryInterface(&This->pin->filter->IBaseFilter_iface, riid, ppv);
 }
 
-ULONG WINAPI QualityControlImpl_AddRef(IQualityControl *iface)
+static ULONG WINAPI quality_control_AddRef(IQualityControl *iface)
 {
     struct strmbase_qc *This = impl_from_IQualityControl(iface);
     return IBaseFilter_AddRef(&This->pin->filter->IBaseFilter_iface);
 }
 
-ULONG WINAPI QualityControlImpl_Release(IQualityControl *iface)
+static ULONG WINAPI quality_control_Release(IQualityControl *iface)
 {
     struct strmbase_qc *This = impl_from_IQualityControl(iface);
     return IBaseFilter_Release(&This->pin->filter->IBaseFilter_iface);
 }
 
-HRESULT WINAPI QualityControlImpl_Notify(IQualityControl *iface, IBaseFilter *sender, Quality qm)
+static HRESULT WINAPI quality_control_Notify(IQualityControl *iface, IBaseFilter *sender, Quality qm)
 {
     struct strmbase_qc *This = impl_from_IQualityControl(iface);
     HRESULT hr = S_FALSE;
@@ -94,7 +80,7 @@ HRESULT WINAPI QualityControlImpl_Notify(IQualityControl *iface, IBaseFilter *se
     return hr;
 }
 
-HRESULT WINAPI QualityControlImpl_SetSink(IQualityControl *iface, IQualityControl *tonotify)
+static HRESULT WINAPI quality_control_SetSink(IQualityControl *iface, IQualityControl *tonotify)
 {
     struct strmbase_qc *This = impl_from_IQualityControl(iface);
     TRACE("%p %p\n", This, tonotify);
@@ -102,6 +88,15 @@ HRESULT WINAPI QualityControlImpl_SetSink(IQualityControl *iface, IQualityContro
     return S_OK;
 }
 
+static const IQualityControlVtbl quality_control_vtbl =
+{
+    quality_control_QueryInterface,
+    quality_control_AddRef,
+    quality_control_Release,
+    quality_control_Notify,
+    quality_control_SetSink,
+};
+
 /* Macros copied from gstreamer, weighted average between old average and new ones */
 #define DO_RUNNING_AVG(avg,val,size) (((val) + ((size)-1) * (avg)) / (size))
 
@@ -317,3 +312,18 @@ void QualityControlRender_EndRender(struct strmbase_qc *This)
     else
         This->avg_render = UPDATE_RUNNING_AVG (This->avg_render, elapsed);
 }
+
+HRESULT QualityControlImpl_Create(struct strmbase_pin *pin, struct strmbase_qc **ppv)
+{
+    struct strmbase_qc *This;
+    *ppv = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(struct strmbase_qc));
+    if (!*ppv)
+        return E_OUTOFMEMORY;
+    This = *ppv;
+    This->pin = pin;
+    This->tonotify = NULL;
+    This->current_rstart = This->current_rstop = -1;
+    This->IQualityControl_iface.lpVtbl = &quality_control_vtbl;
+    TRACE("-> %p\n", This);
+    return S_OK;
+}
diff --git a/dlls/strmbase/renderer.c b/dlls/strmbase/renderer.c
index f1e74f64764..3895cb31194 100644
--- a/dlls/strmbase/renderer.c
+++ b/dlls/strmbase/renderer.c
@@ -27,14 +27,6 @@ static inline struct strmbase_renderer *impl_from_strmbase_filter(struct strmbas
     return CONTAINING_RECORD(iface, struct strmbase_renderer, filter);
 }
 
-static const IQualityControlVtbl Renderer_QualityControl_Vtbl = {
-    QualityControlImpl_QueryInterface,
-    QualityControlImpl_AddRef,
-    QualityControlImpl_Release,
-    QualityControlImpl_Notify,
-    QualityControlImpl_SetSink
-};
-
 static inline struct strmbase_renderer *impl_from_IPin(IPin *iface)
 {
     return CONTAINING_RECORD(iface, struct strmbase_renderer, sink.pin.IPin_iface);
@@ -406,5 +398,4 @@ void strmbase_renderer_init(struct strmbase_renderer *filter, IUnknown *outer,
     filter->flush_event = CreateEventW(NULL, TRUE, TRUE, NULL);
 
     QualityControlImpl_Create(&filter->sink.pin, &filter->qcimpl);
-    filter->qcimpl->IQualityControl_iface.lpVtbl = &Renderer_QualityControl_Vtbl;
 }
diff --git a/dlls/strmbase/strmbase_private.h b/dlls/strmbase/strmbase_private.h
index 8df1cac71eb..15be9498e7d 100644
--- a/dlls/strmbase/strmbase_private.h
+++ b/dlls/strmbase/strmbase_private.h
@@ -70,11 +70,6 @@ struct strmbase_qc
 
 HRESULT QualityControlImpl_Create(struct strmbase_pin *pin, struct strmbase_qc **out);
 void QualityControlImpl_Destroy(struct strmbase_qc *qc);
-HRESULT WINAPI QualityControlImpl_QueryInterface(IQualityControl *iface, REFIID riid, void **ppv);
-ULONG WINAPI QualityControlImpl_AddRef(IQualityControl *iface);
-ULONG WINAPI QualityControlImpl_Release(IQualityControl *iface);
-HRESULT WINAPI QualityControlImpl_Notify(IQualityControl *iface, IBaseFilter *sender, Quality qm);
-HRESULT WINAPI QualityControlImpl_SetSink(IQualityControl *iface, IQualityControl *tonotify);
 
 void QualityControlRender_Start(struct strmbase_qc *This, REFERENCE_TIME tStart);
 void QualityControlRender_DoQOS(struct strmbase_qc *priv);
From a9fbbda429f28ba74de207b1bd2fd1ce32133bfb Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 17 Jul 2020 14:51:24 -0500
Subject: [PATCH] strmbase: Store the quality control object directly in
 strmbase_renderer.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/strmbase/qualitycontrol.c   | 22 +++++-----------------
 dlls/strmbase/renderer.c         | 16 +++++++---------
 dlls/strmbase/strmbase_private.h | 18 ------------------
 include/wine/strmbase.h          | 20 +++++++++++++++++---
 4 files changed, 29 insertions(+), 47 deletions(-)

diff --git a/dlls/strmbase/qualitycontrol.c b/dlls/strmbase/qualitycontrol.c
index c4e055858ef..d0bd070d447 100644
--- a/dlls/strmbase/qualitycontrol.c
+++ b/dlls/strmbase/qualitycontrol.c
@@ -27,11 +27,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(strmbase_qc);
 
-void QualityControlImpl_Destroy(struct strmbase_qc *This)
-{
-    HeapFree(GetProcessHeap(),0,This);
-}
-
 static inline struct strmbase_qc *impl_from_IQualityControl(IQualityControl *iface)
 {
     return CONTAINING_RECORD(iface, struct strmbase_qc, IQualityControl_iface);
@@ -313,17 +308,10 @@ void QualityControlRender_EndRender(struct strmbase_qc *This)
         This->avg_render = UPDATE_RUNNING_AVG (This->avg_render, elapsed);
 }
 
-HRESULT QualityControlImpl_Create(struct strmbase_pin *pin, struct strmbase_qc **ppv)
+void strmbase_qc_init(struct strmbase_qc *qc, struct strmbase_pin *pin)
 {
-    struct strmbase_qc *This;
-    *ppv = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(struct strmbase_qc));
-    if (!*ppv)
-        return E_OUTOFMEMORY;
-    This = *ppv;
-    This->pin = pin;
-    This->tonotify = NULL;
-    This->current_rstart = This->current_rstop = -1;
-    This->IQualityControl_iface.lpVtbl = &quality_control_vtbl;
-    TRACE("-> %p\n", This);
-    return S_OK;
+    memset(qc, 0, sizeof(*qc));
+    qc->pin = pin;
+    qc->current_rstart = qc->current_rstop = -1;
+    qc->IQualityControl_iface.lpVtbl = &quality_control_vtbl;
 }
diff --git a/dlls/strmbase/renderer.c b/dlls/strmbase/renderer.c
index 3895cb31194..939811bfa90 100644
--- a/dlls/strmbase/renderer.c
+++ b/dlls/strmbase/renderer.c
@@ -63,7 +63,7 @@ static HRESULT renderer_query_interface(struct strmbase_filter *iface, REFIID ii
     else if (IsEqualGUID(iid, &IID_IMediaSeeking))
         *out = &filter->passthrough.IMediaSeeking_iface;
     else if (IsEqualGUID(iid, &IID_IQualityControl))
-        *out = &filter->qcimpl->IQualityControl_iface;
+        *out = &filter->qc.IQualityControl_iface;
     else
         return E_NOINTERFACE;
 
@@ -93,7 +93,7 @@ static HRESULT renderer_start_stream(struct strmbase_filter *iface, REFERENCE_TI
     SetEvent(filter->state_event);
     if (filter->sink.pin.peer)
         filter->eos = FALSE;
-    QualityControlRender_Start(filter->qcimpl, filter->stream_start);
+    QualityControlRender_Start(&filter->qc, filter->stream_start);
     if (filter->sink.pin.peer && filter->pFuncsTable->renderer_start_stream)
         filter->pFuncsTable->renderer_start_stream(filter);
 
@@ -234,7 +234,7 @@ static HRESULT sink_end_flush(struct strmbase_sink *iface)
     EnterCriticalSection(&filter->csRenderLock);
 
     filter->eos = FALSE;
-    QualityControlRender_Start(filter->qcimpl, filter->stream_start);
+    QualityControlRender_Start(&filter->qc, filter->stream_start);
     strmbase_passthrough_invalidate_time(&filter->passthrough);
     ResetEvent(filter->flush_event);
 
@@ -272,7 +272,6 @@ void strmbase_renderer_cleanup(struct strmbase_renderer *filter)
     CloseHandle(filter->state_event);
     CloseHandle(filter->advise_event);
     CloseHandle(filter->flush_event);
-    QualityControlImpl_Destroy(filter->qcimpl);
     strmbase_filter_cleanup(&filter->filter);
 }
 
@@ -367,12 +366,12 @@ HRESULT WINAPI BaseRendererImpl_Receive(struct strmbase_renderer *This, IMediaSa
 
     if (SUCCEEDED(hr))
     {
-        QualityControlRender_BeginRender(This->qcimpl, start, stop);
+        QualityControlRender_BeginRender(&This->qc, start, stop);
         hr = This->pFuncsTable->pfnDoRenderSample(This, pSample);
-        QualityControlRender_EndRender(This->qcimpl);
+        QualityControlRender_EndRender(&This->qc);
     }
 
-    QualityControlRender_DoQOS(This->qcimpl);
+    QualityControlRender_DoQOS(&This->qc);
 
     LeaveCriticalSection(&This->csRenderLock);
 
@@ -386,6 +385,7 @@ void strmbase_renderer_init(struct strmbase_renderer *filter, IUnknown *outer,
     strmbase_filter_init(&filter->filter, outer, clsid, &filter_ops);
     strmbase_passthrough_init(&filter->passthrough, (IUnknown *)&filter->filter.IBaseFilter_iface);
     ISeekingPassThru_Init(&filter->passthrough.ISeekingPassThru_iface, TRUE, &filter->sink.pin.IPin_iface);
+    strmbase_qc_init(&filter->qc, &filter->sink.pin);
 
     filter->pFuncsTable = ops;
 
@@ -396,6 +396,4 @@ void strmbase_renderer_init(struct strmbase_renderer *filter, IUnknown *outer,
     filter->state_event = CreateEventW(NULL, TRUE, TRUE, NULL);
     filter->advise_event = CreateEventW(NULL, FALSE, FALSE, NULL);
     filter->flush_event = CreateEventW(NULL, TRUE, TRUE, NULL);
-
-    QualityControlImpl_Create(&filter->sink.pin, &filter->qcimpl);
 }
diff --git a/dlls/strmbase/strmbase_private.h b/dlls/strmbase/strmbase_private.h
index 15be9498e7d..d589213b713 100644
--- a/dlls/strmbase/strmbase_private.h
+++ b/dlls/strmbase/strmbase_private.h
@@ -53,24 +53,6 @@ static inline const char *debugstr_time(REFERENCE_TIME time)
     return wine_dbg_sprintf("%s", rev);
 }
 
-/* Quality Control */
-struct strmbase_qc
-{
-    IQualityControl IQualityControl_iface;
-    struct strmbase_pin *pin;
-    IQualityControl *tonotify;
-
-    /* Render stuff */
-    REFERENCE_TIME last_in_time, last_left, avg_duration, avg_pt, avg_render, start, stop;
-    REFERENCE_TIME current_jitter, current_rstart, current_rstop, clockstart;
-    double avg_rate;
-    LONG64 rendered, dropped;
-    BOOL qos_handled, is_dropped;
-};
-
-HRESULT QualityControlImpl_Create(struct strmbase_pin *pin, struct strmbase_qc **out);
-void QualityControlImpl_Destroy(struct strmbase_qc *qc);
-
 void QualityControlRender_Start(struct strmbase_qc *This, REFERENCE_TIME tStart);
 void QualityControlRender_DoQOS(struct strmbase_qc *priv);
 void QualityControlRender_BeginRender(struct strmbase_qc *This, REFERENCE_TIME start, REFERENCE_TIME stop);
diff --git a/include/wine/strmbase.h b/include/wine/strmbase.h
index b0fa68ecf10..2e84edb7cdd 100644
--- a/include/wine/strmbase.h
+++ b/include/wine/strmbase.h
@@ -271,10 +271,27 @@ struct strmbase_passthrough
 void strmbase_passthrough_init(struct strmbase_passthrough *passthrough, IUnknown *outer);
 void strmbase_passthrough_cleanup(struct strmbase_passthrough *passthrough);
 
+struct strmbase_qc
+{
+    IQualityControl IQualityControl_iface;
+    struct strmbase_pin *pin;
+    IQualityControl *tonotify;
+
+    /* Render stuff */
+    REFERENCE_TIME last_in_time, last_left, avg_duration, avg_pt, avg_render, start, stop;
+    REFERENCE_TIME current_jitter, current_rstart, current_rstop, clockstart;
+    double avg_rate;
+    LONG64 rendered, dropped;
+    BOOL qos_handled, is_dropped;
+};
+
+void strmbase_qc_init(struct strmbase_qc *qc, struct strmbase_pin *pin);
+
 struct strmbase_renderer
 {
     struct strmbase_filter filter;
     struct strmbase_passthrough passthrough;
+    struct strmbase_qc qc;
 
     struct strmbase_sink sink;
 
@@ -290,9 +307,6 @@ struct strmbase_renderer
     HANDLE flush_event;
     REFERENCE_TIME stream_start;
 
-    IQualityControl *pQSink;
-    struct strmbase_qc *qcimpl;
-
     const struct strmbase_renderer_ops *pFuncsTable;
 
     BOOL eos;
From 72f94724922e4db4fb932e404f2f642fef0642e2 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 20 Jul 2020 10:25:27 -0500
Subject: [PATCH] quartz/videorenderer: Render preroll samples.

The documentation specifies that preroll samples shouldn't be rendered, but
the video renderer renders them anyway.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/videorenderer.c |  3 +++
 dlls/quartz/videorenderer.c       | 10 ----------
 2 files changed, 3 insertions(+), 10 deletions(-)

diff --git a/dlls/quartz/tests/videorenderer.c b/dlls/quartz/tests/videorenderer.c
index 4ae320e0225..ac2cadc4b17 100644
--- a/dlls/quartz/tests/videorenderer.c
+++ b/dlls/quartz/tests/videorenderer.c
@@ -797,6 +797,9 @@ static HANDLE send_frame_time(IMemInputPin *sink, REFERENCE_TIME start_time, uns
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
+    hr = IMediaSample_SetPreroll(sample, TRUE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
     params->sink = sink;
     params->sample = sample;
     thread = CreateThread(NULL, 0, frame_thread, params, 0, NULL);
diff --git a/dlls/quartz/videorenderer.c b/dlls/quartz/videorenderer.c
index f635d9eaac0..eb6accf2d34 100644
--- a/dlls/quartz/videorenderer.c
+++ b/dlls/quartz/videorenderer.c
@@ -82,15 +82,6 @@ static void VideoRenderer_AutoShowWindow(struct video_renderer *This)
         ShowWindow(This->window.hwnd, SW_SHOW);
 }
 
-static HRESULT WINAPI VideoRenderer_ShouldDrawSampleNow(struct strmbase_renderer *filter,
-        IMediaSample *pSample, REFERENCE_TIME *start, REFERENCE_TIME *end)
-{
-    /* Preroll means the sample isn't shown, this is used for key frames and things like that */
-    if (IMediaSample_IsPreroll(pSample) == S_OK)
-        return E_FAIL;
-    return S_FALSE;
-}
-
 static HRESULT WINAPI VideoRenderer_DoRenderSample(struct strmbase_renderer *iface, IMediaSample *pSample)
 {
     struct video_renderer *filter = impl_from_strmbase_renderer(iface);
@@ -253,7 +244,6 @@ static const struct strmbase_renderer_ops renderer_ops =
     .renderer_init_stream = video_renderer_init_stream,
     .renderer_start_stream = video_renderer_start_stream,
     .renderer_stop_stream = video_renderer_stop_stream,
-    .pfnShouldDrawSampleNow = VideoRenderer_ShouldDrawSampleNow,
     .renderer_destroy = video_renderer_destroy,
     .renderer_query_interface = video_renderer_query_interface,
     .renderer_pin_query_interface = video_renderer_pin_query_interface,
From b9063c4b7e73d5fad19741c3ec0c485ca0e5b499 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 20 Jul 2020 10:25:28 -0500
Subject: [PATCH] quartz/vmr9: Render preroll samples.

The documentation specifies that preroll samples shouldn't be rendered, but
the VMR9 renders them anyway.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr7.c |  3 +++
 dlls/quartz/tests/vmr9.c |  3 +++
 dlls/quartz/vmr9.c       | 16 ----------------
 3 files changed, 6 insertions(+), 16 deletions(-)

diff --git a/dlls/quartz/tests/vmr7.c b/dlls/quartz/tests/vmr7.c
index cf4675ce069..f1b19aa6634 100644
--- a/dlls/quartz/tests/vmr7.c
+++ b/dlls/quartz/tests/vmr7.c
@@ -983,6 +983,9 @@ static HANDLE send_frame(IMemInputPin *sink)
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
+    hr = IMediaSample_SetPreroll(sample, TRUE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
     params->sink = sink;
     params->sample = sample;
     thread = CreateThread(NULL, 0, frame_thread, params, 0, NULL);
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index cd4df58f791..e630deb8d74 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -1011,6 +1011,9 @@ static HANDLE send_frame_time(IMemInputPin *sink, REFERENCE_TIME start_time, DWO
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
+    hr = IMediaSample_SetPreroll(sample, TRUE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
     params->sink = sink;
     params->sample = sample;
     thread = CreateThread(NULL, 0, frame_thread, params, 0, NULL);
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index aeaefd52c6b..a3f55011062 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -244,12 +244,6 @@ static HRESULT WINAPI VMR9_DoRenderSample(struct strmbase_renderer *iface, IMedi
     if (IMediaSample_IsSyncPoint(sample) == S_OK)
         info.dwFlags |= VMR9Sample_SyncPoint;
 
-    /* If we render ourselves, and this is a preroll sample, discard it */
-    if (info.dwFlags & VMR9Sample_Preroll)
-    {
-        return S_OK;
-    }
-
     if (FAILED(hr = IMediaSample_GetPointer(sample, &data)))
     {
         ERR("Failed to get pointer to sample data, hr %#x.\n", hr);
@@ -504,15 +498,6 @@ static void vmr_stop_stream(struct strmbase_renderer *iface)
     ResetEvent(This->run_event);
 }
 
-static HRESULT WINAPI VMR9_ShouldDrawSampleNow(struct strmbase_renderer *iface,
-        IMediaSample *pSample, REFERENCE_TIME *start, REFERENCE_TIME *end)
-{
-    /* Preroll means the sample isn't shown, this is used for key frames and things like that */
-    if (IMediaSample_IsPreroll(pSample) == S_OK)
-        return E_FAIL;
-    return S_FALSE;
-}
-
 static HRESULT vmr_connect(struct strmbase_renderer *iface, const AM_MEDIA_TYPE *mt)
 {
     struct quartz_vmr *filter = impl_from_IBaseFilter(&iface->filter.IBaseFilter_iface);
@@ -668,7 +653,6 @@ static const struct strmbase_renderer_ops renderer_ops =
     .renderer_init_stream = vmr_init_stream,
     .renderer_start_stream = vmr_start_stream,
     .renderer_stop_stream = vmr_stop_stream,
-    .pfnShouldDrawSampleNow = VMR9_ShouldDrawSampleNow,
     .renderer_connect = vmr_connect,
     .pfnBreakConnect = VMR9_BreakConnect,
     .renderer_destroy = vmr_destroy,
From 9f467402df4c9fb0a4e20ccd35d86d817936a8c5 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 20 Jul 2020 10:25:29 -0500
Subject: [PATCH] quartz/dsoundrender: Reimplement the DirectSound renderer
 directly on top of the strmbase filter.

The DirectSound renderer does a lot of things differently. To a large degree
this is to be expected; it's an audio renderer and therefore needs to buffer
much farther in advance. However, it also doesn't participate in quality
management, doesn't block in Receive(), and has a few other mild differences in
behaviour. Weighing the features implemented by the base renderer against the
quirks necessary for the DirectSound renderer leads me to believe that it would
be easier not to use that framework.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/dsoundrender.c       | 438 +++++++++++++++++++++++--------
 dlls/quartz/tests/dsoundrender.c |   3 +-
 dlls/strmbase/strmbase_private.h |   4 -
 include/wine/strmbase.h          |   4 +
 4 files changed, 333 insertions(+), 116 deletions(-)

diff --git a/dlls/quartz/dsoundrender.c b/dlls/quartz/dsoundrender.c
index fba206ecb60..a3155477fde 100644
--- a/dlls/quartz/dsoundrender.c
+++ b/dlls/quartz/dsoundrender.c
@@ -41,12 +41,25 @@ static const REFERENCE_TIME DSoundRenderer_Max_Fill = 150 * 10000;
 
 struct dsound_render
 {
-    struct strmbase_renderer renderer;
-
-    IBasicAudio IBasicAudio_iface;
+    struct strmbase_filter filter;
+    struct strmbase_passthrough passthrough;
     IAMDirectSound IAMDirectSound_iface;
+    IBasicAudio IBasicAudio_iface;
+    IQualityControl IQualityControl_iface;
     IUnknown *system_clock;
 
+    struct strmbase_sink sink;
+
+    CRITICAL_SECTION stream_cs;
+    /* Signaled when the filter has completed a state change. The filter waits
+     * for this event in IBaseFilter::GetState(). */
+    HANDLE state_event;
+    /* Signaled when a flush or state change occurs, i.e. anything that needs
+     * to immediately unblock the streaming thread. */
+    HANDLE flush_event;
+    REFERENCE_TIME stream_start;
+    BOOL eos;
+
     IDirectSound8 *dsound;
     LPDIRECTSOUNDBUFFER dsbuffer;
     DWORD buf_size;
@@ -59,9 +72,14 @@ struct dsound_render
     LONG pan;
 };
 
-static struct dsound_render *impl_from_strmbase_renderer(struct strmbase_renderer *iface)
+static struct dsound_render *impl_from_strmbase_pin(struct strmbase_pin *iface)
 {
-    return CONTAINING_RECORD(iface, struct dsound_render, renderer);
+    return CONTAINING_RECORD(iface, struct dsound_render, sink.pin);
+}
+
+static struct dsound_render *impl_from_strmbase_filter(struct strmbase_filter *iface)
+{
+    return CONTAINING_RECORD(iface, struct dsound_render, filter);
 }
 
 static struct dsound_render *impl_from_IBasicAudio(IBasicAudio *iface)
@@ -76,7 +94,7 @@ static struct dsound_render *impl_from_IAMDirectSound(IAMDirectSound *iface)
 
 static REFERENCE_TIME time_from_pos(struct dsound_render *This, DWORD pos)
 {
-    WAVEFORMATEX *wfx = (WAVEFORMATEX *)This->renderer.sink.pin.mt.pbFormat;
+    WAVEFORMATEX *wfx = (WAVEFORMATEX *)This->sink.pin.mt.pbFormat;
     REFERENCE_TIME ret = 10000000;
     ret = ret * pos / wfx->nAvgBytesPerSec;
     return ret;
@@ -84,7 +102,7 @@ static REFERENCE_TIME time_from_pos(struct dsound_render *This, DWORD pos)
 
 static DWORD pos_from_time(struct dsound_render *This, REFERENCE_TIME time)
 {
-    WAVEFORMATEX *wfx = (WAVEFORMATEX *)This->renderer.sink.pin.mt.pbFormat;
+    WAVEFORMATEX *wfx = (WAVEFORMATEX *)This->sink.pin.mt.pbFormat;
     REFERENCE_TIME ret = time;
     ret *= wfx->nAvgBytesPerSec;
     ret /= 10000000;
@@ -94,7 +112,7 @@ static DWORD pos_from_time(struct dsound_render *This, REFERENCE_TIME time)
 
 static void DSoundRender_UpdatePositions(struct dsound_render *This, DWORD *seqwritepos, DWORD *minwritepos)
 {
-    WAVEFORMATEX *wfx = (WAVEFORMATEX *)This->renderer.sink.pin.mt.pbFormat;
+    WAVEFORMATEX *wfx = (WAVEFORMATEX *)This->sink.pin.mt.pbFormat;
     BYTE *buf1, *buf2;
     DWORD size1, size2, playpos, writepos, old_writepos, old_playpos, adv;
     BOOL writepos_set = This->writepos < This->buf_size;
@@ -133,17 +151,17 @@ static void DSoundRender_UpdatePositions(struct dsound_render *This, DWORD *seqw
 static HRESULT DSoundRender_GetWritePos(struct dsound_render *This,
         DWORD *ret_writepos, REFERENCE_TIME write_at, DWORD *pfree, DWORD *skip)
 {
-    WAVEFORMATEX *wfx = (WAVEFORMATEX *)This->renderer.sink.pin.mt.pbFormat;
+    WAVEFORMATEX *wfx = (WAVEFORMATEX *)This->sink.pin.mt.pbFormat;
     DWORD writepos, min_writepos, playpos;
     REFERENCE_TIME max_lag = 50 * 10000;
     REFERENCE_TIME cur, writepos_t, delta_t;
 
     DSoundRender_UpdatePositions(This, &writepos, &min_writepos);
     playpos = This->last_playpos;
-    if (This->renderer.filter.clock)
+    if (This->filter.clock)
     {
-        IReferenceClock_GetTime(This->renderer.filter.clock, &cur);
-        cur -= This->renderer.stream_start;
+        IReferenceClock_GetTime(This->filter.clock, &cur);
+        cur -= This->stream_start;
     } else
         write_at = -1;
 
@@ -212,7 +230,7 @@ static HRESULT DSoundRender_GetWritePos(struct dsound_render *This,
 
 static HRESULT DSoundRender_HandleEndOfStream(struct dsound_render *This)
 {
-    while (This->renderer.filter.state == State_Running)
+    while (This->filter.state == State_Running)
     {
         DWORD pos1, pos2;
         DSoundRender_UpdatePositions(This, &pos1, &pos2);
@@ -220,9 +238,9 @@ static HRESULT DSoundRender_HandleEndOfStream(struct dsound_render *This)
             break;
 
         This->in_loop = 1;
-        LeaveCriticalSection(&This->renderer.csRenderLock);
-        WaitForSingleObject(This->renderer.flush_event, 10);
-        EnterCriticalSection(&This->renderer.csRenderLock);
+        LeaveCriticalSection(&This->stream_cs);
+        WaitForSingleObject(This->flush_event, 10);
+        EnterCriticalSection(&This->stream_cs);
         This->in_loop = 0;
     }
 
@@ -234,23 +252,23 @@ static HRESULT DSoundRender_SendSampleData(struct dsound_render *This,
 {
     HRESULT hr;
 
-    while (size && This->renderer.filter.state != State_Stopped) {
+    while (size && This->filter.state != State_Stopped) {
         DWORD writepos, skip = 0, free, size1, size2, ret;
         BYTE *buf1, *buf2;
 
-        if (This->renderer.filter.state == State_Running)
+        if (This->filter.state == State_Running)
             hr = DSoundRender_GetWritePos(This, &writepos, tStart, &free, &skip);
         else
             hr = S_FALSE;
 
         if (hr != S_OK) {
             This->in_loop = 1;
-            LeaveCriticalSection(&This->renderer.csRenderLock);
-            ret = WaitForSingleObject(This->renderer.flush_event, 10);
-            EnterCriticalSection(&This->renderer.csRenderLock);
+            LeaveCriticalSection(&This->stream_cs);
+            ret = WaitForSingleObject(This->flush_event, 10);
+            EnterCriticalSection(&This->stream_cs);
             This->in_loop = 0;
-            if (This->renderer.sink.flushing || This->renderer.filter.state == State_Stopped)
-                return This->renderer.filter.state == State_Paused ? S_OK : VFW_E_WRONG_STATE;
+            if (This->sink.flushing || This->filter.state == State_Stopped)
+                return This->filter.state == State_Paused ? S_OK : VFW_E_WRONG_STATE;
             if (ret != WAIT_TIMEOUT)
                 ERR("%x\n", ret);
             continue;
@@ -281,26 +299,20 @@ static HRESULT DSoundRender_SendSampleData(struct dsound_render *This,
     return S_OK;
 }
 
-static HRESULT WINAPI DSoundRender_ShouldDrawSampleNow(struct strmbase_renderer *iface,
-        IMediaSample *sample, REFERENCE_TIME *start, REFERENCE_TIME *end)
-{
-    /* We time ourselves do not use the base renderers timing */
-    return S_OK;
-}
-
-
-static HRESULT WINAPI DSoundRender_PrepareReceive(struct strmbase_renderer *iface, IMediaSample *pSample)
+static HRESULT WINAPI DSoundRender_PrepareReceive(struct dsound_render *This, IMediaSample *pSample)
 {
-    struct dsound_render *This = impl_from_strmbase_renderer(iface);
     HRESULT hr;
     AM_MEDIA_TYPE *amt;
 
     if (IMediaSample_GetMediaType(pSample, &amt) == S_OK)
     {
-        AM_MEDIA_TYPE *orig = &This->renderer.sink.pin.mt;
+        AM_MEDIA_TYPE *orig = &This->sink.pin.mt;
         WAVEFORMATEX *origfmt = (WAVEFORMATEX *)orig->pbFormat;
         WAVEFORMATEX *newfmt = (WAVEFORMATEX *)amt->pbFormat;
 
+        TRACE("Format change.\n");
+        strmbase_dump_media_type(amt);
+
         if (origfmt->wFormatTag == newfmt->wFormatTag &&
             origfmt->nChannels == newfmt->nChannels &&
             origfmt->nBlockAlign == newfmt->nBlockAlign &&
@@ -324,20 +336,13 @@ static HRESULT WINAPI DSoundRender_PrepareReceive(struct strmbase_renderer *ifac
     return S_OK;
 }
 
-static HRESULT WINAPI DSoundRender_DoRenderSample(struct strmbase_renderer *iface, IMediaSample *pSample)
+static HRESULT WINAPI DSoundRender_DoRenderSample(struct dsound_render *This, IMediaSample *pSample)
 {
-    struct dsound_render *This = impl_from_strmbase_renderer(iface);
     LPBYTE pbSrcStream = NULL;
     LONG cbSrcStream = 0;
     REFERENCE_TIME tStart, tStop;
     HRESULT hr;
 
-    TRACE("%p %p\n", iface, pSample);
-
-    /* Slightly incorrect, Pause completes when a frame is received so we should signal
-     * pause completion here, but for sound playing a single frame doesn't make sense
-     */
-
     hr = IMediaSample_GetPointer(pSample, &pbSrcStream);
     if (FAILED(hr))
     {
@@ -363,39 +368,59 @@ static HRESULT WINAPI DSoundRender_DoRenderSample(struct strmbase_renderer *ifac
     return DSoundRender_SendSampleData(This, tStart, tStop, pbSrcStream, cbSrcStream);
 }
 
-static HRESULT WINAPI DSoundRender_CheckMediaType(struct strmbase_renderer *iface, const AM_MEDIA_TYPE * pmt)
+static HRESULT WINAPI dsound_render_sink_Receive(struct strmbase_sink *iface, IMediaSample *sample)
 {
-    if (!IsEqualIID(&pmt->majortype, &MEDIATYPE_Audio))
+    struct dsound_render *filter = impl_from_strmbase_pin(&iface->pin);
+    REFERENCE_TIME start, stop;
+    HRESULT hr;
+
+    if (filter->eos || filter->sink.flushing)
         return S_FALSE;
 
-    return S_OK;
+    if (filter->filter.state == State_Stopped)
+        return VFW_E_WRONG_STATE;
+
+    if (FAILED(hr = DSoundRender_PrepareReceive(filter, sample)))
+        return hr;
+
+    EnterCriticalSection(&filter->stream_cs);
+
+    if (filter->filter.clock && SUCCEEDED(IMediaSample_GetTime(sample, &start, &stop)))
+        strmbase_passthrough_update_time(&filter->passthrough, start);
+
+    if (filter->filter.state == State_Paused)
+        SetEvent(filter->state_event);
+
+    hr = DSoundRender_DoRenderSample(filter, sample);
+
+    LeaveCriticalSection(&filter->stream_cs);
+    return hr;
 }
 
-static void dsound_render_stop_stream(struct strmbase_renderer *iface)
+static HRESULT dsound_render_sink_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
 {
-    struct dsound_render *This = impl_from_strmbase_renderer(iface);
+    struct dsound_render *filter = impl_from_strmbase_pin(iface);
 
-    TRACE("(%p/%p)->()\n", This, iface);
+    if (IsEqualGUID(iid, &IID_IMemInputPin))
+        *out = &filter->sink.IMemInputPin_iface;
+    else
+        return E_NOINTERFACE;
 
-    IDirectSoundBuffer_Stop(This->dsbuffer);
-    This->writepos = This->buf_size;
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
 }
 
-static void dsound_render_start_stream(struct strmbase_renderer *iface)
+static HRESULT dsound_render_sink_query_accept(struct strmbase_pin *iface, const AM_MEDIA_TYPE * pmt)
 {
-    struct dsound_render *This = impl_from_strmbase_renderer(iface);
-
-    TRACE("(%p)\n", This);
+    if (!IsEqualIID(&pmt->majortype, &MEDIATYPE_Audio))
+        return S_FALSE;
 
-    if (This->renderer.sink.pin.peer)
-    {
-        IDirectSoundBuffer_Play(This->dsbuffer, 0, 0, DSBPLAY_LOOPING);
-    }
+    return S_OK;
 }
 
-static HRESULT dsound_render_connect(struct strmbase_renderer *iface, const AM_MEDIA_TYPE *mt)
+static HRESULT dsound_render_sink_connect(struct strmbase_sink *iface, IPin *peer, const AM_MEDIA_TYPE *mt)
 {
-    struct dsound_render *This = impl_from_strmbase_renderer(iface);
+    struct dsound_render *This = impl_from_strmbase_pin(&iface->pin);
     const WAVEFORMATEX *format = (WAVEFORMATEX *)mt->pbFormat;
     HRESULT hr = S_OK;
     DSBUFFERDESC buf_desc;
@@ -436,47 +461,93 @@ static HRESULT dsound_render_connect(struct strmbase_renderer *iface, const AM_M
     return hr;
 }
 
-static HRESULT WINAPI DSoundRender_BreakConnect(struct strmbase_renderer *iface)
+static void dsound_render_sink_disconnect(struct strmbase_sink *iface)
 {
-    struct dsound_render *This = impl_from_strmbase_renderer(iface);
+    struct dsound_render *This = impl_from_strmbase_pin(&iface->pin);
 
     TRACE("(%p)->()\n", iface);
 
     if (This->dsbuffer)
         IDirectSoundBuffer_Release(This->dsbuffer);
     This->dsbuffer = NULL;
+}
+
+static HRESULT dsound_render_sink_eos(struct strmbase_sink *iface)
+{
+    struct dsound_render *filter = impl_from_strmbase_pin(&iface->pin);
+    IFilterGraph *graph = filter->filter.graph;
+    IMediaEventSink *event_sink;
+
+    EnterCriticalSection(&filter->stream_cs);
 
+    filter->eos = TRUE;
+
+    if (graph && SUCCEEDED(IFilterGraph_QueryInterface(graph,
+            &IID_IMediaEventSink, (void **)&event_sink)))
+    {
+        IMediaEventSink_Notify(event_sink, EC_COMPLETE, S_OK,
+                (LONG_PTR)&filter->filter.IBaseFilter_iface);
+        IMediaEventSink_Release(event_sink);
+    }
+    strmbase_passthrough_eos(&filter->passthrough);
+    SetEvent(filter->state_event);
+
+    DSoundRender_HandleEndOfStream(filter);
+
+    LeaveCriticalSection(&filter->stream_cs);
     return S_OK;
 }
 
-static HRESULT WINAPI DSoundRender_EndOfStream(struct strmbase_renderer *iface)
+static HRESULT dsound_render_sink_begin_flush(struct strmbase_sink *iface)
 {
-    struct dsound_render *This = impl_from_strmbase_renderer(iface);
-    return DSoundRender_HandleEndOfStream(This);
+    struct dsound_render *filter = impl_from_strmbase_pin(&iface->pin);
+
+    SetEvent(filter->flush_event);
+    return S_OK;
 }
 
-static HRESULT WINAPI DSoundRender_EndFlush(struct strmbase_renderer *iface)
+static HRESULT dsound_render_sink_end_flush(struct strmbase_sink *iface)
 {
-    struct dsound_render *This = impl_from_strmbase_renderer(iface);
+    struct dsound_render *filter = impl_from_strmbase_pin(&iface->pin);
 
-    if (This->dsbuffer)
+    EnterCriticalSection(&filter->stream_cs);
+
+    filter->eos = FALSE;
+    strmbase_passthrough_invalidate_time(&filter->passthrough);
+    ResetEvent(filter->flush_event);
+
+    if (filter->dsbuffer)
     {
-        LPBYTE buffer;
+        void *buffer;
         DWORD size;
 
         /* Force a reset */
-        IDirectSoundBuffer_Lock(This->dsbuffer, 0, 0, (LPVOID *)&buffer, &size, NULL, NULL, DSBLOCK_ENTIREBUFFER);
+        IDirectSoundBuffer_Lock(filter->dsbuffer, 0, 0, &buffer, &size, NULL, NULL, DSBLOCK_ENTIREBUFFER);
         memset(buffer, 0, size);
-        IDirectSoundBuffer_Unlock(This->dsbuffer, buffer, size, NULL, 0);
-        This->writepos = This->buf_size;
+        IDirectSoundBuffer_Unlock(filter->dsbuffer, buffer, size, NULL, 0);
+        filter->writepos = filter->buf_size;
     }
 
+    LeaveCriticalSection(&filter->stream_cs);
     return S_OK;
 }
 
-static void dsound_render_destroy(struct strmbase_renderer *iface)
+static const struct strmbase_sink_ops sink_ops =
 {
-    struct dsound_render *filter = impl_from_strmbase_renderer(iface);
+    .base.pin_query_interface = dsound_render_sink_query_interface,
+    .base.pin_query_accept = dsound_render_sink_query_accept,
+    .base.pin_get_media_type = strmbase_pin_get_media_type,
+    .pfnReceive = dsound_render_sink_Receive,
+    .sink_connect = dsound_render_sink_connect,
+    .sink_disconnect = dsound_render_sink_disconnect,
+    .sink_eos = dsound_render_sink_eos,
+    .sink_begin_flush = dsound_render_sink_begin_flush,
+    .sink_end_flush = dsound_render_sink_end_flush,
+};
+
+static void dsound_render_destroy(struct strmbase_filter *iface)
+{
+    struct dsound_render *filter = impl_from_strmbase_filter(iface);
 
     if (filter->dsbuffer)
         IDirectSoundBuffer_Release(filter->dsbuffer);
@@ -485,22 +556,49 @@ static void dsound_render_destroy(struct strmbase_renderer *iface)
         IDirectSound8_Release(filter->dsound);
     filter->dsound = NULL;
 
-    strmbase_renderer_cleanup(&filter->renderer);
+    if (filter->sink.pin.peer)
+        IPin_Disconnect(filter->sink.pin.peer);
+    IPin_Disconnect(&filter->sink.pin.IPin_iface);
+    strmbase_sink_cleanup(&filter->sink);
+
+    filter->stream_cs.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&filter->stream_cs);
+
+    CloseHandle(filter->state_event);
+    CloseHandle(filter->flush_event);
+
+    strmbase_passthrough_cleanup(&filter->passthrough);
+    strmbase_filter_cleanup(&filter->filter);
     free(filter);
 
     InterlockedDecrement(&object_locks);
 }
 
-static HRESULT dsound_render_query_interface(struct strmbase_renderer *iface, REFIID iid, void **out)
+static struct strmbase_pin *dsound_render_get_pin(struct strmbase_filter *iface, unsigned int index)
 {
-    struct dsound_render *filter = impl_from_strmbase_renderer(iface);
+    struct dsound_render *filter = impl_from_strmbase_filter(iface);
 
-    if (IsEqualGUID(iid, &IID_IBasicAudio))
+    if (index == 0)
+        return &filter->sink.pin;
+    return NULL;
+}
+
+static HRESULT dsound_render_query_interface(struct strmbase_filter *iface, REFIID iid, void **out)
+{
+    struct dsound_render *filter = impl_from_strmbase_filter(iface);
+
+    if (IsEqualGUID(iid, &IID_IAMDirectSound))
+        *out = &filter->IAMDirectSound_iface;
+    else if (IsEqualGUID(iid, &IID_IBasicAudio))
         *out = &filter->IBasicAudio_iface;
+    else if (IsEqualGUID(iid, &IID_IMediaPosition))
+        *out = &filter->passthrough.IMediaPosition_iface;
+    else if (IsEqualGUID(iid, &IID_IMediaSeeking))
+        *out = &filter->passthrough.IMediaSeeking_iface;
+    else if (IsEqualGUID(iid, &IID_IQualityControl))
+        *out = &filter->IQualityControl_iface;
     else if (IsEqualGUID(iid, &IID_IReferenceClock))
         return IUnknown_QueryInterface(filter->system_clock, iid, out);
-    else if (IsEqualGUID(iid, &IID_IAMDirectSound))
-        *out = &filter->IAMDirectSound_iface;
     else
         return E_NOINTERFACE;
 
@@ -508,20 +606,77 @@ static HRESULT dsound_render_query_interface(struct strmbase_renderer *iface, RE
     return S_OK;
 }
 
-static const struct strmbase_renderer_ops renderer_ops =
-{
-    .pfnCheckMediaType = DSoundRender_CheckMediaType,
-    .pfnDoRenderSample = DSoundRender_DoRenderSample,
-    .renderer_start_stream = dsound_render_start_stream,
-    .renderer_stop_stream = dsound_render_stop_stream,
-    .pfnShouldDrawSampleNow = DSoundRender_ShouldDrawSampleNow,
-    .pfnPrepareReceive = DSoundRender_PrepareReceive,
-    .renderer_connect = dsound_render_connect,
-    .pfnBreakConnect = DSoundRender_BreakConnect,
-    .pfnEndOfStream = DSoundRender_EndOfStream,
-    .pfnEndFlush = DSoundRender_EndFlush,
-    .renderer_destroy = dsound_render_destroy,
-    .renderer_query_interface = dsound_render_query_interface,
+static HRESULT dsound_render_init_stream(struct strmbase_filter *iface)
+{
+    struct dsound_render *filter = impl_from_strmbase_filter(iface);
+
+    if (filter->sink.pin.peer)
+        ResetEvent(filter->state_event);
+    filter->eos = FALSE;
+    ResetEvent(filter->flush_event);
+
+    return filter->sink.pin.peer ? S_FALSE : S_OK;
+}
+
+static HRESULT dsound_render_start_stream(struct strmbase_filter *iface, REFERENCE_TIME start)
+{
+    struct dsound_render *filter = impl_from_strmbase_filter(iface);
+
+    filter->stream_start = start;
+
+    SetEvent(filter->state_event);
+
+    if (filter->sink.pin.peer)
+    {
+        filter->eos = FALSE;
+        IDirectSoundBuffer_Play(filter->dsbuffer, 0, 0, DSBPLAY_LOOPING);
+    }
+
+    return S_OK;
+}
+
+static HRESULT dsound_render_stop_stream(struct strmbase_filter *iface)
+{
+    struct dsound_render *filter = impl_from_strmbase_filter(iface);
+
+    if (filter->sink.pin.peer)
+    {
+        IDirectSoundBuffer_Stop(filter->dsbuffer);
+        filter->writepos = filter->buf_size;
+    }
+    return S_OK;
+}
+
+static HRESULT dsound_render_cleanup_stream(struct strmbase_filter *iface)
+{
+    struct dsound_render *filter = impl_from_strmbase_filter(iface);
+
+    strmbase_passthrough_invalidate_time(&filter->passthrough);
+    SetEvent(filter->state_event);
+    SetEvent(filter->flush_event);
+
+    return S_OK;
+}
+
+static HRESULT dsound_render_wait_state(struct strmbase_filter *iface, DWORD timeout)
+{
+    struct dsound_render *filter = impl_from_strmbase_filter(iface);
+
+    if (WaitForSingleObject(filter->state_event, timeout) == WAIT_TIMEOUT)
+        return VFW_S_STATE_INTERMEDIATE;
+    return S_OK;
+}
+
+static const struct strmbase_filter_ops filter_ops =
+{
+    .filter_destroy = dsound_render_destroy,
+    .filter_get_pin = dsound_render_get_pin,
+    .filter_query_interface = dsound_render_query_interface,
+    .filter_init_stream = dsound_render_init_stream,
+    .filter_start_stream = dsound_render_start_stream,
+    .filter_stop_stream = dsound_render_stop_stream,
+    .filter_cleanup_stream = dsound_render_cleanup_stream,
+    .filter_wait_state = dsound_render_wait_state,
 };
 
 /*** IUnknown methods ***/
@@ -532,7 +687,7 @@ static HRESULT WINAPI Basicaudio_QueryInterface(IBasicAudio *iface,
 
     TRACE("(%p/%p)->(%s, %p)\n", This, iface, debugstr_guid(riid), ppvObj);
 
-    return IUnknown_QueryInterface(This->renderer.filter.outer_unk, riid, ppvObj);
+    return IUnknown_QueryInterface(This->filter.outer_unk, riid, ppvObj);
 }
 
 static ULONG WINAPI Basicaudio_AddRef(IBasicAudio *iface) {
@@ -540,7 +695,7 @@ static ULONG WINAPI Basicaudio_AddRef(IBasicAudio *iface) {
 
     TRACE("(%p/%p)->()\n", This, iface);
 
-    return IUnknown_AddRef(This->renderer.filter.outer_unk);
+    return IUnknown_AddRef(This->filter.outer_unk);
 }
 
 static ULONG WINAPI Basicaudio_Release(IBasicAudio *iface) {
@@ -548,7 +703,7 @@ static ULONG WINAPI Basicaudio_Release(IBasicAudio *iface) {
 
     TRACE("(%p/%p)->()\n", This, iface);
 
-    return IUnknown_Release(This->renderer.filter.outer_unk);
+    return IUnknown_Release(This->filter.outer_unk);
 }
 
 HRESULT WINAPI basic_audio_GetTypeInfoCount(IBasicAudio *iface, UINT *count)
@@ -685,7 +840,7 @@ static HRESULT WINAPI AMDirectSound_QueryInterface(IAMDirectSound *iface,
 
     TRACE("(%p/%p)->(%s, %p)\n", This, iface, debugstr_guid(riid), ppvObj);
 
-    return IUnknown_QueryInterface(This->renderer.filter.outer_unk, riid, ppvObj);
+    return IUnknown_QueryInterface(This->filter.outer_unk, riid, ppvObj);
 }
 
 static ULONG WINAPI AMDirectSound_AddRef(IAMDirectSound *iface)
@@ -694,7 +849,7 @@ static ULONG WINAPI AMDirectSound_AddRef(IAMDirectSound *iface)
 
     TRACE("(%p/%p)->()\n", This, iface);
 
-    return IUnknown_AddRef(This->renderer.filter.outer_unk);
+    return IUnknown_AddRef(This->filter.outer_unk);
 }
 
 static ULONG WINAPI AMDirectSound_Release(IAMDirectSound *iface)
@@ -703,7 +858,7 @@ static ULONG WINAPI AMDirectSound_Release(IAMDirectSound *iface)
 
     TRACE("(%p/%p)->()\n", This, iface);
 
-    return IUnknown_Release(This->renderer.filter.outer_unk);
+    return IUnknown_Release(This->filter.outer_unk);
 }
 
 /*** IAMDirectSound methods ***/
@@ -794,6 +949,59 @@ static const IAMDirectSoundVtbl IAMDirectSound_Vtbl =
     AMDirectSound_GetFocusWindow
 };
 
+static struct dsound_render *impl_from_IQualityControl(IQualityControl *iface)
+{
+    return CONTAINING_RECORD(iface, struct dsound_render, IQualityControl_iface);
+}
+
+static HRESULT WINAPI dsound_render_qc_QueryInterface(IQualityControl *iface,
+        REFIID iid, void **out)
+{
+    struct dsound_render *filter = impl_from_IQualityControl(iface);
+    return IUnknown_QueryInterface(filter->filter.outer_unk, iid, out);
+}
+
+static ULONG WINAPI dsound_render_qc_AddRef(IQualityControl *iface)
+{
+    struct dsound_render *filter = impl_from_IQualityControl(iface);
+    return IUnknown_AddRef(filter->filter.outer_unk);
+}
+
+static ULONG WINAPI dsound_render_qc_Release(IQualityControl *iface)
+{
+    struct dsound_render *filter = impl_from_IQualityControl(iface);
+    return IUnknown_AddRef(filter->filter.outer_unk);
+}
+
+static HRESULT WINAPI dsound_render_qc_Notify(IQualityControl *iface,
+        IBaseFilter *sender, Quality q)
+{
+    struct dsound_render *filter = impl_from_IQualityControl(iface);
+
+    FIXME("filter %p, sender %p, type %#x, proportion %u, late %s, timestamp %s, stub!\n",
+            filter, sender, q.Type, q.Proportion, debugstr_time(q.Late), debugstr_time(q.TimeStamp));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dsound_render_qc_SetSink(IQualityControl *iface, IQualityControl *sink)
+{
+    struct dsound_render *filter = impl_from_IQualityControl(iface);
+
+    FIXME("filter %p, sink %p, stub!\n", filter, sink);
+
+    return E_NOTIMPL;
+}
+
+static const IQualityControlVtbl dsound_render_qc_vtbl =
+{
+    dsound_render_qc_QueryInterface,
+    dsound_render_qc_AddRef,
+    dsound_render_qc_Release,
+    dsound_render_qc_Notify,
+    dsound_render_qc_SetSink,
+};
+
 HRESULT dsound_render_create(IUnknown *outer, IUnknown **out)
 {
     static const DSBUFFERDESC buffer_desc = {
@@ -808,23 +1016,19 @@ HRESULT dsound_render_create(IUnknown *outer, IUnknown **out)
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
 
-    strmbase_renderer_init(&object->renderer, outer,
-            &CLSID_DSoundRender, L"Audio Input pin (rendered)", &renderer_ops);
+    strmbase_filter_init(&object->filter, outer, &CLSID_DSoundRender, &filter_ops);
 
-    if (FAILED(hr = system_clock_create(&object->renderer.filter.IUnknown_inner, &object->system_clock)))
+    if (FAILED(hr = system_clock_create(&object->filter.IUnknown_inner, &object->system_clock)))
     {
-        strmbase_renderer_cleanup(&object->renderer);
+        strmbase_filter_cleanup(&object->filter);
         free(object);
         return hr;
     }
 
-    object->IBasicAudio_iface.lpVtbl = &IBasicAudio_Vtbl;
-    object->IAMDirectSound_iface.lpVtbl = &IAMDirectSound_Vtbl;
-
     if (FAILED(hr = DirectSoundCreate8(NULL, &object->dsound, NULL)))
     {
         IUnknown_Release(object->system_clock);
-        strmbase_renderer_cleanup(&object->renderer);
+        strmbase_filter_cleanup(&object->filter);
         free(object);
         return hr;
     }
@@ -834,7 +1038,7 @@ HRESULT dsound_render_create(IUnknown *outer, IUnknown **out)
     {
         IDirectSound8_Release(object->dsound);
         IUnknown_Release(object->system_clock);
-        strmbase_renderer_cleanup(&object->renderer);
+        strmbase_filter_cleanup(&object->filter);
         free(object);
         return hr;
     }
@@ -846,8 +1050,22 @@ HRESULT dsound_render_create(IUnknown *outer, IUnknown **out)
         IDirectSoundBuffer_Release(buffer);
     }
 
+    strmbase_passthrough_init(&object->passthrough, (IUnknown *)&object->filter.IBaseFilter_iface);
+    ISeekingPassThru_Init(&object->passthrough.ISeekingPassThru_iface, TRUE, &object->sink.pin.IPin_iface);
+
+    strmbase_sink_init(&object->sink, &object->filter, L"Audio Input pin (rendered)", &sink_ops, NULL);
+
+    InitializeCriticalSection(&object->stream_cs);
+    object->stream_cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__": dsound_render.stream_cs");
+    object->state_event = CreateEventW(NULL, TRUE, TRUE, NULL);
+    object->flush_event = CreateEventW(NULL, TRUE, TRUE, NULL);
+
+    object->IBasicAudio_iface.lpVtbl = &IBasicAudio_Vtbl;
+    object->IAMDirectSound_iface.lpVtbl = &IAMDirectSound_Vtbl;
+    object->IQualityControl_iface.lpVtbl = &dsound_render_qc_vtbl;
+
     TRACE("Created DirectSound renderer %p.\n", object);
-    *out = &object->renderer.filter.IUnknown_inner;
+    *out = &object->filter.IUnknown_inner;
 
     return S_OK;
 }
diff --git a/dlls/quartz/tests/dsoundrender.c b/dlls/quartz/tests/dsoundrender.c
index 0e7fed4c259..9506abc7977 100644
--- a/dlls/quartz/tests/dsoundrender.c
+++ b/dlls/quartz/tests/dsoundrender.c
@@ -615,8 +615,7 @@ static const struct strmbase_filter_ops testfilter_ops =
 
 static HRESULT testsource_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
 {
-    todo_wine_if (IsEqualGUID(iid, &IID_IQualityControl))
-        ok(!IsEqualGUID(iid, &IID_IQualityControl), "Unexpected query for IQualityControl.\n");
+    ok(!IsEqualGUID(iid, &IID_IQualityControl), "Unexpected query for IQualityControl.\n");
     return E_NOINTERFACE;
 }
 
diff --git a/dlls/strmbase/strmbase_private.h b/dlls/strmbase/strmbase_private.h
index d589213b713..ff82d942813 100644
--- a/dlls/strmbase/strmbase_private.h
+++ b/dlls/strmbase/strmbase_private.h
@@ -58,8 +58,4 @@ void QualityControlRender_DoQOS(struct strmbase_qc *priv);
 void QualityControlRender_BeginRender(struct strmbase_qc *This, REFERENCE_TIME start, REFERENCE_TIME stop);
 void QualityControlRender_EndRender(struct strmbase_qc *This);
 
-void strmbase_passthrough_update_time(struct strmbase_passthrough *passthrough, REFERENCE_TIME time);
-void strmbase_passthrough_invalidate_time(struct strmbase_passthrough *passthrough);
-void strmbase_passthrough_eos(struct strmbase_passthrough *passthrough);
-
 #endif /* __WINE_STRMBASE_PRIVATE_H */
diff --git a/include/wine/strmbase.h b/include/wine/strmbase.h
index 2e84edb7cdd..9c3cdc4ac5e 100644
--- a/include/wine/strmbase.h
+++ b/include/wine/strmbase.h
@@ -271,6 +271,10 @@ struct strmbase_passthrough
 void strmbase_passthrough_init(struct strmbase_passthrough *passthrough, IUnknown *outer);
 void strmbase_passthrough_cleanup(struct strmbase_passthrough *passthrough);
 
+void strmbase_passthrough_eos(struct strmbase_passthrough *passthrough);
+void strmbase_passthrough_invalidate_time(struct strmbase_passthrough *passthrough);
+void strmbase_passthrough_update_time(struct strmbase_passthrough *passthrough, REFERENCE_TIME time);
+
 struct strmbase_qc
 {
     IQualityControl IQualityControl_iface;
From af50b499cb776c25368224b0910778d05a066e55 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 20 Jul 2020 10:25:30 -0500
Subject: [PATCH] strmbase: Remove some no longer used callbacks.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/strmbase/renderer.c | 86 ++++++++++++----------------------------
 include/wine/strmbase.h  | 10 -----
 2 files changed, 25 insertions(+), 71 deletions(-)

diff --git a/dlls/strmbase/renderer.c b/dlls/strmbase/renderer.c
index 939811bfa90..1f0a747a2ce 100644
--- a/dlls/strmbase/renderer.c
+++ b/dlls/strmbase/renderer.c
@@ -194,7 +194,6 @@ static HRESULT sink_eos(struct strmbase_sink *iface)
     struct strmbase_renderer *filter = impl_from_IPin(&iface->pin.IPin_iface);
     IFilterGraph *graph = filter->filter.graph;
     IMediaEventSink *event_sink;
-    HRESULT hr = S_OK;
 
     EnterCriticalSection(&filter->csRenderLock);
 
@@ -210,11 +209,8 @@ static HRESULT sink_eos(struct strmbase_sink *iface)
     strmbase_passthrough_eos(&filter->passthrough);
     SetEvent(filter->state_event);
 
-    if (filter->pFuncsTable->pfnEndOfStream)
-        hr = filter->pFuncsTable->pfnEndOfStream(filter);
-
     LeaveCriticalSection(&filter->csRenderLock);
-    return hr;
+    return S_OK;
 }
 
 static HRESULT sink_begin_flush(struct strmbase_sink *iface)
@@ -229,7 +225,6 @@ static HRESULT sink_begin_flush(struct strmbase_sink *iface)
 static HRESULT sink_end_flush(struct strmbase_sink *iface)
 {
     struct strmbase_renderer *filter = impl_from_IPin(&iface->pin.IPin_iface);
-    HRESULT hr = S_OK;
 
     EnterCriticalSection(&filter->csRenderLock);
 
@@ -238,11 +233,8 @@ static HRESULT sink_end_flush(struct strmbase_sink *iface)
     strmbase_passthrough_invalidate_time(&filter->passthrough);
     ResetEvent(filter->flush_event);
 
-    if (filter->pFuncsTable->pfnEndFlush)
-        hr = filter->pFuncsTable->pfnEndFlush(filter);
-
     LeaveCriticalSection(&filter->csRenderLock);
-    return hr;
+    return S_OK;
 }
 
 static const struct strmbase_sink_ops sink_ops =
@@ -277,9 +269,9 @@ void strmbase_renderer_cleanup(struct strmbase_renderer *filter)
 
 HRESULT WINAPI BaseRendererImpl_Receive(struct strmbase_renderer *This, IMediaSample *pSample)
 {
-    HRESULT hr = S_OK;
     REFERENCE_TIME start, stop;
     AM_MEDIA_TYPE *pmt;
+    HRESULT hr;
 
     TRACE("(%p)->%p\n", This, pSample);
 
@@ -301,16 +293,6 @@ HRESULT WINAPI BaseRendererImpl_Receive(struct strmbase_renderer *This, IMediaSa
         DeleteMediaType(pmt);
     }
 
-    if (This->pFuncsTable->pfnPrepareReceive)
-        hr = This->pFuncsTable->pfnPrepareReceive(This, pSample);
-    if (FAILED(hr))
-    {
-        if (hr == VFW_E_SAMPLE_REJECTED)
-            return S_OK;
-        else
-            return hr;
-    }
-
     EnterCriticalSection(&This->csRenderLock);
     if (This->filter.state == State_Paused)
         SetEvent(This->state_event);
@@ -318,59 +300,41 @@ HRESULT WINAPI BaseRendererImpl_Receive(struct strmbase_renderer *This, IMediaSa
     /* Wait for render Time */
     if (This->filter.clock && SUCCEEDED(IMediaSample_GetTime(pSample, &start, &stop)))
     {
-        hr = S_FALSE;
-        strmbase_passthrough_update_time(&This->passthrough, start);
-        if (This->pFuncsTable->pfnShouldDrawSampleNow)
-            hr = This->pFuncsTable->pfnShouldDrawSampleNow(This, pSample, &start, &stop);
-
-        if (hr == S_OK)
-            ;/* Do not wait: drop through */
-        else if (hr == S_FALSE)
-        {
-            REFERENCE_TIME now;
-            DWORD_PTR cookie;
+        REFERENCE_TIME now;
+        DWORD_PTR cookie;
 
-            IReferenceClock_GetTime(This->filter.clock, &now);
+        strmbase_passthrough_update_time(&This->passthrough, start);
 
-            if (now - This->stream_start - start <= -10000)
-            {
-                HANDLE handles[2] = {This->advise_event, This->flush_event};
-                DWORD ret;
+        IReferenceClock_GetTime(This->filter.clock, &now);
 
-                IReferenceClock_AdviseTime(This->filter.clock, This->stream_start,
-                        start, (HEVENT)This->advise_event, &cookie);
+        if (now - This->stream_start - start <= -10000)
+        {
+            HANDLE handles[2] = {This->advise_event, This->flush_event};
+            DWORD ret;
 
-                LeaveCriticalSection(&This->csRenderLock);
+            IReferenceClock_AdviseTime(This->filter.clock, This->stream_start,
+                    start, (HEVENT)This->advise_event, &cookie);
 
-                ret = WaitForMultipleObjects(2, handles, FALSE, INFINITE);
-                IReferenceClock_Unadvise(This->filter.clock, cookie);
+            LeaveCriticalSection(&This->csRenderLock);
 
-                if (ret == 1)
-                {
-                    TRACE("Flush signaled, discarding current sample.\n");
-                    return S_OK;
-                }
+            ret = WaitForMultipleObjects(2, handles, FALSE, INFINITE);
+            IReferenceClock_Unadvise(This->filter.clock, cookie);
 
-                EnterCriticalSection(&This->csRenderLock);
+            if (ret == 1)
+            {
+                TRACE("Flush signaled, discarding current sample.\n");
+                return S_OK;
             }
-        }
-        else
-        {
-            LeaveCriticalSection(&This->csRenderLock);
-            /* Drop Sample */
-            return S_OK;
+
+            EnterCriticalSection(&This->csRenderLock);
         }
     }
     else
         start = stop = -1;
 
-    if (SUCCEEDED(hr))
-    {
-        QualityControlRender_BeginRender(&This->qc, start, stop);
-        hr = This->pFuncsTable->pfnDoRenderSample(This, pSample);
-        QualityControlRender_EndRender(&This->qc);
-    }
-
+    QualityControlRender_BeginRender(&This->qc, start, stop);
+    hr = This->pFuncsTable->pfnDoRenderSample(This, pSample);
+    QualityControlRender_EndRender(&This->qc);
     QualityControlRender_DoQOS(&This->qc);
 
     LeaveCriticalSection(&This->csRenderLock);
diff --git a/include/wine/strmbase.h b/include/wine/strmbase.h
index 9c3cdc4ac5e..9e0d4e7d479 100644
--- a/include/wine/strmbase.h
+++ b/include/wine/strmbase.h
@@ -318,12 +318,6 @@ struct strmbase_renderer
 
 typedef HRESULT (WINAPI *BaseRenderer_CheckMediaType)(struct strmbase_renderer *iface, const AM_MEDIA_TYPE *mt);
 typedef HRESULT (WINAPI *BaseRenderer_DoRenderSample)(struct strmbase_renderer *iface, IMediaSample *sample);
-typedef HRESULT (WINAPI *BaseRenderer_ShouldDrawSampleNow)(struct strmbase_renderer *iface,
-        IMediaSample *sample, REFERENCE_TIME *start, REFERENCE_TIME *end);
-typedef HRESULT (WINAPI *BaseRenderer_PrepareReceive)(struct strmbase_renderer *iface, IMediaSample *sample);
-typedef HRESULT (WINAPI *BaseRenderer_EndOfStream)(struct strmbase_renderer *iface);
-typedef HRESULT (WINAPI *BaseRenderer_BeginFlush) (struct strmbase_renderer *iface);
-typedef HRESULT (WINAPI *BaseRenderer_EndFlush) (struct strmbase_renderer *iface);
 typedef HRESULT (WINAPI *BaseRenderer_BreakConnect) (struct strmbase_renderer *iface);
 
 struct strmbase_renderer_ops
@@ -333,12 +327,8 @@ struct strmbase_renderer_ops
     void (*renderer_init_stream)(struct strmbase_renderer *iface);
     void (*renderer_start_stream)(struct strmbase_renderer *iface);
     void (*renderer_stop_stream)(struct strmbase_renderer *iface);
-    BaseRenderer_ShouldDrawSampleNow  pfnShouldDrawSampleNow;
-    BaseRenderer_PrepareReceive pfnPrepareReceive;
     HRESULT (*renderer_connect)(struct strmbase_renderer *iface, const AM_MEDIA_TYPE *mt);
     BaseRenderer_BreakConnect pfnBreakConnect;
-    BaseRenderer_EndOfStream pfnEndOfStream;
-    BaseRenderer_EndFlush pfnEndFlush;
     void (*renderer_destroy)(struct strmbase_renderer *iface);
     HRESULT (*renderer_query_interface)(struct strmbase_renderer *iface, REFIID iid, void **out);
     HRESULT (*renderer_pin_query_interface)(struct strmbase_renderer *iface, REFIID iid, void **out);
From 5df591fe017df41f1774d30505869fc766585652 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Mon, 20 Jul 2020 18:19:46 +0200
Subject: [PATCH] qcap/tests: Avoid test failures in test_seeking().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/tests/avimux.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/qcap/tests/avimux.c b/dlls/qcap/tests/avimux.c
index 572314f8ab3..d1a67a01a11 100644
--- a/dlls/qcap/tests/avimux.c
+++ b/dlls/qcap/tests/avimux.c
@@ -784,11 +784,13 @@ static void test_seeking(void)
 
     hr = IMediaSeeking_GetDuration(seeking, &time);
     todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(!time, "Got duration %s.\n", wine_dbgstr_longlong(time));
+    if (hr == S_OK)
+        ok(!time, "Got duration %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
     todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(!time, "Got duration %s.\n", wine_dbgstr_longlong(time));
+    if (hr == S_OK)
+        ok(!time, "Got duration %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaSeeking_GetStopPosition(seeking, &time);
     ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
From e4ebf09f4f5e1692b8e67a19c0c09fde59fc19d8 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 20 Jul 2020 17:49:06 -0500
Subject: [PATCH] strmbase: Get rid of BaseRendererImpl_Receive().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/strmbase/renderer.c | 142 ++++++++++++++++++---------------------
 include/wine/strmbase.h  |   2 -
 2 files changed, 66 insertions(+), 78 deletions(-)

diff --git a/dlls/strmbase/renderer.c b/dlls/strmbase/renderer.c
index 1f0a747a2ce..bc2d0551fe3 100644
--- a/dlls/strmbase/renderer.c
+++ b/dlls/strmbase/renderer.c
@@ -169,7 +169,72 @@ static HRESULT sink_query_interface(struct strmbase_pin *iface, REFIID iid, void
 static HRESULT WINAPI BaseRenderer_Receive(struct strmbase_sink *pin, IMediaSample *sample)
 {
     struct strmbase_renderer *filter = impl_from_IPin(&pin->pin.IPin_iface);
-    return BaseRendererImpl_Receive(filter, sample);
+    REFERENCE_TIME start, stop;
+    AM_MEDIA_TYPE *mt;
+    HRESULT hr;
+
+    if (filter->eos || filter->sink.flushing)
+        return S_FALSE;
+
+    if (filter->filter.state == State_Stopped)
+        return VFW_E_WRONG_STATE;
+
+    if (IMediaSample_GetMediaType(sample, &mt) == S_OK)
+    {
+        TRACE("Format change.\n");
+        strmbase_dump_media_type(mt);
+
+        if (FAILED(filter->pFuncsTable->pfnCheckMediaType(filter, mt)))
+            return VFW_E_TYPE_NOT_ACCEPTED;
+        DeleteMediaType(mt);
+    }
+
+    EnterCriticalSection(&filter->csRenderLock);
+    if (filter->filter.state == State_Paused)
+        SetEvent(filter->state_event);
+
+    if (filter->filter.clock && SUCCEEDED(IMediaSample_GetTime(sample, &start, &stop)))
+    {
+        REFERENCE_TIME now;
+        DWORD_PTR cookie;
+
+        strmbase_passthrough_update_time(&filter->passthrough, start);
+
+        IReferenceClock_GetTime(filter->filter.clock, &now);
+
+        if (now - filter->stream_start - start <= -10000)
+        {
+            HANDLE handles[2] = {filter->advise_event, filter->flush_event};
+            DWORD ret;
+
+            IReferenceClock_AdviseTime(filter->filter.clock, filter->stream_start,
+                    start, (HEVENT)filter->advise_event, &cookie);
+
+            LeaveCriticalSection(&filter->csRenderLock);
+
+            ret = WaitForMultipleObjects(2, handles, FALSE, INFINITE);
+            IReferenceClock_Unadvise(filter->filter.clock, cookie);
+
+            if (ret == 1)
+            {
+                TRACE("Flush signaled; discarding current sample.\n");
+                return S_OK;
+            }
+
+            EnterCriticalSection(&filter->csRenderLock);
+        }
+    }
+    else
+        start = stop = -1;
+
+    QualityControlRender_BeginRender(&filter->qc, start, stop);
+    hr = filter->pFuncsTable->pfnDoRenderSample(filter, sample);
+    QualityControlRender_EndRender(&filter->qc);
+    QualityControlRender_DoQOS(&filter->qc);
+
+    LeaveCriticalSection(&filter->csRenderLock);
+
+    return hr;
 }
 
 static HRESULT sink_connect(struct strmbase_sink *iface, IPin *peer, const AM_MEDIA_TYPE *mt)
@@ -267,81 +332,6 @@ void strmbase_renderer_cleanup(struct strmbase_renderer *filter)
     strmbase_filter_cleanup(&filter->filter);
 }
 
-HRESULT WINAPI BaseRendererImpl_Receive(struct strmbase_renderer *This, IMediaSample *pSample)
-{
-    REFERENCE_TIME start, stop;
-    AM_MEDIA_TYPE *pmt;
-    HRESULT hr;
-
-    TRACE("(%p)->%p\n", This, pSample);
-
-    if (This->eos || This->sink.flushing)
-        return S_FALSE;
-
-    if (This->filter.state == State_Stopped)
-        return VFW_E_WRONG_STATE;
-
-    if (IMediaSample_GetMediaType(pSample, &pmt) == S_OK)
-    {
-        TRACE("Format change.\n");
-        strmbase_dump_media_type(pmt);
-
-        if (FAILED(This->pFuncsTable->pfnCheckMediaType(This, pmt)))
-        {
-            return VFW_E_TYPE_NOT_ACCEPTED;
-        }
-        DeleteMediaType(pmt);
-    }
-
-    EnterCriticalSection(&This->csRenderLock);
-    if (This->filter.state == State_Paused)
-        SetEvent(This->state_event);
-
-    /* Wait for render Time */
-    if (This->filter.clock && SUCCEEDED(IMediaSample_GetTime(pSample, &start, &stop)))
-    {
-        REFERENCE_TIME now;
-        DWORD_PTR cookie;
-
-        strmbase_passthrough_update_time(&This->passthrough, start);
-
-        IReferenceClock_GetTime(This->filter.clock, &now);
-
-        if (now - This->stream_start - start <= -10000)
-        {
-            HANDLE handles[2] = {This->advise_event, This->flush_event};
-            DWORD ret;
-
-            IReferenceClock_AdviseTime(This->filter.clock, This->stream_start,
-                    start, (HEVENT)This->advise_event, &cookie);
-
-            LeaveCriticalSection(&This->csRenderLock);
-
-            ret = WaitForMultipleObjects(2, handles, FALSE, INFINITE);
-            IReferenceClock_Unadvise(This->filter.clock, cookie);
-
-            if (ret == 1)
-            {
-                TRACE("Flush signaled, discarding current sample.\n");
-                return S_OK;
-            }
-
-            EnterCriticalSection(&This->csRenderLock);
-        }
-    }
-    else
-        start = stop = -1;
-
-    QualityControlRender_BeginRender(&This->qc, start, stop);
-    hr = This->pFuncsTable->pfnDoRenderSample(This, pSample);
-    QualityControlRender_EndRender(&This->qc);
-    QualityControlRender_DoQOS(&This->qc);
-
-    LeaveCriticalSection(&This->csRenderLock);
-
-    return hr;
-}
-
 void strmbase_renderer_init(struct strmbase_renderer *filter, IUnknown *outer,
         const CLSID *clsid, const WCHAR *sink_name, const struct strmbase_renderer_ops *ops)
 {
diff --git a/include/wine/strmbase.h b/include/wine/strmbase.h
index 9e0d4e7d479..24bb97702b5 100644
--- a/include/wine/strmbase.h
+++ b/include/wine/strmbase.h
@@ -334,8 +334,6 @@ struct strmbase_renderer_ops
     HRESULT (*renderer_pin_query_interface)(struct strmbase_renderer *iface, REFIID iid, void **out);
 };
 
-HRESULT WINAPI BaseRendererImpl_Receive(struct strmbase_renderer *filter, IMediaSample *sample);
-
 void strmbase_renderer_init(struct strmbase_renderer *filter, IUnknown *outer,
         const CLSID *clsid, const WCHAR *sink_name, const struct strmbase_renderer_ops *ops);
 void strmbase_renderer_cleanup(struct strmbase_renderer *filter);
From 8803a81b33e0f17833226464b47ed13276b0a70b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 20 Jul 2020 17:49:07 -0500
Subject: [PATCH] strmbase: Wait for presentation time after rendering the
 first sample.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/strmbase/renderer.c | 36 +++++++++++++++++++++++++++---------
 1 file changed, 27 insertions(+), 9 deletions(-)

diff --git a/dlls/strmbase/renderer.c b/dlls/strmbase/renderer.c
index bc2d0551fe3..b6d552b3b0a 100644
--- a/dlls/strmbase/renderer.c
+++ b/dlls/strmbase/renderer.c
@@ -170,13 +170,16 @@ static HRESULT WINAPI BaseRenderer_Receive(struct strmbase_sink *pin, IMediaSamp
 {
     struct strmbase_renderer *filter = impl_from_IPin(&pin->pin.IPin_iface);
     REFERENCE_TIME start, stop;
+    BOOL need_wait = FALSE;
+    FILTER_STATE state;
+    HRESULT hr = S_OK;
     AM_MEDIA_TYPE *mt;
-    HRESULT hr;
 
     if (filter->eos || filter->sink.flushing)
         return S_FALSE;
 
-    if (filter->filter.state == State_Stopped)
+    state = filter->filter.state;
+    if (state == State_Stopped)
         return VFW_E_WRONG_STATE;
 
     if (IMediaSample_GetMediaType(sample, &mt) == S_OK)
@@ -194,12 +197,25 @@ static HRESULT WINAPI BaseRenderer_Receive(struct strmbase_sink *pin, IMediaSamp
         SetEvent(filter->state_event);
 
     if (filter->filter.clock && SUCCEEDED(IMediaSample_GetTime(sample, &start, &stop)))
+    {
+        strmbase_passthrough_update_time(&filter->passthrough, start);
+        need_wait = TRUE;
+    }
+    else
+        start = stop = -1;
+
+    if (state == State_Paused)
+    {
+        QualityControlRender_BeginRender(&filter->qc, start, stop);
+        hr = filter->pFuncsTable->pfnDoRenderSample(filter, sample);
+        QualityControlRender_EndRender(&filter->qc);
+    }
+
+    if (need_wait)
     {
         REFERENCE_TIME now;
         DWORD_PTR cookie;
 
-        strmbase_passthrough_update_time(&filter->passthrough, start);
-
         IReferenceClock_GetTime(filter->filter.clock, &now);
 
         if (now - filter->stream_start - start <= -10000)
@@ -224,12 +240,14 @@ static HRESULT WINAPI BaseRenderer_Receive(struct strmbase_sink *pin, IMediaSamp
             EnterCriticalSection(&filter->csRenderLock);
         }
     }
-    else
-        start = stop = -1;
 
-    QualityControlRender_BeginRender(&filter->qc, start, stop);
-    hr = filter->pFuncsTable->pfnDoRenderSample(filter, sample);
-    QualityControlRender_EndRender(&filter->qc);
+    if (state == State_Running)
+    {
+        QualityControlRender_BeginRender(&filter->qc, start, stop);
+        hr = filter->pFuncsTable->pfnDoRenderSample(filter, sample);
+        QualityControlRender_EndRender(&filter->qc);
+    }
+
     QualityControlRender_DoQOS(&filter->qc);
 
     LeaveCriticalSection(&filter->csRenderLock);
From d3ef27f7561a8fa47c675c8d537ce153ba3bebd7 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 20 Jul 2020 17:49:08 -0500
Subject: [PATCH] quartz/vmr9: Signal state change completion only after
 PresentImage() has been called.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qedit/nullrenderer.c   | 5 +++++
 dlls/quartz/tests/vmr9.c    | 5 +++++
 dlls/quartz/videorenderer.c | 1 +
 dlls/quartz/vmr9.c          | 1 +
 dlls/strmbase/renderer.c    | 2 --
 5 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/dlls/qedit/nullrenderer.c b/dlls/qedit/nullrenderer.c
index e703ea24305..c64d5e2987c 100644
--- a/dlls/qedit/nullrenderer.c
+++ b/dlls/qedit/nullrenderer.c
@@ -38,6 +38,11 @@ static struct null_renderer *impl_from_strmbase_renderer(struct strmbase_rendere
 
 static HRESULT WINAPI NullRenderer_DoRenderSample(struct strmbase_renderer *iface, IMediaSample *sample)
 {
+    struct null_renderer *filter = impl_from_strmbase_renderer(iface);
+
+    if (filter->renderer.filter.state == State_Paused)
+        SetEvent(filter->renderer.state_event);
+
     return S_OK;
 }
 
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index e630deb8d74..a2fd5b76861 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -2943,6 +2943,11 @@ static void test_renderless_present(IFilterGraph2 *graph, IMemInputPin *input)
     thread = send_frame(input);
     hr = IMediaControl_GetState(control, 1000, &state);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
+    /* Atelier Sophie uses the VMR in renderless mode, calls
+     * IMediaControl::Run() from a stopped state and expects that
+     * IMediaControl::GetState() returns S_OK only after PresentImage() has
+     * been called. */
+    ok(allocator_got_PresentImage == 1, "Got %u calls to PresentImage().\n", allocator_got_PresentImage);
 
     hr = IMediaControl_Run(control);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
diff --git a/dlls/quartz/videorenderer.c b/dlls/quartz/videorenderer.c
index eb6accf2d34..2ad479a6301 100644
--- a/dlls/quartz/videorenderer.c
+++ b/dlls/quartz/videorenderer.c
@@ -111,6 +111,7 @@ static HRESULT WINAPI VideoRenderer_DoRenderSample(struct strmbase_renderer *ifa
 
         filter->current_sample = pSample;
 
+        SetEvent(filter->renderer.state_event);
         LeaveCriticalSection(&filter->renderer.csRenderLock);
         WaitForMultipleObjects(2, events, FALSE, INFINITE);
         EnterCriticalSection(&filter->renderer.csRenderLock);
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index a3f55011062..00cd6bbce84 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -315,6 +315,7 @@ static HRESULT WINAPI VMR9_DoRenderSample(struct strmbase_renderer *iface, IMedi
 
     if (filter->renderer.filter.state == State_Paused)
     {
+        SetEvent(filter->renderer.state_event);
         LeaveCriticalSection(&filter->renderer.csRenderLock);
         WaitForMultipleObjects(2, events, FALSE, INFINITE);
         EnterCriticalSection(&filter->renderer.csRenderLock);
diff --git a/dlls/strmbase/renderer.c b/dlls/strmbase/renderer.c
index b6d552b3b0a..dde56b7a346 100644
--- a/dlls/strmbase/renderer.c
+++ b/dlls/strmbase/renderer.c
@@ -193,8 +193,6 @@ static HRESULT WINAPI BaseRenderer_Receive(struct strmbase_sink *pin, IMediaSamp
     }
 
     EnterCriticalSection(&filter->csRenderLock);
-    if (filter->filter.state == State_Paused)
-        SetEvent(filter->state_event);
 
     if (filter->filter.clock && SUCCEEDED(IMediaSample_GetTime(sample, &start, &stop)))
     {
From a6d539381e23fa117367033618b4ab340c7c7620 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 20 Jul 2020 17:49:09 -0500
Subject: [PATCH] quartz/tests: Add tests for
 IMediaSeeking::GetCurrentPosition() and EC_COMPLETE interaction.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/filtergraph.c | 59 +++++++++++++++++++++++++++++++++
 1 file changed, 59 insertions(+)

diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index bd6562b0ed5..1eecd0483b2 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -3939,6 +3939,7 @@ static void test_graph_seeking(void)
 
     LONGLONG time, current, stop, earliest, latest;
     IFilterGraph2 *graph = create_graph();
+    IMediaEventSink *eventsink;
     IMediaControl *control;
     IMediaSeeking *seeking;
     IMediaFilter *filter;
@@ -3976,6 +3977,7 @@ static void test_graph_seeking(void)
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaSeeking, (void **)&seeking);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaFilter, (void **)&filter);
+    IFilterGraph2_QueryInterface(graph, &IID_IMediaEventSink, (void **)&eventsink);
 
     hr = IMediaSeeking_GetCapabilities(seeking, &caps);
     todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -4482,9 +4484,66 @@ static void test_graph_seeking(void)
     hr = IMediaControl_Stop(control);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
+    /* GetCurrentPositions() will return the stop position once all renderers
+     * report EC_COMPLETE. Atelier Sophie depends on this behaviour. */
+
+    hr = IFilterGraph2_SetDefaultSyncSource(graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    filter1.seek_stop = 5000 * 10000;
+    filter2.seek_stop = 6000 * 10000;
+
+    hr = IMediaControl_Run(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(time < 5000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter1.IBaseFilter_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(time < 5000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter2.IBaseFilter_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(time == 6000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    hr = IMediaControl_Stop(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    filter1.seek_hr = filter2.seek_hr = E_NOTIMPL;
+    filter1.seek_stop = filter2.seek_stop = 0xdeadbeef;
+
+    hr = IMediaControl_Run(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(time < 5000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter1.IBaseFilter_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter2.IBaseFilter_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(time == 6000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    hr = IMediaControl_Stop(control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
     IMediaFilter_Release(filter);
     IMediaControl_Release(control);
     IMediaSeeking_Release(seeking);
+    IMediaEventSink_Release(eventsink);
 
     ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
     ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter2.seeking_ref);
From 8c9d60c308c20e92bbbb204008082dad7ad160c9 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 20 Jul 2020 17:49:10 -0500
Subject: [PATCH] quartz: Return the stop position from GetCurrentPosition()
 after all filters return EC_COMPLETE.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 15 +++++++++++++--
 dlls/quartz/tests/filtergraph.c |  5 ++---
 2 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 22d7f7b4450..7d6463c1f37 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -219,10 +219,11 @@ struct filter_graph
     /* Respectively: the last timestamp at which we started streaming, and the
      * current offset within the stream. */
     REFERENCE_TIME stream_start, stream_elapsed;
-
+    REFERENCE_TIME stream_stop;
     LONGLONG current_pos;
 
     unsigned int needs_async_run : 1;
+    unsigned int got_ec_complete : 1;
 };
 
 struct enum_filters
@@ -1739,6 +1740,7 @@ static void update_render_count(struct filter_graph *graph)
 /* Perform the paused -> running transition. The caller must hold graph->cs. */
 static HRESULT graph_start(struct filter_graph *graph, REFERENCE_TIME stream_start)
 {
+    REFERENCE_TIME stream_stop;
     struct filter *filter;
     HRESULT hr = S_OK;
 
@@ -1757,6 +1759,9 @@ static HRESULT graph_start(struct filter_graph *graph, REFERENCE_TIME stream_sta
         stream_start += 200 * 10000;
     }
 
+    if (SUCCEEDED(IMediaSeeking_GetStopPosition(&graph->IMediaSeeking_iface, &stream_stop)))
+        graph->stream_stop = stream_stop;
+
     LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         HRESULT filter_hr = IBaseFilter_Run(filter->filter, stream_start);
@@ -2322,7 +2327,11 @@ static HRESULT WINAPI MediaSeeking_GetCurrentPosition(IMediaSeeking *iface, LONG
 
     EnterCriticalSection(&graph->cs);
 
-    if (graph->state == State_Running && graph->refClock)
+    if (graph->got_ec_complete)
+    {
+        ret = graph->stream_stop;
+    }
+    else if (graph->state == State_Running && graph->refClock)
     {
         REFERENCE_TIME time;
         IReferenceClock_GetTime(graph->refClock, &time);
@@ -4982,6 +4991,7 @@ static HRESULT WINAPI MediaFilter_Stop(IMediaFilter *iface)
     graph->state = State_Stopped;
     graph->needs_async_run = 0;
     work = graph->async_run_work;
+    graph->got_ec_complete = 0;
 
     /* Update the current position, probably to synchronize multiple streams. */
     IMediaSeeking_SetPositions(&graph->IMediaSeeking_iface, &graph->current_pos,
@@ -5281,6 +5291,7 @@ static HRESULT WINAPI MediaEventSink_Notify(IMediaEventSink *iface, LONG EventCo
                 PostMessageW(This->notif.hWnd, This->notif.msg, 0, This->notif.instance);
             }
             This->CompletionStatus = EC_COMPLETE;
+            This->got_ec_complete = 1;
             SetEvent(This->hEventCompletion);
         }
     }
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 1eecd0483b2..9219b30cec7 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -530,7 +530,6 @@ static void test_media_event(IFilterGraph2 *graph)
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &current);
     ok(hr == S_OK, "GetCurrentPosition() failed: %#x\n", hr);
-todo_wine
     ok(current == stop, "expected %s, got %s\n", wine_dbgstr_longlong(stop), wine_dbgstr_longlong(current));
 
     hr = IMediaControl_Stop(control);
@@ -4512,7 +4511,7 @@ static void test_graph_seeking(void)
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(time == 6000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
+    ok(time == 6000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaControl_Stop(control);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -4535,7 +4534,7 @@ static void test_graph_seeking(void)
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(time == 6000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
+    ok(time == 6000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaControl_Stop(control);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
From 6a1109f3cd0ba0953c02509e9fdb2a84a9549e7b Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Tue, 21 Jul 2020 10:50:02 -0500
Subject: [PATCH] amstream/tests: Fix AMMultiMediaStream::OpenFile test.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 47 ++++++++++++++++++++--------------
 1 file changed, 28 insertions(+), 19 deletions(-)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index a81cdba3f35..c47f11f1f6c 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -231,35 +231,44 @@ static void test_interfaces(void)
 
 static void test_openfile(void)
 {
-    IAMMultiMediaStream *pams;
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IMediaStreamFilter *filter;
+    IGraphBuilder *graph;
     HRESULT hr;
-    IGraphBuilder* pgraph;
+    ULONG ref;
 
-    if (!(pams = create_ammultimediastream()))
-        return;
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!graph, "Expected NULL graph.\n");
 
-    hr = IAMMultiMediaStream_GetFilterGraph(pams, &pgraph);
-    ok(hr==S_OK, "IAMMultiMediaStream_GetFilterGraph returned: %x\n", hr);
-    ok(pgraph==NULL, "Filtergraph should not be created yet\n");
+    hr = IAMMultiMediaStream_OpenFile(mmstream, L"test.avi", AMMSF_NORENDER);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    if (pgraph)
-        IGraphBuilder_Release(pgraph);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!!graph, "Expected non-NULL graph.\n");
+    IGraphBuilder_Release(graph);
 
-    check_interface(pams, &IID_IMediaSeeking, FALSE);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
-    hr = IAMMultiMediaStream_OpenFile(pams, L"test.avi", 0);
-    ok(hr==S_OK, "IAMMultiMediaStream_OpenFile returned: %x\n", hr);
+    mmstream = create_ammultimediastream();
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    check_interface(pams, &IID_IMediaSeeking, TRUE);
+    check_interface(filter, &IID_IMediaSeeking, FALSE);
 
-    hr = IAMMultiMediaStream_GetFilterGraph(pams, &pgraph);
-    ok(hr==S_OK, "IAMMultiMediaStream_GetFilterGraph returned: %x\n", hr);
-    ok(pgraph!=NULL, "Filtergraph should be created\n");
+    hr = IAMMultiMediaStream_OpenFile(mmstream, L"test.avi", 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    if (pgraph)
-        IGraphBuilder_Release(pgraph);
+    check_interface(filter, &IID_IMediaSeeking, TRUE);
 
-    IAMMultiMediaStream_Release(pams);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_renderfile(void)
From 7490b857b988baee2df547e2caac3d543088046e Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Tue, 21 Jul 2020 10:50:03 -0500
Subject: [PATCH] amstream/tests: Fix file rendering test.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index c47f11f1f6c..f6d4c5d3c41 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -296,7 +296,7 @@ static void test_renderfile(void)
     ok(hr==S_OK, "IAMMultiMediaStream_AddMediaStream returned: %x\n", hr);
 
     hr = IAMMultiMediaStream_AddMediaStream(pams, NULL, &MSPID_PrimaryAudio, AMMSF_ADDDEFAULTRENDERER, NULL);
-    ok(hr==S_OK, "IAMMultiMediaStream_AddMediaStream returned: %x\n", hr);
+    ok(hr == S_OK || hr == VFW_E_NO_AUDIO_HARDWARE, "Got hr %#x.\n", hr);
 
     hr = IAMMultiMediaStream_OpenFile(pams, L"test.avi", 0);
     ok(hr==S_OK, "IAMMultiMediaStream_OpenFile returned: %x\n", hr);
@@ -315,14 +315,15 @@ static void test_renderfile(void)
     surface = NULL;
     hr = IDirectDrawStreamSample_GetSurface(pddsample, &surface, &rect);
     ok(hr == S_OK, "got 0x%08x\n", hr);
-    ok(surface == NULL, "got %p\n", surface);
+    ok(surface != NULL, "Expected non-NULL surface.\n");
+    IDirectDrawSurface_Release(surface);
     IDirectDrawStreamSample_Release(pddsample);
 
     hr = IDirectDrawSurface7_QueryInterface(pdds7, &IID_IDirectDrawSurface, (void**)&surface);
     ok(hr == S_OK, "got 0x%08x\n", hr);
 
     EXPECT_REF(surface, 1);
-    hr = IDirectDrawMediaStream_CreateSample(pddstream, surface, NULL, 0, &pddsample);
+    hr = IDirectDrawMediaStream_CreateSample(pddstream, surface, &rect, 0, &pddsample);
     ok(hr == S_OK, "IDirectDrawMediaStream_CreateSample returned: %x\n", hr);
     EXPECT_REF(surface, 2);
     IDirectDrawStreamSample_Release(pddsample);
From 053b55d2a8a1bf6055293c78835a4a0843e95ae6 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Tue, 21 Jul 2020 10:50:04 -0500
Subject: [PATCH] amstream/tests: Add a test AVI file.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/Makefile.in |   3 ++
 dlls/amstream/tests/amstream.c  |  63 +++++++++++++++++++++++++-------
 dlls/amstream/tests/rsrc.rc     |  25 +++++++++++++
 dlls/amstream/tests/test.avi    | Bin 0 -> 12088 bytes
 4 files changed, 78 insertions(+), 13 deletions(-)
 create mode 100644 dlls/amstream/tests/rsrc.rc
 create mode 100644 dlls/amstream/tests/test.avi

diff --git a/dlls/amstream/tests/Makefile.in b/dlls/amstream/tests/Makefile.in
index 81eaed3c152..eb756ddf39d 100644
--- a/dlls/amstream/tests/Makefile.in
+++ b/dlls/amstream/tests/Makefile.in
@@ -3,3 +3,6 @@ IMPORTS   = strmbase strmiids uuid ddraw ole32 user32
 
 C_SRCS = \
 	amstream.c
+
+RC_SRCS = \
+	rsrc.rc
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index f6d4c5d3c41..0175257c058 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -53,6 +53,45 @@ static const AM_MEDIA_TYPE audio_mt =
 static const WCHAR primary_video_sink_id[] = L"I{A35FF56A-9FDA-11D0-8FDF-00C04FD9189D}";
 static const WCHAR primary_audio_sink_id[] = L"I{A35FF56B-9FDA-11D0-8FDF-00C04FD9189D}";
 
+static const WCHAR *load_resource(const WCHAR *name)
+{
+    HMODULE module = GetModuleHandleA(NULL);
+    HRSRC resource;
+    DWORD written;
+    HANDLE file;
+    WCHAR *path;
+    DWORD size;
+    void *ptr;
+
+    path = calloc(MAX_PATH + 1, sizeof(WCHAR));
+    ok(!!path, "Failed to allocate temp path string.\n");
+    GetTempPathW(MAX_PATH + 1, path);
+    wcscat(path, name);
+
+    file = CreateFileW(path, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
+    ok(file != INVALID_HANDLE_VALUE, "Failed to create file %s, error %u.\n", wine_dbgstr_w(path), GetLastError());
+
+    resource = FindResourceW(module, name, (const WCHAR *)RT_RCDATA);
+    ok(!!resource, "Failed to find resource %s, error %u.\n", wine_dbgstr_w(name), GetLastError());
+
+    size = SizeofResource(module, resource);
+    ptr = LockResource(LoadResource(module, resource));
+
+    WriteFile(file, ptr, size, &written, NULL);
+    ok(written == size, "Failed to write file %s.\n", wine_dbgstr_w(path));
+
+    CloseHandle(file);
+
+    return path;
+}
+
+static void unload_resource(const WCHAR *path)
+{
+    BOOL ret = DeleteFileW(path);
+    ok(ret, "Failed to delete file %s.\n", wine_dbgstr_w(path));
+    free((void *)path);
+}
+
 #define EXPECT_REF(obj,ref) _expect_ref((IUnknown*)obj, ref, __LINE__)
 static void _expect_ref(IUnknown* obj, ULONG ref, int line)
 {
@@ -229,7 +268,7 @@ static void test_interfaces(void)
     ok(!ref, "Got outstanding refcount %u.\n", ref);
 }
 
-static void test_openfile(void)
+static void test_openfile(const WCHAR *test_avi_path)
 {
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
     IMediaStreamFilter *filter;
@@ -241,7 +280,7 @@ static void test_openfile(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!graph, "Expected NULL graph.\n");
 
-    hr = IAMMultiMediaStream_OpenFile(mmstream, L"test.avi", AMMSF_NORENDER);
+    hr = IAMMultiMediaStream_OpenFile(mmstream, test_avi_path, AMMSF_NORENDER);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
@@ -260,7 +299,7 @@ static void test_openfile(void)
 
     check_interface(filter, &IID_IMediaSeeking, FALSE);
 
-    hr = IAMMultiMediaStream_OpenFile(mmstream, L"test.avi", 0);
+    hr = IAMMultiMediaStream_OpenFile(mmstream, test_avi_path, 0);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_interface(filter, &IID_IMediaSeeking, TRUE);
@@ -271,7 +310,7 @@ static void test_openfile(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
-static void test_renderfile(void)
+static void test_renderfile(const WCHAR *test_avi_path)
 {
     IAMMultiMediaStream *pams;
     HRESULT hr;
@@ -298,7 +337,7 @@ static void test_renderfile(void)
     hr = IAMMultiMediaStream_AddMediaStream(pams, NULL, &MSPID_PrimaryAudio, AMMSF_ADDDEFAULTRENDERER, NULL);
     ok(hr == S_OK || hr == VFW_E_NO_AUDIO_HARDWARE, "Got hr %#x.\n", hr);
 
-    hr = IAMMultiMediaStream_OpenFile(pams, L"test.avi", 0);
+    hr = IAMMultiMediaStream_OpenFile(pams, test_avi_path, 0);
     ok(hr==S_OK, "IAMMultiMediaStream_OpenFile returned: %x\n", hr);
 
     hr = IAMMultiMediaStream_GetMediaStream(pams, &MSPID_PrimaryVideo, &pvidstream);
@@ -5066,7 +5105,7 @@ static void test_ddrawstream_getsetdirectdraw(void)
 
 START_TEST(amstream)
 {
-    HANDLE file;
+    const WCHAR *test_avi_path;
 
     CoInitializeEx(NULL, COINIT_MULTITHREADED);
 
@@ -5081,14 +5120,12 @@ START_TEST(amstream)
     test_media_types();
     test_IDirectDrawStreamSample();
 
-    file = CreateFileW(L"test.avi", 0, 0, NULL, OPEN_EXISTING, 0, NULL);
-    if (file != INVALID_HANDLE_VALUE)
-    {
-        CloseHandle(file);
+    test_avi_path = load_resource(L"test.avi");
 
-        test_openfile();
-        test_renderfile();
-    }
+    test_openfile(test_avi_path);
+    test_renderfile(test_avi_path);
+
+    unload_resource(test_avi_path);
 
     test_audiodata_query_interface();
     test_audiodata_get_info();
diff --git a/dlls/amstream/tests/rsrc.rc b/dlls/amstream/tests/rsrc.rc
new file mode 100644
index 00000000000..e1fc277503f
--- /dev/null
+++ b/dlls/amstream/tests/rsrc.rc
@@ -0,0 +1,25 @@
+/*
+ * Resource file for amstream tests.
+ *
+ * Copyright 2020 Anton Baskanov
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "windef.h"
+
+/* ffmpeg -f lavfi -i smptebars -f lavfi -i "sine=frequency=1000" -t 0.1 -r 10 -ar 8000 -f avi -vcodec rawvideo -vf scale=32x24 -acodec pcm_u8 test.avi */
+/* @makedep: test.avi */
+test.avi RCDATA "test.avi"
diff --git a/dlls/amstream/tests/test.avi b/dlls/amstream/tests/test.avi
new file mode 100644
index 0000000000000000000000000000000000000000..70aead54538fbc89b9c563121bbf217a5a78131d
GIT binary patch
literal 12088
zcmWIYbaOM%XJBv)^HlKh3=Y|&#K4e|Qk0WemYHF}z`(Gejgi5@2gm>d0Zs-6MhKIE
z2_nLv0Hh_LV#pN8tOo)N48<iyIY10Ht1L66*we(w09hT#JT9mJh~2=#!0;akU}_YA
zrUUh-X#fR4SOJJZ_AxT>Fo4VgsYeH1p?=;HK)Yd51_mj~=xRp!qaiRF0;3@?8Umvs
zFd71*Aut*OqaiRF0;3@?8UmvsFd72GI|RxKiV9qiya*b9Pyk}kxB@e9)Bwf?jYojQ
zV0;jb4nX4^HE81;iKQvUAic-{#CMQ~h$t{KFzf;{LE{|A>OkWhK%;<T8^AFapjr@S
zWZ+=H7|$>)PlA{<N{)uWXb6mkz-S1JhQMeDjE2By2#kinXb6mkz-S1JhQMeDjFb=n
zjSsK@2NLpAa&v$v<HtzxI2M0`#$%*_;+}qP{+_{ZA$&l#Phwe`skxqov7VuU0eCd!
z2XF*t6pV(zXb6nF5CD}B*Vq{ta`VeFK`X;RE6BD2!P-TO7ccH=ZfR{OEG#Ta2o4Pm
zc6M@dHd9hjQ31;@1S;riYH6u2C@3t74-Ns!J32a<Dk&=~Zvlce3l}X~+}YF&k}oKX
z4+;qlastUKj>^+Ke6|C@`o&9@ECt68F#3w)1A{|?!0{umprEi42o_G8Hhp?aT|+}v
zMn+~<Tv&KSn7ys7ow=?a1gOhMOG|l#hedlyN=k}Gv^6$Y%8QEe2W?ujW{r}PlCq4L
zlA>Z@Qe>dBu&^+1Ktpv+v7~?yxBrG!t5%r<fnn60Tet4Ln5nL(si`d`0yIQ|gIhpU
zS{4W_fxtNN<NJ4Szb#PG*3r?E=H=t#<7ML#5EJDE0t+B8j(_|5_3JP5m34G<bfx(O
z1O)imf%0NNh5#XXu=xpZ-vIT`gXrgn>K7LW=_e%L*y64dwPd2V`+|f0v9;H(HZ;2d
z`4ha{798k{t+@)~D@QKw_i~%Rzb~fd>J?J?^-V5H5sUjhUFRPF>c4)iy~{@{ZrLPX
zulf7>;%m>JJ9&C?@q}$_8fvG`>#b>MZ(q1*W@A(DnpJZeni?A$>+5IFnbBC+xq99F
zy7~s7K;xXbVE)>9^$lRq*w{5CLqp%vYQ?E@H}@A6H#BrjNmtjiv|MrO?2Y|}MGXy|
zlYx8-i{&TJ-q=SDziUdGijKMY$}>Ro3ybROJ11qESlQXl+jIERuA<_?!s_~|JJ;1#
z`&cG-x7ODuC8gIj_spE!TUl0JU*Fi6kdRtm-!ge>FVO8E4<rKl4K0(W^g`Wl0G!cT
z1uTl2x+ZitloXUSbVKNRDBaNA4;HV7(lB{+afCcXJxm=;oO<SgTnw7Sg1HOkZWtfc
z{(*BR%srUy1NmSl&<DujJs91I(|ruEH~=OXSOmj7K)Z;?9iTWJiral4A9w=e0PcQD
z6DUJwN`+wp&_qzp4w_2^tpNws@F1H&{2m}1l+$2*J66bCER4^<#=rnd6)^rGARm;@
MVf+?g%K_wK0F@rn4FCWD

literal 0
HcmV?d00001

From 0e6f24db19a29fce4cb6a2f7107d5318e6a131b6 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Tue, 21 Jul 2020 10:50:05 -0500
Subject: [PATCH] amstream/tests: Move the testfilter code above to use it in
 SetState tests.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 890 ++++++++++++++++-----------------
 1 file changed, 445 insertions(+), 445 deletions(-)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 0175257c058..9882b5c04e5 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -701,6 +701,279 @@ static void check_enum_stream_(int line, IAMMultiMediaStream *mmstream,
     }
 }
 
+struct testfilter
+{
+    struct strmbase_filter filter;
+    struct strmbase_source source;
+    IMediaSeeking IMediaSeeking_iface;
+    LONGLONG current_position;
+    LONGLONG stop_position;
+    HRESULT get_duration_hr;
+    HRESULT set_positions_hr;
+};
+
+static inline struct testfilter *impl_from_BaseFilter(struct strmbase_filter *iface)
+{
+    return CONTAINING_RECORD(iface, struct testfilter, filter);
+}
+
+static struct strmbase_pin *testfilter_get_pin(struct strmbase_filter *iface, unsigned int index)
+{
+    struct testfilter *filter = impl_from_BaseFilter(iface);
+    if (!index)
+        return &filter->source.pin;
+    return NULL;
+}
+
+static void testfilter_destroy(struct strmbase_filter *iface)
+{
+    struct testfilter *filter = impl_from_BaseFilter(iface);
+    strmbase_source_cleanup(&filter->source);
+    strmbase_filter_cleanup(&filter->filter);
+}
+
+static HRESULT testfilter_init_stream(struct strmbase_filter *iface)
+{
+    struct testfilter *filter = impl_from_BaseFilter(iface);
+
+    BaseOutputPinImpl_Active(&filter->source);
+    return S_OK;
+}
+
+static HRESULT testfilter_cleanup_stream(struct strmbase_filter *iface)
+{
+    struct testfilter *filter = impl_from_BaseFilter(iface);
+
+    BaseOutputPinImpl_Inactive(&filter->source);
+    return S_OK;
+}
+
+static const struct strmbase_filter_ops testfilter_ops =
+{
+    .filter_get_pin = testfilter_get_pin,
+    .filter_destroy = testfilter_destroy,
+    .filter_init_stream = testfilter_init_stream,
+    .filter_cleanup_stream = testfilter_cleanup_stream,
+};
+
+static inline struct testfilter *impl_from_base_pin(struct strmbase_pin *iface)
+{
+    return CONTAINING_RECORD(iface, struct testfilter, source.pin);
+}
+
+static HRESULT testsource_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
+{
+    struct testfilter *filter = impl_from_base_pin(iface);
+
+    if (IsEqualGUID(iid, &IID_IMediaSeeking) && filter->IMediaSeeking_iface.lpVtbl)
+        *out = &filter->IMediaSeeking_iface;
+    else
+        return E_NOINTERFACE;
+
+    IUnknown_AddRef((IUnknown *)*out);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI testsource_DecideBufferSize(struct strmbase_source *iface,
+        IMemAllocator *alloc, ALLOCATOR_PROPERTIES *requested)
+{
+    ALLOCATOR_PROPERTIES actual;
+
+    if (!requested->cbAlign)
+        requested->cbAlign = 1;
+
+    if (requested->cbBuffer < 4096)
+        requested->cbBuffer = 4096;
+
+    if (!requested->cBuffers)
+        requested->cBuffers = 2;
+
+    return IMemAllocator_SetProperties(alloc, requested, &actual);
+}
+
+static const struct strmbase_source_ops testsource_ops =
+{
+    .base.pin_query_interface = testsource_query_interface,
+    .pfnAttemptConnection = BaseOutputPinImpl_AttemptConnection,
+    .pfnDecideBufferSize = testsource_DecideBufferSize,
+    .pfnDecideAllocator = BaseOutputPinImpl_DecideAllocator,
+};
+
+static void testfilter_init(struct testfilter *filter)
+{
+    static const GUID clsid = {0xabacab};
+    memset(filter, 0, sizeof(*filter));
+    strmbase_filter_init(&filter->filter, NULL, &clsid, &testfilter_ops);
+    strmbase_source_init(&filter->source, &filter->filter, L"", &testsource_ops);
+    filter->stop_position = 0x8000000000000000ULL;
+}
+
+static inline struct testfilter *impl_from_IMediaSeeking(IMediaSeeking *iface)
+{
+    return CONTAINING_RECORD(iface, struct testfilter, IMediaSeeking_iface);
+}
+
+static HRESULT WINAPI testsource_seeking_QueryInterface(IMediaSeeking *iface, REFIID iid, void **out)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+    return IBaseFilter_QueryInterface(&filter->filter.IBaseFilter_iface, iid, out);
+}
+
+static ULONG WINAPI testsource_seeking_AddRef(IMediaSeeking *iface)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+    return IBaseFilter_AddRef(&filter->filter.IBaseFilter_iface);
+}
+
+static ULONG WINAPI testsource_seeking_Release(IMediaSeeking *iface)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+    return IBaseFilter_Release(&filter->filter.IBaseFilter_iface);
+}
+
+static HRESULT WINAPI testsource_seeking_GetCapabilities(IMediaSeeking *iface, DWORD *capabilities)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_CheckCapabilities(IMediaSeeking *iface, DWORD *capabilities)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_IsFormatSupported(IMediaSeeking *iface, const GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_QueryPreferredFormat(IMediaSeeking *iface, GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetTimeFormat(IMediaSeeking *iface, GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_IsUsingTimeFormat(IMediaSeeking *iface, const GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_SetTimeFormat(IMediaSeeking *iface, const GUID *format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetDuration(IMediaSeeking *iface, LONGLONG *duration)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+
+    if (SUCCEEDED(filter->get_duration_hr))
+        *duration = 0x8000000000000000ULL;
+
+    return filter->get_duration_hr;
+}
+
+static HRESULT WINAPI testsource_seeking_GetStopPosition(IMediaSeeking *iface, LONGLONG *stop)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetCurrentPosition(IMediaSeeking *iface, LONGLONG *current)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_ConvertTimeFormat(IMediaSeeking *iface, LONGLONG *target,
+        const GUID *target_format, LONGLONG source, const GUID *source_format)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_SetPositions(IMediaSeeking *iface, LONGLONG *current_ptr, DWORD current_flags,
+        LONGLONG *stop_ptr, DWORD stop_flags)
+{
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+
+    if (SUCCEEDED(filter->set_positions_hr))
+    {
+        if (current_ptr)
+            filter->current_position = *current_ptr;
+
+        if (stop_ptr)
+            filter->stop_position = *stop_ptr;
+    }
+
+    return filter->set_positions_hr;
+}
+
+static HRESULT WINAPI testsource_seeking_GetPositions(IMediaSeeking *iface, LONGLONG *current, LONGLONG *stop)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetAvailable(IMediaSeeking *iface, LONGLONG *earliest, LONGLONG *latest)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_SetRate(IMediaSeeking *iface, double rate)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetRate(IMediaSeeking *iface, double *rate)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testsource_seeking_GetPreroll(IMediaSeeking *iface, LONGLONG *preroll)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static const IMediaSeekingVtbl testsource_seeking_vtbl =
+{
+    testsource_seeking_QueryInterface,
+    testsource_seeking_AddRef,
+    testsource_seeking_Release,
+    testsource_seeking_GetCapabilities,
+    testsource_seeking_CheckCapabilities,
+    testsource_seeking_IsFormatSupported,
+    testsource_seeking_QueryPreferredFormat,
+    testsource_seeking_GetTimeFormat,
+    testsource_seeking_IsUsingTimeFormat,
+    testsource_seeking_SetTimeFormat,
+    testsource_seeking_GetDuration,
+    testsource_seeking_GetStopPosition,
+    testsource_seeking_GetCurrentPosition,
+    testsource_seeking_ConvertTimeFormat,
+    testsource_seeking_SetPositions,
+    testsource_seeking_GetPositions,
+    testsource_seeking_GetAvailable,
+    testsource_seeking_SetRate,
+    testsource_seeking_GetRate,
+    testsource_seeking_GetPreroll,
+};
+
 #define check_get_stream(a,b,c,d) check_get_stream_(__LINE__,a,b,c,d)
 static void check_get_stream_(int line, IAMMultiMediaStream *mmstream,
         IMediaStreamFilter *filter, const GUID *mspid, IMediaStream *expect)
@@ -2176,171 +2449,51 @@ static void test_IDirectDrawStreamSample(void)
 
 error:
     if (ddraw_stream)
-        IDirectDrawMediaStream_Release(ddraw_stream);
-    if (stream)
-        IMediaStream_Release(stream);
-
-    release_directdraw();
-    IAMMultiMediaStream_Release(mmstream);
-}
-
-static IUnknown *create_audio_data(void)
-{
-    IUnknown *audio_data = NULL;
-    HRESULT result = CoCreateInstance(&CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER,
-            &IID_IUnknown, (void **)&audio_data);
-    ok(S_OK == result, "got 0x%08x\n", result);
-    return audio_data;
-}
-
-static void test_audiodata_query_interface(void)
-{
-    IUnknown *unknown = create_audio_data();
-    IMemoryData *memory_data = NULL;
-    IAudioData *audio_data = NULL;
-
-    HRESULT result;
-
-    result = IUnknown_QueryInterface(unknown, &IID_IMemoryData, (void **)&memory_data);
-    ok(E_NOINTERFACE == result, "got 0x%08x\n", result);
-
-    result = IUnknown_QueryInterface(unknown, &IID_IAudioData, (void **)&audio_data);
-    ok(S_OK == result, "got 0x%08x\n", result);
-    if (S_OK == result)
-    {
-        result = IAudioData_QueryInterface(audio_data, &IID_IMemoryData, (void **)&memory_data);
-        ok(E_NOINTERFACE == result, "got 0x%08x\n", result);
-
-        IAudioData_Release(audio_data);
-    }
-
-    IUnknown_Release(unknown);
-}
-
-static void test_audiodata_get_info(void)
-{
-    IUnknown *unknown = create_audio_data();
-    IAudioData *audio_data = NULL;
-
-    HRESULT result;
-
-    result = IUnknown_QueryInterface(unknown, &IID_IAudioData, (void **)&audio_data);
-    if (FAILED(result))
-    {
-        /* test_audiodata_query_interface handles this case */
-        skip("No IAudioData\n");
-        goto out_unknown;
-    }
-
-    result = IAudioData_GetInfo(audio_data, NULL, NULL, NULL);
-    ok(MS_E_NOTINIT == result, "got 0x%08x\n", result);
-
-    IAudioData_Release(audio_data);
-
-out_unknown:
-    IUnknown_Release(unknown);
-}
-
-static void test_audiodata_set_buffer(void)
-{
-    IUnknown *unknown = create_audio_data();
-    IAudioData *audio_data = NULL;
-    BYTE buffer[100] = {0};
-    DWORD length = 0;
-    BYTE *data = NULL;
-
-    HRESULT result;
-
-    result = IUnknown_QueryInterface(unknown, &IID_IAudioData, (void **)&audio_data);
-    if (FAILED(result))
-    {
-        /* test_audiodata_query_interface handles this case */
-        skip("No IAudioData\n");
-        goto out_unknown;
-    }
-
-    result = IAudioData_SetBuffer(audio_data, 100, NULL, 0);
-    ok(S_OK == result, "got 0x%08x\n", result);
-
-    data = (BYTE *)0xdeadbeef;
-    length = 0xdeadbeef;
-    result = IAudioData_GetInfo(audio_data, &length, &data, NULL);
-    ok(S_OK == result, "got 0x%08x\n", result);
-    ok(100 == length, "got %u\n", length);
-    ok(NULL != data, "got %p\n", data);
-
-    result = IAudioData_SetBuffer(audio_data, 0, buffer, 0);
-    ok(E_INVALIDARG == result, "got 0x%08x\n", result);
-
-    result = IAudioData_SetBuffer(audio_data, sizeof(buffer), buffer, 0);
-    ok(S_OK == result, "got 0x%08x\n", result);
-
-    data = (BYTE *)0xdeadbeef;
-    length = 0xdeadbeef;
-    result = IAudioData_GetInfo(audio_data, &length, &data, NULL);
-    ok(S_OK == result, "got 0x%08x\n", result);
-    ok(sizeof(buffer) == length, "got %u\n", length);
-    ok(buffer == data, "got %p\n", data);
+        IDirectDrawMediaStream_Release(ddraw_stream);
+    if (stream)
+        IMediaStream_Release(stream);
 
-    IAudioData_Release(audio_data);
+    release_directdraw();
+    IAMMultiMediaStream_Release(mmstream);
+}
 
-out_unknown:
-    IUnknown_Release(unknown);
+static IUnknown *create_audio_data(void)
+{
+    IUnknown *audio_data = NULL;
+    HRESULT result = CoCreateInstance(&CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IUnknown, (void **)&audio_data);
+    ok(S_OK == result, "got 0x%08x\n", result);
+    return audio_data;
 }
 
-static void test_audiodata_set_actual(void)
+static void test_audiodata_query_interface(void)
 {
     IUnknown *unknown = create_audio_data();
+    IMemoryData *memory_data = NULL;
     IAudioData *audio_data = NULL;
-    BYTE buffer[100] = {0};
-    DWORD actual_data = 0;
 
     HRESULT result;
 
-    result = IUnknown_QueryInterface(unknown, &IID_IAudioData, (void **)&audio_data);
-    if (FAILED(result))
-    {
-        /* test_audiodata_query_interface handles this case */
-        skip("No IAudioData\n");
-        goto out_unknown;
-    }
-
-    result = IAudioData_SetActual(audio_data, 0);
-    ok(S_OK == result, "got 0x%08x\n", result);
-
-    result = IAudioData_SetBuffer(audio_data, sizeof(buffer), buffer, 0);
-    ok(S_OK == result, "got 0x%08x\n", result);
-
-    result = IAudioData_SetActual(audio_data, sizeof(buffer) + 1);
-    ok(E_INVALIDARG == result, "got 0x%08x\n", result);
-
-    result = IAudioData_SetActual(audio_data, sizeof(buffer));
-    ok(S_OK == result, "got 0x%08x\n", result);
-
-    actual_data = 0xdeadbeef;
-    result = IAudioData_GetInfo(audio_data, NULL, NULL, &actual_data);
-    ok(S_OK == result, "got 0x%08x\n", result);
-    ok(sizeof(buffer) == actual_data, "got %u\n", actual_data);
-
-    result = IAudioData_SetActual(audio_data, 0);
-    ok(S_OK == result, "got 0x%08x\n", result);
+    result = IUnknown_QueryInterface(unknown, &IID_IMemoryData, (void **)&memory_data);
+    ok(E_NOINTERFACE == result, "got 0x%08x\n", result);
 
-    actual_data = 0xdeadbeef;
-    result = IAudioData_GetInfo(audio_data, NULL, NULL, &actual_data);
+    result = IUnknown_QueryInterface(unknown, &IID_IAudioData, (void **)&audio_data);
     ok(S_OK == result, "got 0x%08x\n", result);
-    ok(0 == actual_data, "got %u\n", actual_data);
+    if (S_OK == result)
+    {
+        result = IAudioData_QueryInterface(audio_data, &IID_IMemoryData, (void **)&memory_data);
+        ok(E_NOINTERFACE == result, "got 0x%08x\n", result);
 
-    IAudioData_Release(audio_data);
+        IAudioData_Release(audio_data);
+    }
 
-out_unknown:
     IUnknown_Release(unknown);
 }
 
-static void test_audiodata_get_format(void)
+static void test_audiodata_get_info(void)
 {
     IUnknown *unknown = create_audio_data();
     IAudioData *audio_data = NULL;
-    WAVEFORMATEX wave_format = {0};
 
     HRESULT result;
 
@@ -2352,25 +2505,8 @@ static void test_audiodata_get_format(void)
         goto out_unknown;
     }
 
-    result = IAudioData_GetFormat(audio_data, NULL);
-    ok(E_POINTER == result, "got 0x%08x\n", result);
-
-    wave_format.wFormatTag = 0xdead;
-    wave_format.nChannels = 0xdead;
-    wave_format.nSamplesPerSec = 0xdeadbeef;
-    wave_format.nAvgBytesPerSec = 0xdeadbeef;
-    wave_format.nBlockAlign = 0xdead;
-    wave_format.wBitsPerSample = 0xdead;
-    wave_format.cbSize = 0xdead;
-    result = IAudioData_GetFormat(audio_data, &wave_format);
-    ok(S_OK == result, "got 0x%08x\n", result);
-    ok(WAVE_FORMAT_PCM == wave_format.wFormatTag, "got %u\n", wave_format.wFormatTag);
-    ok(1 == wave_format.nChannels, "got %u\n", wave_format.nChannels);
-    ok(11025 == wave_format.nSamplesPerSec, "got %u\n", wave_format.nSamplesPerSec);
-    ok(22050 == wave_format.nAvgBytesPerSec, "got %u\n", wave_format.nAvgBytesPerSec);
-    ok(2 == wave_format.nBlockAlign, "got %u\n", wave_format.nBlockAlign);
-    ok(16 == wave_format.wBitsPerSample, "got %u\n", wave_format.wBitsPerSample);
-    ok(0 == wave_format.cbSize, "got %u\n", wave_format.cbSize);
+    result = IAudioData_GetInfo(audio_data, NULL, NULL, NULL);
+    ok(MS_E_NOTINIT == result, "got 0x%08x\n", result);
 
     IAudioData_Release(audio_data);
 
@@ -2378,11 +2514,13 @@ static void test_audiodata_get_format(void)
     IUnknown_Release(unknown);
 }
 
-static void test_audiodata_set_format(void)
+static void test_audiodata_set_buffer(void)
 {
     IUnknown *unknown = create_audio_data();
     IAudioData *audio_data = NULL;
-    WAVEFORMATPCMEX wave_format = {{0}};
+    BYTE buffer[100] = {0};
+    DWORD length = 0;
+    BYTE *data = NULL;
 
     HRESULT result;
 
@@ -2394,328 +2532,190 @@ static void test_audiodata_set_format(void)
         goto out_unknown;
     }
 
-    result = IAudioData_SetFormat(audio_data, NULL);
-    ok(E_POINTER == result, "got 0x%08x\n", result);
+    result = IAudioData_SetBuffer(audio_data, 100, NULL, 0);
+    ok(S_OK == result, "got 0x%08x\n", result);
 
-    wave_format.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
-    wave_format.Format.nChannels = 2;
-    wave_format.Format.nSamplesPerSec = 44100;
-    wave_format.Format.nAvgBytesPerSec = 176400;
-    wave_format.Format.nBlockAlign = 4;
-    wave_format.Format.wBitsPerSample = 16;
-    wave_format.Format.cbSize = 22;
-    wave_format.Samples.wValidBitsPerSample = 16;
-    wave_format.dwChannelMask = KSAUDIO_SPEAKER_STEREO;
-    wave_format.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
-    result = IAudioData_SetFormat(audio_data, &wave_format.Format);
+    data = (BYTE *)0xdeadbeef;
+    length = 0xdeadbeef;
+    result = IAudioData_GetInfo(audio_data, &length, &data, NULL);
+    ok(S_OK == result, "got 0x%08x\n", result);
+    ok(100 == length, "got %u\n", length);
+    ok(NULL != data, "got %p\n", data);
+
+    result = IAudioData_SetBuffer(audio_data, 0, buffer, 0);
     ok(E_INVALIDARG == result, "got 0x%08x\n", result);
 
-    wave_format.Format.wFormatTag = WAVE_FORMAT_PCM;
-    wave_format.Format.nChannels = 2;
-    wave_format.Format.nSamplesPerSec = 44100;
-    wave_format.Format.nAvgBytesPerSec = 176400;
-    wave_format.Format.nBlockAlign = 4;
-    wave_format.Format.wBitsPerSample = 16;
-    wave_format.Format.cbSize = 0;
-    result = IAudioData_SetFormat(audio_data, &wave_format.Format);
+    result = IAudioData_SetBuffer(audio_data, sizeof(buffer), buffer, 0);
     ok(S_OK == result, "got 0x%08x\n", result);
 
-    wave_format.Format.wFormatTag = 0xdead;
-    wave_format.Format.nChannels = 0xdead;
-    wave_format.Format.nSamplesPerSec = 0xdeadbeef;
-    wave_format.Format.nAvgBytesPerSec = 0xdeadbeef;
-    wave_format.Format.nBlockAlign = 0xdead;
-    wave_format.Format.wBitsPerSample = 0xdead;
-    wave_format.Format.cbSize = 0xdead;
-    result = IAudioData_GetFormat(audio_data, &wave_format.Format);
+    data = (BYTE *)0xdeadbeef;
+    length = 0xdeadbeef;
+    result = IAudioData_GetInfo(audio_data, &length, &data, NULL);
     ok(S_OK == result, "got 0x%08x\n", result);
-    ok(WAVE_FORMAT_PCM == wave_format.Format.wFormatTag, "got %u\n", wave_format.Format.wFormatTag);
-    ok(2 == wave_format.Format.nChannels, "got %u\n", wave_format.Format.nChannels);
-    ok(44100 == wave_format.Format.nSamplesPerSec, "got %u\n", wave_format.Format.nSamplesPerSec);
-    ok(176400 == wave_format.Format.nAvgBytesPerSec, "got %u\n", wave_format.Format.nAvgBytesPerSec);
-    ok(4 == wave_format.Format.nBlockAlign, "got %u\n", wave_format.Format.nBlockAlign);
-    ok(16 == wave_format.Format.wBitsPerSample, "got %u\n", wave_format.Format.wBitsPerSample);
-    ok(0 == wave_format.Format.cbSize, "got %u\n", wave_format.Format.cbSize);
+    ok(sizeof(buffer) == length, "got %u\n", length);
+    ok(buffer == data, "got %p\n", data);
 
     IAudioData_Release(audio_data);
 
-out_unknown:
-    IUnknown_Release(unknown);
-}
-
-struct testfilter
-{
-    struct strmbase_filter filter;
-    struct strmbase_source source;
-    IMediaSeeking IMediaSeeking_iface;
-    LONGLONG current_position;
-    LONGLONG stop_position;
-    HRESULT get_duration_hr;
-    HRESULT set_positions_hr;
-};
-
-static inline struct testfilter *impl_from_BaseFilter(struct strmbase_filter *iface)
-{
-    return CONTAINING_RECORD(iface, struct testfilter, filter);
-}
-
-static struct strmbase_pin *testfilter_get_pin(struct strmbase_filter *iface, unsigned int index)
-{
-    struct testfilter *filter = impl_from_BaseFilter(iface);
-    if (!index)
-        return &filter->source.pin;
-    return NULL;
-}
-
-static void testfilter_destroy(struct strmbase_filter *iface)
-{
-    struct testfilter *filter = impl_from_BaseFilter(iface);
-    strmbase_source_cleanup(&filter->source);
-    strmbase_filter_cleanup(&filter->filter);
-}
-
-static HRESULT testfilter_init_stream(struct strmbase_filter *iface)
-{
-    struct testfilter *filter = impl_from_BaseFilter(iface);
-
-    BaseOutputPinImpl_Active(&filter->source);
-    return S_OK;
-}
-
-static HRESULT testfilter_cleanup_stream(struct strmbase_filter *iface)
-{
-    struct testfilter *filter = impl_from_BaseFilter(iface);
-
-    BaseOutputPinImpl_Inactive(&filter->source);
-    return S_OK;
-}
-
-static const struct strmbase_filter_ops testfilter_ops =
-{
-    .filter_get_pin = testfilter_get_pin,
-    .filter_destroy = testfilter_destroy,
-    .filter_init_stream = testfilter_init_stream,
-    .filter_cleanup_stream = testfilter_cleanup_stream,
-};
-
-static inline struct testfilter *impl_from_base_pin(struct strmbase_pin *iface)
-{
-    return CONTAINING_RECORD(iface, struct testfilter, source.pin);
-}
-
-static HRESULT testsource_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
-{
-    struct testfilter *filter = impl_from_base_pin(iface);
-
-    if (IsEqualGUID(iid, &IID_IMediaSeeking) && filter->IMediaSeeking_iface.lpVtbl)
-        *out = &filter->IMediaSeeking_iface;
-    else
-        return E_NOINTERFACE;
-
-    IUnknown_AddRef((IUnknown *)*out);
-
-    return S_OK;
-}
-
-static HRESULT WINAPI testsource_DecideBufferSize(struct strmbase_source *iface,
-        IMemAllocator *alloc, ALLOCATOR_PROPERTIES *requested)
-{
-    ALLOCATOR_PROPERTIES actual;
-
-    if (!requested->cbAlign)
-        requested->cbAlign = 1;
-
-    if (requested->cbBuffer < 4096)
-        requested->cbBuffer = 4096;
-
-    if (!requested->cBuffers)
-        requested->cBuffers = 2;
-
-    return IMemAllocator_SetProperties(alloc, requested, &actual);
-}
-
-static const struct strmbase_source_ops testsource_ops =
-{
-    .base.pin_query_interface = testsource_query_interface,
-    .pfnAttemptConnection = BaseOutputPinImpl_AttemptConnection,
-    .pfnDecideBufferSize = testsource_DecideBufferSize,
-    .pfnDecideAllocator = BaseOutputPinImpl_DecideAllocator,
-};
-
-static void testfilter_init(struct testfilter *filter)
-{
-    static const GUID clsid = {0xabacab};
-    memset(filter, 0, sizeof(*filter));
-    strmbase_filter_init(&filter->filter, NULL, &clsid, &testfilter_ops);
-    strmbase_source_init(&filter->source, &filter->filter, L"", &testsource_ops);
-    filter->stop_position = 0x8000000000000000ULL;
-}
-
-static inline struct testfilter *impl_from_IMediaSeeking(IMediaSeeking *iface)
-{
-    return CONTAINING_RECORD(iface, struct testfilter, IMediaSeeking_iface);
+out_unknown:
+    IUnknown_Release(unknown);
 }
 
-static HRESULT WINAPI testsource_seeking_QueryInterface(IMediaSeeking *iface, REFIID iid, void **out)
+static void test_audiodata_set_actual(void)
 {
-    struct testfilter *filter = impl_from_IMediaSeeking(iface);
-    return IBaseFilter_QueryInterface(&filter->filter.IBaseFilter_iface, iid, out);
-}
+    IUnknown *unknown = create_audio_data();
+    IAudioData *audio_data = NULL;
+    BYTE buffer[100] = {0};
+    DWORD actual_data = 0;
 
-static ULONG WINAPI testsource_seeking_AddRef(IMediaSeeking *iface)
-{
-    struct testfilter *filter = impl_from_IMediaSeeking(iface);
-    return IBaseFilter_AddRef(&filter->filter.IBaseFilter_iface);
-}
+    HRESULT result;
 
-static ULONG WINAPI testsource_seeking_Release(IMediaSeeking *iface)
-{
-    struct testfilter *filter = impl_from_IMediaSeeking(iface);
-    return IBaseFilter_Release(&filter->filter.IBaseFilter_iface);
-}
+    result = IUnknown_QueryInterface(unknown, &IID_IAudioData, (void **)&audio_data);
+    if (FAILED(result))
+    {
+        /* test_audiodata_query_interface handles this case */
+        skip("No IAudioData\n");
+        goto out_unknown;
+    }
 
-static HRESULT WINAPI testsource_seeking_GetCapabilities(IMediaSeeking *iface, DWORD *capabilities)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
-}
+    result = IAudioData_SetActual(audio_data, 0);
+    ok(S_OK == result, "got 0x%08x\n", result);
 
-static HRESULT WINAPI testsource_seeking_CheckCapabilities(IMediaSeeking *iface, DWORD *capabilities)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
-}
+    result = IAudioData_SetBuffer(audio_data, sizeof(buffer), buffer, 0);
+    ok(S_OK == result, "got 0x%08x\n", result);
 
-static HRESULT WINAPI testsource_seeking_IsFormatSupported(IMediaSeeking *iface, const GUID *format)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
-}
+    result = IAudioData_SetActual(audio_data, sizeof(buffer) + 1);
+    ok(E_INVALIDARG == result, "got 0x%08x\n", result);
 
-static HRESULT WINAPI testsource_seeking_QueryPreferredFormat(IMediaSeeking *iface, GUID *format)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
-}
+    result = IAudioData_SetActual(audio_data, sizeof(buffer));
+    ok(S_OK == result, "got 0x%08x\n", result);
 
-static HRESULT WINAPI testsource_seeking_GetTimeFormat(IMediaSeeking *iface, GUID *format)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
-}
+    actual_data = 0xdeadbeef;
+    result = IAudioData_GetInfo(audio_data, NULL, NULL, &actual_data);
+    ok(S_OK == result, "got 0x%08x\n", result);
+    ok(sizeof(buffer) == actual_data, "got %u\n", actual_data);
 
-static HRESULT WINAPI testsource_seeking_IsUsingTimeFormat(IMediaSeeking *iface, const GUID *format)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
-}
+    result = IAudioData_SetActual(audio_data, 0);
+    ok(S_OK == result, "got 0x%08x\n", result);
 
-static HRESULT WINAPI testsource_seeking_SetTimeFormat(IMediaSeeking *iface, const GUID *format)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
+    actual_data = 0xdeadbeef;
+    result = IAudioData_GetInfo(audio_data, NULL, NULL, &actual_data);
+    ok(S_OK == result, "got 0x%08x\n", result);
+    ok(0 == actual_data, "got %u\n", actual_data);
+
+    IAudioData_Release(audio_data);
+
+out_unknown:
+    IUnknown_Release(unknown);
 }
 
-static HRESULT WINAPI testsource_seeking_GetDuration(IMediaSeeking *iface, LONGLONG *duration)
+static void test_audiodata_get_format(void)
 {
-    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+    IUnknown *unknown = create_audio_data();
+    IAudioData *audio_data = NULL;
+    WAVEFORMATEX wave_format = {0};
 
-    if (SUCCEEDED(filter->get_duration_hr))
-        *duration = 0x8000000000000000ULL;
+    HRESULT result;
 
-    return filter->get_duration_hr;
-}
+    result = IUnknown_QueryInterface(unknown, &IID_IAudioData, (void **)&audio_data);
+    if (FAILED(result))
+    {
+        /* test_audiodata_query_interface handles this case */
+        skip("No IAudioData\n");
+        goto out_unknown;
+    }
 
-static HRESULT WINAPI testsource_seeking_GetStopPosition(IMediaSeeking *iface, LONGLONG *stop)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
-}
+    result = IAudioData_GetFormat(audio_data, NULL);
+    ok(E_POINTER == result, "got 0x%08x\n", result);
 
-static HRESULT WINAPI testsource_seeking_GetCurrentPosition(IMediaSeeking *iface, LONGLONG *current)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
-}
+    wave_format.wFormatTag = 0xdead;
+    wave_format.nChannels = 0xdead;
+    wave_format.nSamplesPerSec = 0xdeadbeef;
+    wave_format.nAvgBytesPerSec = 0xdeadbeef;
+    wave_format.nBlockAlign = 0xdead;
+    wave_format.wBitsPerSample = 0xdead;
+    wave_format.cbSize = 0xdead;
+    result = IAudioData_GetFormat(audio_data, &wave_format);
+    ok(S_OK == result, "got 0x%08x\n", result);
+    ok(WAVE_FORMAT_PCM == wave_format.wFormatTag, "got %u\n", wave_format.wFormatTag);
+    ok(1 == wave_format.nChannels, "got %u\n", wave_format.nChannels);
+    ok(11025 == wave_format.nSamplesPerSec, "got %u\n", wave_format.nSamplesPerSec);
+    ok(22050 == wave_format.nAvgBytesPerSec, "got %u\n", wave_format.nAvgBytesPerSec);
+    ok(2 == wave_format.nBlockAlign, "got %u\n", wave_format.nBlockAlign);
+    ok(16 == wave_format.wBitsPerSample, "got %u\n", wave_format.wBitsPerSample);
+    ok(0 == wave_format.cbSize, "got %u\n", wave_format.cbSize);
 
-static HRESULT WINAPI testsource_seeking_ConvertTimeFormat(IMediaSeeking *iface, LONGLONG *target,
-        const GUID *target_format, LONGLONG source, const GUID *source_format)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
+    IAudioData_Release(audio_data);
+
+out_unknown:
+    IUnknown_Release(unknown);
 }
 
-static HRESULT WINAPI testsource_seeking_SetPositions(IMediaSeeking *iface, LONGLONG *current_ptr, DWORD current_flags,
-        LONGLONG *stop_ptr, DWORD stop_flags)
+static void test_audiodata_set_format(void)
 {
-    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+    IUnknown *unknown = create_audio_data();
+    IAudioData *audio_data = NULL;
+    WAVEFORMATPCMEX wave_format = {{0}};
 
-    if (SUCCEEDED(filter->set_positions_hr))
-    {
-        if (current_ptr)
-            filter->current_position = *current_ptr;
+    HRESULT result;
 
-        if (stop_ptr)
-            filter->stop_position = *stop_ptr;
+    result = IUnknown_QueryInterface(unknown, &IID_IAudioData, (void **)&audio_data);
+    if (FAILED(result))
+    {
+        /* test_audiodata_query_interface handles this case */
+        skip("No IAudioData\n");
+        goto out_unknown;
     }
 
-    return filter->set_positions_hr;
-}
+    result = IAudioData_SetFormat(audio_data, NULL);
+    ok(E_POINTER == result, "got 0x%08x\n", result);
 
-static HRESULT WINAPI testsource_seeking_GetPositions(IMediaSeeking *iface, LONGLONG *current, LONGLONG *stop)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
-}
+    wave_format.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
+    wave_format.Format.nChannels = 2;
+    wave_format.Format.nSamplesPerSec = 44100;
+    wave_format.Format.nAvgBytesPerSec = 176400;
+    wave_format.Format.nBlockAlign = 4;
+    wave_format.Format.wBitsPerSample = 16;
+    wave_format.Format.cbSize = 22;
+    wave_format.Samples.wValidBitsPerSample = 16;
+    wave_format.dwChannelMask = KSAUDIO_SPEAKER_STEREO;
+    wave_format.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
+    result = IAudioData_SetFormat(audio_data, &wave_format.Format);
+    ok(E_INVALIDARG == result, "got 0x%08x\n", result);
 
-static HRESULT WINAPI testsource_seeking_GetAvailable(IMediaSeeking *iface, LONGLONG *earliest, LONGLONG *latest)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
-}
+    wave_format.Format.wFormatTag = WAVE_FORMAT_PCM;
+    wave_format.Format.nChannels = 2;
+    wave_format.Format.nSamplesPerSec = 44100;
+    wave_format.Format.nAvgBytesPerSec = 176400;
+    wave_format.Format.nBlockAlign = 4;
+    wave_format.Format.wBitsPerSample = 16;
+    wave_format.Format.cbSize = 0;
+    result = IAudioData_SetFormat(audio_data, &wave_format.Format);
+    ok(S_OK == result, "got 0x%08x\n", result);
 
-static HRESULT WINAPI testsource_seeking_SetRate(IMediaSeeking *iface, double rate)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
-}
+    wave_format.Format.wFormatTag = 0xdead;
+    wave_format.Format.nChannels = 0xdead;
+    wave_format.Format.nSamplesPerSec = 0xdeadbeef;
+    wave_format.Format.nAvgBytesPerSec = 0xdeadbeef;
+    wave_format.Format.nBlockAlign = 0xdead;
+    wave_format.Format.wBitsPerSample = 0xdead;
+    wave_format.Format.cbSize = 0xdead;
+    result = IAudioData_GetFormat(audio_data, &wave_format.Format);
+    ok(S_OK == result, "got 0x%08x\n", result);
+    ok(WAVE_FORMAT_PCM == wave_format.Format.wFormatTag, "got %u\n", wave_format.Format.wFormatTag);
+    ok(2 == wave_format.Format.nChannels, "got %u\n", wave_format.Format.nChannels);
+    ok(44100 == wave_format.Format.nSamplesPerSec, "got %u\n", wave_format.Format.nSamplesPerSec);
+    ok(176400 == wave_format.Format.nAvgBytesPerSec, "got %u\n", wave_format.Format.nAvgBytesPerSec);
+    ok(4 == wave_format.Format.nBlockAlign, "got %u\n", wave_format.Format.nBlockAlign);
+    ok(16 == wave_format.Format.wBitsPerSample, "got %u\n", wave_format.Format.wBitsPerSample);
+    ok(0 == wave_format.Format.cbSize, "got %u\n", wave_format.Format.cbSize);
 
-static HRESULT WINAPI testsource_seeking_GetRate(IMediaSeeking *iface, double *rate)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
-}
+    IAudioData_Release(audio_data);
 
-static HRESULT WINAPI testsource_seeking_GetPreroll(IMediaSeeking *iface, LONGLONG *preroll)
-{
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
+out_unknown:
+    IUnknown_Release(unknown);
 }
 
-static const IMediaSeekingVtbl testsource_seeking_vtbl =
-{
-    testsource_seeking_QueryInterface,
-    testsource_seeking_AddRef,
-    testsource_seeking_Release,
-    testsource_seeking_GetCapabilities,
-    testsource_seeking_CheckCapabilities,
-    testsource_seeking_IsFormatSupported,
-    testsource_seeking_QueryPreferredFormat,
-    testsource_seeking_GetTimeFormat,
-    testsource_seeking_IsUsingTimeFormat,
-    testsource_seeking_SetTimeFormat,
-    testsource_seeking_GetDuration,
-    testsource_seeking_GetStopPosition,
-    testsource_seeking_GetCurrentPosition,
-    testsource_seeking_ConvertTimeFormat,
-    testsource_seeking_SetPositions,
-    testsource_seeking_GetPositions,
-    testsource_seeking_GetAvailable,
-    testsource_seeking_SetRate,
-    testsource_seeking_GetRate,
-    testsource_seeking_GetPreroll,
-};
-
 struct testclock
 {
     IReferenceClock IReferenceClock_iface;
From 6395c83d2ad48a9f660e22e58a1c4125eae32e30 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Tue, 21 Jul 2020 10:50:06 -0500
Subject: [PATCH] amstream: Return S_OK from AMMultiMediaStream::SetState when
 IMediaControl::Run succeeds.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/multimedia.c     |  4 ++
 dlls/amstream/tests/amstream.c | 71 ++++++++++++++++++++++++++++++++--
 2 files changed, 71 insertions(+), 4 deletions(-)

diff --git a/dlls/amstream/multimedia.c b/dlls/amstream/multimedia.c
index f615e436b18..b2c9082cae0 100644
--- a/dlls/amstream/multimedia.c
+++ b/dlls/amstream/multimedia.c
@@ -153,7 +153,11 @@ static HRESULT WINAPI multimedia_stream_SetState(IAMMultiMediaStream *iface, STR
     TRACE("(%p/%p)->(%u)\n", This, iface, new_state);
 
     if (new_state == STREAMSTATE_RUN)
+    {
         hr = IMediaControl_Run(This->media_control);
+        if (SUCCEEDED(hr))
+            hr = S_OK;
+    }
     else if (new_state == STREAMSTATE_STOP)
         hr = IMediaControl_Stop(This->media_control);
 
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 9882b5c04e5..8338a5a3ecf 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -710,6 +710,8 @@ struct testfilter
     LONGLONG stop_position;
     HRESULT get_duration_hr;
     HRESULT set_positions_hr;
+    HRESULT init_stream_hr;
+    HRESULT cleanup_stream_hr;
 };
 
 static inline struct testfilter *impl_from_BaseFilter(struct strmbase_filter *iface)
@@ -736,16 +738,20 @@ static HRESULT testfilter_init_stream(struct strmbase_filter *iface)
 {
     struct testfilter *filter = impl_from_BaseFilter(iface);
 
-    BaseOutputPinImpl_Active(&filter->source);
-    return S_OK;
+    if (SUCCEEDED(filter->init_stream_hr))
+        BaseOutputPinImpl_Active(&filter->source);
+
+    return filter->init_stream_hr;
 }
 
 static HRESULT testfilter_cleanup_stream(struct strmbase_filter *iface)
 {
     struct testfilter *filter = impl_from_BaseFilter(iface);
 
-    BaseOutputPinImpl_Inactive(&filter->source);
-    return S_OK;
+    if (SUCCEEDED(filter->cleanup_stream_hr))
+        BaseOutputPinImpl_Inactive(&filter->source);
+
+    return filter->cleanup_stream_hr;
 }
 
 static const struct strmbase_filter_ops testfilter_ops =
@@ -2062,6 +2068,62 @@ static void test_initialize(void)
     IUnknown_Release(graph_inner_unk);
 }
 
+static void test_set_state(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    struct testfilter source;
+    IGraphBuilder *graph;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    testfilter_init(&source);
+
+    hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    source.init_stream_hr = E_FAIL;
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    source.init_stream_hr = S_OK;
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    source.init_stream_hr = S_FALSE;
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    source.init_stream_hr = S_OK;
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    source.cleanup_stream_hr = E_FAIL;
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    source.cleanup_stream_hr = S_OK;
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_RUN);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    source.cleanup_stream_hr = S_FALSE;
+    hr = IAMMultiMediaStream_SetState(mmstream, STREAMSTATE_STOP);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    source.cleanup_stream_hr = S_OK;
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void test_enum_media_types(void)
 {
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
@@ -5116,6 +5178,7 @@ START_TEST(amstream)
     test_find_pin();
     test_pin_info();
     test_initialize();
+    test_set_state();
     test_enum_media_types();
     test_media_types();
     test_IDirectDrawStreamSample();
From bd97b597e6a161081fbbffd694fafd240da16e35 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Tue, 21 Jul 2020 10:50:07 -0500
Subject: [PATCH] amstream: Start the stream when AMMSF_RUN is passed to
 AMMultiMediaStream::OpenFile.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/multimedia.c     |  3 +++
 dlls/amstream/tests/amstream.c | 25 +++++++++++++++++++++++++
 2 files changed, 28 insertions(+)

diff --git a/dlls/amstream/multimedia.c b/dlls/amstream/multimedia.c
index b2c9082cae0..200bd5c4a5e 100644
--- a/dlls/amstream/multimedia.c
+++ b/dlls/amstream/multimedia.c
@@ -449,6 +449,9 @@ static HRESULT WINAPI multimedia_stream_OpenFile(IAMMultiMediaStream *iface,
 
     IMediaStreamFilter_SupportSeeking(This->filter, This->type == STREAMTYPE_READ);
 
+    if (SUCCEEDED(ret) && (flags & AMMSF_RUN))
+        ret = IAMMultiMediaStream_SetState(iface, STREAMSTATE_RUN);
+
     if (EnumPins)
         IEnumPins_Release(EnumPins);
     if (BaseFilter)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 8338a5a3ecf..8adf9db9347 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -271,8 +271,10 @@ static void test_interfaces(void)
 static void test_openfile(const WCHAR *test_avi_path)
 {
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IMediaControl *media_control;
     IMediaStreamFilter *filter;
     IGraphBuilder *graph;
+    OAFilterState state;
     HRESULT hr;
     ULONG ref;
 
@@ -308,6 +310,29 @@ static void test_openfile(const WCHAR *test_avi_path)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IMediaStreamFilter_Release(filter);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+    mmstream = create_ammultimediastream();
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!!graph, "Expected non-NULL graph.\n");
+    hr = IGraphBuilder_QueryInterface(graph, &IID_IMediaControl, (void **)&media_control);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_OpenFile(mmstream, test_avi_path, AMMSF_RUN);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    state = 0xdeadbeef;
+    hr = IMediaControl_GetState(media_control, INFINITE, &state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %#x.\n", state);
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IMediaControl_Release(media_control);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_renderfile(const WCHAR *test_avi_path)
From 97aeeb01427e04f1ff5bd47f8f55639283c058a7 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Sat, 25 Jul 2020 00:18:16 +0200
Subject: [PATCH] amstream: Accept more media subtypes in
 AMVideoStream::ReceiveConnection().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    | 26 +++++-----
 dlls/amstream/tests/amstream.c | 95 +++++++++++++++++++++++++++++++++-
 2 files changed, 108 insertions(+), 13 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 9f74eaf91ab..4c94bacf52e 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -632,16 +632,6 @@ static HRESULT WINAPI ddraw_sink_Connect(IPin *iface, IPin *peer, const AM_MEDIA
     return E_UNEXPECTED;
 }
 
-static BOOL check_media_type(const AM_MEDIA_TYPE *mt)
-{
-    if (IsEqualGUID(&mt->majortype, &MEDIATYPE_Video)
-            && IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB8)
-            && IsEqualGUID(&mt->formattype, &FORMAT_VideoInfo))
-        return TRUE;
-
-    return FALSE;
-}
-
 static HRESULT WINAPI ddraw_sink_ReceiveConnection(IPin *iface, IPin *peer, const AM_MEDIA_TYPE *mt)
 {
     struct ddraw_stream *stream = impl_from_IPin(iface);
@@ -657,7 +647,13 @@ static HRESULT WINAPI ddraw_sink_ReceiveConnection(IPin *iface, IPin *peer, cons
         return VFW_E_ALREADY_CONNECTED;
     }
 
-    if (!check_media_type(mt))
+    if (!IsEqualGUID(&mt->majortype, &MEDIATYPE_Video)
+            || (!IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB8)
+                && !IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB24)
+                && !IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB32)
+                && !IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB555)
+                && !IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB565))
+            || !IsEqualGUID(&mt->formattype, &FORMAT_VideoInfo))
     {
         LeaveCriticalSection(&stream->cs);
         return VFW_E_TYPE_NOT_ACCEPTED;
@@ -788,7 +784,13 @@ static HRESULT WINAPI ddraw_sink_QueryId(IPin *iface, WCHAR **id)
 static HRESULT WINAPI ddraw_sink_QueryAccept(IPin *iface, const AM_MEDIA_TYPE *mt)
 {
     TRACE("iface %p, mt %p.\n", iface, mt);
-    return check_media_type(mt) ? S_OK : VFW_E_TYPE_NOT_ACCEPTED;
+
+    if (IsEqualGUID(&mt->majortype, &MEDIATYPE_Video)
+            && IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB8)
+            && IsEqualGUID(&mt->formattype, &FORMAT_VideoInfo))
+        return S_OK;
+
+    return VFW_E_TYPE_NOT_ACCEPTED;
 }
 
 static HRESULT WINAPI ddraw_sink_EnumMediaTypes(IPin *iface, IEnumMediaTypes **enum_media_types)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 8adf9db9347..68d2b9c18fc 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -28,6 +28,7 @@
 #include "initguid.h"
 #include "ksmedia.h"
 #include "dvdmedia.h"
+#include "wmcodecdsp.h"
 #include "wine/strmbase.h"
 
 static const WAVEFORMATEX audio_format =
@@ -2330,6 +2331,14 @@ static void test_media_types(void)
         &MEDIASUBTYPE_ARGB32,
         &MEDIASUBTYPE_ARGB1555,
         &MEDIASUBTYPE_ARGB4444,
+        &MEDIASUBTYPE_Avi,
+        &MEDIASUBTYPE_NV12,
+        &MEDIASUBTYPE_I420,
+        &MEDIASUBTYPE_AYUV,
+        &MEDIASUBTYPE_YV12,
+        &MEDIASUBTYPE_YUY2,
+        &MEDIASUBTYPE_UYVY,
+        &MEDIASUBTYPE_YVYU,
         &GUID_NULL,
     };
 
@@ -2364,7 +2373,7 @@ static void test_media_types(void)
         pmt->cbFormat = tests[i].size;
         pmt->pbFormat = tests[i].format;
         hr = IPin_QueryAccept(pin, pmt);
-        ok(hr == (i == 6) ? S_OK : VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+        ok(hr == (i == 6 ? S_OK : VFW_E_TYPE_NOT_ACCEPTED), "Got hr %#x.\n", hr);
     }
 
     pmt->bFixedSizeSamples = FALSE;
@@ -3243,6 +3252,89 @@ static void test_audiostream_receive_connection(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_ddrawstream_receive_connection(void)
+{
+    static const VIDEOINFOHEADER req_vih;
+    IDirectDrawMediaStream *ddraw_stream;
+    IAMMultiMediaStream *mmstream;
+    struct testfilter source;
+    IMediaStream *stream;
+    AM_MEDIA_TYPE mt;
+    HRESULT hr;
+    ULONG ref;
+    IPin *pin;
+    int i;
+
+    const AM_MEDIA_TYPE video_mt =
+    {
+        .majortype = MEDIATYPE_Video,
+        .subtype = MEDIASUBTYPE_RGB8,
+        .formattype = FORMAT_VideoInfo,
+        .cbFormat = sizeof(VIDEOINFOHEADER),
+        .pbFormat = (BYTE *)&req_vih,
+    };
+
+    static const GUID *subtypes[] =
+    {
+        &MEDIASUBTYPE_RGB24,
+        &MEDIASUBTYPE_RGB32,
+        &MEDIASUBTYPE_RGB555,
+        &MEDIASUBTYPE_RGB565,
+        &MEDIASUBTYPE_RGB1,
+        &MEDIASUBTYPE_RGB4,
+        &MEDIASUBTYPE_ARGB32,
+        &MEDIASUBTYPE_ARGB1555,
+        &MEDIASUBTYPE_ARGB4444,
+        &MEDIASUBTYPE_NV12,
+        &MEDIASUBTYPE_Avi,
+        &MEDIASUBTYPE_I420,
+        &MEDIASUBTYPE_AYUV,
+        &MEDIASUBTYPE_YV12,
+        &MEDIASUBTYPE_YUY2,
+        &MEDIASUBTYPE_UYVY,
+        &MEDIASUBTYPE_YVYU,
+        &GUID_NULL,
+    };
+
+    mmstream = create_ammultimediastream();
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryVideo, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (void **)&ddraw_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    testfilter_init(&source);
+
+    mt = video_mt;
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IPin_Disconnect(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    for (i = 0; i < ARRAY_SIZE(subtypes); ++i)
+    {
+        mt = video_mt;
+        mt.subtype = *subtypes[i];
+        hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &mt);
+        ok(hr == (i < 4 ? S_OK : VFW_E_TYPE_NOT_ACCEPTED), "Got hr %#x.\n", hr);
+        if (hr == S_OK)
+        {
+            hr = IPin_Disconnect(pin);
+            ok(hr == S_OK, "Got hr %#x.\n", hr);
+        }
+    }
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin);
+    IDirectDrawMediaStream_Release(ddraw_stream);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void test_audiostream_set_state(void)
 {
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
@@ -5238,6 +5330,7 @@ START_TEST(amstream)
 
     test_ddrawstream_initialize();
     test_ddrawstream_getsetdirectdraw();
+    test_ddrawstream_receive_connection();
 
     test_ammediastream_join_am_multi_media_stream();
     test_ammediastream_join_filter();
From 7f0347bb04a2be2fcd5ebab826439c6f0d6a5703 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 21 Jul 2020 17:49:57 -0500
Subject: [PATCH] quartz/vmr9: Return E_INVALIDARG if both texture and
 offscreen flags are passed to AllocateSurfaceHelper().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr9.c | 7 +++++++
 dlls/quartz/vmr9.c       | 7 +++++++
 2 files changed, 14 insertions(+)

diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index a2fd5b76861..092ee871328 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -2760,6 +2760,13 @@ static void test_allocate_surface_helper(void)
 
     IDirect3DSurface9_Release(surfaces[0]);
 
+    info.Format = D3DFMT_A8R8G8B8;
+    info.dwFlags = VMR9AllocFlag_OffscreenSurface | VMR9AllocFlag_TextureSurface;
+    count = 1;
+    hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(notify, &info, &count, surfaces);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
+
 out:
     IVMRSurfaceAllocatorNotify9_Release(notify);
     ref = IBaseFilter_Release(filter);
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 00cd6bbce84..f66500086d5 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -2042,6 +2042,13 @@ static HRESULT WINAPI VMR9SurfaceAllocatorNotify_AllocateSurfaceHelper(IVMRSurfa
             allocinfo->dwFlags, allocinfo->dwWidth, allocinfo->dwHeight,
             allocinfo->Format, allocinfo->Format, allocinfo->Pool, allocinfo->MinBuffers);
 
+    if ((allocinfo->dwFlags & VMR9AllocFlag_TextureSurface)
+            && (allocinfo->dwFlags & VMR9AllocFlag_OffscreenSurface))
+    {
+        WARN("Invalid flags specified; returning E_INVALIDARG.\n");
+        return E_INVALIDARG;
+    }
+
     if (!allocinfo->Format)
     {
         IDirect3DSurface9 *backbuffer;
From 5e407cec530e2d79f04a755e7f818c2ef84d725e Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 21 Jul 2020 17:49:58 -0500
Subject: [PATCH] qcap/vfwcapture: Return VFW_S_CANT_CUE from GetState(), not
 Pause().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/vfwcapture.c | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/dlls/qcap/vfwcapture.c b/dlls/qcap/vfwcapture.c
index 7d82a01109c..910be107b0b 100644
--- a/dlls/qcap/vfwcapture.c
+++ b/dlls/qcap/vfwcapture.c
@@ -124,7 +124,7 @@ static HRESULT vfw_capture_init_stream(struct strmbase_filter *iface)
     VfwCapture *filter = impl_from_strmbase_filter(iface);
 
     filter->device->ops->init_stream(filter->device);
-    return VFW_S_CANT_CUE;
+    return S_OK;
 }
 
 static HRESULT vfw_capture_start_stream(struct strmbase_filter *iface, REFERENCE_TIME time)
@@ -140,7 +140,7 @@ static HRESULT vfw_capture_stop_stream(struct strmbase_filter *iface)
     VfwCapture *filter = impl_from_strmbase_filter(iface);
 
     filter->device->ops->stop_stream(filter->device);
-    return VFW_S_CANT_CUE;
+    return S_OK;
 }
 
 static HRESULT vfw_capture_cleanup_stream(struct strmbase_filter *iface)
@@ -151,6 +151,11 @@ static HRESULT vfw_capture_cleanup_stream(struct strmbase_filter *iface)
     return S_OK;
 }
 
+static HRESULT vfw_capture_wait_state(struct strmbase_filter *iface, DWORD timeout)
+{
+    return iface->state == State_Paused ? VFW_S_CANT_CUE : S_OK;
+}
+
 static const struct strmbase_filter_ops filter_ops =
 {
     .filter_get_pin = vfw_capture_get_pin,
@@ -160,6 +165,7 @@ static const struct strmbase_filter_ops filter_ops =
     .filter_start_stream = vfw_capture_start_stream,
     .filter_stop_stream = vfw_capture_stop_stream,
     .filter_cleanup_stream = vfw_capture_cleanup_stream,
+    .filter_wait_state = vfw_capture_wait_state,
 };
 
 static HRESULT WINAPI AMStreamConfig_QueryInterface(IAMStreamConfig *iface, REFIID iid, void **out)
From 11df839b69a37b001e05a2dae433209efd100c36 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 22 Jul 2020 18:29:21 -0500
Subject: [PATCH] quartz: Allow the arguments to IMediaSeeking::GetPositions()
 to be NULL.

This allows "UNDER NIGHT IN-BIRTH Exe:Late" to render video.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       | 18 ++++++++++--------
 dlls/quartz/tests/filtergraph.c |  6 +++---
 2 files changed, 13 insertions(+), 11 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 7d6463c1f37..b691fd79fcd 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -2441,16 +2441,18 @@ static HRESULT WINAPI MediaSeeking_SetPositions(IMediaSeeking *iface, LONGLONG *
     return hr;
 }
 
-static HRESULT WINAPI MediaSeeking_GetPositions(IMediaSeeking *iface, LONGLONG *pCurrent,
-        LONGLONG *pStop)
+static HRESULT WINAPI MediaSeeking_GetPositions(IMediaSeeking *iface,
+        LONGLONG *current, LONGLONG *stop)
 {
-    struct filter_graph *This = impl_from_IMediaSeeking(iface);
-    HRESULT hr;
+    struct filter_graph *graph = impl_from_IMediaSeeking(iface);
+    HRESULT hr = S_OK;
 
-    TRACE("(%p/%p)->(%p, %p)\n", This, iface, pCurrent, pStop);
-    hr = IMediaSeeking_GetCurrentPosition(iface, pCurrent);
-    if (SUCCEEDED(hr))
-        hr = IMediaSeeking_GetStopPosition(iface, pStop);
+    TRACE("graph %p, current %p, stop %p.\n", graph, current, stop);
+
+    if (current)
+        hr = IMediaSeeking_GetCurrentPosition(iface, current);
+    if (SUCCEEDED(hr) && stop)
+        hr = IMediaSeeking_GetStopPosition(iface, stop);
 
     return hr;
 }
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 9219b30cec7..4fcd27b2918 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -4098,14 +4098,14 @@ static void test_graph_seeking(void)
     ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetPositions(seeking, NULL, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_GetPositions(seeking, NULL, &stop);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
     ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     current = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, NULL);
From ead0e8e5cfcfa3a56217c4f535e960ba99b2485b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 22 Jul 2020 18:29:22 -0500
Subject: [PATCH] quartz: Correctly convert reference time to REFTIME in
 IBasicVideo::get_AvgTimePerFrame().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/videorenderer.c | 2 +-
 dlls/quartz/tests/vmr9.c          | 2 +-
 dlls/quartz/window.c              | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/quartz/tests/videorenderer.c b/dlls/quartz/tests/videorenderer.c
index ac2cadc4b17..9e6a618a36e 100644
--- a/dlls/quartz/tests/videorenderer.c
+++ b/dlls/quartz/tests/videorenderer.c
@@ -2702,7 +2702,7 @@ static void test_basic_video(void)
     reftime = 0.0;
     hr = IBasicVideo_get_AvgTimePerFrame(video, &reftime);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(reftime == 0.02, "Got frame rate %.16e.\n", reftime);
+    ok(reftime == 0.02, "Got frame rate %.16e.\n", reftime);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_BitRate(video, &l);
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 092ee871328..789c5e429a5 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -3717,7 +3717,7 @@ static void test_basic_video(void)
     reftime = 0.0;
     hr = IBasicVideo_get_AvgTimePerFrame(video, &reftime);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(compare_double(reftime, 0.02, 1 << 28), "Got frame rate %.16e.\n", reftime);
+    ok(compare_double(reftime, 0.02, 1 << 28), "Got frame rate %.16e.\n", reftime);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_BitRate(video, &l);
diff --git a/dlls/quartz/window.c b/dlls/quartz/window.c
index a5ff4979efc..07e042eccdb 100644
--- a/dlls/quartz/window.c
+++ b/dlls/quartz/window.c
@@ -755,7 +755,7 @@ static HRESULT WINAPI basic_video_get_AvgTimePerFrame(IBasicVideo *iface, REFTIM
 
     TRACE("window %p, reftime %p.\n", window, reftime);
 
-    *reftime = get_video_format(window)->AvgTimePerFrame;
+    *reftime = (double)get_video_format(window)->AvgTimePerFrame / 1e7;
     return S_OK;
 }
 
From 79129db1cdcb3117bc24f02c5d4a219bb9e28e0f Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 23 Jul 2020 19:29:23 -0500
Subject: [PATCH] quartz/dsoundrender: Clear the DirectSound buffer on EOS.

"Zero Escape: Nine Hours, Nine Persons, Nine Doors" does not stop or destroy the
graph after it is finished running, so the last second of audio repeats
otherwise.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/dsoundrender.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/quartz/dsoundrender.c b/dlls/quartz/dsoundrender.c
index a3155477fde..8b914751e15 100644
--- a/dlls/quartz/dsoundrender.c
+++ b/dlls/quartz/dsoundrender.c
@@ -477,6 +477,8 @@ static HRESULT dsound_render_sink_eos(struct strmbase_sink *iface)
     struct dsound_render *filter = impl_from_strmbase_pin(&iface->pin);
     IFilterGraph *graph = filter->filter.graph;
     IMediaEventSink *event_sink;
+    void *buffer;
+    DWORD size;
 
     EnterCriticalSection(&filter->stream_cs);
 
@@ -494,6 +496,10 @@ static HRESULT dsound_render_sink_eos(struct strmbase_sink *iface)
 
     DSoundRender_HandleEndOfStream(filter);
 
+    IDirectSoundBuffer_Lock(filter->dsbuffer, 0, 0, &buffer, &size, NULL, NULL, DSBLOCK_ENTIREBUFFER);
+    memset(buffer, 0, size);
+    IDirectSoundBuffer_Unlock(filter->dsbuffer, buffer, size, NULL, 0);
+
     LeaveCriticalSection(&filter->stream_cs);
     return S_OK;
 }
From 41a9f828704c64548e7cfc3c34804e5019d7202e Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 23 Jul 2020 19:29:24 -0500
Subject: [PATCH] quartz: Don't pause the graph in IMediaSeeking::SetPositions
 if it hasn't finished running yet.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49604
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c       |  4 ++--
 dlls/quartz/tests/filtergraph.c | 13 ++++++++++++-
 2 files changed, 14 insertions(+), 3 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index b691fd79fcd..2c32b3bc436 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -2398,7 +2398,7 @@ static HRESULT WINAPI MediaSeeking_SetPositions(IMediaSeeking *iface, LONGLONG *
     EnterCriticalSection(&graph->cs);
 
     state = graph->state;
-    if (state == State_Running)
+    if (state == State_Running && !graph->needs_async_run)
         IMediaControl_Pause(&graph->IMediaControl_iface);
 
     LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
@@ -2434,7 +2434,7 @@ static HRESULT WINAPI MediaSeeking_SetPositions(IMediaSeeking *iface, LONGLONG *
         graph->stream_elapsed = 0;
     }
 
-    if (state == State_Running)
+    if (state == State_Running && !graph->needs_async_run)
         IMediaControl_Run(&graph->IMediaControl_iface);
 
     LeaveCriticalSection(&graph->cs);
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 4fcd27b2918..cf641a4306e 100644
--- a/dlls/quartz/tests/filtergraph.c
+++ b/dlls/quartz/tests/filtergraph.c
@@ -3205,9 +3205,10 @@ static void test_filter_state(void)
     struct testpin source_pin, sink_pin;
 
     IFilterGraph2 *graph = create_graph();
-    REFERENCE_TIME start_time;
+    REFERENCE_TIME start_time, time;
     IReferenceClock *clock;
     IMediaControl *control;
+    IMediaSeeking *seeking;
     FILTER_STATE mf_state;
     IMediaFilter *filter;
     OAFilterState state;
@@ -3219,6 +3220,7 @@ static void test_filter_state(void)
     testfilter_init(&source, &source_pin, 1);
     testfilter_init(&sink, &sink_pin, 1);
     testfilter_init(&dummy, NULL, 0);
+    sink.IMediaSeeking_iface.lpVtbl = &testseek_vtbl;
 
     IFilterGraph2_QueryInterface(graph, &IID_IMediaFilter, (void **)&filter);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
@@ -3350,6 +3352,7 @@ static void test_filter_state(void)
     graph = create_graph();
     IFilterGraph2_QueryInterface(graph, &IID_IMediaFilter, (void **)&filter);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
+    IFilterGraph2_QueryInterface(graph, &IID_IMediaSeeking, (void **)&seeking);
 
     /* Add the filters in reverse order this time. */
     IFilterGraph2_AddFilter(graph, &sink.IBaseFilter_iface, NULL);
@@ -3511,6 +3514,13 @@ todo_wine
     ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
     ok(source.state == State_Paused, "Got state %u.\n", source.state);
 
+    /* SetPositions() does not pause the graph in this case, since it is
+     * already in a paused state. */
+    time = 0;
+    hr = IMediaSeeking_SetPositions(seeking, &time, AM_SEEKING_AbsolutePositioning,
+            NULL, AM_SEEKING_NoPositioning);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
     hr = IMediaControl_Run(control);
     todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
@@ -3684,6 +3694,7 @@ todo_wine
     source.expect_stop_prev = sink.expect_stop_prev = State_Running;
     IMediaFilter_Release(filter);
     IMediaControl_Release(control);
+    IMediaSeeking_Release(seeking);
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
     ok(source.ref == 1, "Got outstanding refcount %d.\n", source.ref);
From 1ce2cae3e931a027aa0aee01ddd11bcbff6433c6 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 23 Jul 2020 19:30:16 -0500
Subject: [PATCH] quartz/vmr9: Allow AdviseSurfaceAllocator() to be called
 multiple times.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47161
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/vmr9.c | 132 ++++++++++++++++++++++++++-------------
 dlls/quartz/vmr9.c       |  21 ++++++-
 2 files changed, 109 insertions(+), 44 deletions(-)

diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 789c5e429a5..2d09caea14e 100644
--- a/dlls/quartz/tests/vmr9.c
+++ b/dlls/quartz/tests/vmr9.c
@@ -2776,28 +2776,40 @@ static void test_allocate_surface_helper(void)
     DestroyWindow(window);
 }
 
-static IVMRSurfaceAllocator9 allocator_iface;
-static IVMRImagePresenter9 presenter_iface;
-static LONG allocator_refcount = 1;
-static D3DFORMAT allocator_format;
-static DWORD allocator_accept_flags;
-static IDirect3DSurface9 *allocator_surfaces[5];
-static IVMRSurfaceAllocatorNotify9 *allocator_notify;
-static unsigned int allocator_got_PresentImage, allocator_got_TerminateDevice;
+struct presenter
+{
+    IVMRSurfaceAllocator9 IVMRSurfaceAllocator9_iface;
+    IVMRImagePresenter9 IVMRImagePresenter9_iface;
+    LONG refcount;
+
+    D3DFORMAT format;
+    DWORD accept_flags;
+    IDirect3DSurface9 *surfaces[5];
+    IVMRSurfaceAllocatorNotify9 *notify;
+    unsigned int got_PresentImage, got_TerminateDevice;
+};
+
+static struct presenter *impl_from_IVMRImagePresenter9(IVMRImagePresenter9 *iface)
+{
+    return CONTAINING_RECORD(iface, struct presenter, IVMRImagePresenter9_iface);
+}
 
 static HRESULT WINAPI presenter_QueryInterface(IVMRImagePresenter9 *iface, REFIID iid, void **out)
 {
-    return IVMRSurfaceAllocator9_QueryInterface(&allocator_iface, iid, out);
+    struct presenter *presenter = impl_from_IVMRImagePresenter9(iface);
+    return IVMRSurfaceAllocator9_QueryInterface(&presenter->IVMRSurfaceAllocator9_iface, iid, out);
 }
 
 static ULONG WINAPI presenter_AddRef(IVMRImagePresenter9 *iface)
 {
-    return IVMRSurfaceAllocator9_AddRef(&allocator_iface);
+    struct presenter *presenter = impl_from_IVMRImagePresenter9(iface);
+    return IVMRSurfaceAllocator9_AddRef(&presenter->IVMRSurfaceAllocator9_iface);
 }
 
 static ULONG WINAPI presenter_Release(IVMRImagePresenter9 *iface)
 {
-    return IVMRSurfaceAllocator9_Release(&allocator_iface);
+    struct presenter *presenter = impl_from_IVMRImagePresenter9(iface);
+    return IVMRSurfaceAllocator9_Release(&presenter->IVMRSurfaceAllocator9_iface);
 }
 
 static HRESULT WINAPI presenter_StartPresenting(IVMRImagePresenter9 *iface, DWORD_PTR cookie)
@@ -2816,7 +2828,9 @@ static HRESULT WINAPI presenter_StopPresenting(IVMRImagePresenter9 *iface, DWORD
 
 static HRESULT WINAPI presenter_PresentImage(IVMRImagePresenter9 *iface, DWORD_PTR cookie, VMR9PresentationInfo *info)
 {
+    struct presenter *presenter = impl_from_IVMRImagePresenter9(iface);
     static const RECT rect;
+
     if (winetest_debug > 1) trace("PresentImage()\n");
     ok(cookie == 0xabacab, "Got cookie %#lx.\n", cookie);
     todo_wine ok(info->dwFlags == VMR9Sample_TimeValid, "Got flags %#x.\n", info->dwFlags);
@@ -2829,7 +2843,7 @@ static HRESULT WINAPI presenter_PresentImage(IVMRImagePresenter9 *iface, DWORD_P
     ok(!info->dwReserved1, "Got dwReserved1 %#x.\n", info->dwReserved1);
     ok(!info->dwReserved2, "Got dwReserved2 %#x.\n", info->dwReserved2);
 
-    ++allocator_got_PresentImage;
+    ++presenter->got_PresentImage;
     return S_OK;
 }
 
@@ -2843,14 +2857,21 @@ static const IVMRImagePresenter9Vtbl presenter_vtbl =
     presenter_PresentImage,
 };
 
+static struct presenter *impl_from_IVMRSurfaceAllocator9(IVMRSurfaceAllocator9 *iface)
+{
+    return CONTAINING_RECORD(iface, struct presenter, IVMRSurfaceAllocator9_iface);
+}
+
 static HRESULT WINAPI allocator_QueryInterface(IVMRSurfaceAllocator9 *iface, REFIID iid, void **out)
 {
+    struct presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
+
     if (winetest_debug > 1) trace("QueryInterface(%s)\n", wine_dbgstr_guid(iid));
 
     if (IsEqualGUID(iid, &IID_IVMRImagePresenter9))
     {
-        *out = &presenter_iface;
-        IVMRImagePresenter9_AddRef(&presenter_iface);
+        *out = &presenter->IVMRImagePresenter9_iface;
+        IVMRImagePresenter9_AddRef(&presenter->IVMRImagePresenter9_iface);
         return S_OK;
     }
     ok(!IsEqualGUID(iid, &IID_IVMRSurfaceAllocatorEx9), "Unexpected query for IVMRSurfaceAllocatorEx9.\n");
@@ -2860,17 +2881,21 @@ static HRESULT WINAPI allocator_QueryInterface(IVMRSurfaceAllocator9 *iface, REF
 
 static ULONG WINAPI allocator_AddRef(IVMRSurfaceAllocator9 *iface)
 {
-    return InterlockedIncrement(&allocator_refcount);
+    struct presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
+    return InterlockedIncrement(&presenter->refcount);
 }
 
 static ULONG WINAPI allocator_Release(IVMRSurfaceAllocator9 *iface)
 {
-    return InterlockedDecrement(&allocator_refcount);
+    struct presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
+    return InterlockedDecrement(&presenter->refcount);
 }
 
 static HRESULT WINAPI allocator_InitializeDevice(IVMRSurfaceAllocator9 *iface,
         DWORD_PTR cookie, VMR9AllocationInfo *info, DWORD *buffer_count)
 {
+    struct presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
+
     if (winetest_debug > 1) trace("InitializeDevice(flags %#x, format %u)\n",
             info->dwFlags, info->Format);
     ok(cookie == 0xabacab, "Got cookie %#lx.\n", cookie);
@@ -2884,33 +2909,37 @@ static HRESULT WINAPI allocator_InitializeDevice(IVMRSurfaceAllocator9 *iface,
     ok(info->szNativeSize.cy == 16, "Got native height %d.\n", info->szNativeSize.cy);
     todo_wine ok(*buffer_count == 5, "Got buffer count %u.\n", *buffer_count);
 
-    allocator_format = info->Format;
+    presenter->format = info->Format;
 
-    if (info->dwFlags != allocator_accept_flags)
+    if (info->dwFlags != presenter->accept_flags)
         return 0xdeadbeef;
-    return IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(allocator_notify,
-            info, buffer_count, allocator_surfaces);
+    return IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(presenter->notify,
+            info, buffer_count, presenter->surfaces);
 }
 
 static HRESULT WINAPI allocator_TerminateDevice(IVMRSurfaceAllocator9 *iface, DWORD_PTR cookie)
 {
+    struct presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
+
     if (winetest_debug > 1) trace("TerminateDevice()\n");
     ok(cookie == 0xabacab, "Got cookie %#lx.\n", cookie);
     /* Don't dereference the surfaces here, to mimic How to Survive. */
-    ++allocator_got_TerminateDevice;
+    ++presenter->got_TerminateDevice;
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI allocator_GetSurface(IVMRSurfaceAllocator9 *iface,
         DWORD_PTR cookie, DWORD index, DWORD flags, IDirect3DSurface9 **surface)
 {
+    struct presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
+
     if (winetest_debug > 1) trace("GetSurface(index %u)\n", index);
     ok(cookie == 0xabacab, "Got cookie %#lx.\n", cookie);
     ok(!flags, "Got flags %#x.\n", flags);
     ok(index < 5, "Got index %u.\n", index);
 
     /* Don't reference the surface here, to mimic How to Survive. */
-    *surface = allocator_surfaces[index];
+    *surface = presenter->surfaces[index];
     return S_OK;
 }
 
@@ -2931,10 +2960,8 @@ static const IVMRSurfaceAllocator9Vtbl allocator_vtbl =
     allocator_AdviseNotify,
 };
 
-static IVMRSurfaceAllocator9 allocator_iface = {&allocator_vtbl};
-static IVMRImagePresenter9 presenter_iface = {&presenter_vtbl};
-
-static void test_renderless_present(IFilterGraph2 *graph, IMemInputPin *input)
+static void test_renderless_present(struct presenter *presenter,
+        IFilterGraph2 *graph, IMemInputPin *input)
 {
     IMediaControl *control;
     OAFilterState state;
@@ -2943,7 +2970,7 @@ static void test_renderless_present(IFilterGraph2 *graph, IMemInputPin *input)
 
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
 
-    allocator_got_PresentImage = 0;
+    presenter->got_PresentImage = 0;
 
     hr = IMediaControl_Pause(control);
     ok(hr == S_FALSE, "Got hr %#x.\n", hr);
@@ -2954,13 +2981,13 @@ static void test_renderless_present(IFilterGraph2 *graph, IMemInputPin *input)
      * IMediaControl::Run() from a stopped state and expects that
      * IMediaControl::GetState() returns S_OK only after PresentImage() has
      * been called. */
-    ok(allocator_got_PresentImage == 1, "Got %u calls to PresentImage().\n", allocator_got_PresentImage);
+    ok(presenter->got_PresentImage == 1, "Got %u calls to PresentImage().\n", presenter->got_PresentImage);
 
     hr = IMediaControl_Run(control);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = join_thread(thread);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    ok(allocator_got_PresentImage == 1, "Got %u calls to PresentImage().\n", allocator_got_PresentImage);
+    ok(presenter->got_PresentImage == 1, "Got %u calls to PresentImage().\n", presenter->got_PresentImage);
 
     hr = IMediaControl_Stop(control);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -2986,6 +3013,13 @@ static void test_renderless_formats(void)
         .pbFormat = (BYTE *)&vih,
     };
     ALLOCATOR_PROPERTIES req_props = {5, 32 * 16 * 4, 1, 0}, ret_props;
+    struct presenter presenter =
+    {
+        .IVMRSurfaceAllocator9_iface.lpVtbl = &allocator_vtbl,
+        .IVMRImagePresenter9_iface.lpVtbl = &presenter_vtbl,
+        .refcount = 1,
+    };
+    struct presenter presenter2 = presenter;
     IVMRSurfaceAllocatorNotify9 *notify;
     RECT rect = {0, 0, 640, 480};
     struct testfilter source;
@@ -3047,10 +3081,11 @@ static void test_renderless_formats(void)
     }
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    hr = IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(notify, 0xabacab, &allocator_iface);
+    hr = IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(notify, 0xabacab,
+            &presenter.IVMRSurfaceAllocator9_iface);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    allocator_notify = notify;
+    presenter.notify = notify;
 
     testfilter_init(&source);
     graph = create_graph();
@@ -3062,7 +3097,7 @@ static void test_renderless_formats(void)
     for (i = 0; i < ARRAY_SIZE(tests); ++i)
     {
         req_mt.subtype = *tests[i].subtype;
-        allocator_accept_flags = tests[i].flags;
+        presenter.accept_flags = tests[i].flags;
 
         hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
         /* Connection never fails on Native, but Wine currently creates D3D
@@ -3100,10 +3135,14 @@ static void test_renderless_formats(void)
         hr = IMemAllocator_Commit(allocator);
         ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
 
-        ok(allocator_format == tests[i].format, "Test %u: Got format %u (%#x).\n",
-                i, allocator_format, allocator_format);
+        hr = IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(notify, 0xabacab,
+                &presenter2.IVMRSurfaceAllocator9_iface);
+        ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
+
+        ok(presenter.format == tests[i].format, "Test %u: Got format %u (%#x).\n",
+                i, presenter.format, presenter.format);
 
-        test_renderless_present(graph, input);
+        test_renderless_present(&presenter, graph, input);
 
         hr = IMemAllocator_Decommit(allocator);
         ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
@@ -3115,6 +3154,9 @@ static void test_renderless_formats(void)
         ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
     }
 
+    hr = IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(notify, 0xabacab, &presenter2.IVMRSurfaceAllocator9_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
     IMemInputPin_Release(input);
@@ -3124,7 +3166,8 @@ static void test_renderless_formats(void)
     IVMRSurfaceAllocatorNotify9_Release(notify);
     ref = IBaseFilter_Release(filter);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
-    ok(allocator_refcount == 1, "Got outstanding refcount %d.\n", allocator_refcount);
+    ok(presenter.refcount == 1, "Got outstanding refcount %d.\n", presenter.refcount);
+    ok(presenter2.refcount == 1, "Got outstanding refcount %d.\n", presenter2.refcount);
     ref = IDirect3DDevice9_Release(device);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
     DestroyWindow(window);
@@ -3279,25 +3322,30 @@ static void test_clipping_window(void)
 
 static void test_surface_allocator_notify_refcount(void)
 {
+    struct presenter presenter =
+    {
+        .IVMRSurfaceAllocator9_iface.lpVtbl = &allocator_vtbl,
+        .IVMRImagePresenter9_iface.lpVtbl = &presenter_vtbl,
+        .refcount = 1,
+    };
     IBaseFilter *filter = create_vmr9(VMR9Mode_Renderless);
     IVMRSurfaceAllocatorNotify9 *notify;
     HRESULT hr;
     ULONG ref;
 
-    allocator_got_TerminateDevice = 0;
-
     set_mixing_mode(filter, 2);
 
     IBaseFilter_QueryInterface(filter, &IID_IVMRSurfaceAllocatorNotify9, (void **)&notify);
 
-    hr = IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(notify, 0xabacab, &allocator_iface);
+    hr = IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(notify, 0xabacab,
+            &presenter.IVMRSurfaceAllocator9_iface);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ref = IBaseFilter_Release(filter);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
-    ok(allocator_got_TerminateDevice == 1, "Got %u calls to TerminateDevice().\n",
-            allocator_got_TerminateDevice);
-    ok(allocator_refcount == 1, "Got outstanding refcount %d.\n", allocator_refcount);
+    ok(presenter.got_TerminateDevice == 1, "Got %u calls to TerminateDevice().\n",
+            presenter.got_TerminateDevice);
+    ok(presenter.refcount == 1, "Got outstanding refcount %d.\n", presenter.refcount);
 
     ref = IVMRSurfaceAllocatorNotify9_Release(notify);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index f66500086d5..28123dcf7da 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -1982,20 +1982,37 @@ static HRESULT WINAPI VMR9SurfaceAllocatorNotify_AdviseSurfaceAllocator(
         IVMRSurfaceAllocatorNotify9 *iface, DWORD_PTR cookie, IVMRSurfaceAllocator9 *allocator)
 {
     struct quartz_vmr *filter = impl_from_IVMRSurfaceAllocatorNotify9(iface);
+    IVMRImagePresenter9 *presenter;
 
     TRACE("filter %p, cookie %#Ix, allocator %p.\n", filter, cookie, allocator);
 
+    EnterCriticalSection(&filter->renderer.filter.csFilter);
+
     filter->cookie = cookie;
 
-    if (filter->presenter)
+    if (filter->renderer.sink.pin.peer)
+    {
+        LeaveCriticalSection(&filter->renderer.filter.csFilter);
+        WARN("Attempt to set allocator while connected; returning VFW_E_WRONG_STATE.\n");
         return VFW_E_WRONG_STATE;
+    }
 
-    if (FAILED(IVMRSurfaceAllocator9_QueryInterface(allocator, &IID_IVMRImagePresenter9, (void **)&filter->presenter)))
+    if (FAILED(IVMRSurfaceAllocator9_QueryInterface(allocator, &IID_IVMRImagePresenter9, (void **)&presenter)))
+    {
+        LeaveCriticalSection(&filter->renderer.filter.csFilter);
         return E_NOINTERFACE;
+    }
 
+    if (filter->allocator)
+    {
+        IVMRImagePresenter9_Release(filter->presenter);
+        IVMRSurfaceAllocator9_Release(filter->allocator);
+    }
     filter->allocator = allocator;
+    filter->presenter = presenter;
     IVMRSurfaceAllocator9_AddRef(allocator);
 
+    LeaveCriticalSection(&filter->renderer.filter.csFilter);
     return S_OK;
 }
 
From d05ec6b2780144c5f1c56a702e0c1c502c6cb78a Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 28 Jul 2020 10:29:58 +0200
Subject: [PATCH] qdvd: Add a stub IDvdInfo2 interface.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qdvd/navigator.c       | 436 ++++++++++++++++++++++++++++++++++++
 dlls/qdvd/tests/navigator.c |   2 +-
 2 files changed, 437 insertions(+), 1 deletion(-)

diff --git a/dlls/qdvd/navigator.c b/dlls/qdvd/navigator.c
index 00cb0af995b..74bd9a3923d 100644
--- a/dlls/qdvd/navigator.c
+++ b/dlls/qdvd/navigator.c
@@ -27,6 +27,7 @@ struct navigator
 {
     struct strmbase_filter filter;
     IDvdControl2 IDvdControl2_iface;
+    IDvdInfo2 IDvdInfo2_iface;
 };
 
 static inline struct navigator *impl_from_strmbase_filter(struct strmbase_filter *filter)
@@ -40,6 +41,8 @@ static HRESULT navigator_query_interface(struct strmbase_filter *iface, REFIID i
 
     if (IsEqualGUID(iid, &IID_IDvdControl2))
         *out = &filter->IDvdControl2_iface;
+    else if (IsEqualGUID(iid, &IID_IDvdInfo2))
+        *out = &filter->IDvdInfo2_iface;
     else
         return E_NOINTERFACE;
 
@@ -504,6 +507,438 @@ static const struct IDvdControl2Vtbl dvd_control2_vtbl =
     dvd_control2_SelectDefaultSubpictureLanguage,
 };
 
+static struct navigator *impl_from_IDvdInfo2(IDvdInfo2 *iface)
+{
+    return CONTAINING_RECORD(iface, struct navigator, IDvdInfo2_iface);
+}
+
+static HRESULT WINAPI dvd_info2_QueryInterface(IDvdInfo2 *iface, REFIID iid, void **out)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+    return IUnknown_QueryInterface(filter->filter.outer_unk, iid, out);
+}
+
+static ULONG WINAPI dvd_info2_AddRef(IDvdInfo2 *iface)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+    return IUnknown_AddRef(filter->filter.outer_unk);
+}
+
+static ULONG WINAPI dvd_info2_Release(IDvdInfo2 *iface)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+    return IUnknown_Release(filter->filter.outer_unk);
+}
+
+static HRESULT WINAPI dvd_info2_GetCurrentDomain(IDvdInfo2 *iface, DVD_DOMAIN *domain)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, domain %p.\n", filter, domain);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetCurrentLocation(IDvdInfo2 *iface, DVD_PLAYBACK_LOCATION2 *location)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, location %p.\n", filter, location);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetTotalTitleTime(IDvdInfo2 *iface, DVD_HMSF_TIMECODE *time, ULONG *flags)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, time %p, flags %p.\n", filter, time, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetCurrentButton(IDvdInfo2 *iface, ULONG *count, ULONG *current)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, count %p, current %p.\n", filter, count, current);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetCurrentAngle(IDvdInfo2 *iface, ULONG *count, ULONG *current)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, count %p, current %p.\n", filter, count, current);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetCurrentAudio(IDvdInfo2 *iface, ULONG *count, ULONG *current)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, count %p, current %p.\n", filter, count, current);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetCurrentSubpicture(IDvdInfo2 *iface, ULONG *count, ULONG *current, BOOL *enable)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, count %p, current %p, enable %p.\n", filter, count, current, enable);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetCurrentUOPS(IDvdInfo2 *iface, ULONG *uops)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, uops %p.\n", filter, uops);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetAllSPRMs(IDvdInfo2 *iface, SPRMARRAY *regs)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, regs %p.\n", filter, regs);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetAllGPRMs(IDvdInfo2 *iface, GPRMARRAY *regs)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, regs %p.\n", filter, regs);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetAudioLanguage(IDvdInfo2 *iface, ULONG stream, LCID *language)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, stream %u, language %p.\n", filter, stream, language);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetSubpictureLanguage(IDvdInfo2 *iface, ULONG stream, LCID *language)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, stream %u, language %p.\n", filter, stream, language);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetTitleAttributes(IDvdInfo2 *iface, ULONG index,
+        DVD_MenuAttributes *menu, DVD_TitleAttributes *title)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, index %u, menu %p, title %p.\n", filter, index, menu, title);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetVMGAttributes(IDvdInfo2 *iface, DVD_MenuAttributes *attr)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, attr %p.\n", filter, attr);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetVideoAttributes(IDvdInfo2 *iface, DVD_VideoAttributes *attr)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, attr %p.\n", filter, attr);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetAudioAttributes(IDvdInfo2 *iface, ULONG stream, DVD_AudioAttributes *attr)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, stream %u, attr %p.\n", filter, stream, attr);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetKaraokeAttributes(IDvdInfo2 *iface, ULONG stream, DVD_KaraokeAttributes *attr)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, stream %u, attr %p.\n", filter, stream, attr);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetSubpictureAttributes(IDvdInfo2 *iface, ULONG stream,
+        DVD_SubpictureAttributes *attr)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, stream %u, attr %p.\n", filter, stream, attr);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetCurrentVolumeInfo(IDvdInfo2 *iface, ULONG *volume_count, ULONG *current,
+        DVD_DISC_SIDE *side, ULONG *title_count)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, volume_count %p, current %p, side %p, title_count %p.\n",
+            filter, volume_count, current, side, title_count);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetDVDTextNumberOfLanguages(IDvdInfo2 *iface, ULONG *count)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, count %p.\n", filter, count);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetDVDTextLanguageInfo(IDvdInfo2 *iface, ULONG index, ULONG *string_count,
+        LCID *language, enum DVD_TextCharSet *character_set)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, index %u, string_count %p, language %p, character_set %p.\n",
+            filter, index, string_count, language, character_set);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetDVDTextStringAsNative(IDvdInfo2 *iface, ULONG lang_index, ULONG string_index,
+        BYTE *string, ULONG size, ULONG *ret_size, enum DVD_TextStringType *type)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, lang_index %u, string_index %u, string %p, size %u, ret_size %p, type %p.\n",
+            filter, lang_index, string_index, string, size, ret_size, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetDVDTextStringAsUnicode(IDvdInfo2 *iface, ULONG lang_index, ULONG string_index,
+        WCHAR *string, ULONG size, ULONG *ret_size, enum DVD_TextStringType *type)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, lang_index %u, string_index %u, string %p, size %u, ret_size %p, type %p.\n",
+            filter, lang_index, string_index, string, size, ret_size, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetPlayerParentalLevel(IDvdInfo2 *iface, ULONG *level, BYTE country_code[2])
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, level %p, country_code %p.\n", filter, level, country_code);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetNumberOfChapters(IDvdInfo2 *iface, ULONG title, ULONG *count)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, title %u, count %p.\n", filter, title, count);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetTitleParentalLevels(IDvdInfo2 *iface, ULONG title, ULONG *levels)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, title %u, levels %p.\n", filter, title, levels);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetDVDDirectory(IDvdInfo2 *iface, WCHAR *path, ULONG size, ULONG *ret_size)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, path %p, size %u, ret_size %p.\n", filter, path, size, ret_size);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_IsAudioStreamEnabled(IDvdInfo2 *iface, ULONG stream, BOOL *enable)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, stream %u, enable %p.\n", filter, stream, enable);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetDiscID(IDvdInfo2 *iface, const WCHAR *path, ULONGLONG *id)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, path %s, id %p.\n", filter, debugstr_w(path), id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetState(IDvdInfo2 *iface, IDvdState **state)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, state %p.\n", filter, state);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetMenuLanguages(IDvdInfo2 *iface, LCID *languages, ULONG count, ULONG *ret_count)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, languages %p, count %u, ret_count %p.\n", filter, languages, count, ret_count);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetButtonAtPosition(IDvdInfo2 *iface, POINT point, ULONG *button)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, point %s, button %p.\n", filter, wine_dbgstr_point(&point), button);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetCmdFromEvent(IDvdInfo2 *iface, LONG_PTR param, IDvdCmd **cmd)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, param %#lx, cmd %p.\n", filter, param, cmd);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetDefaultMenuLanguage(IDvdInfo2 *iface, LCID *language)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, language %p.\n", filter, language);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetDefaultAudioLanguage(IDvdInfo2 *iface, LCID *language,
+        DVD_AUDIO_LANG_EXT *extension)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, language %p, extension %p.\n", filter, language, extension);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_SelectDefaultSubpictureLanguage(IDvdInfo2 *iface, LCID *language,
+        DVD_SUBPICTURE_LANG_EXT *extension)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, language %p, extension %p.\n", filter, language, extension);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetDecoderCaps(IDvdInfo2 *iface, DVD_DECODER_CAPS *caps)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, caps %p.\n", filter, caps);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_GetButtonRect(IDvdInfo2 *iface, ULONG button, RECT *rect)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, button %u, rect %p.\n", filter, button, rect);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dvd_info2_IsSubpictureStreamEnabled(IDvdInfo2 *iface, ULONG stream, BOOL *enable)
+{
+    struct navigator *filter = impl_from_IDvdInfo2(iface);
+
+    FIXME("filter %p, stream %u, enable %p.\n", filter, stream, enable);
+
+    return E_NOTIMPL;
+}
+
+static const struct IDvdInfo2Vtbl dvd_info2_vtbl =
+{
+    dvd_info2_QueryInterface,
+    dvd_info2_AddRef,
+    dvd_info2_Release,
+    dvd_info2_GetCurrentDomain,
+    dvd_info2_GetCurrentLocation,
+    dvd_info2_GetTotalTitleTime,
+    dvd_info2_GetCurrentButton,
+    dvd_info2_GetCurrentAngle,
+    dvd_info2_GetCurrentAudio,
+    dvd_info2_GetCurrentSubpicture,
+    dvd_info2_GetCurrentUOPS,
+    dvd_info2_GetAllSPRMs,
+    dvd_info2_GetAllGPRMs,
+    dvd_info2_GetAudioLanguage,
+    dvd_info2_GetSubpictureLanguage,
+    dvd_info2_GetTitleAttributes,
+    dvd_info2_GetVMGAttributes,
+    dvd_info2_GetVideoAttributes,
+    dvd_info2_GetAudioAttributes,
+    dvd_info2_GetKaraokeAttributes,
+    dvd_info2_GetSubpictureAttributes,
+    dvd_info2_GetCurrentVolumeInfo,
+    dvd_info2_GetDVDTextNumberOfLanguages,
+    dvd_info2_GetDVDTextLanguageInfo,
+    dvd_info2_GetDVDTextStringAsNative,
+    dvd_info2_GetDVDTextStringAsUnicode,
+    dvd_info2_GetPlayerParentalLevel,
+    dvd_info2_GetNumberOfChapters,
+    dvd_info2_GetTitleParentalLevels,
+    dvd_info2_GetDVDDirectory,
+    dvd_info2_IsAudioStreamEnabled,
+    dvd_info2_GetDiscID,
+    dvd_info2_GetState,
+    dvd_info2_GetMenuLanguages,
+    dvd_info2_GetButtonAtPosition,
+    dvd_info2_GetCmdFromEvent,
+    dvd_info2_GetDefaultMenuLanguage,
+    dvd_info2_GetDefaultAudioLanguage,
+    dvd_info2_SelectDefaultSubpictureLanguage,
+    dvd_info2_GetDecoderCaps,
+    dvd_info2_GetButtonRect,
+    dvd_info2_IsSubpictureStreamEnabled
+};
+
 HRESULT navigator_create(IUnknown *outer, IUnknown **out)
 {
     struct navigator *object;
@@ -513,6 +948,7 @@ HRESULT navigator_create(IUnknown *outer, IUnknown **out)
 
     strmbase_filter_init(&object->filter, outer, &CLSID_DVDNavigator, &filter_ops);
     object->IDvdControl2_iface.lpVtbl = &dvd_control2_vtbl;
+    object->IDvdInfo2_iface.lpVtbl = &dvd_info2_vtbl;
 
     TRACE("Created DVD Navigator filter %p.\n", object);
     *out = &object->filter.IUnknown_inner;
diff --git a/dlls/qdvd/tests/navigator.c b/dlls/qdvd/tests/navigator.c
index db2ba392dc5..51999065cf5 100644
--- a/dlls/qdvd/tests/navigator.c
+++ b/dlls/qdvd/tests/navigator.c
@@ -62,7 +62,7 @@ static void test_interfaces(void)
     todo_wine check_interface(filter, &IID_IDvdControl, TRUE);
     check_interface(filter, &IID_IDvdControl2, TRUE);
     todo_wine check_interface(filter, &IID_IDvdInfo, TRUE);
-    todo_wine check_interface(filter, &IID_IDvdInfo2, TRUE);
+    check_interface(filter, &IID_IDvdInfo2, TRUE);
     check_interface(filter, &IID_IMediaFilter, TRUE);
     check_interface(filter, &IID_IPersist, TRUE);
     todo_wine check_interface(filter, &IID_ISpecifyPropertyPages, TRUE);
From 17f766a853ede17e3f4365692c593d16c9e657cd Mon Sep 17 00:00:00 2001
From: Myah Caron <qsniyg@protonmail.com>
Date: Tue, 28 Jul 2020 16:13:59 -0500
Subject: [PATCH] amstream: Implement IMediaStreamFilter::GetDuration.

Signed-off-by: Myah Caron <qsniyg@protonmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/filter.c         |  19 ++++-
 dlls/amstream/tests/amstream.c | 130 +++++++++++++++++++++++++++++++++
 2 files changed, 147 insertions(+), 2 deletions(-)

diff --git a/dlls/amstream/filter.c b/dlls/amstream/filter.c
index 0a06e78180c..b99cc4cda0c 100644
--- a/dlls/amstream/filter.c
+++ b/dlls/amstream/filter.c
@@ -773,9 +773,24 @@ static HRESULT WINAPI filter_seeking_SetTimeFormat(IMediaSeeking *iface, const G
 
 static HRESULT WINAPI filter_seeking_GetDuration(IMediaSeeking *iface, LONGLONG *duration)
 {
-    FIXME("iface %p, duration %p, stub!\n", iface, duration);
+    struct filter *filter = impl_from_IMediaSeeking(iface);
+    IMediaSeeking *seeking;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("filter %p, duration %p.\n", filter, duration);
+
+    EnterCriticalSection(&filter->cs);
+
+    if (!(seeking = get_seeking(filter->seekable_stream)))
+    {
+        LeaveCriticalSection(&filter->cs);
+        return E_NOTIMPL;
+    }
+    hr = IMediaSeeking_GetDuration(seeking, duration);
+    IMediaSeeking_Release(seeking);
+
+    LeaveCriticalSection(&filter->cs);
+    return hr;
 }
 
 static HRESULT WINAPI filter_seeking_GetStopPosition(IMediaSeeking *iface, LONGLONG *stop)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 68d2b9c18fc..5402734b3df 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -5099,6 +5099,135 @@ static void test_mediastreamfilter_set_positions(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_mediastreamfilter_get_duration(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    static const MSPID mspid1 = {0x88888888, 1};
+    static const MSPID mspid2 = {0x88888888, 2};
+    static const MSPID mspid3 = {0x88888888, 3};
+    struct testfilter source1, source2, source3;
+    IAMMediaStream *stream1, *stream2, *stream3;
+    IMediaStreamFilter *filter;
+    IPin *pin1, *pin2, *pin3;
+    IMediaSeeking *seeking;
+    IGraphBuilder *graph;
+    LONGLONG duration;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream1);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream1, NULL, 0, &mspid1, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream2, NULL, 0, &mspid2, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream3, NULL, 0, &mspid3, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream1, &mspid1, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream2, &mspid2, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream3, &mspid3, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream1, &IID_IPin, (void **)&pin1);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream2, &IID_IPin, (void **)&pin2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream3, &IID_IPin, (void **)&pin3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    testfilter_init(&source1);
+    testfilter_init(&source2);
+    testfilter_init(&source3);
+    source1.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    source2.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    source3.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    hr = IGraphBuilder_AddFilter(graph, &source1.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_AddFilter(graph, &source2.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_AddFilter(graph, &source3.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &audio_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &audio_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &audio_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_QueryInterface(filter, &IID_IMediaSeeking, (void **)&seeking);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    duration = 0xdeadbeefdeadbeefULL;
+    hr = IMediaSeeking_GetDuration(seeking, &duration);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(duration == 0x8000000000000000ULL, "Got duration %s.\n", wine_dbgstr_longlong(duration));
+
+    source2.get_duration_hr = E_FAIL;
+    duration = 0xdeadbeefdeadbeefULL;
+    hr = IMediaSeeking_GetDuration(seeking, &duration);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(duration == 0xdeadbeefdeadbeefULL, "Got duration %s.\n", wine_dbgstr_longlong(duration));
+
+    source2.get_duration_hr = E_NOTIMPL;
+    duration = 0xdeadbeefdeadbeefULL;
+    hr = IMediaSeeking_GetDuration(seeking, &duration);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(duration == 0xdeadbeefdeadbeefULL, "Got duration %s.\n", wine_dbgstr_longlong(duration));
+
+    source2.IMediaSeeking_iface.lpVtbl = NULL;
+    duration = 0xdeadbeefdeadbeefULL;
+    hr = IMediaSeeking_GetDuration(seeking, &duration);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(duration == 0xdeadbeefdeadbeefULL, "Got duration %s.\n", wine_dbgstr_longlong(duration));
+
+    IGraphBuilder_Disconnect(graph, pin2);
+    IGraphBuilder_Disconnect(graph, &source2.source.pin.IPin_iface);
+
+    source2.IMediaSeeking_iface.lpVtbl = NULL;
+    duration = 0xdeadbeefdeadbeefULL;
+    hr = IMediaSeeking_GetDuration(seeking, &duration);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(duration == 0xdeadbeefdeadbeefULL, "Got duration %s.\n", wine_dbgstr_longlong(duration));
+
+    IGraphBuilder_Disconnect(graph, pin2);
+    IGraphBuilder_Disconnect(graph, &source2.source.pin.IPin_iface);
+    IGraphBuilder_Disconnect(graph, pin3);
+    IGraphBuilder_Disconnect(graph, &source3.source.pin.IPin_iface);
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IMediaSeeking_Release(seeking);
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin1);
+    ref = IAMMediaStream_Release(stream1);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin2);
+    ref = IAMMediaStream_Release(stream2);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin3);
+    ref = IAMMediaStream_Release(stream3);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void test_mediastreamfilter_get_current_stream_time(void)
 {
     IMediaStreamFilter *filter;
@@ -5340,6 +5469,7 @@ START_TEST(amstream)
     test_mediastreamfilter_stop_pause_run();
     test_mediastreamfilter_support_seeking();
     test_mediastreamfilter_set_positions();
+    test_mediastreamfilter_get_duration();
     test_mediastreamfilter_get_current_stream_time();
 
     CoUninitialize();
From b0fcdf9405be5edc2c83fe542a5aca4c284d1404 Mon Sep 17 00:00:00 2001
From: Myah Caron <qsniyg@protonmail.com>
Date: Tue, 28 Jul 2020 16:14:00 -0500
Subject: [PATCH] amstream: Implement IAMMultiMediaStream::GetDuration.

Signed-off-by: Myah Caron <qsniyg@protonmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/multimedia.c     | 10 +++--
 dlls/amstream/tests/amstream.c | 80 ++++++++++++++++++++++++++++++++++
 2 files changed, 86 insertions(+), 4 deletions(-)

diff --git a/dlls/amstream/multimedia.c b/dlls/amstream/multimedia.c
index 200bd5c4a5e..414a903cf20 100644
--- a/dlls/amstream/multimedia.c
+++ b/dlls/amstream/multimedia.c
@@ -173,13 +173,15 @@ static HRESULT WINAPI multimedia_stream_GetTime(IAMMultiMediaStream *iface, STRE
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI multimedia_stream_GetDuration(IAMMultiMediaStream *iface, STREAM_TIME *pDuration)
+static HRESULT WINAPI multimedia_stream_GetDuration(IAMMultiMediaStream *iface, STREAM_TIME *duration)
 {
-    struct multimedia_stream *This = impl_from_IAMMultiMediaStream(iface);
+    struct multimedia_stream *mmstream = impl_from_IAMMultiMediaStream(iface);
 
-    FIXME("(%p/%p)->(%p) stub!\n", This, iface, pDuration);
+    TRACE("mmstream %p, duration %p.\n", mmstream, duration);
 
-    return E_NOTIMPL;
+    if (!mmstream->media_seeking)
+        return E_NOINTERFACE;
+    return IMediaSeeking_GetDuration(mmstream->media_seeking, duration);
 }
 
 static HRESULT WINAPI multimedia_stream_Seek(IAMMultiMediaStream *iface, STREAM_TIME seek_time)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 5402734b3df..85dcac91ad3 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -336,6 +336,85 @@ static void test_openfile(const WCHAR *test_avi_path)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_mmstream_get_duration(const WCHAR *test_avi_path)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    HRESULT hr, audio_hr;
+    LONGLONG duration;
+    ULONG ref;
+
+    duration = 0xdeadbeefdeadbeefULL;
+    hr = IAMMultiMediaStream_GetDuration(mmstream, &duration);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+    ok(duration == 0xdeadbeefdeadbeefULL, "Got duration %s.\n", wine_dbgstr_longlong(duration));
+
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryVideo, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, AMMSF_ADDDEFAULTRENDERER, NULL);
+    ok(hr == S_OK || hr == VFW_E_NO_AUDIO_HARDWARE, "Got hr %#x.\n", hr);
+    audio_hr = hr;
+
+    hr = IAMMultiMediaStream_OpenFile(mmstream, test_avi_path, 0);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    duration = 0xdeadbeefdeadbeefULL;
+    hr = IAMMultiMediaStream_GetDuration(mmstream, &duration);
+    if (audio_hr == S_OK)
+    {
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(duration == 1000000LL, "Got duration %s.\n", wine_dbgstr_longlong(duration));
+    }
+    else
+    {
+        ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+        ok(!duration, "Got duration %s.\n", wine_dbgstr_longlong(duration));
+    }
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+    mmstream = create_ammultimediastream();
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    duration = 0xdeadbeefdeadbeefULL;
+    hr = IAMMultiMediaStream_GetDuration(mmstream, &duration);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(duration == 0, "Got duration %s.\n", wine_dbgstr_longlong(duration));
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+    mmstream = create_ammultimediastream();
+
+    hr = IAMMultiMediaStream_OpenFile(mmstream, test_avi_path, 0);
+    todo_wine ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x.\n", hr);
+
+    duration = 0xdeadbeefdeadbeefULL;
+    hr = IAMMultiMediaStream_GetDuration(mmstream, &duration);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    todo_wine ok(duration == 0, "Got duration %s.\n", wine_dbgstr_longlong(duration));
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+    mmstream = create_ammultimediastream();
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_OpenFile(mmstream, test_avi_path, AMMSF_NORENDER);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    duration = 0xdeadbeefdeadbeefULL;
+    hr = IAMMultiMediaStream_GetDuration(mmstream, &duration);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(duration == 0, "Got duration %s.\n", wine_dbgstr_longlong(duration));
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void test_renderfile(const WCHAR *test_avi_path)
 {
     IAMMultiMediaStream *pams;
@@ -5432,6 +5511,7 @@ START_TEST(amstream)
     test_avi_path = load_resource(L"test.avi");
 
     test_openfile(test_avi_path);
+    test_mmstream_get_duration(test_avi_path);
     test_renderfile(test_avi_path);
 
     unload_resource(test_avi_path);
From fc74e4b3dca5a8d4f22e53025a1f99ef1dff7fe6 Mon Sep 17 00:00:00 2001
From: Myah Caron <qsniyg@protonmail.com>
Date: Tue, 28 Jul 2020 16:14:01 -0500
Subject: [PATCH] amstream: Implement IMediaStreamFilter::GetStopPosition.

Signed-off-by: Myah Caron <qsniyg@protonmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/filter.c         |  19 ++++-
 dlls/amstream/tests/amstream.c | 139 ++++++++++++++++++++++++++++++++-
 2 files changed, 154 insertions(+), 4 deletions(-)

diff --git a/dlls/amstream/filter.c b/dlls/amstream/filter.c
index b99cc4cda0c..13fd30c3a51 100644
--- a/dlls/amstream/filter.c
+++ b/dlls/amstream/filter.c
@@ -795,9 +795,24 @@ static HRESULT WINAPI filter_seeking_GetDuration(IMediaSeeking *iface, LONGLONG
 
 static HRESULT WINAPI filter_seeking_GetStopPosition(IMediaSeeking *iface, LONGLONG *stop)
 {
-    FIXME("iface %p, stop %p, stub!\n", iface, stop);
+    struct filter *filter = impl_from_IMediaSeeking(iface);
+    IMediaSeeking *seeking;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("filter %p, stop %p.\n", filter, stop);
+
+    EnterCriticalSection(&filter->cs);
+
+    if (!(seeking = get_seeking(filter->seekable_stream)))
+    {
+        LeaveCriticalSection(&filter->cs);
+        return E_NOTIMPL;
+    }
+    hr = IMediaSeeking_GetStopPosition(seeking, stop);
+    IMediaSeeking_Release(seeking);
+
+    LeaveCriticalSection(&filter->cs);
+    return hr;
 }
 
 static HRESULT WINAPI filter_seeking_GetCurrentPosition(IMediaSeeking *iface, LONGLONG *current)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 85dcac91ad3..c5cdd7aaee4 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -814,6 +814,7 @@ struct testfilter
     LONGLONG current_position;
     LONGLONG stop_position;
     HRESULT get_duration_hr;
+    HRESULT get_stop_position_hr;
     HRESULT set_positions_hr;
     HRESULT init_stream_hr;
     HRESULT cleanup_stream_hr;
@@ -997,8 +998,12 @@ static HRESULT WINAPI testsource_seeking_GetDuration(IMediaSeeking *iface, LONGL
 
 static HRESULT WINAPI testsource_seeking_GetStopPosition(IMediaSeeking *iface, LONGLONG *stop)
 {
-    ok(0, "Unexpected call.\n");
-    return E_NOTIMPL;
+    struct testfilter *filter = impl_from_IMediaSeeking(iface);
+
+    if (SUCCEEDED(filter->get_stop_position_hr))
+        *stop = 0x8000000000000000ULL;
+
+    return filter->get_stop_position_hr;
 }
 
 static HRESULT WINAPI testsource_seeking_GetCurrentPosition(IMediaSeeking *iface, LONGLONG *current)
@@ -5307,6 +5312,135 @@ static void test_mediastreamfilter_get_duration(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_mediastreamfilter_get_stop_position(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    static const MSPID mspid1 = {0x88888888, 1};
+    static const MSPID mspid2 = {0x88888888, 2};
+    static const MSPID mspid3 = {0x88888888, 3};
+    struct testfilter source1, source2, source3;
+    IAMMediaStream *stream1, *stream2, *stream3;
+    IMediaStreamFilter *filter;
+    IPin *pin1, *pin2, *pin3;
+    IMediaSeeking *seeking;
+    IGraphBuilder *graph;
+    LONGLONG stop;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream1);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = CoCreateInstance(&CLSID_AMAudioStream, NULL, CLSCTX_INPROC_SERVER, &IID_IAMMediaStream, (void **)&stream3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream1, NULL, 0, &mspid1, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream2, NULL, 0, &mspid2, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_Initialize(stream3, NULL, 0, &mspid3, STREAMTYPE_READ);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream1, &mspid1, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream2, &mspid2, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)stream3, &mspid3, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream1, &IID_IPin, (void **)&pin1);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream2, &IID_IPin, (void **)&pin2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMediaStream_QueryInterface(stream3, &IID_IPin, (void **)&pin3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(graph != NULL, "Expected non-NULL graph.\n");
+    testfilter_init(&source1);
+    testfilter_init(&source2);
+    testfilter_init(&source3);
+    source1.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    source2.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    source3.IMediaSeeking_iface.lpVtbl = &testsource_seeking_vtbl;
+    hr = IGraphBuilder_AddFilter(graph, &source1.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_AddFilter(graph, &source2.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_AddFilter(graph, &source3.filter.IBaseFilter_iface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source2.source.pin.IPin_iface, pin2, &audio_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_ConnectDirect(graph, &source3.source.pin.IPin_iface, pin3, &audio_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_SupportSeeking(filter, TRUE);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source1.source.pin.IPin_iface, pin1, &audio_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStreamFilter_QueryInterface(filter, &IID_IMediaSeeking, (void **)&seeking);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    stop = 0xdeadbeefdeadbeefULL;
+    hr = IMediaSeeking_GetStopPosition(seeking, &stop);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(stop == 0x8000000000000000ULL, "Got stop position %s.\n", wine_dbgstr_longlong(stop));
+
+    source2.get_stop_position_hr = E_FAIL;
+    stop = 0xdeadbeefdeadbeefULL;
+    hr = IMediaSeeking_GetStopPosition(seeking, &stop);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(stop == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n", wine_dbgstr_longlong(stop));
+
+    source2.get_stop_position_hr = E_NOTIMPL;
+    stop = 0xdeadbeefdeadbeefULL;
+    hr = IMediaSeeking_GetStopPosition(seeking, &stop);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(stop == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n", wine_dbgstr_longlong(stop));
+
+    source2.IMediaSeeking_iface.lpVtbl = NULL;
+    stop = 0xdeadbeefdeadbeefULL;
+    hr = IMediaSeeking_GetStopPosition(seeking, &stop);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(stop == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n", wine_dbgstr_longlong(stop));
+
+    IGraphBuilder_Disconnect(graph, pin2);
+    IGraphBuilder_Disconnect(graph, &source2.source.pin.IPin_iface);
+
+    source2.IMediaSeeking_iface.lpVtbl = NULL;
+    stop = 0xdeadbeefdeadbeefULL;
+    hr = IMediaSeeking_GetStopPosition(seeking, &stop);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
+    ok(stop == 0xdeadbeefdeadbeefULL, "Got stop position %s.\n", wine_dbgstr_longlong(stop));
+
+    IGraphBuilder_Disconnect(graph, pin2);
+    IGraphBuilder_Disconnect(graph, &source2.source.pin.IPin_iface);
+    IGraphBuilder_Disconnect(graph, pin3);
+    IGraphBuilder_Disconnect(graph, &source3.source.pin.IPin_iface);
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IMediaSeeking_Release(seeking);
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin1);
+    ref = IAMMediaStream_Release(stream1);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin2);
+    ref = IAMMediaStream_Release(stream2);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin3);
+    ref = IAMMediaStream_Release(stream3);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void test_mediastreamfilter_get_current_stream_time(void)
 {
     IMediaStreamFilter *filter;
@@ -5550,6 +5684,7 @@ START_TEST(amstream)
     test_mediastreamfilter_support_seeking();
     test_mediastreamfilter_set_positions();
     test_mediastreamfilter_get_duration();
+    test_mediastreamfilter_get_stop_position();
     test_mediastreamfilter_get_current_stream_time();
 
     CoUninitialize();
From 08c076f542b7397aa78939b922ca348dd6a66588 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Wed, 29 Jul 2020 14:43:59 +0200
Subject: [PATCH] amstream: Increase parent IAMMediaStream refcount in
 IAudioMediaStream::CreateSample().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    | 2 ++
 dlls/amstream/tests/amstream.c | 3 +++
 2 files changed, 5 insertions(+)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 112891eeb74..e888caaa989 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -201,6 +201,7 @@ static ULONG WINAPI IAudioStreamSampleImpl_Release(IAudioStreamSample *iface)
 
     if (!ref)
     {
+        IAMMediaStream_Release(&This->parent->IAMMediaStream_iface);
         CloseHandle(This->update_event);
         HeapFree(GetProcessHeap(), 0, This);
     }
@@ -375,6 +376,7 @@ static HRESULT audiostreamsample_create(struct audio_stream *parent, IAudioData
     object->IAudioStreamSample_iface.lpVtbl = &AudioStreamSample_Vtbl;
     object->ref = 1;
     object->parent = parent;
+    IAMMediaStream_AddRef(&parent->IAMMediaStream_iface);
     object->audio_data = audio_data;
     object->update_event = CreateEventW(NULL, FALSE, FALSE, NULL);
 
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index c5cdd7aaee4..e9e9a6d8250 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -1505,8 +1505,11 @@ static void test_media_streams(void)
 
             hr = IAudioMediaStream_CreateSample(audio_media_stream, NULL, 0, &audio_sample);
             ok(hr == E_POINTER, "IAudioMediaStream_CreateSample returned: %x\n", hr);
+
+            EXPECT_REF(audio_stream, 3);
             hr = IAudioMediaStream_CreateSample(audio_media_stream, audio_data, 0, &audio_sample);
             ok(hr == S_OK, "IAudioMediaStream_CreateSample returned: %x\n", hr);
+            EXPECT_REF(audio_stream, 4);
 
             hr = IAudioMediaStream_GetMultiMediaStream(audio_media_stream, NULL);
             ok(hr == E_POINTER, "Expected E_POINTER, got %x\n", hr);
From 1b3121c2ed0d02c4f516c760a3e701321a2f8f4e Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Wed, 29 Jul 2020 14:44:00 +0200
Subject: [PATCH] amstream: Increase IAudioData refcount in
 IAudioMediaStream::CreateSample().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    | 2 ++
 dlls/amstream/tests/amstream.c | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index e888caaa989..85613f4f0e2 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -202,6 +202,7 @@ static ULONG WINAPI IAudioStreamSampleImpl_Release(IAudioStreamSample *iface)
     if (!ref)
     {
         IAMMediaStream_Release(&This->parent->IAMMediaStream_iface);
+        IAudioData_Release(This->audio_data);
         CloseHandle(This->update_event);
         HeapFree(GetProcessHeap(), 0, This);
     }
@@ -378,6 +379,7 @@ static HRESULT audiostreamsample_create(struct audio_stream *parent, IAudioData
     object->parent = parent;
     IAMMediaStream_AddRef(&parent->IAMMediaStream_iface);
     object->audio_data = audio_data;
+    IAudioData_AddRef(audio_data);
     object->update_event = CreateEventW(NULL, FALSE, FALSE, NULL);
 
     *audio_stream_sample = &object->IAudioStreamSample_iface;
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index e9e9a6d8250..6631fd312a9 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -1507,9 +1507,11 @@ static void test_media_streams(void)
             ok(hr == E_POINTER, "IAudioMediaStream_CreateSample returned: %x\n", hr);
 
             EXPECT_REF(audio_stream, 3);
+            EXPECT_REF(audio_data, 1);
             hr = IAudioMediaStream_CreateSample(audio_media_stream, audio_data, 0, &audio_sample);
             ok(hr == S_OK, "IAudioMediaStream_CreateSample returned: %x\n", hr);
             EXPECT_REF(audio_stream, 4);
+            EXPECT_REF(audio_data, 2);
 
             hr = IAudioMediaStream_GetMultiMediaStream(audio_media_stream, NULL);
             ok(hr == E_POINTER, "Expected E_POINTER, got %x\n", hr);
From 67b7d597c92798a9719ee0fe10d6bde5bf116536 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Wed, 29 Jul 2020 12:30:35 +0200
Subject: [PATCH] amstream: Implement IAudioStreamSample::GetMediaStream().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    | 12 ++++++--
 dlls/amstream/tests/amstream.c | 52 ++++++++++++++++++++++++++++++++++
 2 files changed, 62 insertions(+), 2 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 85613f4f0e2..0761050a65b 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -213,9 +213,17 @@ static ULONG WINAPI IAudioStreamSampleImpl_Release(IAudioStreamSample *iface)
 /*** IStreamSample methods ***/
 static HRESULT WINAPI IAudioStreamSampleImpl_GetMediaStream(IAudioStreamSample *iface, IMediaStream **media_stream)
 {
-    FIXME("(%p)->(%p): stub\n", iface, media_stream);
+    IAudioStreamSampleImpl *sample = impl_from_IAudioStreamSample(iface);
 
-    return E_NOTIMPL;
+    TRACE("sample %p, media_stream %p.\n", iface, media_stream);
+
+    if (!media_stream)
+        return E_POINTER;
+
+    IAMMediaStream_AddRef(&sample->parent->IAMMediaStream_iface);
+    *media_stream = (IMediaStream *)&sample->parent->IAMMediaStream_iface;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI IAudioStreamSampleImpl_GetSampleTimes(IAudioStreamSample *iface, STREAM_TIME *start_time,
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 6631fd312a9..d1c39925853 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -5629,6 +5629,57 @@ static void test_ddrawstream_getsetdirectdraw(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_audiostreamsample_get_media_stream(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IAudioStreamSample *audio_sample;
+    IAudioMediaStream *audio_stream;
+    IMediaStream *stream, *stream2;
+    IAudioData *audio_data;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStream_QueryInterface(stream, &IID_IAudioMediaStream, (void **)&audio_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = CoCreateInstance(&CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER, &IID_IAudioData, (void **)&audio_data);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAudioMediaStream_CreateSample(audio_stream, audio_data, 0, &audio_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IAudioStreamSample_GetMediaStream(audio_sample, NULL);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+    }
+
+    EXPECT_REF(stream, 4);
+    hr = IAudioStreamSample_GetMediaStream(audio_sample, &stream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(stream2 == stream, "Expected stream %p, got %p.\n", stream, stream2);
+    EXPECT_REF(stream, 5);
+
+    IMediaStream_Release(stream2);
+
+    IAudioMediaStream_Release(audio_stream);
+    ref = IAudioStreamSample_Release(audio_sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAudioData_Release(audio_data);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(amstream)
 {
     const WCHAR *test_avi_path;
@@ -5675,6 +5726,7 @@ START_TEST(amstream)
     test_audiostreamsample_update();
     test_audiostreamsample_completion_status();
     test_audiostreamsample_get_sample_times();
+    test_audiostreamsample_get_media_stream();
 
     test_ddrawstream_initialize();
     test_ddrawstream_getsetdirectdraw();
From b8a39aaf759e20ee738bdee7cbcef2119d524f6e Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Wed, 29 Jul 2020 12:30:36 +0200
Subject: [PATCH] amstream: Implement IAudioStreamSample::GetAudioData().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    | 12 +++++++--
 dlls/amstream/tests/amstream.c | 48 ++++++++++++++++++++++++++++++++++
 2 files changed, 58 insertions(+), 2 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 0761050a65b..41f225d022a 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -351,9 +351,17 @@ static HRESULT WINAPI IAudioStreamSampleImpl_CompletionStatus(IAudioStreamSample
 /*** IAudioStreamSample methods ***/
 static HRESULT WINAPI IAudioStreamSampleImpl_GetAudioData(IAudioStreamSample *iface, IAudioData **audio_data)
 {
-    FIXME("(%p)->(%p): stub\n", iface, audio_data);
+    IAudioStreamSampleImpl *sample = impl_from_IAudioStreamSample(iface);
 
-    return E_NOTIMPL;
+    TRACE("sample %p, audio_data %p.\n", sample, audio_data);
+
+    if (!audio_data)
+        return E_POINTER;
+
+    IAudioData_AddRef(sample->audio_data);
+    *audio_data = sample->audio_data;
+
+    return S_OK;
 }
 
 static const struct IAudioStreamSampleVtbl AudioStreamSample_Vtbl =
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index d1c39925853..130f9f0e0e2 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -5680,6 +5680,53 @@ static void test_audiostreamsample_get_media_stream(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_audiostreamsample_get_audio_data(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IAudioData *audio_data, *audio_data2;
+    IAudioStreamSample *audio_sample;
+    IAudioMediaStream *audio_stream;
+    IMediaStream *stream;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryAudio, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStream_QueryInterface(stream, &IID_IAudioMediaStream, (void **)&audio_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = CoCreateInstance(&CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER, &IID_IAudioData, (void **)&audio_data);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAudioMediaStream_CreateSample(audio_stream, audio_data, 0, &audio_sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAudioStreamSample_GetAudioData(audio_sample, NULL);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+
+    EXPECT_REF(audio_data, 2);
+    hr = IAudioStreamSample_GetAudioData(audio_sample, &audio_data2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(audio_data2 == audio_data, "Expected audio data %p, got %p.\n", audio_data, audio_data2);
+    EXPECT_REF(audio_data, 3);
+
+    IAudioData_Release(audio_data2);
+
+    IAudioMediaStream_Release(audio_stream);
+    ref = IAudioStreamSample_Release(audio_sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAudioData_Release(audio_data);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(amstream)
 {
     const WCHAR *test_avi_path;
@@ -5727,6 +5774,7 @@ START_TEST(amstream)
     test_audiostreamsample_completion_status();
     test_audiostreamsample_get_sample_times();
     test_audiostreamsample_get_media_stream();
+    test_audiostreamsample_get_audio_data();
 
     test_ddrawstream_initialize();
     test_ddrawstream_getsetdirectdraw();
From e68e74a1bc9b77844ff118c9d032c552bbb8ee02 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Wed, 29 Jul 2020 12:30:37 +0200
Subject: [PATCH] amstream: Get rid of the IAudioStreamSampleImpl typedef.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c | 98 ++++++++++++++++++-------------------
 1 file changed, 47 insertions(+), 51 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 41f225d022a..072850aae73 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -63,7 +63,8 @@ struct audio_stream
     struct list update_queue;
 };
 
-typedef struct {
+struct audio_sample
+{
     IAudioStreamSample IAudioStreamSample_iface;
     LONG ref;
     struct audio_stream *parent;
@@ -77,7 +78,7 @@ typedef struct {
     BYTE *pointer;
     DWORD position;
     HRESULT update_hr;
-} IAudioStreamSampleImpl;
+};
 
 static void remove_queued_receive(struct queued_receive *receive)
 {
@@ -86,7 +87,7 @@ static void remove_queued_receive(struct queued_receive *receive)
     free(receive);
 }
 
-static void remove_queued_update(IAudioStreamSampleImpl *sample)
+static void remove_queued_update(struct audio_sample *sample)
 {
     HRESULT hr;
 
@@ -112,7 +113,7 @@ static STREAM_TIME stream_time_from_position(struct audio_stream *stream, struct
     return receive->start_time + (receive->position * 10000000 + format->nAvgBytesPerSec / 2) / format->nAvgBytesPerSec;
 }
 
-static void process_update(IAudioStreamSampleImpl *sample, struct queued_receive *receive)
+static void process_update(struct audio_sample *sample, struct queued_receive *receive)
 {
     DWORD advance;
 
@@ -134,7 +135,7 @@ static void process_updates(struct audio_stream *stream)
 {
     while (!list_empty(&stream->update_queue) && !list_empty(&stream->receive_queue))
     {
-        IAudioStreamSampleImpl *sample = LIST_ENTRY(list_head(&stream->update_queue), IAudioStreamSampleImpl, entry);
+        struct audio_sample *sample = LIST_ENTRY(list_head(&stream->update_queue), struct audio_sample, entry);
         struct queued_receive *receive = LIST_ENTRY(list_head(&stream->receive_queue), struct queued_receive, entry);
 
         process_update(sample, receive);
@@ -148,7 +149,7 @@ static void process_updates(struct audio_stream *stream)
     {
         while (!list_empty(&stream->update_queue))
         {
-            IAudioStreamSampleImpl *sample = LIST_ENTRY(list_head(&stream->update_queue), IAudioStreamSampleImpl, entry);
+            struct audio_sample *sample = LIST_ENTRY(list_head(&stream->update_queue), struct audio_sample, entry);
 
             sample->update_hr = sample->position ? S_OK : MS_S_ENDOFSTREAM;
             remove_queued_update(sample);
@@ -156,13 +157,13 @@ static void process_updates(struct audio_stream *stream)
     }
 }
 
-static inline IAudioStreamSampleImpl *impl_from_IAudioStreamSample(IAudioStreamSample *iface)
+static inline struct audio_sample *impl_from_IAudioStreamSample(IAudioStreamSample *iface)
 {
-    return CONTAINING_RECORD(iface, IAudioStreamSampleImpl, IAudioStreamSample_iface);
+    return CONTAINING_RECORD(iface, struct audio_sample, IAudioStreamSample_iface);
 }
 
 /*** IUnknown methods ***/
-static HRESULT WINAPI IAudioStreamSampleImpl_QueryInterface(IAudioStreamSample *iface,
+static HRESULT WINAPI audio_sample_QueryInterface(IAudioStreamSample *iface,
         REFIID riid, void **ret_iface)
 {
     TRACE("(%p)->(%s,%p)\n", iface, debugstr_guid(riid), ret_iface);
@@ -182,38 +183,33 @@ static HRESULT WINAPI IAudioStreamSampleImpl_QueryInterface(IAudioStreamSample *
     return E_NOINTERFACE;
 }
 
-static ULONG WINAPI IAudioStreamSampleImpl_AddRef(IAudioStreamSample *iface)
+static ULONG WINAPI audio_sample_AddRef(IAudioStreamSample *iface)
 {
-    IAudioStreamSampleImpl *This = impl_from_IAudioStreamSample(iface);
-    ULONG ref = InterlockedIncrement(&This->ref);
-
-    TRACE("(%p)->(): new ref = %u\n", iface, ref);
-
-    return ref;
+    struct audio_sample *sample = impl_from_IAudioStreamSample(iface);
+    ULONG refcount = InterlockedIncrement(&sample->ref);
+    TRACE("%p increasing refcount to %u.\n", sample, refcount);
+    return refcount;
 }
 
-static ULONG WINAPI IAudioStreamSampleImpl_Release(IAudioStreamSample *iface)
+static ULONG WINAPI audio_sample_Release(IAudioStreamSample *iface)
 {
-    IAudioStreamSampleImpl *This = impl_from_IAudioStreamSample(iface);
-    ULONG ref = InterlockedDecrement(&This->ref);
-
-    TRACE("(%p)->(): new ref = %u\n", iface, ref);
-
-    if (!ref)
+    struct audio_sample *sample = impl_from_IAudioStreamSample(iface);
+    ULONG refcount = InterlockedDecrement(&sample->ref);
+    TRACE("%p decreasing refcount to %u.\n", sample, refcount);
+    if (!refcount)
     {
-        IAMMediaStream_Release(&This->parent->IAMMediaStream_iface);
-        IAudioData_Release(This->audio_data);
-        CloseHandle(This->update_event);
-        HeapFree(GetProcessHeap(), 0, This);
+        IAMMediaStream_Release(&sample->parent->IAMMediaStream_iface);
+        IAudioData_Release(sample->audio_data);
+        CloseHandle(sample->update_event);
+        HeapFree(GetProcessHeap(), 0, sample);
     }
-
-    return ref;
+    return refcount;
 }
 
 /*** IStreamSample methods ***/
-static HRESULT WINAPI IAudioStreamSampleImpl_GetMediaStream(IAudioStreamSample *iface, IMediaStream **media_stream)
+static HRESULT WINAPI audio_sample_GetMediaStream(IAudioStreamSample *iface, IMediaStream **media_stream)
 {
-    IAudioStreamSampleImpl *sample = impl_from_IAudioStreamSample(iface);
+    struct audio_sample *sample = impl_from_IAudioStreamSample(iface);
 
     TRACE("sample %p, media_stream %p.\n", iface, media_stream);
 
@@ -226,10 +222,10 @@ static HRESULT WINAPI IAudioStreamSampleImpl_GetMediaStream(IAudioStreamSample *
     return S_OK;
 }
 
-static HRESULT WINAPI IAudioStreamSampleImpl_GetSampleTimes(IAudioStreamSample *iface, STREAM_TIME *start_time,
+static HRESULT WINAPI audio_sample_GetSampleTimes(IAudioStreamSample *iface, STREAM_TIME *start_time,
                                                                  STREAM_TIME *end_time, STREAM_TIME *current_time)
 {
-    IAudioStreamSampleImpl *sample = impl_from_IAudioStreamSample(iface);
+    struct audio_sample *sample = impl_from_IAudioStreamSample(iface);
 
     TRACE("sample %p, start_time %p, end_time %p, current_time %p.\n", sample, start_time, end_time, current_time);
 
@@ -244,7 +240,7 @@ static HRESULT WINAPI IAudioStreamSampleImpl_GetSampleTimes(IAudioStreamSample *
     return S_OK;
 }
 
-static HRESULT WINAPI IAudioStreamSampleImpl_SetSampleTimes(IAudioStreamSample *iface, const STREAM_TIME *start_time,
+static HRESULT WINAPI audio_sample_SetSampleTimes(IAudioStreamSample *iface, const STREAM_TIME *start_time,
                                                                  const STREAM_TIME *end_time)
 {
     FIXME("(%p)->(%p,%p): stub\n", iface, start_time, end_time);
@@ -252,10 +248,10 @@ static HRESULT WINAPI IAudioStreamSampleImpl_SetSampleTimes(IAudioStreamSample *
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI IAudioStreamSampleImpl_Update(IAudioStreamSample *iface,
+static HRESULT WINAPI audio_sample_Update(IAudioStreamSample *iface,
         DWORD flags, HANDLE event, PAPCFUNC apc_func, DWORD apc_data)
 {
-    IAudioStreamSampleImpl *sample = impl_from_IAudioStreamSample(iface);
+    struct audio_sample *sample = impl_from_IAudioStreamSample(iface);
     BYTE *pointer;
     DWORD length;
     HRESULT hr;
@@ -326,9 +322,9 @@ static HRESULT WINAPI IAudioStreamSampleImpl_Update(IAudioStreamSample *iface,
     return sample->update_hr;
 }
 
-static HRESULT WINAPI IAudioStreamSampleImpl_CompletionStatus(IAudioStreamSample *iface, DWORD flags, DWORD milliseconds)
+static HRESULT WINAPI audio_sample_CompletionStatus(IAudioStreamSample *iface, DWORD flags, DWORD milliseconds)
 {
-    IAudioStreamSampleImpl *sample = impl_from_IAudioStreamSample(iface);
+    struct audio_sample *sample = impl_from_IAudioStreamSample(iface);
     HRESULT hr;
 
     TRACE("sample %p, flags %#x, milliseconds %u.\n", sample, flags, milliseconds);
@@ -349,9 +345,9 @@ static HRESULT WINAPI IAudioStreamSampleImpl_CompletionStatus(IAudioStreamSample
 }
 
 /*** IAudioStreamSample methods ***/
-static HRESULT WINAPI IAudioStreamSampleImpl_GetAudioData(IAudioStreamSample *iface, IAudioData **audio_data)
+static HRESULT WINAPI audio_sample_GetAudioData(IAudioStreamSample *iface, IAudioData **audio_data)
 {
-    IAudioStreamSampleImpl *sample = impl_from_IAudioStreamSample(iface);
+    struct audio_sample *sample = impl_from_IAudioStreamSample(iface);
 
     TRACE("sample %p, audio_data %p.\n", sample, audio_data);
 
@@ -367,26 +363,26 @@ static HRESULT WINAPI IAudioStreamSampleImpl_GetAudioData(IAudioStreamSample *if
 static const struct IAudioStreamSampleVtbl AudioStreamSample_Vtbl =
 {
     /*** IUnknown methods ***/
-    IAudioStreamSampleImpl_QueryInterface,
-    IAudioStreamSampleImpl_AddRef,
-    IAudioStreamSampleImpl_Release,
+    audio_sample_QueryInterface,
+    audio_sample_AddRef,
+    audio_sample_Release,
     /*** IStreamSample methods ***/
-    IAudioStreamSampleImpl_GetMediaStream,
-    IAudioStreamSampleImpl_GetSampleTimes,
-    IAudioStreamSampleImpl_SetSampleTimes,
-    IAudioStreamSampleImpl_Update,
-    IAudioStreamSampleImpl_CompletionStatus,
+    audio_sample_GetMediaStream,
+    audio_sample_GetSampleTimes,
+    audio_sample_SetSampleTimes,
+    audio_sample_Update,
+    audio_sample_CompletionStatus,
     /*** IAudioStreamSample methods ***/
-    IAudioStreamSampleImpl_GetAudioData
+    audio_sample_GetAudioData
 };
 
 static HRESULT audiostreamsample_create(struct audio_stream *parent, IAudioData *audio_data, IAudioStreamSample **audio_stream_sample)
 {
-    IAudioStreamSampleImpl *object;
+    struct audio_sample *object;
 
     TRACE("(%p)\n", audio_stream_sample);
 
-    object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IAudioStreamSampleImpl));
+    object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
     if (!object)
         return E_OUTOFMEMORY;
 
From 218409c2d63ac171229471231d210471af98f068 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Thu, 30 Jul 2020 18:08:52 +0200
Subject: [PATCH] amstream: Return correct media type info when enumerating
 AMAudioStream media types.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/audiostream.c    | 21 ++++++++++++++++++++-
 dlls/amstream/tests/amstream.c | 11 ++++++-----
 2 files changed, 26 insertions(+), 6 deletions(-)

diff --git a/dlls/amstream/audiostream.c b/dlls/amstream/audiostream.c
index 072850aae73..dc6c810d19a 100644
--- a/dlls/amstream/audiostream.c
+++ b/dlls/amstream/audiostream.c
@@ -837,6 +837,17 @@ static HRESULT WINAPI enum_media_types_Next(IEnumMediaTypes *iface, ULONG count,
 {
     struct enum_media_types *enum_media_types = impl_from_IEnumMediaTypes(iface);
 
+    static const WAVEFORMATEX wfx =
+    {
+        .wFormatTag = WAVE_FORMAT_PCM,
+        .nChannels = 1,
+        .nSamplesPerSec = 11025,
+        .nAvgBytesPerSec = 11025 * 2,
+        .nBlockAlign = 2,
+        .wBitsPerSample = 16,
+        .cbSize = 0,
+    };
+
     TRACE("iface %p, count %u, mts %p, ret_count %p.\n", iface, count, mts, ret_count);
 
     if (!ret_count)
@@ -847,7 +858,15 @@ static HRESULT WINAPI enum_media_types_Next(IEnumMediaTypes *iface, ULONG count,
         mts[0] = CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
         memset(mts[0], 0, sizeof(AM_MEDIA_TYPE));
         mts[0]->majortype = MEDIATYPE_Audio;
-        mts[0]->subtype = MEDIASUBTYPE_PCM;
+        mts[0]->subtype = GUID_NULL;
+        mts[0]->bFixedSizeSamples = TRUE;
+        mts[0]->bTemporalCompression = FALSE;
+        mts[0]->lSampleSize = 2;
+        mts[0]->formattype = FORMAT_WaveFormatEx;
+        mts[0]->cbFormat = sizeof(WAVEFORMATEX);
+        mts[0]->pbFormat = CoTaskMemAlloc(sizeof(WAVEFORMATEX));
+        memcpy(mts[0]->pbFormat, &wfx, sizeof(WAVEFORMATEX));
+
         ++enum_media_types->index;
         *ret_count = 1;
         return count == 1 ? S_OK : S_FALSE;
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 130f9f0e0e2..cf66538a7a9 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -2515,20 +2515,21 @@ static void test_media_types(void)
     ok(count == 1, "Got count %u.\n", count);
     ok(IsEqualGUID(&pmt->majortype, &MEDIATYPE_Audio), "Got major type %s\n",
             wine_dbgstr_guid(&pmt->majortype));
-    todo_wine ok(IsEqualGUID(&pmt->subtype, &GUID_NULL), "Got subtype %s\n",
+    ok(IsEqualGUID(&pmt->subtype, &GUID_NULL), "Got subtype %s\n",
             wine_dbgstr_guid(&pmt->subtype));
-    todo_wine ok(pmt->bFixedSizeSamples == TRUE, "Got fixed size %d.\n", pmt->bFixedSizeSamples);
+    ok(pmt->bFixedSizeSamples == TRUE, "Got fixed size %d.\n", pmt->bFixedSizeSamples);
     ok(!pmt->bTemporalCompression, "Got temporal compression %d.\n", pmt->bTemporalCompression);
-    todo_wine ok(pmt->lSampleSize == 2, "Got sample size %u.\n", pmt->lSampleSize);
-    todo_wine ok(IsEqualGUID(&pmt->formattype, &FORMAT_WaveFormatEx), "Got format type %s.\n",
+    ok(pmt->lSampleSize == 2, "Got sample size %u.\n", pmt->lSampleSize);
+    ok(IsEqualGUID(&pmt->formattype, &FORMAT_WaveFormatEx), "Got format type %s.\n",
             wine_dbgstr_guid(&pmt->formattype));
     ok(!pmt->pUnk, "Got pUnk %p.\n", pmt->pUnk);
-    todo_wine ok(pmt->cbFormat == sizeof(WAVEFORMATEX), "Got format size %u.\n", pmt->cbFormat);
+    ok(pmt->cbFormat == sizeof(WAVEFORMATEX), "Got format size %u.\n", pmt->cbFormat);
     ok(!memcmp(pmt->pbFormat, &expect_wfx, pmt->cbFormat), "Format blocks didn't match.\n");
 
     hr = IPin_QueryAccept(pin, pmt);
     ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
+    CoTaskMemFree(pmt->pbFormat);
     CoTaskMemFree(pmt);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, &count);
From 3f27d91629a04ff1f86acdfafa072de8b40f0264 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 23 Jul 2020 11:46:59 -0500
Subject: [PATCH] dsound/tests: Link directly to dsound.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Andrew Eikum <aeikum@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsound/tests/Makefile.in |   2 +-
 dlls/dsound/tests/capture.c   |  37 +++------
 dlls/dsound/tests/ds3d.c      |  35 ++------
 dlls/dsound/tests/ds3d8.c     |  35 ++------
 dlls/dsound/tests/dsound.c    | 115 +++++++-------------------
 dlls/dsound/tests/dsound8.c   |  75 ++++++-----------
 dlls/dsound/tests/duplex.c    |  50 +++---------
 dlls/dsound/tests/propset.c   | 148 ++++++++++++----------------------
 8 files changed, 145 insertions(+), 352 deletions(-)

diff --git a/dlls/dsound/tests/Makefile.in b/dlls/dsound/tests/Makefile.in
index a3e7c37c938..49bc4d9b55a 100644
--- a/dlls/dsound/tests/Makefile.in
+++ b/dlls/dsound/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = dsound.dll
-IMPORTS   = ole32 version user32
+IMPORTS   = dsound ole32 version user32
 
 C_SRCS = \
 	capture.c \
diff --git a/dlls/dsound/tests/capture.c b/dlls/dsound/tests/capture.c
index dada067956f..e326fe8d839 100644
--- a/dlls/dsound/tests/capture.c
+++ b/dlls/dsound/tests/capture.c
@@ -32,9 +32,6 @@
 
 #define NOTIFICATIONS    5
 
-static HRESULT (WINAPI *pDirectSoundCaptureCreate)(LPCGUID,LPDIRECTSOUNDCAPTURE*,LPUNKNOWN)=NULL;
-static HRESULT (WINAPI *pDirectSoundCaptureEnumerateA)(LPDSENUMCALLBACKA,LPVOID)=NULL;
-
 static const char * get_format_str(WORD format)
 {
     static char msg[32];
@@ -232,28 +229,28 @@ static void test_capture(void)
        "should have failed: %08x\n",rc);
 
     /* try with no device specified */
-    rc=pDirectSoundCaptureCreate(NULL,&dsco,NULL);
+    rc = DirectSoundCaptureCreate(NULL, &dsco, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCaptureCreate(NULL) failed: %08x\n",rc);
     if (rc==S_OK && dsco)
         IDirectSoundCapture_test(dsco, TRUE, NULL);
 
     /* try with default capture device specified */
-    rc=pDirectSoundCaptureCreate(&DSDEVID_DefaultCapture,&dsco,NULL);
+    rc = DirectSoundCaptureCreate(&DSDEVID_DefaultCapture, &dsco, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCaptureCreate(DSDEVID_DefaultCapture) failed: %08x\n", rc);
     if (rc==DS_OK && dsco)
         IDirectSoundCapture_test(dsco, TRUE, NULL);
 
     /* try with default voice capture device specified */
-    rc=pDirectSoundCaptureCreate(&DSDEVID_DefaultVoiceCapture,&dsco,NULL);
+    rc = DirectSoundCaptureCreate(&DSDEVID_DefaultVoiceCapture, &dsco, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCaptureCreate(DSDEVID_DefaultVoiceCapture) failed: %08x\n", rc);
     if (rc==DS_OK && dsco)
         IDirectSoundCapture_test(dsco, TRUE, NULL);
 
     /* try with a bad device specified */
-    rc=pDirectSoundCaptureCreate(&DSDEVID_DefaultVoicePlayback,&dsco,NULL);
+    rc = DirectSoundCaptureCreate(&DSDEVID_DefaultVoicePlayback, &dsco, NULL);
     ok(rc==DSERR_NODRIVER,
        "DirectSoundCaptureCreate(DSDEVID_DefaultVoicePlatback) "
        "should have failed: %08x\n",rc);
@@ -442,11 +439,11 @@ static BOOL WINAPI dscenum_callback(LPGUID lpGuid, LPCSTR lpcstrDescription,
 
     /* Private dsound.dll: Error: Invalid interface buffer */
     trace("*** Testing %s - %s ***\n",lpcstrDescription,lpcstrModule);
-    rc=pDirectSoundCaptureCreate(lpGuid,NULL,NULL);
+    rc = DirectSoundCaptureCreate(lpGuid, NULL, NULL);
     ok(rc==DSERR_INVALIDPARAM,"DirectSoundCaptureCreate() should have "
        "returned DSERR_INVALIDPARAM, returned: %08x\n",rc);
 
-    rc=pDirectSoundCaptureCreate(lpGuid,&dsco,NULL);
+    rc = DirectSoundCaptureCreate(lpGuid, &dsco, NULL);
     ok((rc==DS_OK)||(rc==DSERR_NODRIVER)||(rc==E_FAIL)||(rc==DSERR_ALLOCATED),
        "DirectSoundCaptureCreate() failed: %08x\n",rc);
     if (rc!=DS_OK) {
@@ -669,7 +666,7 @@ static BOOL WINAPI dscenum_callback(LPGUID lpGuid, LPCSTR lpcstrDescription,
 static void test_enumerate(void)
 {
     HRESULT rc;
-    rc=pDirectSoundCaptureEnumerateA(&dscenum_callback,NULL);
+    rc = DirectSoundCaptureEnumerateA(dscenum_callback, NULL);
     ok(rc==DS_OK,"DirectSoundCaptureEnumerateA() failed: %08x\n", rc);
 }
 
@@ -684,12 +681,12 @@ static void test_COM(void)
     HRESULT hr;
     ULONG refcount;
 
-    hr = pDirectSoundCaptureCreate(NULL, &dsc, (IUnknown*)0xdeadbeef);
+    hr = DirectSoundCaptureCreate(NULL, &dsc, (IUnknown *)0xdeadbeef);
     ok(hr == DSERR_NOAGGREGATION,
        "DirectSoundCaptureCreate failed: %08x, expected DSERR_NOAGGREGATION\n", hr);
     ok(dsc == (IDirectSoundCapture*)0xdeadbeef, "dsc = %p\n", dsc);
 
-    hr = pDirectSoundCaptureCreate(NULL, &dsc, NULL);
+    hr = DirectSoundCaptureCreate(NULL, &dsc, NULL);
     if (hr == DSERR_NODRIVER) {
         skip("No driver\n");
         return;
@@ -755,27 +752,11 @@ static void test_COM(void)
 
 START_TEST(capture)
 {
-    HMODULE hDsound;
-
     CoInitialize(NULL);
 
-    hDsound = LoadLibraryA("dsound.dll");
-    if (!hDsound) {
-        skip("dsound.dll not found - skipping all tests\n");
-        return;
-    }
-
-    pDirectSoundCaptureCreate = (void*)GetProcAddress(hDsound, "DirectSoundCaptureCreate");
-    pDirectSoundCaptureEnumerateA = (void*)GetProcAddress(hDsound, "DirectSoundCaptureEnumerateA");
-    if (!pDirectSoundCaptureCreate || !pDirectSoundCaptureEnumerateA) {
-        skip("DirectSoundCapture{Create,Enumerate} missing - skipping all tests\n");
-        return;
-    }
-
     test_COM();
     test_capture();
     test_enumerate();
 
-    FreeLibrary(hDsound);
     CoUninitialize();
 }
diff --git a/dlls/dsound/tests/ds3d.c b/dlls/dsound/tests/ds3d.c
index 1b44afff8d7..a6b31641d4a 100644
--- a/dlls/dsound/tests/ds3d.c
+++ b/dlls/dsound/tests/ds3d.c
@@ -36,11 +36,6 @@
 
 #define PI 3.14159265358979323846
 
-
-static HRESULT (WINAPI *pDirectSoundEnumerateA)(LPDSENUMCALLBACKA,LPVOID)=NULL;
-static HRESULT (WINAPI *pDirectSoundCreate)(LPCGUID,LPDIRECTSOUND*,
-    LPUNKNOWN)=NULL;
-
 char* wave_generate_la(WAVEFORMATEX* wfx, double duration, DWORD* size, BOOL ieee)
 {
     int i;
@@ -712,7 +707,7 @@ static HRESULT test_secondary(LPGUID lpGuid, int play,
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER,"DirectSoundCreate() failed: %08x\n", rc);
     if (rc!=DS_OK)
         return rc;
@@ -974,7 +969,7 @@ static HRESULT test_for_driver(LPGUID lpGuid)
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCreate() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -998,7 +993,7 @@ static HRESULT test_primary(LPGUID lpGuid)
     int ref, i;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER,"DirectSoundCreate() failed: %08x\n", rc);
     if (rc!=DS_OK)
         return rc;
@@ -1081,7 +1076,7 @@ static HRESULT test_primary_3d(LPGUID lpGuid)
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER,"DirectSoundCreate() failed: %08x\n", rc);
     if (rc!=DS_OK)
         return rc;
@@ -1152,7 +1147,7 @@ static HRESULT test_primary_3d_with_listener(LPGUID lpGuid)
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER,"DirectSoundCreate() failed: %08x\n", rc);
     if (rc!=DS_OK)
         return rc;
@@ -1306,32 +1301,16 @@ static BOOL WINAPI dsenum_callback(LPGUID lpGuid, LPCSTR lpcstrDescription,
 static void ds3d_tests(void)
 {
     HRESULT rc;
-    rc=pDirectSoundEnumerateA(&dsenum_callback,NULL);
+    rc = DirectSoundEnumerateA(dsenum_callback, NULL);
     ok(rc==DS_OK,"DirectSoundEnumerateA() failed: %08x\n",rc);
     trace("tested %u DirectSound drivers\n", driver_count);
 }
 
 START_TEST(ds3d)
 {
-    HMODULE hDsound;
-
     CoInitialize(NULL);
 
-    hDsound = LoadLibraryA("dsound.dll");
-    if (hDsound)
-    {
-
-        pDirectSoundEnumerateA = (void*)GetProcAddress(hDsound,
-            "DirectSoundEnumerateA");
-        pDirectSoundCreate = (void*)GetProcAddress(hDsound,
-            "DirectSoundCreate");
-
-        ds3d_tests();
-
-        FreeLibrary(hDsound);
-    }
-    else
-        skip("dsound.dll not found - skipping all tests\n");
+    ds3d_tests();
 
     CoUninitialize();
 }
diff --git a/dlls/dsound/tests/ds3d8.c b/dlls/dsound/tests/ds3d8.c
index 00340af94bf..465ba040a33 100644
--- a/dlls/dsound/tests/ds3d8.c
+++ b/dlls/dsound/tests/ds3d8.c
@@ -34,9 +34,6 @@
 #include "ksmedia.h"
 #include "dsound_test.h"
 
-static HRESULT (WINAPI *pDirectSoundEnumerateA)(LPDSENUMCALLBACKA,LPVOID)=NULL;
-static HRESULT (WINAPI *pDirectSoundCreate8)(LPCGUID,LPDIRECTSOUND8*,LPUNKNOWN)=NULL;
-
 typedef struct {
     char* wave;
     DWORD wave_len;
@@ -544,7 +541,7 @@ static HRESULT test_secondary8(LPGUID lpGuid, BOOL play,
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate8(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate8(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER,"DirectSoundCreate8() failed: %08x\n", rc);
     if (rc!=DS_OK)
         return rc;
@@ -822,7 +819,7 @@ static HRESULT test_for_driver8(LPGUID lpGuid)
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate8(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate8(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCreate8() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -846,7 +843,7 @@ static HRESULT test_primary8(LPGUID lpGuid)
     int ref, i;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate8(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate8(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER,"DirectSoundCreate8() failed: %08x\n", rc);
     if (rc!=DS_OK)
         return rc;
@@ -928,7 +925,7 @@ static HRESULT test_primary_3d8(LPGUID lpGuid)
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate8(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate8(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER,"DirectSoundCreate8() failed: %08x\n", rc);
     if (rc!=DS_OK)
         return rc;
@@ -999,7 +996,7 @@ static HRESULT test_primary_3d_with_listener8(LPGUID lpGuid)
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate8(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate8(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER,"DirectSoundCreate8() failed: %08x\n", rc);
     if (rc!=DS_OK)
         return rc;
@@ -1136,34 +1133,16 @@ static BOOL WINAPI dsenum_callback(LPGUID lpGuid, LPCSTR lpcstrDescription,
 static void ds3d8_tests(void)
 {
     HRESULT rc;
-    rc=pDirectSoundEnumerateA(&dsenum_callback,NULL);
+    rc = DirectSoundEnumerateA(dsenum_callback, NULL);
     ok(rc==DS_OK,"DirectSoundEnumerateA() failed: %08x\n",rc);
     trace("tested %u DirectSound drivers\n", driver_count);
 }
 
 START_TEST(ds3d8)
 {
-    HMODULE hDsound;
-
     CoInitialize(NULL);
 
-    hDsound = LoadLibraryA("dsound.dll");
-    if (hDsound)
-    {
-
-        pDirectSoundEnumerateA = (void*)GetProcAddress(hDsound,
-            "DirectSoundEnumerateA");
-        pDirectSoundCreate8 = (void*)GetProcAddress(hDsound,
-            "DirectSoundCreate8");
-        if (pDirectSoundCreate8)
-            ds3d8_tests();
-        else
-            skip("DirectSoundCreate8 missing - skipping all tests\n");
-
-        FreeLibrary(hDsound);
-    }
-    else
-        skip("dsound.dll not found - skipping all tests\n");
+    ds3d8_tests();
 
     CoUninitialize();
 }
diff --git a/dlls/dsound/tests/dsound.c b/dlls/dsound/tests/dsound.c
index 2bf87eb8571..a4f59efaad9 100644
--- a/dlls/dsound/tests/dsound.c
+++ b/dlls/dsound/tests/dsound.c
@@ -41,12 +41,6 @@
 
 DEFINE_GUID(GUID_NULL,0,0,0,0,0,0,0,0,0,0,0);
 
-static HRESULT (WINAPI *pDirectSoundEnumerateA)(LPDSENUMCALLBACKA,LPVOID)=NULL;
-static HRESULT (WINAPI *pDirectSoundCreate)(LPCGUID,LPDIRECTSOUND*,
-    LPUNKNOWN)=NULL;
-
-static BOOL gotdx8;
-
 static void IDirectSound_test(LPDIRECTSOUND dso, BOOL initialized,
                               LPCGUID lpGuid)
 {
@@ -235,28 +229,28 @@ static void IDirectSound_tests(void)
        "should have failed: %08x\n",rc);
 
     /* try with no device specified */
-    rc=pDirectSoundCreate(NULL,&dso,NULL);
+    rc = DirectSoundCreate(NULL, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCreate(NULL) failed: %08x\n",rc);
     if (rc==S_OK && dso)
         IDirectSound_test(dso, TRUE, NULL);
 
     /* try with default playback device specified */
-    rc=pDirectSoundCreate(&DSDEVID_DefaultPlayback,&dso,NULL);
+    rc = DirectSoundCreate(&DSDEVID_DefaultPlayback, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCreate(DSDEVID_DefaultPlayback) failed: %08x\n", rc);
     if (rc==DS_OK && dso)
         IDirectSound_test(dso, TRUE, NULL);
 
     /* try with default voice playback device specified */
-    rc=pDirectSoundCreate(&DSDEVID_DefaultVoicePlayback,&dso,NULL);
+    rc = DirectSoundCreate(&DSDEVID_DefaultVoicePlayback, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCreate(DSDEVID_DefaultVoicePlayback) failed: %08x\n", rc);
     if (rc==DS_OK && dso)
         IDirectSound_test(dso, TRUE, NULL);
 
     /* try with a bad device specified */
-    rc=pDirectSoundCreate(&DSDEVID_DefaultVoiceCapture,&dso,NULL);
+    rc = DirectSoundCreate(&DSDEVID_DefaultVoiceCapture, &dso, NULL);
     ok(rc==DSERR_NODRIVER,"DirectSoundCreate(DSDEVID_DefaultVoiceCapture) "
        "should have failed: %08x\n",rc);
     if (rc==DS_OK && dso)
@@ -270,12 +264,12 @@ static HRESULT test_dsound(LPGUID lpGuid)
     int ref;
 
     /* DSOUND: Error: Invalid interface buffer */
-    rc=pDirectSoundCreate(lpGuid,0,NULL);
+    rc = DirectSoundCreate(lpGuid, 0, NULL);
     ok(rc==DSERR_INVALIDPARAM,"DirectSoundCreate() should have returned "
        "DSERR_INVALIDPARAM, returned: %08x\n",rc);
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCreate() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -292,13 +286,13 @@ static HRESULT test_dsound(LPGUID lpGuid)
         IDirectSound_test(dso, FALSE, lpGuid);
 
     /* Create a DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK,"DirectSoundCreate() failed: %08x\n",rc);
     if (rc==DS_OK) {
         LPDIRECTSOUND dso1=NULL;
 
         /* Create a second DirectSound object */
-        rc=pDirectSoundCreate(lpGuid,&dso1,NULL);
+        rc = DirectSoundCreate(lpGuid, &dso1, NULL);
         ok(rc==DS_OK,"DirectSoundCreate() failed: %08x\n",rc);
         if (rc==DS_OK) {
             /* Release the second DirectSound object */
@@ -318,7 +312,7 @@ static HRESULT test_dsound(LPGUID lpGuid)
         return rc;
 
     /* Create a DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK,"DirectSoundCreate() failed: %08x\n",rc);
     if (rc==DS_OK) {
         LPDIRECTSOUNDBUFFER secondary;
@@ -374,7 +368,7 @@ static HRESULT test_primary(LPGUID lpGuid)
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED,
        "DirectSoundCreate() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -545,7 +539,7 @@ static HRESULT test_primary_secondary(LPGUID lpGuid)
     int f,ref,tag;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED,
        "DirectSoundCreate() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -687,7 +681,7 @@ static HRESULT test_secondary(LPGUID lpGuid)
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED,
        "DirectSoundCreate() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -751,30 +745,16 @@ static HRESULT test_secondary(LPGUID lpGuid)
                                         wfx.nBlockAlign);
             bufdesc.lpwfxFormat=&wfx;
             rc=IDirectSound_CreateSoundBuffer(dso,&bufdesc,&secondary,NULL);
-            if (gotdx8 || wfx.wBitsPerSample <= 16 || wfx.wFormatTag == WAVE_FORMAT_IEEE_FLOAT)
-            {
-                if (wfx.wBitsPerSample > 16)
-                    ok(broken((rc == DSERR_CONTROLUNAVAIL || rc == DSERR_INVALIDCALL || rc == DSERR_INVALIDPARAM /* 2003 */) && !secondary)
-                        || rc == DS_OK, /* driver dependent? */
-                        "IDirectSound_CreateSoundBuffer() "
-                        "should have returned (DSERR_CONTROLUNAVAIL or DSERR_INVALIDCALL) "
-                        "and NULL, returned: %08x %p\n", rc, secondary);
-                else
-                    ok((rc==DS_OK && secondary!=NULL) || broken(rc == DSERR_CONTROLUNAVAIL), /* vmware drivers on w2k */
-                        "IDirectSound_CreateSoundBuffer() failed to create a secondary buffer %08x\n",rc);
-            }
-            else
-                ok(rc==E_INVALIDARG, "Creating %d bpp buffer on dx < 8 returned: %p %08x\n",
-                   wfx.wBitsPerSample, secondary, rc);
 
-            if (!gotdx8)
-            {
-                win_skip("Not doing the WAVE_FORMAT_EXTENSIBLE tests\n");
-                /* Apparently they succeed with bogus values,
-                 * which means that older dsound doesn't look at them
-                 */
-                goto no_wfe;
-            }
+            if (wfx.wBitsPerSample > 16)
+                ok(broken((rc == DSERR_CONTROLUNAVAIL || rc == DSERR_INVALIDCALL || rc == DSERR_INVALIDPARAM /* 2003 */) && !secondary)
+                    || rc == DS_OK, /* driver dependent? */
+                    "IDirectSound_CreateSoundBuffer() "
+                    "should have returned (DSERR_CONTROLUNAVAIL or DSERR_INVALIDCALL) "
+                    "and NULL, returned: %08x %p\n", rc, secondary);
+            else
+                ok((rc==DS_OK && secondary!=NULL) || broken(rc == DSERR_CONTROLUNAVAIL), /* vmware drivers on w2k */
+                    "IDirectSound_CreateSoundBuffer() failed to create a secondary buffer %08x\n",rc);
 
             if (secondary)
                 IDirectSoundBuffer_Release(secondary);
@@ -853,7 +833,6 @@ static HRESULT test_secondary(LPGUID lpGuid)
             ok(rc==DS_OK && secondary!=NULL,
                 "IDirectSound_CreateSoundBuffer() failed to create a secondary buffer %08x\n",rc);
 
-no_wfe:
             if (rc==DS_OK && secondary!=NULL) {
                 if (winetest_interactive) {
                     trace("  Testing a secondary buffer at %dx%dx%d (fmt=%d) "
@@ -902,7 +881,7 @@ static HRESULT test_block_align(LPGUID lpGuid)
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED,
        "DirectSoundCreate() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -973,7 +952,7 @@ static HRESULT test_frequency(LPGUID lpGuid)
                     48000, 96000 };
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED,
        "DirectSoundCreate() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -1104,7 +1083,7 @@ static HRESULT test_duplicate(LPGUID lpGuid)
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED,
        "DirectSoundCreate() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -1431,11 +1410,6 @@ static void perform_invalid_fmt_tests(const char *testname, IDirectSound *dso, I
         }
     }
 
-    if(!gotdx8){
-        win_skip("Not doing the WAVE_FORMAT_EXTENSIBLE tests\n");
-        return;
-    }
-
     fmtex.Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
     fmtex.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
     fmtex.Format.nChannels = 2;
@@ -1510,7 +1484,7 @@ static HRESULT test_invalid_fmts(LPGUID lpGuid)
     DSBUFFERDESC bufdesc;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED,
        "DirectSoundCreate() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -1556,7 +1530,7 @@ static void test_notifications(LPGUID lpGuid)
     DWORD expect, status;
     int cycles;
 
-    rc = pDirectSoundCreate(lpGuid, &dso, NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc == DS_OK || rc == DSERR_NODRIVER || rc == DSERR_ALLOCATED,
            "DirectSoundCreate() failed: %08x\n", rc);
     if(rc != DS_OK)
@@ -1683,7 +1657,7 @@ static BOOL WINAPI dsenum_callback(LPGUID lpGuid, LPCSTR lpcstrDescription,
 static void dsound_tests(void)
 {
     HRESULT rc;
-    rc=pDirectSoundEnumerateA(&dsenum_callback,NULL);
+    rc = DirectSoundEnumerateA(&dsenum_callback, NULL);
     ok(rc==DS_OK,"DirectSoundEnumerateA() failed: %08x\n",rc);
 }
 
@@ -1699,7 +1673,7 @@ static void test_hw_buffers(void)
     UINT i;
     HRESULT hr;
 
-    hr = pDirectSoundCreate(NULL, &ds, NULL);
+    hr = DirectSoundCreate(NULL, &ds, NULL);
     ok(hr == S_OK || hr == DSERR_NODRIVER || hr == DSERR_ALLOCATED || hr == E_FAIL,
             "DirectSoundCreate failed: %08x\n", hr);
     if(hr != S_OK)
@@ -1801,38 +1775,11 @@ static void test_hw_buffers(void)
 
 START_TEST(dsound)
 {
-    HMODULE hDsound;
-
     CoInitialize(NULL);
 
-    hDsound = LoadLibraryA("dsound.dll");
-    if (hDsound)
-    {
-        BOOL ret;
-
-        ret = FreeLibrary(hDsound);
-        ok( ret, "FreeLibrary(1) returned %d\n", GetLastError());
-    }
-
-    hDsound = LoadLibraryA("dsound.dll");
-    if (hDsound)
-    {
-
-        pDirectSoundEnumerateA = (void*)GetProcAddress(hDsound,
-            "DirectSoundEnumerateA");
-        pDirectSoundCreate = (void*)GetProcAddress(hDsound,
-            "DirectSoundCreate");
-
-        gotdx8 = !!GetProcAddress(hDsound, "DirectSoundCreate8");
-
-        IDirectSound_tests();
-        dsound_tests();
-        test_hw_buffers();
-
-        FreeLibrary(hDsound);
-    }
-    else
-        win_skip("dsound.dll not found - skipping all tests\n");
+    IDirectSound_tests();
+    dsound_tests();
+    test_hw_buffers();
 
     CoUninitialize();
 }
diff --git a/dlls/dsound/tests/dsound8.c b/dlls/dsound/tests/dsound8.c
index 8190a617368..6fe13c66fd1 100644
--- a/dlls/dsound/tests/dsound8.c
+++ b/dlls/dsound/tests/dsound8.c
@@ -48,9 +48,6 @@
 
 #include "dsound_test.h"
 
-static HRESULT (WINAPI *pDirectSoundEnumerateA)(LPDSENUMCALLBACKA,LPVOID)=NULL;
-static HRESULT (WINAPI *pDirectSoundCreate8)(LPCGUID,LPDIRECTSOUND8*,LPUNKNOWN)=NULL;
-
 int align(int length, int align)
 {
     return (length / align) * align;
@@ -250,28 +247,28 @@ static void IDirectSound8_tests(void)
        "should have failed: %08x\n",rc);
 
     /* try with no device specified */
-    rc=pDirectSoundCreate8(NULL,&dso,NULL);
+    rc = DirectSoundCreate8(NULL, &dso, NULL);
     ok(rc==S_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCreate8() failed: %08x\n",rc);
     if (rc==DS_OK && dso)
         IDirectSound8_test(dso, TRUE, NULL);
 
     /* try with default playback device specified */
-    rc=pDirectSoundCreate8(&DSDEVID_DefaultPlayback,&dso,NULL);
+    rc = DirectSoundCreate8(&DSDEVID_DefaultPlayback, &dso, NULL);
     ok(rc==S_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCreate8() failed: %08x\n",rc);
     if (rc==DS_OK && dso)
         IDirectSound8_test(dso, TRUE, NULL);
 
     /* try with default voice playback device specified */
-    rc=pDirectSoundCreate8(&DSDEVID_DefaultVoicePlayback,&dso,NULL);
+    rc = DirectSoundCreate8(&DSDEVID_DefaultVoicePlayback, &dso, NULL);
     ok(rc==S_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCreate8() failed: %08x\n",rc);
     if (rc==DS_OK && dso)
         IDirectSound8_test(dso, TRUE, NULL);
 
     /* try with a bad device specified */
-    rc=pDirectSoundCreate8(&DSDEVID_DefaultVoiceCapture,&dso,NULL);
+    rc = DirectSoundCreate8(&DSDEVID_DefaultVoiceCapture, &dso, NULL);
     ok(rc==DSERR_NODRIVER,"DirectSoundCreate8(DSDEVID_DefaultVoiceCapture) "
        "should have failed: %08x\n",rc);
 }
@@ -283,12 +280,12 @@ static HRESULT test_dsound8(LPGUID lpGuid)
     int ref;
 
     /* DSOUND: Error: Invalid interface buffer */
-    rc=pDirectSoundCreate8(lpGuid,0,NULL);
+    rc = DirectSoundCreate8(lpGuid, 0, NULL);
     ok(rc==DSERR_INVALIDPARAM,"DirectSoundCreate8() should have returned "
        "DSERR_INVALIDPARAM, returned: %08x\n",rc);
 
     /* Create the DirectSound8 object */
-    rc=pDirectSoundCreate8(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate8(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCreate8() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -305,13 +302,13 @@ static HRESULT test_dsound8(LPGUID lpGuid)
         IDirectSound8_test(dso, FALSE, lpGuid);
 
     /* Create a DirectSound8 object */
-    rc=pDirectSoundCreate8(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate8(lpGuid, &dso, NULL);
     ok(rc==DS_OK,"DirectSoundCreate8() failed: %08x\n",rc);
     if (rc==DS_OK) {
         LPDIRECTSOUND8 dso1=NULL;
 
         /* Create a second DirectSound8 object */
-        rc=pDirectSoundCreate8(lpGuid,&dso1,NULL);
+        rc = DirectSoundCreate8(lpGuid, &dso1, NULL);
         ok(rc==DS_OK,"DirectSoundCreate8() failed: %08x\n",rc);
         if (rc==DS_OK) {
             /* Release the second DirectSound8 object */
@@ -332,7 +329,7 @@ static HRESULT test_dsound8(LPGUID lpGuid)
         return rc;
 
     /* Create a DirectSound8 object */
-    rc=pDirectSoundCreate8(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate8(lpGuid, &dso, NULL);
     ok(rc==DS_OK,"DirectSoundCreate8() failed: %08x\n",rc);
     if (rc==DS_OK) {
         LPDIRECTSOUNDBUFFER secondary;
@@ -401,7 +398,7 @@ static HRESULT test_primary8(LPGUID lpGuid)
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate8(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate8(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED,
        "DirectSoundCreate8() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -551,7 +548,7 @@ static HRESULT test_primary_secondary8(LPGUID lpGuid)
     unsigned int f, tag;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate8(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate8(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED,
        "DirectSoundCreate8() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -692,7 +689,7 @@ static HRESULT test_secondary8(LPGUID lpGuid)
     int ref;
 
     /* Create the DirectSound object */
-    rc=pDirectSoundCreate8(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate8(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED,
        "DirectSoundCreate8() failed: %08x\n",rc);
     if (rc!=DS_OK)
@@ -938,7 +935,7 @@ static BOOL WINAPI dsenum_callback(LPGUID lpGuid, LPCSTR lpcstrDescription,
 static void dsound8_tests(void)
 {
     HRESULT rc;
-    rc=pDirectSoundEnumerateA(&dsenum_callback,NULL);
+    rc = DirectSoundEnumerateA(dsenum_callback, NULL);
     ok(rc==DS_OK,"DirectSoundEnumerateA() failed: %08x\n",rc);
 }
 
@@ -954,7 +951,7 @@ static void test_hw_buffers(void)
     UINT i;
     HRESULT hr;
 
-    hr = pDirectSoundCreate8(NULL, &ds, NULL);
+    hr = DirectSoundCreate8(NULL, &ds, NULL);
     ok(hr == S_OK || hr == DSERR_NODRIVER || hr == DSERR_ALLOCATED || hr == E_FAIL,
             "DirectSoundCreate8 failed: %08x\n", hr);
     if(hr != S_OK)
@@ -1119,7 +1116,7 @@ static void test_first_device(void)
     IMMDevice_Release(defdev);
     IMMDeviceEnumerator_Release(devenum);
 
-    hr = pDirectSoundEnumerateA(&default_device_cb, NULL);
+    hr = DirectSoundEnumerateA(default_device_cb, NULL);
     ok(hr == S_OK, "DirectSoundEnumerateA failed: %08x\n", hr);
 }
 
@@ -1183,7 +1180,7 @@ static void test_primary_flags(void)
     DSCAPS dscaps;
 
     /* Create a DirectSound8 object */
-    rc = pDirectSoundCreate8(NULL, &dso, NULL);
+    rc = DirectSoundCreate8(NULL, &dso, NULL);
     ok(rc == DS_OK || rc==DSERR_NODRIVER, "Failed: %08x\n",rc);
 
     if (rc!=DS_OK)
@@ -1234,7 +1231,7 @@ static void test_effects(void)
     DWORD resultcodes[2];
 
     /* Create a DirectSound8 object */
-    rc=pDirectSoundCreate8(NULL,&dso,NULL);
+    rc = DirectSoundCreate8(NULL, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER,"DirectSoundCreate8() failed: %08x\n",rc);
 
     if (rc!=DS_OK)
@@ -1696,7 +1693,7 @@ static void test_effects_parameters(void)
     DWORD resultcodes[8];
 
     /* Create a DirectSound8 object */
-    rc = pDirectSoundCreate8(NULL, &dso, NULL);
+    rc = DirectSoundCreate8(NULL, &dso, NULL);
     ok(rc == DS_OK || rc == DSERR_NODRIVER, "DirectSoundCreate8() failed: %08x\n", rc);
     if (rc != DS_OK)
         return;
@@ -1789,36 +1786,16 @@ static void test_effects_parameters(void)
 
 START_TEST(dsound8)
 {
-    HMODULE hDsound;
-
     CoInitialize(NULL);
 
-    hDsound = LoadLibraryA("dsound.dll");
-    if (hDsound)
-    {
-
-        pDirectSoundEnumerateA = (void*)GetProcAddress(hDsound,
-            "DirectSoundEnumerateA");
-        pDirectSoundCreate8 = (void*)GetProcAddress(hDsound,
-            "DirectSoundCreate8");
-        if (pDirectSoundCreate8)
-        {
-            test_COM();
-            IDirectSound8_tests();
-            dsound8_tests();
-            test_hw_buffers();
-            test_first_device();
-            test_primary_flags();
-            test_effects();
-            test_effects_parameters();
-        }
-        else
-            skip("DirectSoundCreate8 missing - skipping all tests\n");
-
-        FreeLibrary(hDsound);
-    }
-    else
-        skip("dsound.dll not found - skipping all tests\n");
+    test_COM();
+    IDirectSound8_tests();
+    dsound8_tests();
+    test_hw_buffers();
+    test_first_device();
+    test_primary_flags();
+    test_effects();
+    test_effects_parameters();
 
     CoUninitialize();
 }
diff --git a/dlls/dsound/tests/duplex.c b/dlls/dsound/tests/duplex.c
index b7705157855..59507c566c1 100644
--- a/dlls/dsound/tests/duplex.c
+++ b/dlls/dsound/tests/duplex.c
@@ -29,10 +29,6 @@
 
 #include "dsound_test.h"
 
-static HRESULT (WINAPI *pDirectSoundFullDuplexCreate)(LPCGUID, LPCGUID,
-    LPCDSCBUFFERDESC, LPCDSBUFFERDESC, HWND, DWORD, LPDIRECTSOUNDFULLDUPLEX *,
-    LPDIRECTSOUNDCAPTUREBUFFER8*, LPDIRECTSOUNDBUFFER8*, LPUNKNOWN)=NULL;
-
 static void IDirectSoundFullDuplex_test(LPDIRECTSOUNDFULLDUPLEX dsfdo,
                                         BOOL initialized, LPCGUID lpGuidCapture,
                                         LPCGUID lpGuidRender)
@@ -181,19 +177,17 @@ static void IDirectSoundFullDuplex_tests(void)
     DSBufferDesc.lpwfxFormat = &wfex;
 
     /* try with no device specified */
-    rc=pDirectSoundFullDuplexCreate(NULL,NULL,&DSCBufferDesc,&DSBufferDesc,
-                                    get_hwnd(),DSSCL_EXCLUSIVE ,&dsfdo,&pDSCBuffer8,
-                                    &pDSBuffer8,NULL);
+    rc = DirectSoundFullDuplexCreate(NULL, NULL, &DSCBufferDesc, &DSBufferDesc,
+            get_hwnd(), DSSCL_EXCLUSIVE, &dsfdo, &pDSCBuffer8, &pDSBuffer8, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL||rc==DSERR_INVALIDCALL,
        "DirectSoundFullDuplexCreate(NULL,NULL) failed: %08x\n",rc);
     if (rc==S_OK && dsfdo)
         IDirectSoundFullDuplex_test(dsfdo, TRUE, NULL, NULL);
 
     /* try with default devices specified */
-    rc=pDirectSoundFullDuplexCreate(&DSDEVID_DefaultCapture,
-                                    &DSDEVID_DefaultPlayback,&DSCBufferDesc,
-                                    &DSBufferDesc,get_hwnd(),DSSCL_EXCLUSIVE,&dsfdo,
-                                    &pDSCBuffer8,&pDSBuffer8,NULL);
+    rc = DirectSoundFullDuplexCreate(&DSDEVID_DefaultCapture,
+            &DSDEVID_DefaultPlayback, &DSCBufferDesc, &DSBufferDesc, get_hwnd(),
+            DSSCL_EXCLUSIVE, &dsfdo, &pDSCBuffer8,&pDSBuffer8, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL||rc==DSERR_INVALIDCALL,
        "DirectSoundFullDuplexCreate(DSDEVID_DefaultCapture,"
        "DSDEVID_DefaultPlayback) failed: %08x\n", rc);
@@ -201,10 +195,9 @@ static void IDirectSoundFullDuplex_tests(void)
         IDirectSoundFullDuplex_test(dsfdo, TRUE, NULL, NULL);
 
     /* try with default voice devices specified */
-    rc=pDirectSoundFullDuplexCreate(&DSDEVID_DefaultVoiceCapture,
-                                    &DSDEVID_DefaultVoicePlayback,
-                                    &DSCBufferDesc,&DSBufferDesc,get_hwnd(),DSSCL_EXCLUSIVE,
-                                    &dsfdo,&pDSCBuffer8,&pDSBuffer8,NULL);
+    rc = DirectSoundFullDuplexCreate(&DSDEVID_DefaultVoiceCapture,
+            &DSDEVID_DefaultVoicePlayback, &DSCBufferDesc, &DSBufferDesc,
+            get_hwnd(), DSSCL_EXCLUSIVE, &dsfdo, &pDSCBuffer8, &pDSBuffer8, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL||rc==DSERR_INVALIDCALL,
        "DirectSoundFullDuplexCreate(DSDEVID_DefaultVoiceCapture,"
        "DSDEVID_DefaultVoicePlayback) failed: %08x\n", rc);
@@ -212,10 +205,9 @@ static void IDirectSoundFullDuplex_tests(void)
         IDirectSoundFullDuplex_test(dsfdo, TRUE, NULL, NULL);
 
     /* try with bad devices specified */
-    rc=pDirectSoundFullDuplexCreate(&DSDEVID_DefaultVoicePlayback,
-                                    &DSDEVID_DefaultVoiceCapture,
-                                    &DSCBufferDesc,&DSBufferDesc,get_hwnd(),DSSCL_EXCLUSIVE,
-                                    &dsfdo,&pDSCBuffer8,&pDSBuffer8,NULL);
+    rc = DirectSoundFullDuplexCreate(&DSDEVID_DefaultVoicePlayback,
+            &DSDEVID_DefaultVoiceCapture, &DSCBufferDesc, &DSBufferDesc,
+            get_hwnd(), DSSCL_EXCLUSIVE, &dsfdo, &pDSCBuffer8, &pDSBuffer8, NULL);
     ok(rc==DSERR_NODRIVER||rc==DSERR_INVALIDCALL,
        "DirectSoundFullDuplexCreate(DSDEVID_DefaultVoicePlayback,"
        "DSDEVID_DefaultVoiceCapture) should have failed: %08x\n", rc);
@@ -336,26 +328,10 @@ static void test_COM(void)
 
 START_TEST(duplex)
 {
-    HMODULE hDsound;
-
     CoInitialize(NULL);
 
-    hDsound = LoadLibraryA("dsound.dll");
-    if (hDsound)
-    {
-
-        pDirectSoundFullDuplexCreate=(void*)GetProcAddress(hDsound,
-            "DirectSoundFullDuplexCreate");
-        if (pDirectSoundFullDuplexCreate) {
-            test_COM();
-            IDirectSoundFullDuplex_tests();
-        } else
-            skip("DirectSoundFullDuplexCreate missing - skipping all tests\n");
-
-        FreeLibrary(hDsound);
-    }
-    else
-        skip("dsound.dll not found - skipping all tests\n");
+    test_COM();
+    IDirectSoundFullDuplex_tests();
 
     CoUninitialize();
 }
diff --git a/dlls/dsound/tests/propset.c b/dlls/dsound/tests/propset.c
index 49e6f518ae4..94f0d36345f 100644
--- a/dlls/dsound/tests/propset.c
+++ b/dlls/dsound/tests/propset.c
@@ -49,19 +49,7 @@ DEFINE_GUID(DSPROPSETID_I3DL2_BufferProperties,
 DEFINE_GUID(DSPROPSETID_ZOOMFX_BufferProperties,
             0xCD5368E0,0x3450,0x11D3,0x8B,0x6E,0x00,0x10,0x5A,0x9B,0x7B,0xBC);
 
-static HRESULT (WINAPI *pDirectSoundEnumerateA)(LPDSENUMCALLBACKA,LPVOID)=NULL;
 static HRESULT (WINAPI *pDllGetClassObject)(REFCLSID,REFIID,LPVOID*)=NULL;
-static HRESULT (WINAPI *pDirectSoundCreate)(LPCGUID,LPDIRECTSOUND*,
-    LPUNKNOWN)=NULL;
-static HRESULT (WINAPI *pDirectSoundCreate8)(LPCGUID,LPDIRECTSOUND8*,
-    LPUNKNOWN)=NULL;
-static HRESULT (WINAPI *pDirectSoundCaptureCreate)(LPCGUID,
-    LPDIRECTSOUNDCAPTURE*,LPUNKNOWN)=NULL;
-static HRESULT (WINAPI *pDirectSoundCaptureCreate8)(LPCGUID,
-    LPDIRECTSOUNDCAPTURE8*,LPUNKNOWN)=NULL;
-static HRESULT (WINAPI *pDirectSoundFullDuplexCreate)(LPCGUID,LPCGUID,
-    LPCDSCBUFFERDESC,LPCDSBUFFERDESC,HWND,DWORD,LPDIRECTSOUNDFULLDUPLEX*,
-    LPDIRECTSOUNDCAPTUREBUFFER8*,LPDIRECTSOUNDBUFFER8*,LPUNKNOWN)=NULL;
 
 static BOOL CALLBACK callback(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA data,
                        LPVOID context)
@@ -202,67 +190,57 @@ static void propset_private_tests(void)
        "returned E_NOINTERFACE, returned: %08x\n",rc);
 
     /* and the direct sound 8 version */
-    if (pDirectSoundCreate8) {
-        rc = (pDllGetClassObject)(&CLSID_DirectSound8, &IID_IClassFactory, (void **)(&pcf));
-        ok(pcf!=0, "DllGetClassObject(CLSID_DirectSound8, IID_IClassFactory) "
-           "failed: %08x\n",rc);
-        if (pcf==0)
-            return;
-
-        /* direct sound 8 doesn't have an IKsPropertySet */
-        rc = IClassFactory_CreateInstance(pcf, NULL, &IID_IKsPropertySet,
-                                         (void **)(&pps));
-        ok(rc==E_NOINTERFACE, "CreateInstance(IID_IKsPropertySet) should have "
-           "returned E_NOINTERFACE, returned: %08x\n",rc);
-    }
+    rc = pDllGetClassObject(&CLSID_DirectSound8, &IID_IClassFactory, (void **)&pcf);
+    ok(pcf!=0, "DllGetClassObject(CLSID_DirectSound8, IID_IClassFactory) "
+       "failed: %08x\n",rc);
+    if (pcf==0)
+        return;
+
+    /* direct sound 8 doesn't have an IKsPropertySet */
+    rc = IClassFactory_CreateInstance(pcf, NULL, &IID_IKsPropertySet,
+                                     (void **)(&pps));
+    ok(rc==E_NOINTERFACE, "CreateInstance(IID_IKsPropertySet) should have "
+       "returned E_NOINTERFACE, returned: %08x\n",rc);
 
     /* try direct sound capture next */
-    if (pDirectSoundCaptureCreate) {
-        rc = (pDllGetClassObject)(&CLSID_DirectSoundCapture, &IID_IClassFactory,
-                     (void **)(&pcf));
-        ok(pcf!=0, "DllGetClassObject(CLSID_DirectSoundCapture, IID_IClassFactory) "
-           "failed: %08x\n",rc);
-        if (pcf==0)
-            return;
-
-        /* direct sound capture doesn't have an IKsPropertySet */
-        rc = IClassFactory_CreateInstance(pcf, NULL, &IID_IKsPropertySet,
-                                         (void **)(&pps));
-        ok(rc==E_NOINTERFACE, "CreateInstance(IID_IKsPropertySet) should have "
-           "returned E_NOINTERFACE,returned: %08x\n",rc);
-    }
+    rc = pDllGetClassObject(&CLSID_DirectSoundCapture, &IID_IClassFactory, (void **)&pcf);
+    ok(pcf!=0, "DllGetClassObject(CLSID_DirectSoundCapture, IID_IClassFactory) "
+       "failed: %08x\n",rc);
+    if (pcf==0)
+        return;
+
+    /* direct sound capture doesn't have an IKsPropertySet */
+    rc = IClassFactory_CreateInstance(pcf, NULL, &IID_IKsPropertySet,
+                                     (void **)(&pps));
+    ok(rc==E_NOINTERFACE, "CreateInstance(IID_IKsPropertySet) should have "
+       "returned E_NOINTERFACE,returned: %08x\n",rc);
 
     /* and the direct sound capture 8 version */
-    if (pDirectSoundCaptureCreate8) {
-        rc = (pDllGetClassObject)(&CLSID_DirectSoundCapture8, &IID_IClassFactory,
-                     (void **)(&pcf));
-        ok(pcf!=0, "DllGetClassObject(CLSID_DirectSoundCapture8, "
-           "IID_IClassFactory) failed: %08x\n",rc);
-        if (pcf==0)
-            return;
-
-        /* direct sound capture 8 doesn't have an IKsPropertySet */
-        rc = IClassFactory_CreateInstance(pcf, NULL, &IID_IKsPropertySet,
-                                         (void **)(&pps));
-        ok(rc==E_NOINTERFACE, "CreateInstance(IID_IKsPropertySet) should have "
-           "returned E_NOINTERFACE, returned: %08x\n",rc);
-    }
+    rc = pDllGetClassObject(&CLSID_DirectSoundCapture8, &IID_IClassFactory, (void **)&pcf);
+    ok(pcf!=0, "DllGetClassObject(CLSID_DirectSoundCapture8, "
+       "IID_IClassFactory) failed: %08x\n",rc);
+    if (pcf==0)
+        return;
+
+    /* direct sound capture 8 doesn't have an IKsPropertySet */
+    rc = IClassFactory_CreateInstance(pcf, NULL, &IID_IKsPropertySet,
+                                     (void **)(&pps));
+    ok(rc==E_NOINTERFACE, "CreateInstance(IID_IKsPropertySet) should have "
+       "returned E_NOINTERFACE, returned: %08x\n",rc);
 
     /* try direct sound full duplex next */
-    if (pDirectSoundFullDuplexCreate) {
-        rc = (pDllGetClassObject)(&CLSID_DirectSoundFullDuplex, &IID_IClassFactory,
-                     (void **)(&pcf));
-        ok(pcf!=0, "DllGetClassObject(CLSID_DirectSoundFullDuplex, "
-           "IID_IClassFactory) failed: %08x\n",rc);
-        if (pcf==0)
-            return;
-
-        /* direct sound full duplex doesn't have an IKsPropertySet */
-        rc = IClassFactory_CreateInstance(pcf, NULL, &IID_IKsPropertySet,
-                                         (void **)(&pps));
-        ok(rc==E_NOINTERFACE, "CreateInstance(IID_IKsPropertySet) should have "
-           "returned NOINTERFACE, returned: %08x\n",rc);
-    }
+    rc = (pDllGetClassObject)(&CLSID_DirectSoundFullDuplex, &IID_IClassFactory,
+                 (void **)(&pcf));
+    ok(pcf!=0, "DllGetClassObject(CLSID_DirectSoundFullDuplex, "
+       "IID_IClassFactory) failed: %08x\n",rc);
+    if (pcf==0)
+        return;
+
+    /* direct sound full duplex doesn't have an IKsPropertySet */
+    rc = IClassFactory_CreateInstance(pcf, NULL, &IID_IKsPropertySet,
+                                     (void **)(&pps));
+    ok(rc==E_NOINTERFACE, "CreateInstance(IID_IKsPropertySet) should have "
+       "returned NOINTERFACE, returned: %08x\n",rc);
 
     /* try direct sound private last */
     rc = (pDllGetClassObject)(&CLSID_DirectSoundPrivate, &IID_IClassFactory,
@@ -549,7 +527,7 @@ static BOOL WINAPI dsenum_callback(LPGUID lpGuid, LPCSTR lpcstrDescription,
     trace("*** Testing %s - %s ***\n",lpcstrDescription,lpcstrModule);
     driver_count++;
 
-    rc=pDirectSoundCreate(lpGuid,&dso,NULL);
+    rc = DirectSoundCreate(lpGuid, &dso, NULL);
     ok(rc==DS_OK||rc==DSERR_NODRIVER||rc==DSERR_ALLOCATED||rc==E_FAIL,
        "DirectSoundCreate() failed: %08x\n",rc);
     if (rc!=DS_OK) {
@@ -692,43 +670,19 @@ static BOOL WINAPI dsenum_callback(LPGUID lpGuid, LPCSTR lpcstrDescription,
 static void propset_buffer_tests(void)
 {
     HRESULT rc;
-    rc=pDirectSoundEnumerateA(&dsenum_callback,NULL);
+    rc = DirectSoundEnumerateA(dsenum_callback, NULL);
     ok(rc==DS_OK,"DirectSoundEnumerateA() failed: %08x\n",rc);
     trace("tested %u DirectSound drivers\n", driver_count);
 }
 
 START_TEST(propset)
 {
-    HMODULE hDsound;
-
     CoInitialize(NULL);
 
-    hDsound = LoadLibraryA("dsound.dll");
-    if (hDsound)
-    {
-
-        pDirectSoundEnumerateA = (void*)GetProcAddress(hDsound,
-            "DirectSoundEnumerateA");
-        pDllGetClassObject = (void *)GetProcAddress(hDsound,
-            "DllGetClassObject");
-        pDirectSoundCreate = (void*)GetProcAddress(hDsound,
-            "DirectSoundCreate");
-        pDirectSoundCreate8 = (void*)GetProcAddress(hDsound,
-            "DirectSoundCreate8");
-        pDirectSoundCaptureCreate=(void*)GetProcAddress(hDsound,
-            "DirectSoundCaptureCreate");
-        pDirectSoundCaptureCreate8=(void*)GetProcAddress(hDsound,
-            "DirectSoundCaptureCreate8");
-        pDirectSoundFullDuplexCreate=(void*)GetProcAddress(hDsound,
-            "DirectSoundFullDuplexCreate");
-
-        propset_private_tests();
-        propset_buffer_tests();
-
-        FreeLibrary(hDsound);
-    }
-    else
-        skip("dsound.dll not found - skipping all tests\n");
+    pDllGetClassObject = (void *)GetProcAddress(GetModuleHandleA("dsound"), "DllGetClassObject");
+
+    propset_private_tests();
+    propset_buffer_tests();
 
     CoUninitialize();
 }
From 7893ef6b9f9216945f31a62f398a70cc646dd892 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 23 Jul 2020 11:47:00 -0500
Subject: [PATCH] dsound/tests: Rewrite test_effects().

Use a custom DMO to show the interaction between dsound the DMO more clearly,
and add more tests for IDirectSoundBuffer8::GetObjectInPath().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Andrew Eikum <aeikum@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsound/tests/Makefile.in |   2 +-
 dlls/dsound/tests/dsound8.c   | 773 ++++++++++++++++++++++++++--------
 2 files changed, 596 insertions(+), 179 deletions(-)

diff --git a/dlls/dsound/tests/Makefile.in b/dlls/dsound/tests/Makefile.in
index 49bc4d9b55a..234b49b1bba 100644
--- a/dlls/dsound/tests/Makefile.in
+++ b/dlls/dsound/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = dsound.dll
-IMPORTS   = dsound ole32 version user32
+IMPORTS   = dmoguids dsound msdmo ole32 version user32
 
 C_SRCS = \
 	capture.c \
diff --git a/dlls/dsound/tests/dsound8.c b/dlls/dsound/tests/dsound8.c
index 6fe13c66fd1..1294e952dbe 100644
--- a/dlls/dsound/tests/dsound8.c
+++ b/dlls/dsound/tests/dsound8.c
@@ -36,10 +36,11 @@
 #include "dsconf.h"
 #include "ks.h"
 #include "ksmedia.h"
+#include "dmo.h"
 
 #include "initguid.h"
 
-#include "mediaobj.h"
+#include "uuids.h"
 #include "wingdi.h"
 #include "mmdeviceapi.h"
 #include "audioclient.h"
@@ -48,6 +49,8 @@
 
 #include "dsound_test.h"
 
+static const GUID testdmo_clsid = {0x1234};
+
 int align(int length, int align)
 {
     return (length / align) * align;
@@ -1219,206 +1222,610 @@ static void test_primary_flags(void)
     IDirectSound8_Release(dso);
 }
 
-static void test_effects(void)
+static IMediaObject testdmo;
+static IMediaObjectInPlace testdmo_inplace;
+static LONG testdmo_refcount;
+static WAVEFORMATEX testdmo_input_type;
+static BOOL testdmo_input_type_set, testdmo_output_type_set;
+
+static unsigned int got_Discontinuity;
+static HANDLE got_Process;
+
+static HRESULT WINAPI dmo_QueryInterface(IMediaObject *iface, REFIID iid, void **out)
 {
-    HRESULT rc;
-    LPDIRECTSOUND8 dso;
-    LPDIRECTSOUNDBUFFER primary, secondary;
-    LPDIRECTSOUNDBUFFER8 secondary8;
-    DSBUFFERDESC bufdesc;
-    WAVEFORMATEX wfx;
-    DSEFFECTDESC effects[2];
-    DWORD resultcodes[2];
+    if (winetest_debug > 1) trace("QueryInterface(%s)\n", wine_dbgstr_guid(iid));
 
-    /* Create a DirectSound8 object */
-    rc = DirectSoundCreate8(NULL, &dso, NULL);
-    ok(rc==DS_OK||rc==DSERR_NODRIVER,"DirectSoundCreate8() failed: %08x\n",rc);
+    if (IsEqualGUID(iid, &IID_IMediaObject))
+        *out = iface;
+    else if (IsEqualGUID(iid, &IID_IMediaObjectInPlace))
+        *out = &testdmo_inplace;
+    else
+        return E_NOINTERFACE;
 
-    if (rc!=DS_OK)
-        return;
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
 
-    rc=IDirectSound8_SetCooperativeLevel(dso,get_hwnd(),DSSCL_PRIORITY);
-    ok(rc==DS_OK,"IDirectSound8_SetCooperativeLevel() failed: %08x\n", rc);
-    if (rc!=DS_OK) {
-        IDirectSound8_Release(dso);
-        return;
-    }
+static ULONG WINAPI dmo_AddRef(IMediaObject *iface)
+{
+    return InterlockedIncrement(&testdmo_refcount);
+}
 
-    primary=NULL;
-    ZeroMemory(&bufdesc, sizeof(bufdesc));
-    bufdesc.dwSize=sizeof(bufdesc);
-    bufdesc.dwFlags=DSBCAPS_PRIMARYBUFFER;
-    rc=IDirectSound8_CreateSoundBuffer(dso,&bufdesc,&primary,NULL);
-    ok((rc==DS_OK && primary!=NULL),
-       "IDirectSound8_CreateSoundBuffer() failed to create a primary buffer: "
-       "%08x\n",rc);
-    if (rc==DS_OK) {
-        init_format(&wfx,WAVE_FORMAT_PCM,11025,8,1);
-        ZeroMemory(&bufdesc, sizeof(bufdesc));
-        bufdesc.dwSize=sizeof(bufdesc);
-        bufdesc.dwFlags=0;
-        bufdesc.dwBufferBytes=align(wfx.nAvgBytesPerSec*BUFFER_LEN/1000,
-                                    wfx.nBlockAlign);
-        bufdesc.lpwfxFormat=&wfx;
+static ULONG WINAPI dmo_Release(IMediaObject *iface)
+{
+    return InterlockedDecrement(&testdmo_refcount);
+}
 
-        ZeroMemory(effects, sizeof(effects));
-        effects[0].dwSize=sizeof(effects[0]);
-        effects[0].guidDSFXClass=GUID_DSFX_STANDARD_ECHO;
-        effects[1].dwSize=sizeof(effects[1]);
-        effects[1].guidDSFXClass=GUID_NULL;
+static HRESULT WINAPI dmo_GetStreamCount(IMediaObject *iface, DWORD *input, DWORD *output)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
 
-        secondary=NULL;
-        rc=IDirectSound8_CreateSoundBuffer(dso,&bufdesc,&secondary,NULL);
-        ok(rc==DS_OK && secondary!=NULL,
-           "IDirectSound8_CreateSoundBuffer() failed to create a secondary "
-           "buffer: %08x\n",rc);
+static HRESULT WINAPI dmo_GetInputStreamInfo(IMediaObject *iface, DWORD index, DWORD *flags)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
 
-        /* Call SetFX on buffer without DSBCAPS_CTRLFX */
-        if (rc==DS_OK && secondary!=NULL) {
-            secondary8=NULL;
-            rc=IDirectSoundBuffer_QueryInterface(secondary,&IID_IDirectSoundBuffer8,(LPVOID*)&secondary8);
-            ok(rc==DS_OK,"IDirectSoundBuffer_QueryInterface(IID_IDirectSoundBuffer8) failed: %08x\n", rc);
+static HRESULT WINAPI dmo_GetOutputStreamInfo(IMediaObject *iface, DWORD index, DWORD *flags)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
 
-            if (rc==DS_OK && secondary8) {
-                rc=IDirectSoundBuffer8_SetFX(secondary8,1,effects,resultcodes);
-                ok(rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_SetFX() "
-                "should have returned DSERR_CONTROLUNAVAIL, returned: %08x\n", rc);
+static HRESULT WINAPI dmo_GetInputType(IMediaObject *iface, DWORD index, DWORD type_index, DMO_MEDIA_TYPE *type)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
 
-                IDirectSoundBuffer8_Release(secondary8);
-            }
-            IDirectSoundBuffer_Release(secondary);
-        }
+static HRESULT WINAPI dmo_GetOutputType(IMediaObject *iface, DWORD index, DWORD type_index, DMO_MEDIA_TYPE *type)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
 
-        secondary=NULL;
-        bufdesc.dwFlags=DSBCAPS_CTRLFX;
-        rc=IDirectSound8_CreateSoundBuffer(dso,&bufdesc,&secondary,NULL);
-        ok(rc==DS_OK && secondary!=NULL,
-           "IDirectSound8_CreateSoundBuffer() failed to create a secondary "
-           "buffer: %08x\n",rc);
+static HRESULT WINAPI dmo_SetInputType(IMediaObject *iface, DWORD index, const DMO_MEDIA_TYPE *type, DWORD flags)
+{
+    const WAVEFORMATEX *wfx;
 
-        if (rc==DS_OK) {
-            secondary8=NULL;
-            rc=IDirectSoundBuffer_QueryInterface(secondary,&IID_IDirectSoundBuffer8,(LPVOID*)&secondary8);
-            ok(rc==DS_OK,"IDirectSoundBuffer_QueryInterface(IID_IDirectSoundBuffer8) failed: %08x\n", rc);
-
-            if (rc==DS_OK && secondary8) {
-                LPVOID ptr1,ptr2;
-                DWORD bytes1,bytes2;
-                IUnknown* obj = NULL;
-                HRESULT rc2;
-
-                /* Call SetFX with dwEffectsCount > 0 and pDSFXDesc == NULL */
-                rc=IDirectSoundBuffer8_SetFX(secondary8,1,NULL,NULL);
-                ok(rc==E_INVALIDARG||rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_SetFX() "
-                "should have returned E_INVALIDARG, returned: %08x\n", rc);
-
-                /* Call SetFX with dwEffectsCount == 0 and pDSFXDesc != NULL */
-                rc=IDirectSoundBuffer8_SetFX(secondary8,0,effects,NULL);
-                ok(rc==E_INVALIDARG||rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_SetFX() "
-                "should have returned E_INVALIDARG, returned: %08x\n", rc);
-
-                /* Call SetFX with dwEffectsCount == 0 and pdwResultCodes != NULL */
-                rc=IDirectSoundBuffer8_SetFX(secondary8,0,NULL,resultcodes);
-                ok(rc==E_INVALIDARG||rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_SetFX() "
-                "should have returned E_INVALIDARG, returned: %08x\n", rc);
-
-                rc=IDirectSoundBuffer8_Lock(secondary8,0,0,&ptr1,&bytes1,&ptr2,&bytes2,DSBLOCK_ENTIREBUFFER);
-                ok(rc==DS_OK,"IDirectSoundBuffer8_Lock() failed: %08x\n",rc);
-
-                if (rc==DS_OK) {
-                    /* Call SetFX when buffer is locked */
-                    rc=IDirectSoundBuffer8_SetFX(secondary8,1,effects,resultcodes);
-                    ok(rc==DSERR_INVALIDCALL||rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_SetFX() "
-                    "should have returned DSERR_INVALIDCALL, returned: %08x\n", rc);
-
-                    rc=IDirectSoundBuffer8_Unlock(secondary8,ptr1,bytes1,ptr2,bytes2);
-                    ok(rc==DS_OK,"IDirectSoundBuffer8_Unlock() failed: %08x\n",rc);
-                }
+    if (winetest_debug > 1) trace("SetInputType()\n");
 
-                rc=IDirectSoundBuffer8_Play(secondary8,0,0,DSBPLAY_LOOPING);
-                ok(rc==DS_OK,"IDirectSoundBuffer8_Play() failed: %08x\n",rc);
+    ok(!index, "Got unexpected index %u.\n", index);
+    ok(!flags, "Got unexpected flags %#x.\n", flags);
 
-                if (rc==DS_OK) {
-                    /* Call SetFX when buffer is playing */
-                    rc=IDirectSoundBuffer8_SetFX(secondary8,1,effects,resultcodes);
-                    ok(rc==DSERR_INVALIDCALL||rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_SetFX() "
-                    "should have returned DSERR_INVALIDCALL, returned: %08x\n", rc);
+    ok(IsEqualGUID(&type->majortype, &MEDIATYPE_Audio), "Got major type %s.\n", debugstr_guid(&type->majortype));
+    todo_wine ok(IsEqualGUID(&type->subtype, &MEDIASUBTYPE_PCM), "Got subtype %s.\n", debugstr_guid(&type->subtype));
+    ok(type->bFixedSizeSamples == TRUE, "Got fixed size %d.\n", type->bFixedSizeSamples);
+    ok(!type->bTemporalCompression, "Got temporal compression %d.\n", type->bTemporalCompression);
+    ok(IsEqualGUID(&type->formattype, &FORMAT_WaveFormatEx), "Got format type %s.\n", debugstr_guid(&type->formattype));
+    ok(!type->pUnk, "Got pUnk %p.\n", type->pUnk);
+    ok(type->cbFormat == sizeof(WAVEFORMATEX), "Got format size %u.\n", type->cbFormat);
 
-                    rc=IDirectSoundBuffer8_Stop(secondary8);
-                    ok(rc==DS_OK,"IDirectSoundBuffer8_Stop() failed: %08x\n",rc);
-                }
+    wfx = (WAVEFORMATEX *)type->pbFormat;
+    todo_wine ok(type->lSampleSize == wfx->nBlockAlign, "Got sample size %u.\n", type->lSampleSize);
 
-                /* Call SetFX with non-existent filter */
-                rc=IDirectSoundBuffer8_SetFX(secondary8,1,&effects[1],resultcodes);
-                ok(rc==REGDB_E_CLASSNOTREG||rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_SetFX(GUID_NULL) "
-                    "should have returned REGDB_E_CLASSNOTREG, returned: %08x\n",rc);
-                if (rc!=DSERR_CONTROLUNAVAIL) {
-                    ok(resultcodes[0]==DSFXR_UNKNOWN,"result code == %08x, expected DSFXR_UNKNOWN\n",resultcodes[0]);
-                }
+    if (wfx->wBitsPerSample != 8)
+        return DMO_E_TYPE_NOT_ACCEPTED;
 
-                /* Call SetFX with standard echo */
-                rc2=IDirectSoundBuffer8_SetFX(secondary8,1,&effects[0],resultcodes);
-                ok(rc2==DS_OK||rc2==REGDB_E_CLASSNOTREG||rc2==DSERR_CONTROLUNAVAIL,
-                   "IDirectSoundBuffer8_SetFX(GUID_DSFX_STANDARD_ECHO) failed: %08x\n",rc);
-                if (rc2!=DSERR_CONTROLUNAVAIL) {
-                    ok(resultcodes[0]==DSFXR_UNKNOWN||resultcodes[0]==DSFXR_LOCHARDWARE||resultcodes[0]==DSFXR_LOCSOFTWARE,
-                        "resultcode == %08x, expected DSFXR_UNKNOWN, DSFXR_LOCHARDWARE, or DSFXR_LOCSOFTWARE\n",resultcodes[0]);
-                }
+    testdmo_input_type = *wfx;
+    testdmo_input_type_set = TRUE;
+    return S_OK;
+}
 
-                /* Call GetObjectInPath for out-of-bounds DMO */
-                rc=IDirectSoundBuffer8_GetObjectInPath(secondary8,&GUID_All_Objects,2,&IID_IMediaObject,(void**)&obj);
-                ok(rc==DSERR_OBJECTNOTFOUND||rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_GetObjectInPath() "
-                "should have returned DSERR_OBJECTNOTFOUND, returned: %08x\n",rc);
-
-                /* Call GetObjectInPath with NULL ppObject */
-                rc=IDirectSoundBuffer8_GetObjectInPath(secondary8,&GUID_All_Objects,0,&IID_IMediaObject,NULL);
-                ok(rc==E_INVALIDARG||rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_GetObjectInPath() "
-                "should have returned E_INVALIDARG, returned: %08x\n",rc);
-
-                /* Call GetObjectInPath for unsupported interface */
-                rc=IDirectSoundBuffer8_GetObjectInPath(secondary8,&GUID_All_Objects,0,&GUID_NULL,(void**)&obj);
-                ok(rc==E_NOINTERFACE||rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_GetObjectInPath() "
-                "should have returned E_NOINTERFACE, returned: %08x\n",rc);
-
-                /* Call GetObjectInPath for unloaded DMO */
-                rc=IDirectSoundBuffer8_GetObjectInPath(secondary8,&GUID_NULL,0,&IID_IMediaObject,(void**)&obj);
-                ok(rc==DSERR_OBJECTNOTFOUND||rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_GetObjectInPath() "
-                "should have returned DSERR_OBJECTNOTFOUND, returned: %08x\n",rc);
-
-                /* Call GetObjectInPath for first DMO */
-                obj=NULL;
-                rc=IDirectSoundBuffer8_GetObjectInPath(secondary8,&GUID_All_Objects,0,&IID_IMediaObject,(void**)&obj);
-                if (rc2==DS_OK) {
-                    ok(rc==DS_OK||rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_GetObjectInPath() "
-                    "should have returned DS_OK, returned: %08x\n",rc);
-                    if (obj) IUnknown_Release(obj);
-                } else {
-                    ok(rc==DSERR_OBJECTNOTFOUND||rc==DSERR_CONTROLUNAVAIL,"IDirectSoundBuffer8_GetObjectInPath() "
-                    "should have returned DSERR_OBJECTNOTFOUND, returned: %08x\n",rc);
-                }
+static HRESULT WINAPI dmo_SetOutputType(IMediaObject *iface, DWORD index, const DMO_MEDIA_TYPE *type, DWORD flags)
+{
+    if (winetest_debug > 1) trace("SetOutputType()\n");
 
-                /* Call SetFX with one real filter and one fake one */
-                rc=IDirectSoundBuffer8_SetFX(secondary8,2,effects,resultcodes);
-                ok(rc==REGDB_E_CLASSNOTREG||rc==DSERR_CONTROLUNAVAIL,
-                   "IDirectSoundBuffer8_SetFX(GUID_DSFX_STANDARD_ECHO, GUID_NULL) "
-                    "should have returned REGDB_E_CLASSNOTREG, returned: %08x\n",rc);
-                if (rc!=DSERR_CONTROLUNAVAIL) {
-                    ok(resultcodes[0]==DSFXR_PRESENT||resultcodes[0]==DSFXR_UNKNOWN,
-                        "resultcodes[0] == %08x, expected DSFXR_PRESENT or DSFXR_UNKNOWN\n",resultcodes[0]);
-                    ok(resultcodes[1]==DSFXR_UNKNOWN,
-                        "resultcodes[1] == %08x, expected DSFXR_UNKNOWN\n",resultcodes[1]);
-                }
+    ok(!index, "Got unexpected index %u.\n", index);
+    ok(!flags, "Got unexpected flags %#x.\n", flags);
 
-                IDirectSoundBuffer8_Release(secondary8);
-            }
+    ok(testdmo_input_type_set, "Expected the input type to be set.\n");
 
-            IDirectSoundBuffer_Release(secondary);
-        }
+    ok(IsEqualGUID(&type->majortype, &MEDIATYPE_Audio), "Got major type %s.\n", debugstr_guid(&type->majortype));
+    ok(IsEqualGUID(&type->subtype, &MEDIASUBTYPE_PCM), "Got subtype %s.\n", debugstr_guid(&type->subtype));
+    ok(type->bFixedSizeSamples == TRUE, "Got fixed size %d.\n", type->bFixedSizeSamples);
+    ok(!type->bTemporalCompression, "Got temporal compression %d.\n", type->bTemporalCompression);
+    ok(type->lSampleSize == 1, "Got sample size %u.\n", type->lSampleSize);
+    ok(IsEqualGUID(&type->formattype, &FORMAT_WaveFormatEx), "Got format type %s.\n", debugstr_guid(&type->formattype));
+    ok(!type->pUnk, "Got pUnk %p.\n", type->pUnk);
+    ok(type->cbFormat == sizeof(WAVEFORMATEX), "Got format size %u.\n", type->cbFormat);
 
-        IDirectSoundBuffer_Release(primary);
+    ok(!memcmp(type->pbFormat, &testdmo_input_type, sizeof(WAVEFORMATEX)), "Format blocks didn't match.\n");
+
+    testdmo_output_type_set = TRUE;
+    return S_OK;
+}
+
+static HRESULT WINAPI dmo_GetInputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_GetOutputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_GetInputSizeInfo(IMediaObject *iface, DWORD index,
+        DWORD *size, DWORD *lookahead, DWORD *alignment)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_GetOutputSizeInfo(IMediaObject *iface, DWORD index, DWORD *size, DWORD *alignment)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_GetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME *latency)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_SetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME latency)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_Flush(IMediaObject *iface)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_Discontinuity(IMediaObject *iface, DWORD index)
+{
+    if (winetest_debug > 1) trace("Discontinuity()\n");
+    ++got_Discontinuity;
+    return S_OK;
+}
+
+static HRESULT WINAPI dmo_AllocateStreamingResources(IMediaObject *iface)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_FreeStreamingResources(IMediaObject *iface)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_GetInputStatus(IMediaObject *iface, DWORD index, DWORD *flags)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_ProcessInput(IMediaObject *iface, DWORD index,
+    IMediaBuffer *buffer, DWORD flags, REFERENCE_TIME timestamp, REFERENCE_TIME timelength)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_ProcessOutput(IMediaObject *iface, DWORD flags,
+        DWORD count, DMO_OUTPUT_DATA_BUFFER *buffers, DWORD *status)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_Lock(IMediaObject *iface, LONG lock)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static const IMediaObjectVtbl dmo_vtbl =
+{
+    dmo_QueryInterface,
+    dmo_AddRef,
+    dmo_Release,
+    dmo_GetStreamCount,
+    dmo_GetInputStreamInfo,
+    dmo_GetOutputStreamInfo,
+    dmo_GetInputType,
+    dmo_GetOutputType,
+    dmo_SetInputType,
+    dmo_SetOutputType,
+    dmo_GetInputCurrentType,
+    dmo_GetOutputCurrentType,
+    dmo_GetInputSizeInfo,
+    dmo_GetOutputSizeInfo,
+    dmo_GetInputMaxLatency,
+    dmo_SetInputMaxLatency,
+    dmo_Flush,
+    dmo_Discontinuity,
+    dmo_AllocateStreamingResources,
+    dmo_FreeStreamingResources,
+    dmo_GetInputStatus,
+    dmo_ProcessInput,
+    dmo_ProcessOutput,
+    dmo_Lock,
+};
+
+static HRESULT WINAPI dmo_inplace_QueryInterface(IMediaObjectInPlace *iface, REFIID iid, void **out)
+{
+    return IMediaObject_QueryInterface(&testdmo, iid, out);
+}
+
+static ULONG WINAPI dmo_inplace_AddRef(IMediaObjectInPlace *iface)
+{
+    return IMediaObject_AddRef(&testdmo);
+}
+
+static ULONG WINAPI dmo_inplace_Release(IMediaObjectInPlace *iface)
+{
+    return IMediaObject_Release(&testdmo);
+}
+
+static HRESULT WINAPI dmo_inplace_Process(IMediaObjectInPlace *iface, ULONG size,
+        BYTE *data, REFERENCE_TIME start, DWORD flags)
+{
+    if (winetest_debug > 1) trace("Process(size %u)\n", size);
+
+    ok(!start, "Got start time %s.\n", wine_dbgstr_longlong(start));
+    ok(!flags, "Got flags %#x.\n", flags);
+
+    SetEvent(got_Process);
+
+    return S_FALSE;
+}
+
+static HRESULT WINAPI dmo_inplace_Clone(IMediaObjectInPlace *iface, IMediaObjectInPlace **ret_dmo)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dmo_inplace_GetLatency(IMediaObjectInPlace *iface, REFERENCE_TIME *latency)
+{
+    ok(0, "Unexpected call.\n");
+    return E_NOTIMPL;
+}
+
+static const IMediaObjectInPlaceVtbl dmo_inplace_vtbl =
+{
+    dmo_inplace_QueryInterface,
+    dmo_inplace_AddRef,
+    dmo_inplace_Release,
+    dmo_inplace_Process,
+    dmo_inplace_Clone,
+    dmo_inplace_GetLatency,
+};
+
+static IMediaObject testdmo = {&dmo_vtbl};
+static IMediaObjectInPlace testdmo_inplace = {&dmo_inplace_vtbl};
+
+static HRESULT WINAPI dmo_cf_QueryInterface(IClassFactory *iface, REFIID iid, void **out)
+{
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IClassFactory))
+    {
+        *out = iface;
+        return S_OK;
+    }
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI dmo_cf_AddRef(IClassFactory *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI dmo_cf_Release(IClassFactory *iface)
+{
+    return 1;
+}
+
+static HRESULT WINAPI dmo_cf_CreateInstance(IClassFactory *iface, IUnknown *outer, REFIID iid, void **out)
+{
+    ok(!outer, "Unexpected outer parameter.\n");
+    ok(IsEqualGUID(iid, &IID_IMediaObject), "Got unexpected iid %s.\n", wine_dbgstr_guid(iid));
+
+    *out = &testdmo;
+    IMediaObject_AddRef(&testdmo);
+    return S_OK;
+}
+
+static HRESULT WINAPI dmo_cf_LockServer(IClassFactory *iface, BOOL lock)
+{
+    ok(0, "Unexpected call.\n");
+    return S_OK;
+}
+
+static const IClassFactoryVtbl dmo_cf_vtbl =
+{
+    dmo_cf_QueryInterface,
+    dmo_cf_AddRef,
+    dmo_cf_Release,
+    dmo_cf_CreateInstance,
+    dmo_cf_LockServer,
+};
+
+static IClassFactory testdmo_cf = {&dmo_cf_vtbl};
+
+static void test_effects(void)
+{
+    DSBPOSITIONNOTIFY notify_params = {DSBPN_OFFSETSTOP, CreateEventA(NULL, TRUE, FALSE, NULL)};
+    DSBUFFERDESC buffer_desc = {.dwSize = sizeof(buffer_desc)};
+    IMediaObject *echo = NULL, *reverb = NULL;
+    IDirectSoundBuffer8 *buffer8;
+    DSEFFECTDESC effects[2] = {};
+    IDirectSoundBuffer *buffer;
+    IDirectSoundNotify *notify;
+    IDirectSound8 *dsound;
+    DWORD size1, size2;
+    IMediaObject *dmo;
+    void *ptr1, *ptr2;
+    WAVEFORMATEX wfx;
+    DWORD results[2];
+    IUnknown *unk;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = DirectSoundCreate8(NULL, &dsound, NULL);
+    ok(hr == DS_OK || hr == DSERR_NODRIVER, "Got hr %#x.\n", hr);
+    if (FAILED(hr))
+        return;
+
+    hr = IDirectSound8_SetCooperativeLevel(dsound, get_hwnd(), DSSCL_PRIORITY);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+
+    effects[0].dwSize = effects[1].dwSize = sizeof(effects[0]);
+    effects[0].guidDSFXClass = GUID_DSFX_STANDARD_PARAMEQ;
+
+    init_format(&wfx, WAVE_FORMAT_PCM, 11025, 8, 1);
+    buffer_desc.dwBufferBytes = align(wfx.nAvgBytesPerSec * BUFFER_LEN / 1000, wfx.nBlockAlign);
+    buffer_desc.lpwfxFormat = &wfx;
+    hr = IDirectSound8_CreateSoundBuffer(dsound, &buffer_desc, &buffer, NULL);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    hr = IDirectSoundBuffer_QueryInterface(buffer, &IID_IDirectSoundBuffer8, (void **)&buffer8);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 1, effects, results);
+    ok(hr == DSERR_CONTROLUNAVAIL, "Got hr %#x.\n", hr);
+
+    IDirectSoundBuffer8_Release(buffer8);
+    IDirectSoundBuffer_Release(buffer);
+
+    buffer_desc.dwFlags = DSBCAPS_CTRLFX | DSBCAPS_CTRLPOSITIONNOTIFY;
+    hr = IDirectSound8_CreateSoundBuffer(dsound, &buffer_desc, &buffer, NULL);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    hr = IDirectSoundBuffer_QueryInterface(buffer, &IID_IDirectSoundBuffer8, (void **)&buffer8);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    hr = IDirectSoundBuffer8_QueryInterface(buffer, &IID_IDirectSoundNotify, (void **)&notify);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectSoundNotify_SetNotificationPositions(notify, 1, &notify_params);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 1, NULL, NULL);
+    ok(hr == DSERR_INVALIDPARAM, "Got hr %#x.\n", hr);
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 0, effects, NULL);
+    ok(hr == DSERR_INVALIDPARAM, "Got hr %#x.\n", hr);
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 0, NULL, results);
+    ok(hr == DSERR_INVALIDPARAM, "Got hr %#x.\n", hr);
+
+    results[0] = 0xdeadbeef;
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 1, effects, results);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(results[0] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[0]);
+
+    hr = IDirectSoundBuffer8_Lock(buffer8, 0, 0, &ptr1, &size1, &ptr2, &size2, DSBLOCK_ENTIREBUFFER);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    results[0] = 0xdeadbeef;
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 1, effects, results);
+    ok(hr == DSERR_INVALIDCALL, "Got hr %#x.\n", hr);
+    todo_wine ok(results[0] == 0xdeadbeef, "Got result %#x.\n", results[0]);
+    hr = IDirectSoundBuffer8_Unlock(buffer8, ptr1, size1, ptr2, size2);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectSoundBuffer8_Play(buffer8, 0, 0, DSBPLAY_LOOPING);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    results[0] = 0xdeadbeef;
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 1, effects, results);
+    ok(hr == DSERR_INVALIDCALL, "Got hr %#x.\n", hr);
+    todo_wine ok(results[0] == 0xdeadbeef, "Got result %#x.\n", results[0]);
+    hr = IDirectSoundBuffer8_Stop(buffer8);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    ok(!WaitForSingleObject(notify_params.hEventNotify, 1000), "Wait timed out.\n");
+
+    effects[0].guidDSFXClass = GUID_NULL;
+    results[0] = 0xdeadbeef;
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 1, effects, results);
+    ok(hr == REGDB_E_CLASSNOTREG, "Got hr %#x.\n", hr);
+    ok(results[0] == DSFXR_UNKNOWN, "Got result %#x.\n", results[0]);
+
+    effects[0].guidDSFXClass = GUID_DSFX_STANDARD_PARAMEQ;
+    results[0] = 0xdeadbeef;
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 1, effects, results);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(results[0] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[0]);
+
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IMediaObject, NULL);
+    todo_wine ok(hr == DSERR_INVALIDPARAM, "Got hr %#x.\n", hr);
+
+    dmo = (IMediaObject *)0xdeadbeef;
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &GUID_NULL, (void **)&dmo);
+    todo_wine ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+    todo_wine ok(!dmo, "Got object %p.\n", dmo);
+
+    dmo = (IMediaObject *)0xdeadbeef;
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_NULL, 0, &IID_IMediaObject, (void **)&dmo);
+    todo_wine ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
+    ok(dmo == (IMediaObject *)0xdeadbeef, "Got object %p.\n", dmo);
+
+    dmo = NULL;
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IMediaObject, (void **)&dmo);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    if (hr == DS_OK)
+    {
+        ok(!!dmo, "Expected a non-NULL object.\n");
+        IMediaObject_Release(dmo);
+    }
+
+    dmo = NULL;
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_DSFX_STANDARD_PARAMEQ, 0, &IID_IMediaObject, (void **)&dmo);
+    if (hr == DS_OK)
+    {
+        ok(!!dmo, "Expected a non-NULL object.\n");
+        IMediaObject_Release(dmo);
     }
 
-    while (IDirectSound8_Release(dso));
+    dmo = (IMediaObject *)0xdeadbeef;
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 1, &IID_IMediaObject, (void **)&dmo);
+    todo_wine ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
+    ok(dmo == (IMediaObject *)0xdeadbeef, "Got object %p.\n", dmo);
+
+    effects[0].guidDSFXClass = GUID_DSFX_STANDARD_PARAMEQ;
+    effects[1].guidDSFXClass = GUID_NULL;
+    results[0] = results[1] = 0xdeadbeef;
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 2, effects, results);
+    ok(hr == REGDB_E_CLASSNOTREG, "Got hr %#x.\n", hr);
+    todo_wine ok(results[0] == DSFXR_PRESENT, "Got result %#x.\n", results[0]);
+    ok(results[1] == DSFXR_UNKNOWN, "Got result %#x.\n", results[1]);
+
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IMediaObject, (void **)&dmo);
+    todo_wine ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
+
+    effects[0].guidDSFXClass = GUID_DSFX_STANDARD_PARAMEQ;
+    effects[1].guidDSFXClass = GUID_DSFX_STANDARD_I3DL2REVERB;
+    results[0] = results[1] = 0xdeadbeef;
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 2, effects, results);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(results[0] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[0]);
+    todo_wine ok(results[1] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[1]);
+
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_DSFX_STANDARD_PARAMEQ, 0, &IID_IMediaObject, (void **)&dmo);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    if (hr == DS_OK)
+        echo = dmo;
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8,
+            &GUID_DSFX_STANDARD_I3DL2REVERB, 0, &IID_IMediaObject, (void **)&dmo);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    if (hr == DS_OK)
+        reverb = dmo;
+
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IMediaObject, (void **)&dmo);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    if (hr == DS_OK)
+    {
+        ok(dmo == echo, "Expected %p, got %p.\n", echo, dmo);
+        IMediaObject_Release(dmo);
+    }
+
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 1, &IID_IMediaObject, (void **)&dmo);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    if (hr == DS_OK)
+    {
+        ok(dmo == reverb, "Expected %p, got %p.\n", reverb, dmo);
+        IMediaObject_Release(dmo);
+    }
+
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8,
+            &GUID_DSFX_STANDARD_I3DL2REVERB, 1, &IID_IMediaObject, (void **)&dmo);
+    todo_wine ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
+
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IDirectSoundFXParamEq, (void **)&unk);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    if (hr == DS_OK)
+        IUnknown_Release(unk);
+
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0,
+            &IID_IDirectSoundFXParamEq, (void **)&unk);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    if (hr == DS_OK)
+        IUnknown_Release(unk);
+
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0,
+            &IID_IDirectSoundFXI3DL2Reverb, (void **)&unk);
+    todo_wine ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 1,
+            &IID_IDirectSoundFXI3DL2Reverb, (void **)&unk);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    if (hr == DS_OK)
+        IUnknown_Release(unk);
+
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8,
+            &GUID_DSFX_STANDARD_I3DL2REVERB, 0, &IID_IDirectSoundFXI3DL2Reverb, (void **)&unk);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    if (hr == DS_OK)
+        IUnknown_Release(unk);
+
+    if (echo)
+        IMediaObject_Release(echo);
+    if (reverb)
+        IMediaObject_Release(reverb);
+
+    got_Process = CreateEventA(NULL, TRUE, FALSE, NULL);
+
+    effects[0].guidDSFXClass = testdmo_clsid;
+    results[0] = 0xdeadbeef;
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 1, effects, results);
+    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(results[0] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[0]);
+    todo_wine ok(!memcmp(&testdmo_input_type, &wfx, sizeof(WAVEFORMATEX)), "Format blocks didn't match.\n");
+
+    ResetEvent(notify_params.hEventNotify);
+    hr = IDirectSoundBuffer8_Play(buffer8, 0, 0, 0);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(got_Discontinuity == 1, "Got %u calls to IMediaObject::Discontinuity().\n", got_Discontinuity);
+
+    todo_wine ok(!WaitForSingleObject(got_Process, 100), "Wait timed out.\n");
+
+    hr = IDirectSoundBuffer8_Stop(buffer8);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(got_Discontinuity == 1, "Got %u calls to IMediaObject::Discontinuity().\n", got_Discontinuity);
+    ok(!WaitForSingleObject(notify_params.hEventNotify, 1000), "Wait timed out.\n");
+
+    ResetEvent(notify_params.hEventNotify);
+    hr = IDirectSoundBuffer8_Play(buffer8, 0, 0, 0);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(got_Discontinuity == 2, "Got %u calls to IMediaObject::Discontinuity().\n", got_Discontinuity);
+
+    hr = IDirectSoundBuffer8_Stop(buffer8);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    ok(!WaitForSingleObject(notify_params.hEventNotify, 1000), "Wait timed out.\n");
+
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 0, NULL, NULL);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IMediaObject, (void **)&dmo);
+    todo_wine ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
+
+    CloseHandle(got_Process);
+    IDirectSoundBuffer8_Release(buffer8);
+    ref = IDirectSoundBuffer_Release(buffer);
+    ok(!ref, "Got outstanding refcount %u.\n", ref);
+
+    init_format(&wfx, WAVE_FORMAT_PCM, 11025, 16, 1);
+    hr = IDirectSound8_CreateSoundBuffer(dsound, &buffer_desc, &buffer, NULL);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    hr = IDirectSoundBuffer_QueryInterface(buffer, &IID_IDirectSoundBuffer8, (void **)&buffer8);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+
+    results[0] = 0xdeadbeef;
+    hr = IDirectSoundBuffer8_SetFX(buffer8, 1, effects, results);
+    ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    todo_wine ok(results[0] == DSFXR_UNKNOWN, "Got result %#x.\n", results[0]);
+
+    IDirectSoundNotify_Release(notify);
+    IDirectSoundBuffer8_Release(buffer8);
+    ref = IDirectSoundBuffer_Release(buffer);
+    ok(!ref, "Got outstanding refcount %u.\n", ref);
+
+    ref = IDirectSound8_Release(dsound);
+    ok(!ref, "Got outstanding refcount %u.\n", ref);
 }
 
 static void test_dsfx_interfaces(const char *test_prefix, IUnknown *dmo, REFGUID refguid)
@@ -1786,6 +2193,9 @@ static void test_effects_parameters(void)
 
 START_TEST(dsound8)
 {
+    DWORD cookie;
+    HRESULT hr;
+
     CoInitialize(NULL);
 
     test_COM();
@@ -1794,8 +2204,15 @@ START_TEST(dsound8)
     test_hw_buffers();
     test_first_device();
     test_primary_flags();
-    test_effects();
     test_effects_parameters();
 
+    hr = CoRegisterClassObject(&testdmo_clsid, (IUnknown *)&testdmo_cf,
+            CLSCTX_INPROC_SERVER, REGCLS_MULTIPLEUSE, &cookie);
+    ok(hr == S_OK, "Failed to register class, hr %#x.\n", hr);
+
+    test_effects();
+
+    CoRevokeClassObject(cookie);
+
     CoUninitialize();
 }
From f32498439750a802f00bc4d185bde2ce5b0105a9 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 23 Jul 2020 11:47:01 -0500
Subject: [PATCH] dsdmo/tests: Add tests for aggregation.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Andrew Eikum <aeikum@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 configure                    |   1 +
 configure.ac                 |   1 +
 dlls/dsdmo/tests/Makefile.in |   5 ++
 dlls/dsdmo/tests/dsdmo.c     | 162 +++++++++++++++++++++++++++++++++++
 4 files changed, 169 insertions(+)
 create mode 100644 dlls/dsdmo/tests/Makefile.in
 create mode 100644 dlls/dsdmo/tests/dsdmo.c

diff --git a/configure b/configure
index 677e19e26db..529b416472b 100755
--- a/configure
+++ b/configure
@@ -20648,6 +20648,7 @@ wine_fn_config_makefile dlls/dpvoice/tests enable_tests
 wine_fn_config_makefile dlls/dpwsockx enable_dpwsockx
 wine_fn_config_makefile dlls/drmclien enable_drmclien
 wine_fn_config_makefile dlls/dsdmo enable_dsdmo
+wine_fn_config_makefile dlls/dsdmo/tests enable_tests
 wine_fn_config_makefile dlls/dsound enable_dsound
 wine_fn_config_makefile dlls/dsound/tests enable_tests
 wine_fn_config_makefile dlls/dsquery enable_dsquery
diff --git a/configure.ac b/configure.ac
index e82ed889545..f2d0c9cd268 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3245,6 +3245,7 @@ WINE_CONFIG_MAKEFILE(dlls/dpvoice/tests)
 WINE_CONFIG_MAKEFILE(dlls/dpwsockx)
 WINE_CONFIG_MAKEFILE(dlls/drmclien)
 WINE_CONFIG_MAKEFILE(dlls/dsdmo)
+WINE_CONFIG_MAKEFILE(dlls/dsdmo/tests)
 WINE_CONFIG_MAKEFILE(dlls/dsound)
 WINE_CONFIG_MAKEFILE(dlls/dsound/tests)
 WINE_CONFIG_MAKEFILE(dlls/dsquery)
diff --git a/dlls/dsdmo/tests/Makefile.in b/dlls/dsdmo/tests/Makefile.in
new file mode 100644
index 00000000000..67378635f3c
--- /dev/null
+++ b/dlls/dsdmo/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL   = dsdmo.dll
+IMPORTS   = dmoguids uuid msdmo ole32
+
+C_SRCS = \
+	dsdmo.c
diff --git a/dlls/dsdmo/tests/dsdmo.c b/dlls/dsdmo/tests/dsdmo.c
new file mode 100644
index 00000000000..244747a6899
--- /dev/null
+++ b/dlls/dsdmo/tests/dsdmo.c
@@ -0,0 +1,162 @@
+/*
+ * Copyright 2020 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+#include "windef.h"
+#include "wingdi.h"
+#include "mmreg.h"
+#include "mmsystem.h"
+#include "dmo.h"
+#include "initguid.h"
+#include "dsound.h"
+#include "uuids.h"
+#include "wine/test.h"
+
+static const GUID test_iid = {0x33333333};
+static LONG outer_ref = 1;
+
+static ULONG get_refcount(void *iface)
+{
+    IUnknown *unknown = iface;
+    IUnknown_AddRef(unknown);
+    return IUnknown_Release(unknown);
+}
+
+static HRESULT WINAPI outer_QueryInterface(IUnknown *iface, REFIID iid, void **out)
+{
+    if (IsEqualGUID(iid, &IID_IUnknown)
+            || IsEqualGUID(iid, &IID_IMediaObject)
+            || IsEqualGUID(iid, &test_iid))
+    {
+        *out = (IUnknown *)0xdeadbeef;
+        return S_OK;
+    }
+    ok(0, "unexpected call %s\n", wine_dbgstr_guid(iid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI outer_AddRef(IUnknown *iface)
+{
+    return InterlockedIncrement(&outer_ref);
+}
+
+static ULONG WINAPI outer_Release(IUnknown *iface)
+{
+    return InterlockedDecrement(&outer_ref);
+}
+
+static const IUnknownVtbl outer_vtbl =
+{
+    outer_QueryInterface,
+    outer_AddRef,
+    outer_Release,
+};
+
+static IUnknown test_outer = {&outer_vtbl};
+
+static void test_aggregation(const GUID *clsid)
+{
+    IMediaObject *dmo, *dmo2;
+    IUnknown *unk, *unk2;
+    HRESULT hr;
+    ULONG ref;
+
+    dmo = (IMediaObject *)0xdeadbeef;
+    hr = CoCreateInstance(clsid, &test_outer, CLSCTX_INPROC_SERVER,
+            &IID_IMediaObject, (void **)&dmo);
+    todo_wine ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+    if (hr != E_NOINTERFACE)
+        return;
+    ok(!dmo, "Got interface %p.\n", dmo);
+
+    hr = CoCreateInstance(clsid, &test_outer, CLSCTX_INPROC_SERVER,
+            &IID_IUnknown, (void **)&unk);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+    ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
+    ref = get_refcount(unk);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+
+    ref = IUnknown_AddRef(unk);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+
+    ref = IUnknown_Release(unk);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+
+    hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
+    IUnknown_Release(unk2);
+
+    hr = IUnknown_QueryInterface(unk, &IID_IMediaObject, (void **)&dmo);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaObject_QueryInterface(dmo, &IID_IUnknown, (void **)&unk2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
+
+    hr = IMediaObject_QueryInterface(dmo, &IID_IMediaObject, (void **)&dmo2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(dmo2 == (IMediaObject *)0xdeadbeef, "Got unexpected IMediaObject %p.\n", dmo2);
+
+    hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+    ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
+
+    hr = IMediaObject_QueryInterface(dmo, &test_iid, (void **)&unk2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
+
+    IMediaObject_Release(dmo);
+    ref = IUnknown_Release(unk);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+}
+
+START_TEST(dsdmo)
+{
+    static const struct
+    {
+        const GUID *clsid;
+        const GUID *iid;
+    }
+    tests[] =
+    {
+        {&GUID_DSFX_STANDARD_CHORUS,        &IID_IDirectSoundFXChorus},
+        {&GUID_DSFX_STANDARD_COMPRESSOR,    &IID_IDirectSoundFXCompressor},
+        {&GUID_DSFX_STANDARD_DISTORTION,    &IID_IDirectSoundFXDistortion},
+        {&GUID_DSFX_STANDARD_ECHO,          &IID_IDirectSoundFXEcho},
+        {&GUID_DSFX_STANDARD_FLANGER,       &IID_IDirectSoundFXFlanger},
+        {&GUID_DSFX_STANDARD_GARGLE,        &IID_IDirectSoundFXGargle},
+        {&GUID_DSFX_STANDARD_I3DL2REVERB,   &IID_IDirectSoundFXI3DL2Reverb},
+        {&GUID_DSFX_STANDARD_PARAMEQ,       &IID_IDirectSoundFXParamEq},
+        {&GUID_DSFX_WAVES_REVERB,           &IID_IDirectSoundFXWavesReverb},
+    };
+    unsigned int i;
+
+    CoInitializeEx(NULL, COINIT_MULTITHREADED);
+
+    for (i = 0; i < ARRAY_SIZE(tests); ++i)
+    {
+        test_aggregation(tests[i].clsid);
+    }
+
+    CoUninitialize();
+}
From afd6cc72973b8dec92d88552a218af752a58cf30 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 23 Jul 2020 11:47:02 -0500
Subject: [PATCH] dsound/tests: Move effect parameter tests to dsdmo.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Andrew Eikum <aeikum@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/tests/dsdmo.c    | 247 ++++++++++++++++++++++++
 dlls/dsound/tests/dsound8.c | 364 ------------------------------------
 2 files changed, 247 insertions(+), 364 deletions(-)

diff --git a/dlls/dsdmo/tests/dsdmo.c b/dlls/dsdmo/tests/dsdmo.c
index 244747a6899..298ebadcf9f 100644
--- a/dlls/dsdmo/tests/dsdmo.c
+++ b/dlls/dsdmo/tests/dsdmo.c
@@ -1,4 +1,5 @@
 /*
+ * Copyright 2019 Alistair Leslie-Hughes
  * Copyright 2020 Zebediah Figura
  *
  * This library is free software; you can redistribute it and/or
@@ -130,6 +131,242 @@ static void test_aggregation(const GUID *clsid)
     ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
+static void test_interfaces(const GUID *clsid, const GUID *iid)
+{
+    IUnknown *unk, *unk2, *unk3;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, iid, (void **)&unk);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr != S_OK)
+        return;
+
+    hr = IUnknown_QueryInterface(unk, &IID_IMediaObject, (void **)&unk2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IUnknown_QueryInterface(unk2, iid, (void **)&unk3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(unk3 == unk, "Interface pointers didn't match.\n");
+    IUnknown_Release(unk3);
+    IUnknown_Release(unk2);
+
+    hr = IUnknown_QueryInterface(unk, &IID_IMediaObjectInPlace, (void **)&unk2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IUnknown_QueryInterface(unk2, iid, (void **)&unk3);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(unk3 == unk, "Interface pointers didn't match.\n");
+    IUnknown_Release(unk3);
+    IUnknown_Release(unk2);
+
+    ref = IUnknown_Release(unk);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_chorus_parameters(void)
+{
+    IDirectSoundFXChorus *chorus;
+    DSFXChorus params;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&GUID_DSFX_STANDARD_CHORUS, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IDirectSoundFXChorus, (void **)&chorus);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr != S_OK)
+        return;
+
+    hr = IDirectSoundFXChorus_GetAllParameters(chorus, &params);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(params.fWetDryMix == 50.0f, "Got wetness %.8e%%.\n", params.fWetDryMix);
+    ok(params.fDepth == 10.0f, "Got depth %.8e.\n", params.fDepth);
+    ok(params.fFeedback == 25.0f, "Got feedback %.8e.\n", params.fFeedback);
+    ok(params.fFrequency == 1.1f, "Got LFO frequency %.8e.\n", params.fFrequency);
+    ok(params.lWaveform == DSFXCHORUS_WAVE_SIN, "Got LFO waveform %d.\n", params.lWaveform);
+    ok(params.fDelay == 16.0f, "Got delay %.8e.\n", params.fDelay);
+    ok(params.lPhase == 3, "Got phase differential %d.\n", params.lPhase);
+
+    ref = IDirectSoundFXChorus_Release(chorus);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_compressor_parameters(void)
+{
+    IDirectSoundFXCompressor *compressor;
+    DSFXCompressor params;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&GUID_DSFX_STANDARD_COMPRESSOR, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IDirectSoundFXCompressor, (void **)&compressor);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr != S_OK)
+        return;
+
+    hr = IDirectSoundFXCompressor_GetAllParameters(compressor, &params);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(params.fGain == 0.0f, "Got gain %.8e dB.\n", params.fGain);
+    ok(params.fAttack == 10.0f, "Got attack time %.8e ms.\n", params.fAttack);
+    ok(params.fThreshold == -20.0f, "Got threshold %.8e dB.\n", params.fThreshold);
+    ok(params.fRatio == 3.0f, "Got ratio %.8e:1.\n", params.fRatio);
+    ok(params.fPredelay == 4.0f, "Got pre-delay %.8e ms.\n", params.fPredelay);
+
+    ref = IDirectSoundFXCompressor_Release(compressor);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_distortion_parameters(void)
+{
+    IDirectSoundFXDistortion *distortion;
+    DSFXDistortion params;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&GUID_DSFX_STANDARD_DISTORTION, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IDirectSoundFXDistortion, (void **)&distortion);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr != S_OK)
+        return;
+
+    hr = IDirectSoundFXDistortion_GetAllParameters(distortion, &params);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(params.fGain == -18.0f, "Got gain %.8e dB.\n", params.fGain);
+    ok(params.fEdge == 15.0f, "Got edge %.8e%%.\n", params.fEdge);
+    ok(params.fPostEQCenterFrequency == 2400.0f, "Got center frequency %.8e Hz.\n", params.fPostEQCenterFrequency);
+    ok(params.fPostEQBandwidth == 2400.0f, "Got band width %.8e Hz.\n", params.fPostEQBandwidth);
+    ok(params.fPreLowpassCutoff == 8000.0f, "Got pre-lowpass cutoff %.8e Hz.\n", params.fPreLowpassCutoff);
+
+    ref = IDirectSoundFXDistortion_Release(distortion);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_echo_parameters(void)
+{
+    IDirectSoundFXEcho *echo;
+    DSFXEcho params;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&GUID_DSFX_STANDARD_ECHO, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IDirectSoundFXEcho, (void **)&echo);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr != S_OK)
+        return;
+
+    hr = IDirectSoundFXEcho_GetAllParameters(echo, &params);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(params.fWetDryMix == 50.0f, "Got %.8e%% wetness.\n", params.fWetDryMix);
+    ok(params.fFeedback == 50.0f, "Got %.8e%% feedback.\n", params.fFeedback);
+    ok(params.fLeftDelay == 500.0f, "Got left delay %.8e ms.\n", params.fLeftDelay);
+    ok(params.fRightDelay == 500.0f, "Got right delay %.8e ms.\n", params.fRightDelay);
+    ok(!params.lPanDelay, "Got delay swap %d.\n", params.lPanDelay);
+
+    ref = IDirectSoundFXEcho_Release(echo);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_flanger_parameters(void)
+{
+    IDirectSoundFXFlanger *flanger;
+    DSFXFlanger params;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&GUID_DSFX_STANDARD_FLANGER, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IDirectSoundFXFlanger, (void **)&flanger);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr != S_OK)
+        return;
+
+    hr = IDirectSoundFXFlanger_GetAllParameters(flanger, &params);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(params.fWetDryMix == 50.0f, "Got %.8e%% wetness.\n", params.fWetDryMix);
+    ok(params.fDepth == 100.0f, "Got %.8e * 0.01%% depth.\n", params.fDepth);
+    ok(params.fFeedback == -50.0f, "Got %.8e%% feedback.\n", params.fFeedback);
+    ok(params.lWaveform == DSFXFLANGER_WAVE_SIN, "Got LFO waveform %d.\n", params.lWaveform);
+    ok(params.fDelay == 2.0f, "Got delay %.8e ms.\n", params.fDelay);
+    ok(params.lPhase == DSFXFLANGER_PHASE_ZERO, "Got phase differential %d.\n", params.lPhase);
+
+    ref = IDirectSoundFXFlanger_Release(flanger);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_gargle_parameters(void)
+{
+    IDirectSoundFXGargle *gargle;
+    DSFXGargle params;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&GUID_DSFX_STANDARD_GARGLE, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IDirectSoundFXGargle, (void **)&gargle);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr != S_OK)
+        return;
+
+    hr = IDirectSoundFXGargle_GetAllParameters(gargle, &params);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(params.dwRateHz == 20, "Got rate %u Hz.\n", params.dwRateHz);
+    ok(params.dwWaveShape == DSFXGARGLE_WAVE_TRIANGLE, "Got wave shape %u.\n", params.dwWaveShape);
+
+    ref = IDirectSoundFXGargle_Release(gargle);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_eq_parameters(void)
+{
+    IDirectSoundFXParamEq *eq;
+    DSFXParamEq params;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&GUID_DSFX_STANDARD_PARAMEQ, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IDirectSoundFXParamEq, (void **)&eq);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr != S_OK)
+        return;
+
+    hr = IDirectSoundFXParamEq_GetAllParameters(eq, &params);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(params.fCenter == 8000.0f, "Got center frequency %.8e Hz.\n", params.fCenter);
+    ok(params.fBandwidth == 12.0f, "Got band width %.8e semitones.\n", params.fBandwidth);
+    ok(params.fGain == 0.0f, "Got gain %.8e.\n", params.fGain);
+
+    ref = IDirectSoundFXParamEq_Release(eq);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_reverb_parameters(void)
+{
+    IDirectSoundFXI3DL2Reverb *reverb;
+    DSFXI3DL2Reverb params;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&GUID_DSFX_STANDARD_I3DL2REVERB, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IDirectSoundFXI3DL2Reverb, (void **)&reverb);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr != S_OK)
+        return;
+
+    hr = IDirectSoundFXI3DL2Reverb_GetAllParameters(reverb, &params);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(params.lRoom == -1000, "Got room attenuation %d mB.\n", params.lRoom);
+    ok(params.lRoomHF == -100, "Got room high-frequency attenuation %d mB.\n", params.lRoomHF);
+    ok(params.flRoomRolloffFactor == 0.0f, "Got room rolloff factor %.8e.\n", params.flRoomRolloffFactor);
+    ok(params.flDecayTime == 1.49f, "Got decay time %.8e s.\n", params.flDecayTime);
+    ok(params.flDecayHFRatio == 0.83f, "Got decay time ratio %.8e.\n", params.flDecayHFRatio);
+    ok(params.lReflections == -2602, "Got early reflection attenuation %d mB.\n", params.lReflections);
+    ok(params.flReflectionsDelay == 0.007f, "Got first reflection delay %.8e s.\n", params.flReflectionsDelay);
+    ok(params.lReverb == 200, "Got reverb attenuation %d mB.\n", params.lReverb);
+    ok(params.flReverbDelay == 0.011f, "Got reverb delay %.8e s.\n", params.flReverbDelay);
+    ok(params.flDiffusion == 100.0f, "Got diffusion %.8e%%.\n", params.flDiffusion);
+    ok(params.flDensity == 100.0f, "Got density %.8e%%.\n", params.flDensity);
+    ok(params.flHFReference == 5000.0f, "Got reference high frequency %.8e Hz.\n", params.flHFReference);
+
+    ref = IDirectSoundFXI3DL2Reverb_Release(reverb);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(dsdmo)
 {
     static const struct
@@ -156,7 +393,17 @@ START_TEST(dsdmo)
     for (i = 0; i < ARRAY_SIZE(tests); ++i)
     {
         test_aggregation(tests[i].clsid);
+        test_interfaces(tests[i].clsid, tests[i].iid);
     }
 
+    test_chorus_parameters();
+    test_compressor_parameters();
+    test_distortion_parameters();
+    test_echo_parameters();
+    test_flanger_parameters();
+    test_gargle_parameters();
+    test_reverb_parameters();
+    test_eq_parameters();
+
     CoUninitialize();
 }
diff --git a/dlls/dsound/tests/dsound8.c b/dlls/dsound/tests/dsound8.c
index 1294e952dbe..702cd4b2ba3 100644
--- a/dlls/dsound/tests/dsound8.c
+++ b/dlls/dsound/tests/dsound8.c
@@ -1828,369 +1828,6 @@ static void test_effects(void)
     ok(!ref, "Got outstanding refcount %u.\n", ref);
 }
 
-static void test_dsfx_interfaces(const char *test_prefix, IUnknown *dmo, REFGUID refguid)
-{
-    HRESULT rc;
-    IMediaObject *mediaobject;
-    IMediaObjectInPlace *inplace;
-    IUnknown *parent;
-
-    rc = IUnknown_QueryInterface(dmo, &IID_IMediaObject, (void**)&mediaobject);
-    ok(rc == DS_OK, "%s: Failed: %08x\n", test_prefix, rc);
-    if (rc == DS_OK)
-    {
-        rc = IMediaObject_QueryInterface(mediaobject, refguid, (void**)&parent);
-        ok(rc == S_OK, "%s: got: %08x\n", test_prefix, rc);
-        ok(dmo == parent, "%s: Objects not equal\n", test_prefix);
-        IUnknown_Release(parent);
-
-        IMediaObject_Release(mediaobject);
-    }
-
-    rc = IUnknown_QueryInterface(dmo, &IID_IMediaObjectInPlace, (void**)&inplace);
-    ok(rc == DS_OK, "%s: Failed: %08x\n", test_prefix, rc);
-    if (rc == DS_OK)
-    {
-        rc = IMediaObjectInPlace_QueryInterface(inplace, refguid, (void**)&parent);
-        ok(rc == S_OK, "%s: got: %08x\n", test_prefix, rc);
-        ok(dmo == parent, "%s: Objects not equal\n", test_prefix);
-        IUnknown_Release(parent);
-
-        IMediaObjectInPlace_Release(inplace);
-    }
-}
-
-static void test_echo_parameters(IDirectSoundBuffer8 *secondary8)
-{
-    HRESULT rc;
-    IDirectSoundFXEcho *echo;
-
-    rc = IDirectSoundBuffer8_GetObjectInPath(secondary8, &GUID_DSFX_STANDARD_ECHO, 0, &IID_IDirectSoundFXEcho, (void**)&echo);
-    ok(rc == DS_OK, "GetObjectInPath failed: %08x\n", rc);
-    if (rc == DS_OK)
-    {
-        DSFXEcho params;
-
-        rc = IDirectSoundFXEcho_GetAllParameters(echo, &params);
-        todo_wine ok(rc == DS_OK, "Failed: %08x\n", rc);
-        if (rc == DS_OK )
-        {
-            ok(params.fWetDryMix == 50.0f, "got %f\n", params.fWetDryMix);
-            ok(params.fFeedback == 50.0f, "got %f\n", params.fFeedback);
-            ok(params.fLeftDelay == 500.0f,"got %f\n", params.fLeftDelay);
-            ok(params.fRightDelay == 500.0f,"got %f\n", params.fRightDelay);
-            ok(params.lPanDelay == 0, "got %d\n", params.lPanDelay);
-        }
-
-        test_dsfx_interfaces("FXEcho", (IUnknown *)echo, &IID_IDirectSoundFXEcho);
-
-        IDirectSoundFXEcho_Release(echo);
-    }
-}
-
-static void test_gargle_parameters(IDirectSoundBuffer8 *secondary8)
-{
-    HRESULT rc;
-    IDirectSoundFXGargle *gargle;
-
-    rc = IDirectSoundBuffer8_GetObjectInPath(secondary8, &GUID_DSFX_STANDARD_GARGLE, 0, &IID_IDirectSoundFXGargle, (void**)&gargle);
-    todo_wine ok(rc == DS_OK, "GetObjectInPath failed: %08x\n", rc);
-    if (rc == DS_OK)
-    {
-        DSFXGargle params;
-
-        rc = IDirectSoundFXGargle_GetAllParameters(gargle, &params);
-        todo_wine ok(rc == DS_OK, "Failed: %08x\n", rc);
-        if (rc == DS_OK)
-        {
-            ok(params.dwRateHz == 20, "got %d\n", params.dwRateHz);
-            ok(params.dwWaveShape == DSFXGARGLE_WAVE_TRIANGLE, "got %d\n", params.dwWaveShape);
-        }
-
-        test_dsfx_interfaces("FXGargle", (IUnknown *)gargle, &IID_IDirectSoundFXGargle);
-
-        IDirectSoundFXGargle_Release(gargle);
-    }
-}
-
-static void test_chorus_parameters(IDirectSoundBuffer8 *secondary8)
-{
-    HRESULT rc;
-    IDirectSoundFXChorus *chorus;
-
-    rc = IDirectSoundBuffer8_GetObjectInPath(secondary8, &GUID_DSFX_STANDARD_CHORUS, 0, &IID_IDirectSoundFXChorus,(void**)&chorus);
-    todo_wine ok(rc == DS_OK, "GetObjectInPath failed: %08x\n", rc);
-    if (rc == DS_OK)
-    {
-        DSFXChorus params;
-
-        rc = IDirectSoundFXChorus_GetAllParameters(chorus, &params);
-        todo_wine ok(rc == DS_OK, "Failed: %08x\n", rc);
-        if (rc == DS_OK)
-        {
-            ok(params.fWetDryMix == 50.0f, "got %f\n", params.fWetDryMix);
-            ok(params.fDepth == 10.0f, "got %f\n", params.fDepth);
-            ok(params.fFeedback == 25.0f, "got %f\n", params.fFeedback);
-            ok(params.fFrequency == 1.1f, "got %f\n", params.fFrequency);
-            ok(params.lWaveform == DSFXCHORUS_WAVE_SIN, "got %d\n", params.lWaveform);
-            ok(params.fDelay == 16.0f, "got %f\n", params.fDelay);
-            ok(params.lPhase == 3, "got %d\n", params.lPhase);
-        }
-
-        test_dsfx_interfaces("FXChorus", (IUnknown *)chorus, &IID_IDirectSoundFXChorus);
-
-        IDirectSoundFXChorus_Release(chorus);
-    }
-}
-
-static void test_flanger_parameters(IDirectSoundBuffer8 *secondary8)
-{
-    HRESULT rc;
-    IDirectSoundFXFlanger *flanger;
-
-    rc = IDirectSoundBuffer8_GetObjectInPath(secondary8, &GUID_DSFX_STANDARD_FLANGER, 0, &IID_IDirectSoundFXFlanger,(void**)&flanger);
-    todo_wine ok(rc == DS_OK, "GetObjectInPath failed: %08x\n", rc);
-    if (rc == DS_OK)
-    {
-        DSFXFlanger params;
-
-        rc = IDirectSoundFXFlanger_GetAllParameters(flanger, &params);
-        todo_wine ok(rc == DS_OK, "Failed: %08x\n", rc);
-        if (rc == DS_OK)
-        {
-            ok(params.fWetDryMix == 50.0f, "got %f\n", params.fWetDryMix);
-            ok(params.fDepth == 100.0f, "got %f\n", params.fDepth);
-            ok(params.fFeedback == -50.0f, "got %f\n", params.fFeedback);
-            ok(params.fFrequency == 0.25f, "got %f\n", params.fFrequency);
-            ok(params.lWaveform == DSFXFLANGER_WAVE_SIN, "got %d\n", params.lWaveform);
-            ok(params.fDelay == 2.0f, "got %f\n", params.fDelay);
-            ok(params.lPhase == 2, "got %d\n", params.lPhase);
-        }
-
-        test_dsfx_interfaces("FXFlanger", (IUnknown *)flanger, &IID_IDirectSoundFXFlanger);
-
-        IDirectSoundFXFlanger_Release(flanger);
-    }
-}
-
-static void test_distortion_parameters(IDirectSoundBuffer8 *secondary8)
-{
-    HRESULT rc;
-    IDirectSoundFXDistortion *distortion;
-
-    rc = IDirectSoundBuffer8_GetObjectInPath(secondary8, &GUID_DSFX_STANDARD_DISTORTION, 0, &IID_IDirectSoundFXDistortion,(void**)&distortion);
-    todo_wine ok(rc == DS_OK, "GetObjectInPath failed: %08x\n", rc);
-    if (rc == DS_OK)
-    {
-        DSFXDistortion params;
-
-        rc = IDirectSoundFXDistortion_GetAllParameters(distortion, &params);
-        todo_wine ok(rc == DS_OK, "Failed: %08x\n", rc);
-        if (rc == DS_OK)
-        {
-            ok(params.fGain == -18.0f, "got %f\n", params.fGain);
-            ok(params.fEdge == 15.0f, "got %f\n", params.fEdge);
-            ok(params.fPostEQCenterFrequency == 2400.0f, "got %f\n", params.fPostEQCenterFrequency);
-            ok(params.fPostEQBandwidth == 2400.0f, "got %f\n", params.fPostEQBandwidth);
-            ok(params.fPreLowpassCutoff == 3675.0f, "got %f\n", params.fPreLowpassCutoff);
-        }
-
-        test_dsfx_interfaces("FXDistortion", (IUnknown *)distortion, &IID_IDirectSoundFXDistortion);
-
-        IDirectSoundFXDistortion_Release(distortion);
-    }
-}
-
-static void test_compressor_parameters(IDirectSoundBuffer8 *secondary8)
-{
-    HRESULT rc;
-    IDirectSoundFXCompressor *compressor;
-
-    rc = IDirectSoundBuffer8_GetObjectInPath(secondary8, &GUID_DSFX_STANDARD_COMPRESSOR, 0, &IID_IDirectSoundFXCompressor,(void**)&compressor);
-    todo_wine ok(rc == DS_OK, "GetObjectInPath failed: %08x\n", rc);
-    if (rc == DS_OK)
-    {
-        DSFXCompressor params;
-
-        rc = IDirectSoundFXCompressor_GetAllParameters(compressor, &params);
-        todo_wine ok(rc == DS_OK, "Failed: %08x\n", rc);
-        if (rc == DS_OK)
-        {
-            ok(params.fGain == 0.0f, "got %f\n", params.fGain);
-            ok(params.fAttack == 10.0f, "got %f\n", params.fAttack);
-            ok(params.fThreshold == -20.0f, "got %f\n", params.fThreshold);
-            ok(params.fRatio == 3.0f, "got %f\n", params.fRatio);
-            ok(params.fPredelay == 4.0f, "got %f\n", params.fPredelay);
-        }
-
-        test_dsfx_interfaces("FXCompressor", (IUnknown *)compressor, &IID_IDirectSoundFXCompressor);
-
-        IDirectSoundFXCompressor_Release(compressor);
-    }
-}
-
-static void test_parameq_parameters(IDirectSoundBuffer8 *secondary8)
-{
-    HRESULT rc;
-    IDirectSoundFXParamEq *parameq;
-
-    rc = IDirectSoundBuffer8_GetObjectInPath(secondary8, &GUID_DSFX_STANDARD_PARAMEQ, 0, &IID_IDirectSoundFXParamEq,(void**)&parameq);
-    todo_wine ok(rc == DS_OK, "GetObjectInPath failed: %08x\n", rc);
-    if (rc == DS_OK)
-    {
-        DSFXParamEq params;
-
-        rc = IDirectSoundFXParamEq_GetAllParameters(parameq, &params);
-        todo_wine ok(rc == DS_OK, "Failed: %08x\n", rc);
-        if (rc == DS_OK)
-        {
-            ok(params.fCenter == 3675.0f, "got %f\n", params.fCenter);
-            ok(params.fBandwidth == 12.0f, "got %f\n", params.fBandwidth);
-            ok(params.fGain == 0.0f, "got %f\n", params.fGain);
-        }
-
-        test_dsfx_interfaces("FXParamEq", (IUnknown *)parameq, &IID_IDirectSoundFXParamEq);
-
-        IDirectSoundFXParamEq_Release(parameq);
-    }
-}
-
-static void test_reverb_parameters(IDirectSoundBuffer8 *secondary8)
-{
-    HRESULT rc;
-    IDirectSoundFXI3DL2Reverb *reverb;
-
-    rc = IDirectSoundBuffer8_GetObjectInPath(secondary8, &GUID_DSFX_STANDARD_I3DL2REVERB, 0, &IID_IDirectSoundFXI3DL2Reverb, (void**)&reverb);
-    todo_wine ok(rc == DS_OK, "GetObjectInPath failed: %08x\n", rc);
-    if (rc == DS_OK)
-    {
-        DSFXI3DL2Reverb params;
-
-        rc = IDirectSoundFXI3DL2Reverb_GetAllParameters(reverb, &params);
-        todo_wine ok(rc == DS_OK, "Failed: %08x\n", rc);
-        if (rc == DS_OK)
-        {
-            ok(params.lRoom == -1000, "got %d\n", params.lRoom);
-            ok(params.flRoomRolloffFactor == 0.0f, "got %f\n", params.flRoomRolloffFactor);
-            ok(params.flDecayTime == 1.49f, "got %f\n", params.flDecayTime);
-            ok(params.flDecayHFRatio == 0.83f, "got %f\n", params.flDecayHFRatio);
-            ok(params.lReflections == -2602, "got %d\n", params.lReflections);
-            ok(params.lReverb == 200, "got %d\n", params.lReverb);
-            ok(params.flReverbDelay == 0.011f, "got %f\n", params.flReverbDelay);
-            ok(params.flDiffusion == 100.0f, "got %f\n", params.flDiffusion);
-            ok(params.flDensity == 100.0f, "got %f\n", params.flDensity);
-            ok(params.flHFReference == 5000.0f, "got %f\n", params.flHFReference);
-        }
-
-        test_dsfx_interfaces("FXI3DL2Reverb", (IUnknown *)reverb, &IID_IDirectSoundFXI3DL2Reverb);
-
-        IDirectSoundFXI3DL2Reverb_Release(reverb);
-    }
-}
-
-static void test_effects_parameters(void)
-{
-    HRESULT rc;
-    IDirectSound8 *dso;
-    IDirectSoundBuffer *primary, *secondary = NULL;
-    IDirectSoundBuffer8 *secondary8 = NULL;
-    DSBUFFERDESC bufdesc;
-    WAVEFORMATEX wfx;
-    DSEFFECTDESC effects[8];
-    DWORD resultcodes[8];
-
-    /* Create a DirectSound8 object */
-    rc = DirectSoundCreate8(NULL, &dso, NULL);
-    ok(rc == DS_OK || rc == DSERR_NODRIVER, "DirectSoundCreate8() failed: %08x\n", rc);
-    if (rc != DS_OK)
-        return;
-
-    rc = IDirectSound8_SetCooperativeLevel(dso, get_hwnd(), DSSCL_PRIORITY);
-    ok(rc == DS_OK, "IDirectSound8_SetCooperativeLevel() failed: %08x\n", rc);
-    if (rc != DS_OK)
-        goto cleanup;
-
-    primary = NULL;
-    ZeroMemory(&bufdesc, sizeof(bufdesc));
-    bufdesc.dwSize = sizeof(bufdesc);
-    bufdesc.dwFlags = DSBCAPS_PRIMARYBUFFER;
-    rc = IDirectSound8_CreateSoundBuffer(dso, &bufdesc, &primary, NULL);
-    ok((rc == DS_OK && primary != NULL), "Failed to create a primary buffer: %08x\n", rc);
-    if (rc != DS_OK)
-        goto cleanup;
-
-    init_format(&wfx, WAVE_FORMAT_PCM, 11025, 8, 1);
-    ZeroMemory(&bufdesc, sizeof(bufdesc));
-    bufdesc.dwSize = sizeof(bufdesc);
-    bufdesc.dwBufferBytes = align(wfx.nAvgBytesPerSec * BUFFER_LEN / 1000, wfx.nBlockAlign);
-    bufdesc.lpwfxFormat=&wfx;
-
-    ZeroMemory(effects, sizeof(effects));
-    effects[0].dwSize=sizeof(effects[0]);
-    effects[0].guidDSFXClass=GUID_DSFX_STANDARD_ECHO;
-    effects[1].dwSize=sizeof(effects[0]);
-    effects[1].guidDSFXClass=GUID_DSFX_STANDARD_GARGLE;
-    effects[2].dwSize=sizeof(effects[0]);
-    effects[2].guidDSFXClass=GUID_DSFX_STANDARD_CHORUS;
-    effects[3].dwSize=sizeof(effects[0]);
-    effects[3].guidDSFXClass=GUID_DSFX_STANDARD_FLANGER;
-    effects[4].dwSize=sizeof(effects[0]);
-    effects[4].guidDSFXClass=GUID_DSFX_STANDARD_DISTORTION;
-    effects[5].dwSize=sizeof(effects[0]);
-    effects[5].guidDSFXClass=GUID_DSFX_STANDARD_COMPRESSOR;
-    effects[6].dwSize=sizeof(effects[0]);
-    effects[6].guidDSFXClass=GUID_DSFX_STANDARD_PARAMEQ;
-    effects[7].dwSize=sizeof(effects[0]);
-    effects[7].guidDSFXClass=GUID_DSFX_STANDARD_I3DL2REVERB;
-
-    bufdesc.dwFlags = DSBCAPS_CTRLFX;
-    rc = IDirectSound8_CreateSoundBuffer(dso, &bufdesc, &secondary, NULL);
-    ok(rc == DS_OK && secondary != NULL, "Failed to create a secondary buffer: %08x\n",rc);
-    if (rc != DS_OK || !secondary)
-        goto cleanup;
-
-    rc = IDirectSoundBuffer_QueryInterface(secondary, &IID_IDirectSoundBuffer8, (void**)&secondary8);
-    ok(rc == DS_OK, "Failed: %08x\n", rc);
-    if (rc != DS_OK)
-        goto cleanup;
-
-    rc = IDirectSoundBuffer8_SetFX(secondary8, ARRAY_SIZE(effects), effects, resultcodes);
-    ok(rc == DS_OK || rc == REGDB_E_CLASSNOTREG || rc == DSERR_CONTROLUNAVAIL, "Failed: %08x\n", rc);
-    if (rc != DS_OK)
-        goto cleanup;
-
-    ok (resultcodes[0] == DSFXR_LOCSOFTWARE || resultcodes[0] == DSFXR_LOCHARDWARE, "Result: %08x\n", resultcodes[0]);
-    test_echo_parameters(secondary8);
-
-    ok (resultcodes[1] == DSFXR_LOCSOFTWARE || resultcodes[1] == DSFXR_LOCHARDWARE, "Result: %08x\n", resultcodes[1]);
-    test_gargle_parameters(secondary8);
-
-    ok (resultcodes[2] == DSFXR_LOCSOFTWARE || resultcodes[2] == DSFXR_LOCHARDWARE, "Result: %08x\n", resultcodes[2]);
-    test_chorus_parameters(secondary8);
-
-    ok (resultcodes[3] == DSFXR_LOCSOFTWARE || resultcodes[3] == DSFXR_LOCHARDWARE, "Result: %08x\n", resultcodes[3]);
-    test_flanger_parameters(secondary8);
-
-    ok (resultcodes[4] == DSFXR_LOCSOFTWARE || resultcodes[4] == DSFXR_LOCHARDWARE, "Result: %08x\n", resultcodes[4]);
-    test_distortion_parameters(secondary8);
-
-    ok (resultcodes[5] == DSFXR_LOCSOFTWARE || resultcodes[5] == DSFXR_LOCHARDWARE, "Result: %08x\n", resultcodes[5]);
-    test_compressor_parameters(secondary8);
-
-    ok (resultcodes[6] == DSFXR_LOCSOFTWARE || resultcodes[6] == DSFXR_LOCHARDWARE, "Result: %08x\n", resultcodes[6]);
-    test_parameq_parameters(secondary8);
-
-    ok (resultcodes[7] == DSFXR_LOCSOFTWARE || resultcodes[7] == DSFXR_LOCHARDWARE, "Result: %08x\n", resultcodes[7]);
-    test_reverb_parameters(secondary8);
-
-cleanup:
-    if (secondary8)
-        IDirectSoundBuffer8_Release(secondary8);
-    if (primary)
-        IDirectSoundBuffer_Release(primary);
-    IDirectSound8_Release(dso);
-}
-
 START_TEST(dsound8)
 {
     DWORD cookie;
@@ -2204,7 +1841,6 @@ START_TEST(dsound8)
     test_hw_buffers();
     test_first_device();
     test_primary_flags();
-    test_effects_parameters();
 
     hr = CoRegisterClassObject(&testdmo_clsid, (IUnknown *)&testdmo_cf,
             CLSCTX_INPROC_SERVER, REGCLS_MULTIPLEUSE, &cookie);
From 222b1b06739722a1df5bd86c99355e6e34241516 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 23 Jul 2020 11:47:03 -0500
Subject: [PATCH] dsdmo/tests: Add some tests for media types.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Andrew Eikum <aeikum@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/tests/dsdmo.c | 136 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 136 insertions(+)

diff --git a/dlls/dsdmo/tests/dsdmo.c b/dlls/dsdmo/tests/dsdmo.c
index 298ebadcf9f..b8f0932790b 100644
--- a/dlls/dsdmo/tests/dsdmo.c
+++ b/dlls/dsdmo/tests/dsdmo.c
@@ -162,6 +162,141 @@ static void test_interfaces(const GUID *clsid, const GUID *iid)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void build_pcm_format(WAVEFORMATEX *format, WORD tag, WORD depth, DWORD sample_rate, WORD channels)
+{
+    format->wFormatTag = tag;
+    format->wBitsPerSample = depth;
+    format->nChannels = channels;
+    format->nSamplesPerSec = sample_rate;
+    format->nBlockAlign = channels * depth / 8;
+    format->nAvgBytesPerSec = sample_rate * channels * depth / 8;
+    format->cbSize = 0;
+}
+
+static void test_media_types(const GUID *clsid)
+{
+    WAVEFORMATEX wfx;
+    DMO_MEDIA_TYPE mt =
+    {
+        .majortype = MEDIATYPE_Audio,
+        .subtype = MEDIASUBTYPE_PCM,
+        .formattype = FORMAT_WaveFormatEx,
+        .cbFormat = sizeof(wfx),
+        .pbFormat = (BYTE *)&wfx,
+    };
+    IMediaObject *dmo;
+    unsigned int i, j;
+    WORD channels;
+    HRESULT hr;
+    ULONG ref;
+
+    static const DWORD sample_rates[] = {8000, 11025, 22050, 44100, 48000, 96000};
+    static const struct
+    {
+        WORD format;
+        WORD depth;
+    }
+    depths[] =
+    {
+        {WAVE_FORMAT_PCM, 8},
+        {WAVE_FORMAT_PCM, 16},
+        {WAVE_FORMAT_IEEE_FLOAT, 32},
+    };
+
+    hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMediaObject, (void **)&dmo);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr != S_OK)
+        return;
+
+    build_pcm_format(&wfx, WAVE_FORMAT_PCM, 16, 44100, 2);
+
+    mt.majortype = MEDIATYPE_Video;
+    hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
+    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    mt.majortype = GUID_NULL;
+    hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
+    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    mt.majortype = MEDIATYPE_Audio;
+
+    mt.subtype = MEDIASUBTYPE_RGB8;
+    hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
+    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    mt.subtype = GUID_NULL;
+    hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
+    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    mt.subtype = MEDIASUBTYPE_IEEE_FLOAT;
+    hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    mt.subtype = MEDIASUBTYPE_PCM;
+
+    mt.formattype = FORMAT_VideoInfo;
+    hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
+    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    mt.formattype = FORMAT_None;
+    hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
+    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    mt.formattype = GUID_NULL;
+    hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
+    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    mt.formattype = FORMAT_WaveFormatEx;
+
+    for (i = 0; i < ARRAY_SIZE(sample_rates); ++i)
+    {
+        for (j = 0; j < ARRAY_SIZE(depths); ++j)
+        {
+            /* Waves reverberation is documented as not supporting 8-bit PCM. */
+            if (IsEqualGUID(clsid, &GUID_DSFX_WAVES_REVERB) && depths[j].depth == 8)
+                continue;
+
+            for (channels = 1; channels <= 2; ++channels)
+            {
+                build_pcm_format(&wfx, depths[j].format, depths[j].depth, sample_rates[i], channels);
+
+                hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
+                todo_wine ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                        hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
+
+                /* The output type must match the input type. */
+
+                build_pcm_format(&wfx, depths[j].format, depths[j].depth, sample_rates[i], 3 - channels);
+                hr = IMediaObject_SetOutputType(dmo, 0, &mt, 0);
+                todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                        hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
+
+                build_pcm_format(&wfx, depths[j].format, depths[j].depth, 2 * sample_rates[i], channels);
+                hr = IMediaObject_SetOutputType(dmo, 0, &mt, 0);
+                todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                        hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
+
+                build_pcm_format(&wfx, depths[j].format, 24 - depths[j].depth, sample_rates[i], channels);
+                hr = IMediaObject_SetOutputType(dmo, 0, &mt, 0);
+                todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                        hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
+
+                build_pcm_format(&wfx, depths[j].format, depths[j].depth, sample_rates[i], channels);
+                hr = IMediaObject_SetOutputType(dmo, 0, &mt, 0);
+                todo_wine ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                        hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
+
+                hr = IMediaObject_SetInputType(dmo, 0, NULL, DMO_SET_TYPEF_CLEAR);
+                todo_wine ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                        hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
+
+                hr = IMediaObject_SetOutputType(dmo, 0, NULL, DMO_SET_TYPEF_CLEAR);
+                todo_wine ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                        hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
+
+                hr = IMediaObject_SetInputType(dmo, 0, NULL, DMO_SET_TYPEF_CLEAR);
+                todo_wine ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                        hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
+            }
+        }
+    }
+
+    ref = IMediaObject_Release(dmo);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void test_chorus_parameters(void)
 {
     IDirectSoundFXChorus *chorus;
@@ -394,6 +529,7 @@ START_TEST(dsdmo)
     {
         test_aggregation(tests[i].clsid);
         test_interfaces(tests[i].clsid, tests[i].iid);
+        test_media_types(tests[i].clsid);
     }
 
     test_chorus_parameters();
From 2fea7e869c3d47d1c2ca910b9ee2a4bab68bb216 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 24 Jul 2020 19:20:20 -0500
Subject: [PATCH] dsdmo: Add a stub waves reverb effect.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/Makefile.in   |   4 +
 dlls/dsdmo/dsdmo.idl     |  27 +++
 dlls/dsdmo/main.c        | 429 +++++++++++++++++++++++++++++++++++++--
 dlls/dsdmo/tests/dsdmo.c |  42 ++--
 4 files changed, 462 insertions(+), 40 deletions(-)
 create mode 100644 dlls/dsdmo/dsdmo.idl

diff --git a/dlls/dsdmo/Makefile.in b/dlls/dsdmo/Makefile.in
index 99816ae0c08..3787415abd6 100644
--- a/dlls/dsdmo/Makefile.in
+++ b/dlls/dsdmo/Makefile.in
@@ -1,6 +1,10 @@
 MODULE    = dsdmo.dll
+IMPORTS   = dmoguids uuid
 
 EXTRADLLFLAGS = -mno-cygwin
 
 C_SRCS = \
 	main.c
+
+IDL_SRCS = \
+	dsdmo.idl
diff --git a/dlls/dsdmo/dsdmo.idl b/dlls/dsdmo/dsdmo.idl
new file mode 100644
index 00000000000..a967186af3f
--- /dev/null
+++ b/dlls/dsdmo/dsdmo.idl
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2020 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+[
+    threading(both),
+    progid("Microsoft.DirectSoundWavesReverbDMO.1"),
+    vi_progid("Microsoft.DirectSoundWavesReverbDMO"),
+    uuid(87fc0268-9a55-4360-95aa-004a1d9de26c)
+]
+coclass DirectSoundWavesReverbDMO {}
diff --git a/dlls/dsdmo/main.c b/dlls/dsdmo/main.c
index 788381b7a45..44915ca8566 100644
--- a/dlls/dsdmo/main.c
+++ b/dlls/dsdmo/main.c
@@ -15,9 +15,13 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-#define COBJMACROS
 
-#include "ole2.h"
+#define COBJMACROS
+#include "dmo.h"
+#include "mmreg.h"
+#include "mmsystem.h"
+#include "initguid.h"
+#include "dsound.h"
 #include "rpcproxy.h"
 
 #include "wine/debug.h"
@@ -26,19 +30,318 @@ WINE_DEFAULT_DEBUG_CHANNEL(dsdmo);
 
 static HINSTANCE dsdmo_instance;
 
-/******************************************************************
- *     DllMain
- */
-BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, void *reserved)
+struct effect
+{
+    IMediaObject IMediaObject_iface;
+    IUnknown IUnknown_inner;
+    IUnknown *outer_unk;
+    LONG refcount;
+
+    const struct effect_ops *ops;
+};
+
+struct effect_ops
+{
+    void *(*query_interface)(struct effect *effect, REFIID iid);
+    void (*destroy)(struct effect *effect);
+};
+
+static struct effect *impl_from_IUnknown(IUnknown *iface)
+{
+    return CONTAINING_RECORD(iface, struct effect, IUnknown_inner);
+}
+
+static HRESULT WINAPI effect_inner_QueryInterface(IUnknown *iface, REFIID iid, void **out)
+{
+    struct effect *effect = impl_from_IUnknown(iface);
+
+    TRACE("effect %p, iid %s, out %p.\n", effect, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown))
+        *out = iface;
+    else if (IsEqualGUID(iid, &IID_IMediaObject))
+        *out = &effect->IMediaObject_iface;
+    else if (!(*out = effect->ops->query_interface(effect, iid)))
+    {
+        WARN("%s not implemented; returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI effect_inner_AddRef(IUnknown *iface)
+{
+    struct effect *effect = impl_from_IUnknown(iface);
+    ULONG refcount = InterlockedIncrement(&effect->refcount);
+
+    TRACE("%p increasing refcount to %u.\n", effect, refcount);
+    return refcount;
+}
+
+static ULONG WINAPI effect_inner_Release(IUnknown *iface)
 {
-    TRACE("(%p %d %p)\n", inst, reason, reserved);
+    struct effect *effect = impl_from_IUnknown(iface);
+    ULONG refcount = InterlockedDecrement(&effect->refcount);
+
+    TRACE("%p decreasing refcount to %u.\n", effect, refcount);
+
+    if (!refcount)
+    {
+        effect->ops->destroy(effect);
+    }
+    return refcount;
+}
+
+static const IUnknownVtbl effect_inner_vtbl =
+{
+    effect_inner_QueryInterface,
+    effect_inner_AddRef,
+    effect_inner_Release,
+};
+
+static struct effect *impl_from_IMediaObject(IMediaObject *iface)
+{
+    return CONTAINING_RECORD(iface, struct effect, IMediaObject_iface);
+}
+
+static HRESULT WINAPI effect_QueryInterface(IMediaObject *iface, REFIID iid, void **out)
+{
+    struct effect *effect = impl_from_IMediaObject(iface);
+    return IUnknown_QueryInterface(effect->outer_unk, iid, out);
+}
+
+static ULONG WINAPI effect_AddRef(IMediaObject *iface)
+{
+    struct effect *effect = impl_from_IMediaObject(iface);
+    return IUnknown_AddRef(effect->outer_unk);
+}
+
+static ULONG WINAPI effect_Release(IMediaObject *iface)
+{
+    struct effect *effect = impl_from_IMediaObject(iface);
+    return IUnknown_Release(effect->outer_unk);
+}
+
+static HRESULT WINAPI effect_GetStreamCount(IMediaObject *iface, DWORD *input, DWORD *output)
+{
+    FIXME("iface %p, input %p, output %p, stub!\n", iface, input, output);
+    return E_NOTIMPL;
+}
 
+static HRESULT WINAPI effect_GetInputStreamInfo(IMediaObject *iface, DWORD index, DWORD *flags)
+{
+    FIXME("iface %p, index %u, flags %p, stub!\n", iface, index, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetOutputStreamInfo(IMediaObject *iface, DWORD index, DWORD *flags)
+{
+    FIXME("iface %p, index %u, flags %p, stub!\n", iface, index, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetInputType(IMediaObject *iface, DWORD index, DWORD type_index, DMO_MEDIA_TYPE *type)
+{
+    FIXME("iface %p, index %u, type_index %u, type %p, stub!\n", iface, index, type_index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetOutputType(IMediaObject *iface, DWORD index, DWORD type_index, DMO_MEDIA_TYPE *type)
+{
+    FIXME("iface %p, index %u, type_index %u, type %p, stub!\n", iface, index, type_index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_SetInputType(IMediaObject *iface, DWORD index, const DMO_MEDIA_TYPE *type, DWORD flags)
+{
+    FIXME("iface %p, index %u, type %p, flags %#x, stub!\n", iface, index, type, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_SetOutputType(IMediaObject *iface, DWORD index, const DMO_MEDIA_TYPE *type, DWORD flags)
+{
+    FIXME("iface %p, index %u, type %p, flags %#x, stub!\n", iface, index, type, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetInputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
+{
+    FIXME("iface %p, index %u, type %p, stub!\n", iface, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetOutputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
+{
+    FIXME("iface %p, index %u, type %p, stub!\n", iface, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetInputSizeInfo(IMediaObject *iface, DWORD index,
+        DWORD *size, DWORD *lookahead, DWORD *alignment)
+{
+    FIXME("iface %p, index %u, size %p, lookahead %p, alignment %p, stub!\n", iface, index, size, lookahead, alignment);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetOutputSizeInfo(IMediaObject *iface, DWORD index, DWORD *size, DWORD *alignment)
+{
+    FIXME("iface %p, index %u, size %p, alignment %p, stub!\n", iface, index, size, alignment);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME *latency)
+{
+    FIXME("iface %p, index %u, latency %p, stub!\n", iface, index, latency);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_SetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME latency)
+{
+    FIXME("iface %p, index %u, latency %s, stub!\n", iface, index, wine_dbgstr_longlong(latency));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_Flush(IMediaObject *iface)
+{
+    FIXME("iface %p, stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_Discontinuity(IMediaObject *iface, DWORD index)
+{
+    FIXME("iface %p, index %u, stub!\n", iface, index);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_AllocateStreamingResources(IMediaObject *iface)
+{
+    FIXME("iface %p, stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_FreeStreamingResources(IMediaObject *iface)
+{
+    FIXME("iface %p, stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetInputStatus(IMediaObject *iface, DWORD index, DWORD *flags)
+{
+    FIXME("iface %p, index %u, flags %p, stub!\n", iface, index, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_ProcessInput(IMediaObject *iface, DWORD index,
+    IMediaBuffer *buffer, DWORD flags, REFERENCE_TIME timestamp, REFERENCE_TIME timelength)
+{
+    FIXME("iface %p, index %u, buffer %p, flags %#x, timestamp %s, timelength %s, stub!\n",
+            iface, index, buffer, flags, wine_dbgstr_longlong(timestamp), wine_dbgstr_longlong(timelength));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_ProcessOutput(IMediaObject *iface, DWORD flags,
+        DWORD count, DMO_OUTPUT_DATA_BUFFER *buffers, DWORD *status)
+{
+    FIXME("iface %p, flags %#x, count %u, buffers %p, status %p, stub!\n", iface, flags, count, buffers, status);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_Lock(IMediaObject *iface, LONG lock)
+{
+    FIXME("iface %p, lock %d, stub!\n", iface, lock);
+    return E_NOTIMPL;
+}
+
+static const IMediaObjectVtbl effect_vtbl =
+{
+    effect_QueryInterface,
+    effect_AddRef,
+    effect_Release,
+    effect_GetStreamCount,
+    effect_GetInputStreamInfo,
+    effect_GetOutputStreamInfo,
+    effect_GetInputType,
+    effect_GetOutputType,
+    effect_SetInputType,
+    effect_SetOutputType,
+    effect_GetInputCurrentType,
+    effect_GetOutputCurrentType,
+    effect_GetInputSizeInfo,
+    effect_GetOutputSizeInfo,
+    effect_GetInputMaxLatency,
+    effect_SetInputMaxLatency,
+    effect_Flush,
+    effect_Discontinuity,
+    effect_AllocateStreamingResources,
+    effect_FreeStreamingResources,
+    effect_GetInputStatus,
+    effect_ProcessInput,
+    effect_ProcessOutput,
+    effect_Lock,
+};
+
+static void effect_init(struct effect *effect, IUnknown *outer, const struct effect_ops *ops)
+{
+    effect->outer_unk = outer ? outer : &effect->IUnknown_inner;
+    effect->refcount = 1;
+    effect->IUnknown_inner.lpVtbl = &effect_inner_vtbl;
+    effect->IMediaObject_iface.lpVtbl = &effect_vtbl;
+
+    effect->ops = ops;
+}
+
+struct waves_reverb
+{
+    struct effect effect;
+};
+
+static struct waves_reverb *impl_waves_reverb_from_effect(struct effect *iface)
+{
+    return CONTAINING_RECORD(iface, struct waves_reverb, effect);
+}
+
+static void *waves_reverb_query_interface(struct effect *iface, REFIID iid)
+{
+    return NULL;
+}
+
+static void waves_reverb_destroy(struct effect *iface)
+{
+    struct waves_reverb *effect = impl_waves_reverb_from_effect(iface);
+
+    free(effect);
+}
+
+static const struct effect_ops waves_reverb_ops =
+{
+    .destroy = waves_reverb_destroy,
+    .query_interface = waves_reverb_query_interface,
+};
+
+static HRESULT waves_reverb_create(IUnknown *outer, IUnknown **out)
+{
+    struct waves_reverb *object;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    effect_init(&object->effect, outer, &waves_reverb_ops);
+
+    TRACE("Created waves reverb effect %p.\n", object);
+    *out = &object->effect.IUnknown_inner;
+    return S_OK;
+}
+
+BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
+{
     switch(reason)
     {
     case DLL_WINE_PREATTACH:
         return FALSE;  /* prefer native version */
     case DLL_PROCESS_ATTACH:
-        dsdmo_instance = inst;
+        dsdmo_instance = instance;
         DisableThreadLibraryCalls(dsdmo_instance);
         break;
     }
@@ -46,35 +349,117 @@ BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, void *reserved)
     return TRUE;
 }
 
-/***********************************************************************
- *      DllGetClassObject
- */
-HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
+struct class_factory
 {
-    FIXME("%s %s %p\n", debugstr_guid(rclsid), debugstr_guid(riid), ppv);
+    IClassFactory IClassFactory_iface;
+    HRESULT (*create_instance)(IUnknown *outer, IUnknown **out);
+};
+
+static struct class_factory *impl_from_IClassFactory(IClassFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct class_factory, IClassFactory_iface);
+}
+
+static HRESULT WINAPI class_factory_QueryInterface(IClassFactory *iface, REFIID iid, void **out)
+{
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IClassFactory))
+    {
+        IClassFactory_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+    *out = NULL;
+    WARN("%s not implemented, returning E_NOINTERFACE\n", debugstr_guid(iid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI class_factory_AddRef(IClassFactory *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI class_factory_Release(IClassFactory *iface)
+{
+    return 1;
+}
+
+static HRESULT WINAPI class_factory_CreateInstance(IClassFactory *iface,
+        IUnknown *outer, REFIID iid, void **out)
+{
+    struct class_factory *factory = impl_from_IClassFactory(iface);
+    IUnknown *unk;
+    HRESULT hr;
+
+    TRACE("iface %p, outer %p, iid %s, out %p.\n", iface, outer, debugstr_guid(iid), out);
+
+    *out = NULL;
+
+    if (outer && !IsEqualGUID(iid, &IID_IUnknown))
+        return E_NOINTERFACE;
+
+    if (SUCCEEDED(hr = factory->create_instance(outer, &unk)))
+    {
+        hr = IUnknown_QueryInterface(unk, iid, out);
+        IUnknown_Release(unk);
+    }
+    return hr;
+}
+
+static HRESULT WINAPI class_factory_LockServer(IClassFactory *iface, BOOL lock)
+{
+    FIXME("lock %d, stub!\n", lock);
+    return S_OK;
+}
+
+static const IClassFactoryVtbl class_factory_vtbl =
+{
+    class_factory_QueryInterface,
+    class_factory_AddRef,
+    class_factory_Release,
+    class_factory_CreateInstance,
+    class_factory_LockServer,
+};
+
+static struct
+{
+    const GUID *clsid;
+    struct class_factory factory;
+}
+class_factories[] =
+{
+    {&GUID_DSFX_WAVES_REVERB,           {{&class_factory_vtbl}, waves_reverb_create}},
+};
+
+HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **out)
+{
+    unsigned int i;
+
+    TRACE("clsid %s, iid %s, out %p.\n", debugstr_guid(clsid), debugstr_guid(iid), out);
+
+    for (i = 0; i < ARRAY_SIZE(class_factories); ++i)
+    {
+        if (IsEqualGUID(clsid, class_factories[i].clsid))
+            return IClassFactory_QueryInterface(&class_factories[i].factory.IClassFactory_iface, iid, out);
+    }
+
+    FIXME("%s not available, returning CLASS_E_CLASSNOTAVAILABLE.\n", debugstr_guid(clsid));
     return CLASS_E_CLASSNOTAVAILABLE;
 }
 
-/***********************************************************************
- *      DllCanUnloadNow
- */
 HRESULT WINAPI DllCanUnloadNow(void)
 {
     return S_FALSE;
 }
 
-/***********************************************************************
- *      DllRegisterServer
- */
 HRESULT WINAPI DllRegisterServer(void)
 {
     TRACE("()\n");
     return __wine_register_resources(dsdmo_instance);
 }
 
-/***********************************************************************
- *      DllUnregisterServer
- */
 HRESULT WINAPI DllUnregisterServer(void)
 {
     TRACE("()\n");
diff --git a/dlls/dsdmo/tests/dsdmo.c b/dlls/dsdmo/tests/dsdmo.c
index b8f0932790b..f236c95d43c 100644
--- a/dlls/dsdmo/tests/dsdmo.c
+++ b/dlls/dsdmo/tests/dsdmo.c
@@ -80,9 +80,7 @@ static void test_aggregation(const GUID *clsid)
     dmo = (IMediaObject *)0xdeadbeef;
     hr = CoCreateInstance(clsid, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IMediaObject, (void **)&dmo);
-    todo_wine ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
-    if (hr != E_NOINTERFACE)
-        return;
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!dmo, "Got interface %p.\n", dmo);
 
     hr = CoCreateInstance(clsid, &test_outer, CLSCTX_INPROC_SERVER,
@@ -138,9 +136,7 @@ static void test_interfaces(const GUID *clsid, const GUID *iid)
     ULONG ref;
 
     hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, iid, (void **)&unk);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
-    if (hr != S_OK)
-        return;
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IUnknown_QueryInterface(unk, &IID_IMediaObject, (void **)&unk2);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -204,9 +200,7 @@ static void test_media_types(const GUID *clsid)
     };
 
     hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMediaObject, (void **)&dmo);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
-    if (hr != S_OK)
-        return;
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     build_pcm_format(&wfx, WAVE_FORMAT_PCM, 16, 44100, 2);
 
@@ -508,18 +502,19 @@ START_TEST(dsdmo)
     {
         const GUID *clsid;
         const GUID *iid;
+        BOOL todo;
     }
     tests[] =
     {
-        {&GUID_DSFX_STANDARD_CHORUS,        &IID_IDirectSoundFXChorus},
-        {&GUID_DSFX_STANDARD_COMPRESSOR,    &IID_IDirectSoundFXCompressor},
-        {&GUID_DSFX_STANDARD_DISTORTION,    &IID_IDirectSoundFXDistortion},
-        {&GUID_DSFX_STANDARD_ECHO,          &IID_IDirectSoundFXEcho},
-        {&GUID_DSFX_STANDARD_FLANGER,       &IID_IDirectSoundFXFlanger},
-        {&GUID_DSFX_STANDARD_GARGLE,        &IID_IDirectSoundFXGargle},
-        {&GUID_DSFX_STANDARD_I3DL2REVERB,   &IID_IDirectSoundFXI3DL2Reverb},
-        {&GUID_DSFX_STANDARD_PARAMEQ,       &IID_IDirectSoundFXParamEq},
-        {&GUID_DSFX_WAVES_REVERB,           &IID_IDirectSoundFXWavesReverb},
+        {&GUID_DSFX_STANDARD_CHORUS,        &IID_IDirectSoundFXChorus, TRUE},
+        {&GUID_DSFX_STANDARD_COMPRESSOR,    &IID_IDirectSoundFXCompressor, TRUE},
+        {&GUID_DSFX_STANDARD_DISTORTION,    &IID_IDirectSoundFXDistortion, TRUE},
+        {&GUID_DSFX_STANDARD_ECHO,          &IID_IDirectSoundFXEcho, TRUE},
+        {&GUID_DSFX_STANDARD_FLANGER,       &IID_IDirectSoundFXFlanger, TRUE},
+        {&GUID_DSFX_STANDARD_GARGLE,        &IID_IDirectSoundFXGargle, TRUE},
+        {&GUID_DSFX_STANDARD_I3DL2REVERB,   &IID_IDirectSoundFXI3DL2Reverb, TRUE},
+        {&GUID_DSFX_STANDARD_PARAMEQ,       &IID_IDirectSoundFXParamEq, TRUE},
+        {&GUID_DSFX_WAVES_REVERB,           &IID_IDirectSoundFXWavesReverb, TRUE},
     };
     unsigned int i;
 
@@ -527,6 +522,17 @@ START_TEST(dsdmo)
 
     for (i = 0; i < ARRAY_SIZE(tests); ++i)
     {
+        IUnknown *unk;
+        HRESULT hr;
+
+        hr = CoCreateInstance(tests[i].clsid, NULL, CLSCTX_INPROC_SERVER, tests[i].iid, (void **)&unk);
+        todo_wine_if(tests[i].todo) ok(hr == S_OK, "Failed to create %s, hr %#x.\n",
+                debugstr_guid(tests[i].clsid), hr);
+        if (hr == S_OK)
+            IUnknown_Release(unk);
+        else
+            continue;
+
         test_aggregation(tests[i].clsid);
         test_interfaces(tests[i].clsid, tests[i].iid);
         test_media_types(tests[i].clsid);
From 2b9cbfd6269078e92691e2eb0f53a684b8dbbbbf Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 24 Jul 2020 19:20:21 -0500
Subject: [PATCH] dsdmo: Stub IMediaObjectInPlace.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/main.c | 57 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 57 insertions(+)

diff --git a/dlls/dsdmo/main.c b/dlls/dsdmo/main.c
index 44915ca8566..f3be97177a5 100644
--- a/dlls/dsdmo/main.c
+++ b/dlls/dsdmo/main.c
@@ -33,6 +33,7 @@ static HINSTANCE dsdmo_instance;
 struct effect
 {
     IMediaObject IMediaObject_iface;
+    IMediaObjectInPlace IMediaObjectInPlace_iface;
     IUnknown IUnknown_inner;
     IUnknown *outer_unk;
     LONG refcount;
@@ -61,6 +62,8 @@ static HRESULT WINAPI effect_inner_QueryInterface(IUnknown *iface, REFIID iid, v
         *out = iface;
     else if (IsEqualGUID(iid, &IID_IMediaObject))
         *out = &effect->IMediaObject_iface;
+    else if (IsEqualGUID(iid, &IID_IMediaObjectInPlace))
+        *out = &effect->IMediaObjectInPlace_iface;
     else if (!(*out = effect->ops->query_interface(effect, iid)))
     {
         WARN("%s not implemented; returning E_NOINTERFACE.\n", debugstr_guid(iid));
@@ -282,12 +285,66 @@ static const IMediaObjectVtbl effect_vtbl =
     effect_Lock,
 };
 
+static struct effect *impl_from_IMediaObjectInPlace(IMediaObjectInPlace *iface)
+{
+    return CONTAINING_RECORD(iface, struct effect, IMediaObjectInPlace_iface);
+}
+
+static HRESULT WINAPI effect_inplace_QueryInterface(IMediaObjectInPlace *iface, REFIID iid, void **out)
+{
+    struct effect *effect = impl_from_IMediaObjectInPlace(iface);
+    return IUnknown_QueryInterface(effect->outer_unk, iid, out);
+}
+
+static ULONG WINAPI effect_inplace_AddRef(IMediaObjectInPlace *iface)
+{
+    struct effect *effect = impl_from_IMediaObjectInPlace(iface);
+    return IUnknown_AddRef(effect->outer_unk);
+}
+
+static ULONG WINAPI effect_inplace_Release(IMediaObjectInPlace *iface)
+{
+    struct effect *effect = impl_from_IMediaObjectInPlace(iface);
+    return IUnknown_Release(effect->outer_unk);
+}
+
+static HRESULT WINAPI effect_inplace_Process(IMediaObjectInPlace *iface, ULONG size,
+        BYTE *data, REFERENCE_TIME start, DWORD flags)
+{
+    FIXME("iface %p, size %u, data %p, start %s, flags %#x, stub!\n",
+            iface, size, data, wine_dbgstr_longlong(start), flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_inplace_Clone(IMediaObjectInPlace *iface, IMediaObjectInPlace **out)
+{
+    FIXME("iface %p, out %p, stub!\n", iface, out);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_inplace_GetLatency(IMediaObjectInPlace *iface, REFERENCE_TIME *latency)
+{
+    FIXME("iface %p, latency %p, stub!\n", iface, latency);
+    return E_NOTIMPL;
+}
+
+static const IMediaObjectInPlaceVtbl effect_inplace_vtbl =
+{
+    effect_inplace_QueryInterface,
+    effect_inplace_AddRef,
+    effect_inplace_Release,
+    effect_inplace_Process,
+    effect_inplace_Clone,
+    effect_inplace_GetLatency,
+};
+
 static void effect_init(struct effect *effect, IUnknown *outer, const struct effect_ops *ops)
 {
     effect->outer_unk = outer ? outer : &effect->IUnknown_inner;
     effect->refcount = 1;
     effect->IUnknown_inner.lpVtbl = &effect_inner_vtbl;
     effect->IMediaObject_iface.lpVtbl = &effect_vtbl;
+    effect->IMediaObjectInPlace_iface.lpVtbl = &effect_inplace_vtbl;
 
     effect->ops = ops;
 }
From 0cf9b5949e176572332e43596f05268896837660 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 24 Jul 2020 19:20:22 -0500
Subject: [PATCH] dsdmo: Stub IDirectSoundFXWavesReverb.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/main.c        | 56 ++++++++++++++++++++++++++++++++++++++++
 dlls/dsdmo/tests/dsdmo.c |  2 +-
 2 files changed, 57 insertions(+), 1 deletion(-)

diff --git a/dlls/dsdmo/main.c b/dlls/dsdmo/main.c
index f3be97177a5..cc06dfe6f5c 100644
--- a/dlls/dsdmo/main.c
+++ b/dlls/dsdmo/main.c
@@ -352,6 +352,57 @@ static void effect_init(struct effect *effect, IUnknown *outer, const struct eff
 struct waves_reverb
 {
     struct effect effect;
+    IDirectSoundFXWavesReverb IDirectSoundFXWavesReverb_iface;
+};
+
+static struct waves_reverb *impl_from_IDirectSoundFXWavesReverb(IDirectSoundFXWavesReverb *iface)
+{
+    return CONTAINING_RECORD(iface, struct waves_reverb, IDirectSoundFXWavesReverb_iface);
+}
+
+static HRESULT WINAPI waves_reverb_params_QueryInterface(IDirectSoundFXWavesReverb *iface, REFIID iid, void **out)
+{
+    struct waves_reverb *effect = impl_from_IDirectSoundFXWavesReverb(iface);
+    return IUnknown_QueryInterface(effect->effect.outer_unk, iid, out);
+}
+
+static ULONG WINAPI waves_reverb_params_AddRef(IDirectSoundFXWavesReverb *iface)
+{
+    struct waves_reverb *effect = impl_from_IDirectSoundFXWavesReverb(iface);
+    return IUnknown_AddRef(effect->effect.outer_unk);
+}
+
+static ULONG WINAPI waves_reverb_params_Release(IDirectSoundFXWavesReverb *iface)
+{
+    struct waves_reverb *effect = impl_from_IDirectSoundFXWavesReverb(iface);
+    return IUnknown_Release(effect->effect.outer_unk);
+}
+
+static HRESULT WINAPI waves_reverb_params_SetAllParameters(IDirectSoundFXWavesReverb *iface, const DSFXWavesReverb *params)
+{
+    struct waves_reverb *effect = impl_from_IDirectSoundFXWavesReverb(iface);
+
+    FIXME("effect %p, params %p, stub!\n", effect, params);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI waves_reverb_params_GetAllParameters(IDirectSoundFXWavesReverb *iface, DSFXWavesReverb *params)
+{
+    struct waves_reverb *effect = impl_from_IDirectSoundFXWavesReverb(iface);
+
+    FIXME("effect %p, params %p, stub!\n", effect, params);
+
+    return E_NOTIMPL;
+}
+
+static const IDirectSoundFXWavesReverbVtbl waves_reverb_params_vtbl =
+{
+    waves_reverb_params_QueryInterface,
+    waves_reverb_params_AddRef,
+    waves_reverb_params_Release,
+    waves_reverb_params_SetAllParameters,
+    waves_reverb_params_GetAllParameters,
 };
 
 static struct waves_reverb *impl_waves_reverb_from_effect(struct effect *iface)
@@ -361,6 +412,10 @@ static struct waves_reverb *impl_waves_reverb_from_effect(struct effect *iface)
 
 static void *waves_reverb_query_interface(struct effect *iface, REFIID iid)
 {
+    struct waves_reverb *effect = impl_waves_reverb_from_effect(iface);
+
+    if (IsEqualGUID(iid, &IID_IDirectSoundFXWavesReverb))
+        return &effect->IDirectSoundFXWavesReverb_iface;
     return NULL;
 }
 
@@ -385,6 +440,7 @@ static HRESULT waves_reverb_create(IUnknown *outer, IUnknown **out)
         return E_OUTOFMEMORY;
 
     effect_init(&object->effect, outer, &waves_reverb_ops);
+    object->IDirectSoundFXWavesReverb_iface.lpVtbl = &waves_reverb_params_vtbl;
 
     TRACE("Created waves reverb effect %p.\n", object);
     *out = &object->effect.IUnknown_inner;
diff --git a/dlls/dsdmo/tests/dsdmo.c b/dlls/dsdmo/tests/dsdmo.c
index f236c95d43c..cb6e698b6ec 100644
--- a/dlls/dsdmo/tests/dsdmo.c
+++ b/dlls/dsdmo/tests/dsdmo.c
@@ -514,7 +514,7 @@ START_TEST(dsdmo)
         {&GUID_DSFX_STANDARD_GARGLE,        &IID_IDirectSoundFXGargle, TRUE},
         {&GUID_DSFX_STANDARD_I3DL2REVERB,   &IID_IDirectSoundFXI3DL2Reverb, TRUE},
         {&GUID_DSFX_STANDARD_PARAMEQ,       &IID_IDirectSoundFXParamEq, TRUE},
-        {&GUID_DSFX_WAVES_REVERB,           &IID_IDirectSoundFXWavesReverb, TRUE},
+        {&GUID_DSFX_WAVES_REVERB,           &IID_IDirectSoundFXWavesReverb},
     };
     unsigned int i;
 
From f21d13e2bc9df80f6a6021ae0d2514469ece7354 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 24 Jul 2020 19:20:23 -0500
Subject: [PATCH] dsdmo: Implement IMediaObject::SetInputType().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/Makefile.in   |  2 +-
 dlls/dsdmo/main.c        | 68 ++++++++++++++++++++++++++++++++++++++--
 dlls/dsdmo/tests/dsdmo.c | 22 ++++++-------
 3 files changed, 78 insertions(+), 14 deletions(-)

diff --git a/dlls/dsdmo/Makefile.in b/dlls/dsdmo/Makefile.in
index 3787415abd6..d184b025ad0 100644
--- a/dlls/dsdmo/Makefile.in
+++ b/dlls/dsdmo/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = dsdmo.dll
-IMPORTS   = dmoguids uuid
+IMPORTS   = dmoguids strmiids uuid
 
 EXTRADLLFLAGS = -mno-cygwin
 
diff --git a/dlls/dsdmo/main.c b/dlls/dsdmo/main.c
index cc06dfe6f5c..9d4fbc5b785 100644
--- a/dlls/dsdmo/main.c
+++ b/dlls/dsdmo/main.c
@@ -20,6 +20,7 @@
 #include "dmo.h"
 #include "mmreg.h"
 #include "mmsystem.h"
+#include "uuids.h"
 #include "initguid.h"
 #include "dsound.h"
 #include "rpcproxy.h"
@@ -38,6 +39,9 @@ struct effect
     IUnknown *outer_unk;
     LONG refcount;
 
+    CRITICAL_SECTION cs;
+    WAVEFORMATEX format;
+
     const struct effect_ops *ops;
 };
 
@@ -92,6 +96,8 @@ static ULONG WINAPI effect_inner_Release(IUnknown *iface)
 
     if (!refcount)
     {
+        effect->cs.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection(&effect->cs);
         effect->ops->destroy(effect);
     }
     return refcount;
@@ -159,8 +165,63 @@ static HRESULT WINAPI effect_GetOutputType(IMediaObject *iface, DWORD index, DWO
 
 static HRESULT WINAPI effect_SetInputType(IMediaObject *iface, DWORD index, const DMO_MEDIA_TYPE *type, DWORD flags)
 {
-    FIXME("iface %p, index %u, type %p, flags %#x, stub!\n", iface, index, type, flags);
-    return E_NOTIMPL;
+    struct effect *effect = impl_from_IMediaObject(iface);
+    const WAVEFORMATEX *format;
+
+    TRACE("iface %p, index %u, type %p, flags %#x.\n", iface, index, type, flags);
+
+    if (flags & DMO_SET_TYPEF_CLEAR)
+    {
+        EnterCriticalSection(&effect->cs);
+        memset(&effect->format, 0, sizeof(effect->format));
+        LeaveCriticalSection(&effect->cs);
+        return S_OK;
+    }
+
+    if (!IsEqualGUID(&type->majortype, &MEDIATYPE_Audio))
+        return DMO_E_TYPE_NOT_ACCEPTED;
+
+    if (!IsEqualGUID(&type->subtype, &MEDIASUBTYPE_PCM)
+            && !IsEqualGUID(&type->subtype, &MEDIASUBTYPE_IEEE_FLOAT))
+        return DMO_E_TYPE_NOT_ACCEPTED;
+
+    if (!IsEqualGUID(&type->formattype, &FORMAT_WaveFormatEx))
+        return DMO_E_TYPE_NOT_ACCEPTED;
+
+    format = (const WAVEFORMATEX *)type->pbFormat;
+    if (format->wFormatTag == WAVE_FORMAT_PCM)
+    {
+        if (format->wBitsPerSample != 8 && format->wBitsPerSample != 16)
+        {
+            WARN("Rejecting %u-bit integer PCM.\n", format->wBitsPerSample);
+            return DMO_E_TYPE_NOT_ACCEPTED;
+        }
+    }
+    else if (format->wFormatTag == WAVE_FORMAT_IEEE_FLOAT)
+    {
+        if (format->wBitsPerSample != 32)
+        {
+            WARN("Rejecting %u-bit float PCM.\n", format->wBitsPerSample);
+            return DMO_E_TYPE_NOT_ACCEPTED;
+        }
+    }
+    else
+    {
+        WARN("Rejecting tag %#x.\n", format->wFormatTag);
+        return DMO_E_TYPE_NOT_ACCEPTED;
+    }
+
+    if (format->nChannels != 1 && format->nChannels != 2)
+    {
+        WARN("Rejecting %u channels.\n", format->nChannels);
+        return DMO_E_TYPE_NOT_ACCEPTED;
+    }
+
+    EnterCriticalSection(&effect->cs);
+    effect->format = *format;
+    LeaveCriticalSection(&effect->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI effect_SetOutputType(IMediaObject *iface, DWORD index, const DMO_MEDIA_TYPE *type, DWORD flags)
@@ -346,6 +407,9 @@ static void effect_init(struct effect *effect, IUnknown *outer, const struct eff
     effect->IMediaObject_iface.lpVtbl = &effect_vtbl;
     effect->IMediaObjectInPlace_iface.lpVtbl = &effect_inplace_vtbl;
 
+    InitializeCriticalSection(&effect->cs);
+    effect->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": effect.cs");
+
     effect->ops = ops;
 }
 
diff --git a/dlls/dsdmo/tests/dsdmo.c b/dlls/dsdmo/tests/dsdmo.c
index cb6e698b6ec..d1cf2575de2 100644
--- a/dlls/dsdmo/tests/dsdmo.c
+++ b/dlls/dsdmo/tests/dsdmo.c
@@ -206,32 +206,32 @@ static void test_media_types(const GUID *clsid)
 
     mt.majortype = MEDIATYPE_Video;
     hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
-    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     mt.majortype = GUID_NULL;
     hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
-    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     mt.majortype = MEDIATYPE_Audio;
 
     mt.subtype = MEDIASUBTYPE_RGB8;
     hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
-    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     mt.subtype = GUID_NULL;
     hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
-    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     mt.subtype = MEDIASUBTYPE_IEEE_FLOAT;
     hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     mt.subtype = MEDIASUBTYPE_PCM;
 
     mt.formattype = FORMAT_VideoInfo;
     hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
-    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     mt.formattype = FORMAT_None;
     hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
-    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     mt.formattype = GUID_NULL;
     hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
-    todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+    ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     mt.formattype = FORMAT_WaveFormatEx;
 
     for (i = 0; i < ARRAY_SIZE(sample_rates); ++i)
@@ -247,7 +247,7 @@ static void test_media_types(const GUID *clsid)
                 build_pcm_format(&wfx, depths[j].format, depths[j].depth, sample_rates[i], channels);
 
                 hr = IMediaObject_SetInputType(dmo, 0, &mt, 0);
-                todo_wine ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
                         hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
 
                 /* The output type must match the input type. */
@@ -273,7 +273,7 @@ static void test_media_types(const GUID *clsid)
                         hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
 
                 hr = IMediaObject_SetInputType(dmo, 0, NULL, DMO_SET_TYPEF_CLEAR);
-                todo_wine ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
                         hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
 
                 hr = IMediaObject_SetOutputType(dmo, 0, NULL, DMO_SET_TYPEF_CLEAR);
@@ -281,7 +281,7 @@ static void test_media_types(const GUID *clsid)
                         hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
 
                 hr = IMediaObject_SetInputType(dmo, 0, NULL, DMO_SET_TYPEF_CLEAR);
-                todo_wine ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
                         hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
             }
         }
From ffdc68d517ccd28f0277b7bdb45f21aa1135d80b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 24 Jul 2020 19:20:24 -0500
Subject: [PATCH] dsdmo: Implement IMediaObject::SetOutputType().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/main.c        | 25 +++++++++++++++++++++++--
 dlls/dsdmo/tests/dsdmo.c | 10 +++++-----
 2 files changed, 28 insertions(+), 7 deletions(-)

diff --git a/dlls/dsdmo/main.c b/dlls/dsdmo/main.c
index 9d4fbc5b785..1e992fe5419 100644
--- a/dlls/dsdmo/main.c
+++ b/dlls/dsdmo/main.c
@@ -226,8 +226,29 @@ static HRESULT WINAPI effect_SetInputType(IMediaObject *iface, DWORD index, cons
 
 static HRESULT WINAPI effect_SetOutputType(IMediaObject *iface, DWORD index, const DMO_MEDIA_TYPE *type, DWORD flags)
 {
-    FIXME("iface %p, index %u, type %p, flags %#x, stub!\n", iface, index, type, flags);
-    return E_NOTIMPL;
+    struct effect *effect = impl_from_IMediaObject(iface);
+    HRESULT hr;
+
+    TRACE("iface %p, index %u, type %p, flags %#x.\n", iface, index, type, flags);
+
+    if (flags & DMO_SET_TYPEF_CLEAR)
+        return S_OK;
+
+    if (!IsEqualGUID(&type->majortype, &MEDIATYPE_Audio))
+        return DMO_E_TYPE_NOT_ACCEPTED;
+
+    if (!IsEqualGUID(&type->subtype, &MEDIASUBTYPE_PCM)
+            && !IsEqualGUID(&type->subtype, &MEDIASUBTYPE_IEEE_FLOAT))
+        return DMO_E_TYPE_NOT_ACCEPTED;
+
+    if (!IsEqualGUID(&type->formattype, &FORMAT_WaveFormatEx))
+        return DMO_E_TYPE_NOT_ACCEPTED;
+
+    EnterCriticalSection(&effect->cs);
+    hr = memcmp(type->pbFormat, &effect->format, sizeof(WAVEFORMATEX)) ? DMO_E_TYPE_NOT_ACCEPTED : S_OK;
+    LeaveCriticalSection(&effect->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI effect_GetInputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
diff --git a/dlls/dsdmo/tests/dsdmo.c b/dlls/dsdmo/tests/dsdmo.c
index d1cf2575de2..9026728f6c6 100644
--- a/dlls/dsdmo/tests/dsdmo.c
+++ b/dlls/dsdmo/tests/dsdmo.c
@@ -254,22 +254,22 @@ static void test_media_types(const GUID *clsid)
 
                 build_pcm_format(&wfx, depths[j].format, depths[j].depth, sample_rates[i], 3 - channels);
                 hr = IMediaObject_SetOutputType(dmo, 0, &mt, 0);
-                todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
                         hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
 
                 build_pcm_format(&wfx, depths[j].format, depths[j].depth, 2 * sample_rates[i], channels);
                 hr = IMediaObject_SetOutputType(dmo, 0, &mt, 0);
-                todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
                         hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
 
                 build_pcm_format(&wfx, depths[j].format, 24 - depths[j].depth, sample_rates[i], channels);
                 hr = IMediaObject_SetOutputType(dmo, 0, &mt, 0);
-                todo_wine ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
                         hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
 
                 build_pcm_format(&wfx, depths[j].format, depths[j].depth, sample_rates[i], channels);
                 hr = IMediaObject_SetOutputType(dmo, 0, &mt, 0);
-                todo_wine ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
                         hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
 
                 hr = IMediaObject_SetInputType(dmo, 0, NULL, DMO_SET_TYPEF_CLEAR);
@@ -277,7 +277,7 @@ static void test_media_types(const GUID *clsid)
                         hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
 
                 hr = IMediaObject_SetOutputType(dmo, 0, NULL, DMO_SET_TYPEF_CLEAR);
-                todo_wine ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
+                ok(hr == S_OK, "Got hr %#x for %u Hz, %u channels, format %#x, depth %u.\n",
                         hr, sample_rates[i], channels, depths[j].format, depths[j].depth);
 
                 hr = IMediaObject_SetInputType(dmo, 0, NULL, DMO_SET_TYPEF_CLEAR);
From eb6709dab41e7b2efe528a47e80c2d01f98d7384 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 27 Jul 2020 20:26:00 -0500
Subject: [PATCH] dsdmo: Add a stub I3DL2 reverb effect.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/dsdmo.idl |  8 ++++++++
 dlls/dsdmo/main.c    | 43 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 51 insertions(+)

diff --git a/dlls/dsdmo/dsdmo.idl b/dlls/dsdmo/dsdmo.idl
index a967186af3f..e5735b42f73 100644
--- a/dlls/dsdmo/dsdmo.idl
+++ b/dlls/dsdmo/dsdmo.idl
@@ -18,6 +18,14 @@
 
 #pragma makedep register
 
+[
+    threading(both),
+    progid("Microsoft.DirectSoundI3DL2ReverbDMO.1"),
+    vi_progid("Microsoft.DirectSoundI3DL2ReverbDMO"),
+    uuid(ef985e71-d5c7-42d4-ba4d-2d073e2e96f4)
+]
+coclass DirectSoundI3DL2ReverbDMO {}
+
 [
     threading(both),
     progid("Microsoft.DirectSoundWavesReverbDMO.1"),
diff --git a/dlls/dsdmo/main.c b/dlls/dsdmo/main.c
index 1e992fe5419..f42d29f58ba 100644
--- a/dlls/dsdmo/main.c
+++ b/dlls/dsdmo/main.c
@@ -434,6 +434,48 @@ static void effect_init(struct effect *effect, IUnknown *outer, const struct eff
     effect->ops = ops;
 }
 
+struct reverb
+{
+    struct effect effect;
+};
+
+static struct reverb *impl_reverb_from_effect(struct effect *iface)
+{
+    return CONTAINING_RECORD(iface, struct reverb, effect);
+}
+
+static void *reverb_query_interface(struct effect *iface, REFIID iid)
+{
+    return NULL;
+}
+
+static void reverb_destroy(struct effect *iface)
+{
+    struct reverb *effect = impl_reverb_from_effect(iface);
+
+    free(effect);
+}
+
+static const struct effect_ops reverb_ops =
+{
+    .destroy = reverb_destroy,
+    .query_interface = reverb_query_interface,
+};
+
+static HRESULT reverb_create(IUnknown *outer, IUnknown **out)
+{
+    struct reverb *object;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    effect_init(&object->effect, outer, &reverb_ops);
+
+    TRACE("Created I3DL2 reverb effect %p.\n", object);
+    *out = &object->effect.IUnknown_inner;
+    return S_OK;
+}
+
 struct waves_reverb
 {
     struct effect effect;
@@ -628,6 +670,7 @@ static struct
 }
 class_factories[] =
 {
+    {&GUID_DSFX_STANDARD_I3DL2REVERB,   {{&class_factory_vtbl}, reverb_create}},
     {&GUID_DSFX_WAVES_REVERB,           {{&class_factory_vtbl}, waves_reverb_create}},
 };
 
From 9faa7af99a1e3cb2acf49e607974f57400664ee2 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 27 Jul 2020 20:26:01 -0500
Subject: [PATCH] dsdmo: Stub IDirectSoundFXI3DL2Reverb.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/main.c        | 96 ++++++++++++++++++++++++++++++++++++++++
 dlls/dsdmo/tests/dsdmo.c | 35 ++++++++-------
 2 files changed, 114 insertions(+), 17 deletions(-)

diff --git a/dlls/dsdmo/main.c b/dlls/dsdmo/main.c
index f42d29f58ba..8efef855b29 100644
--- a/dlls/dsdmo/main.c
+++ b/dlls/dsdmo/main.c
@@ -437,6 +437,97 @@ static void effect_init(struct effect *effect, IUnknown *outer, const struct eff
 struct reverb
 {
     struct effect effect;
+    IDirectSoundFXI3DL2Reverb IDirectSoundFXI3DL2Reverb_iface;
+};
+
+static struct reverb *impl_from_IDirectSoundFXI3DL2Reverb(IDirectSoundFXI3DL2Reverb *iface)
+{
+    return CONTAINING_RECORD(iface, struct reverb, IDirectSoundFXI3DL2Reverb_iface);
+}
+
+static HRESULT WINAPI reverb_params_QueryInterface(IDirectSoundFXI3DL2Reverb *iface, REFIID iid, void **out)
+{
+    struct reverb *effect = impl_from_IDirectSoundFXI3DL2Reverb(iface);
+    return IUnknown_QueryInterface(effect->effect.outer_unk, iid, out);
+}
+
+static ULONG WINAPI reverb_params_AddRef(IDirectSoundFXI3DL2Reverb *iface)
+{
+    struct reverb *effect = impl_from_IDirectSoundFXI3DL2Reverb(iface);
+    return IUnknown_AddRef(effect->effect.outer_unk);
+}
+
+static ULONG WINAPI reverb_params_Release(IDirectSoundFXI3DL2Reverb *iface)
+{
+    struct reverb *effect = impl_from_IDirectSoundFXI3DL2Reverb(iface);
+    return IUnknown_Release(effect->effect.outer_unk);
+}
+
+static HRESULT WINAPI reverb_params_SetAllParameters(IDirectSoundFXI3DL2Reverb *iface, const DSFXI3DL2Reverb *params)
+{
+    struct reverb *effect = impl_from_IDirectSoundFXI3DL2Reverb(iface);
+
+    FIXME("effect %p, params %p, stub!\n", effect, params);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI reverb_params_GetAllParameters(IDirectSoundFXI3DL2Reverb *iface, DSFXI3DL2Reverb *params)
+{
+    struct reverb *effect = impl_from_IDirectSoundFXI3DL2Reverb(iface);
+
+    FIXME("effect %p, params %p, stub!\n", effect, params);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI reverb_params_SetPreset(IDirectSoundFXI3DL2Reverb *iface, DWORD preset)
+{
+    struct reverb *effect = impl_from_IDirectSoundFXI3DL2Reverb(iface);
+
+    FIXME("effect %p, preset %u, stub!\n", effect, preset);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI reverb_params_GetPreset(IDirectSoundFXI3DL2Reverb *iface, DWORD *preset)
+{
+    struct reverb *effect = impl_from_IDirectSoundFXI3DL2Reverb(iface);
+
+    FIXME("effect %p, preset %p, stub!\n", effect, preset);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI reverb_params_SetQuality(IDirectSoundFXI3DL2Reverb *iface, LONG quality)
+{
+    struct reverb *effect = impl_from_IDirectSoundFXI3DL2Reverb(iface);
+
+    FIXME("effect %p, quality %u, stub!\n", effect, quality);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI reverb_params_GetQuality(IDirectSoundFXI3DL2Reverb *iface, LONG *quality)
+{
+    struct reverb *effect = impl_from_IDirectSoundFXI3DL2Reverb(iface);
+
+    FIXME("effect %p, quality %p, stub!\n", effect, quality);
+
+    return E_NOTIMPL;
+}
+
+static const IDirectSoundFXI3DL2ReverbVtbl reverb_params_vtbl =
+{
+    reverb_params_QueryInterface,
+    reverb_params_AddRef,
+    reverb_params_Release,
+    reverb_params_SetAllParameters,
+    reverb_params_GetAllParameters,
+    reverb_params_SetPreset,
+    reverb_params_GetPreset,
+    reverb_params_SetQuality,
+    reverb_params_GetQuality,
 };
 
 static struct reverb *impl_reverb_from_effect(struct effect *iface)
@@ -446,6 +537,10 @@ static struct reverb *impl_reverb_from_effect(struct effect *iface)
 
 static void *reverb_query_interface(struct effect *iface, REFIID iid)
 {
+    struct reverb *effect = impl_reverb_from_effect(iface);
+
+    if (IsEqualGUID(iid, &IID_IDirectSoundFXI3DL2Reverb))
+        return &effect->IDirectSoundFXI3DL2Reverb_iface;
     return NULL;
 }
 
@@ -470,6 +565,7 @@ static HRESULT reverb_create(IUnknown *outer, IUnknown **out)
         return E_OUTOFMEMORY;
 
     effect_init(&object->effect, outer, &reverb_ops);
+    object->IDirectSoundFXI3DL2Reverb_iface.lpVtbl = &reverb_params_vtbl;
 
     TRACE("Created I3DL2 reverb effect %p.\n", object);
     *out = &object->effect.IUnknown_inner;
diff --git a/dlls/dsdmo/tests/dsdmo.c b/dlls/dsdmo/tests/dsdmo.c
index 9026728f6c6..f949d02e882 100644
--- a/dlls/dsdmo/tests/dsdmo.c
+++ b/dlls/dsdmo/tests/dsdmo.c
@@ -473,24 +473,25 @@ static void test_reverb_parameters(void)
 
     hr = CoCreateInstance(&GUID_DSFX_STANDARD_I3DL2REVERB, NULL, CLSCTX_INPROC_SERVER,
             &IID_IDirectSoundFXI3DL2Reverb, (void **)&reverb);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
-    if (hr != S_OK)
-        return;
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IDirectSoundFXI3DL2Reverb_GetAllParameters(reverb, &params);
-    ok(hr == S_OK, "Got hr %#x.\n", hr);
-    ok(params.lRoom == -1000, "Got room attenuation %d mB.\n", params.lRoom);
-    ok(params.lRoomHF == -100, "Got room high-frequency attenuation %d mB.\n", params.lRoomHF);
-    ok(params.flRoomRolloffFactor == 0.0f, "Got room rolloff factor %.8e.\n", params.flRoomRolloffFactor);
-    ok(params.flDecayTime == 1.49f, "Got decay time %.8e s.\n", params.flDecayTime);
-    ok(params.flDecayHFRatio == 0.83f, "Got decay time ratio %.8e.\n", params.flDecayHFRatio);
-    ok(params.lReflections == -2602, "Got early reflection attenuation %d mB.\n", params.lReflections);
-    ok(params.flReflectionsDelay == 0.007f, "Got first reflection delay %.8e s.\n", params.flReflectionsDelay);
-    ok(params.lReverb == 200, "Got reverb attenuation %d mB.\n", params.lReverb);
-    ok(params.flReverbDelay == 0.011f, "Got reverb delay %.8e s.\n", params.flReverbDelay);
-    ok(params.flDiffusion == 100.0f, "Got diffusion %.8e%%.\n", params.flDiffusion);
-    ok(params.flDensity == 100.0f, "Got density %.8e%%.\n", params.flDensity);
-    ok(params.flHFReference == 5000.0f, "Got reference high frequency %.8e Hz.\n", params.flHFReference);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr == S_OK)
+    {
+        ok(params.lRoom == -1000, "Got room attenuation %d mB.\n", params.lRoom);
+        ok(params.lRoomHF == -100, "Got room high-frequency attenuation %d mB.\n", params.lRoomHF);
+        ok(params.flRoomRolloffFactor == 0.0f, "Got room rolloff factor %.8e.\n", params.flRoomRolloffFactor);
+        ok(params.flDecayTime == 1.49f, "Got decay time %.8e s.\n", params.flDecayTime);
+        ok(params.flDecayHFRatio == 0.83f, "Got decay time ratio %.8e.\n", params.flDecayHFRatio);
+        ok(params.lReflections == -2602, "Got early reflection attenuation %d mB.\n", params.lReflections);
+        ok(params.flReflectionsDelay == 0.007f, "Got first reflection delay %.8e s.\n", params.flReflectionsDelay);
+        ok(params.lReverb == 200, "Got reverb attenuation %d mB.\n", params.lReverb);
+        ok(params.flReverbDelay == 0.011f, "Got reverb delay %.8e s.\n", params.flReverbDelay);
+        ok(params.flDiffusion == 100.0f, "Got diffusion %.8e%%.\n", params.flDiffusion);
+        ok(params.flDensity == 100.0f, "Got density %.8e%%.\n", params.flDensity);
+        ok(params.flHFReference == 5000.0f, "Got reference high frequency %.8e Hz.\n", params.flHFReference);
+    }
 
     ref = IDirectSoundFXI3DL2Reverb_Release(reverb);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
@@ -512,7 +513,7 @@ START_TEST(dsdmo)
         {&GUID_DSFX_STANDARD_ECHO,          &IID_IDirectSoundFXEcho, TRUE},
         {&GUID_DSFX_STANDARD_FLANGER,       &IID_IDirectSoundFXFlanger, TRUE},
         {&GUID_DSFX_STANDARD_GARGLE,        &IID_IDirectSoundFXGargle, TRUE},
-        {&GUID_DSFX_STANDARD_I3DL2REVERB,   &IID_IDirectSoundFXI3DL2Reverb, TRUE},
+        {&GUID_DSFX_STANDARD_I3DL2REVERB,   &IID_IDirectSoundFXI3DL2Reverb},
         {&GUID_DSFX_STANDARD_PARAMEQ,       &IID_IDirectSoundFXParamEq, TRUE},
         {&GUID_DSFX_WAVES_REVERB,           &IID_IDirectSoundFXWavesReverb},
     };
From baddd55817c4d8560aa86dea4c06d6bd4e00e129 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 27 Jul 2020 20:26:02 -0500
Subject: [PATCH] dsdmo: Implement IDirectSoundFXI3DL2Reverb parameters
 methods.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/main.c        | 28 +++++++++++++++++++++----
 dlls/dsdmo/tests/dsdmo.c | 44 +++++++++++++++++++++++++---------------
 2 files changed, 52 insertions(+), 20 deletions(-)

diff --git a/dlls/dsdmo/main.c b/dlls/dsdmo/main.c
index 8efef855b29..5755c6f1444 100644
--- a/dlls/dsdmo/main.c
+++ b/dlls/dsdmo/main.c
@@ -438,6 +438,7 @@ struct reverb
 {
     struct effect effect;
     IDirectSoundFXI3DL2Reverb IDirectSoundFXI3DL2Reverb_iface;
+    DSFXI3DL2Reverb params;
 };
 
 static struct reverb *impl_from_IDirectSoundFXI3DL2Reverb(IDirectSoundFXI3DL2Reverb *iface)
@@ -467,18 +468,24 @@ static HRESULT WINAPI reverb_params_SetAllParameters(IDirectSoundFXI3DL2Reverb *
 {
     struct reverb *effect = impl_from_IDirectSoundFXI3DL2Reverb(iface);
 
-    FIXME("effect %p, params %p, stub!\n", effect, params);
+    TRACE("effect %p, params %p.\n", effect, params);
 
-    return E_NOTIMPL;
+    EnterCriticalSection(&effect->effect.cs);
+    effect->params = *params;
+    LeaveCriticalSection(&effect->effect.cs);
+    return S_OK;
 }
 
 static HRESULT WINAPI reverb_params_GetAllParameters(IDirectSoundFXI3DL2Reverb *iface, DSFXI3DL2Reverb *params)
 {
     struct reverb *effect = impl_from_IDirectSoundFXI3DL2Reverb(iface);
 
-    FIXME("effect %p, params %p, stub!\n", effect, params);
+    TRACE("effect %p, params %p.\n", effect, params);
 
-    return E_NOTIMPL;
+    EnterCriticalSection(&effect->effect.cs);
+    *params = effect->params;
+    LeaveCriticalSection(&effect->effect.cs);
+    return S_OK;
 }
 
 static HRESULT WINAPI reverb_params_SetPreset(IDirectSoundFXI3DL2Reverb *iface, DWORD preset)
@@ -567,6 +574,19 @@ static HRESULT reverb_create(IUnknown *outer, IUnknown **out)
     effect_init(&object->effect, outer, &reverb_ops);
     object->IDirectSoundFXI3DL2Reverb_iface.lpVtbl = &reverb_params_vtbl;
 
+    object->params.lRoom                = DSFX_I3DL2REVERB_ROOM_DEFAULT;
+    object->params.lRoomHF              = DSFX_I3DL2REVERB_ROOMHF_DEFAULT;
+    object->params.flRoomRolloffFactor  = DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_DEFAULT;
+    object->params.flDecayTime          = DSFX_I3DL2REVERB_DECAYTIME_DEFAULT;
+    object->params.flDecayHFRatio       = DSFX_I3DL2REVERB_DECAYHFRATIO_DEFAULT;
+    object->params.lReflections         = DSFX_I3DL2REVERB_REFLECTIONS_DEFAULT;
+    object->params.flReflectionsDelay   = DSFX_I3DL2REVERB_REFLECTIONSDELAY_DEFAULT;
+    object->params.lReverb              = DSFX_I3DL2REVERB_REVERB_DEFAULT;
+    object->params.flReverbDelay        = DSFX_I3DL2REVERB_REVERBDELAY_DEFAULT;
+    object->params.flDiffusion          = DSFX_I3DL2REVERB_DIFFUSION_DEFAULT;
+    object->params.flDensity            = DSFX_I3DL2REVERB_DENSITY_DEFAULT;
+    object->params.flHFReference        = DSFX_I3DL2REVERB_HFREFERENCE_DEFAULT;
+
     TRACE("Created I3DL2 reverb effect %p.\n", object);
     *out = &object->effect.IUnknown_inner;
     return S_OK;
diff --git a/dlls/dsdmo/tests/dsdmo.c b/dlls/dsdmo/tests/dsdmo.c
index f949d02e882..349e300f02e 100644
--- a/dlls/dsdmo/tests/dsdmo.c
+++ b/dlls/dsdmo/tests/dsdmo.c
@@ -476,22 +476,34 @@ static void test_reverb_parameters(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IDirectSoundFXI3DL2Reverb_GetAllParameters(reverb, &params);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
-    if (hr == S_OK)
-    {
-        ok(params.lRoom == -1000, "Got room attenuation %d mB.\n", params.lRoom);
-        ok(params.lRoomHF == -100, "Got room high-frequency attenuation %d mB.\n", params.lRoomHF);
-        ok(params.flRoomRolloffFactor == 0.0f, "Got room rolloff factor %.8e.\n", params.flRoomRolloffFactor);
-        ok(params.flDecayTime == 1.49f, "Got decay time %.8e s.\n", params.flDecayTime);
-        ok(params.flDecayHFRatio == 0.83f, "Got decay time ratio %.8e.\n", params.flDecayHFRatio);
-        ok(params.lReflections == -2602, "Got early reflection attenuation %d mB.\n", params.lReflections);
-        ok(params.flReflectionsDelay == 0.007f, "Got first reflection delay %.8e s.\n", params.flReflectionsDelay);
-        ok(params.lReverb == 200, "Got reverb attenuation %d mB.\n", params.lReverb);
-        ok(params.flReverbDelay == 0.011f, "Got reverb delay %.8e s.\n", params.flReverbDelay);
-        ok(params.flDiffusion == 100.0f, "Got diffusion %.8e%%.\n", params.flDiffusion);
-        ok(params.flDensity == 100.0f, "Got density %.8e%%.\n", params.flDensity);
-        ok(params.flHFReference == 5000.0f, "Got reference high frequency %.8e Hz.\n", params.flHFReference);
-    }
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(params.lRoom == -1000, "Got room attenuation %d mB.\n", params.lRoom);
+    ok(params.lRoomHF == -100, "Got room high-frequency attenuation %d mB.\n", params.lRoomHF);
+    ok(params.flRoomRolloffFactor == 0.0f, "Got room rolloff factor %.8e.\n", params.flRoomRolloffFactor);
+    ok(params.flDecayTime == 1.49f, "Got decay time %.8e s.\n", params.flDecayTime);
+    ok(params.flDecayHFRatio == 0.83f, "Got decay time ratio %.8e.\n", params.flDecayHFRatio);
+    ok(params.lReflections == -2602, "Got early reflection attenuation %d mB.\n", params.lReflections);
+    ok(params.flReflectionsDelay == 0.007f, "Got first reflection delay %.8e s.\n", params.flReflectionsDelay);
+    ok(params.lReverb == 200, "Got reverb attenuation %d mB.\n", params.lReverb);
+    ok(params.flReverbDelay == 0.011f, "Got reverb delay %.8e s.\n", params.flReverbDelay);
+    ok(params.flDiffusion == 100.0f, "Got diffusion %.8e%%.\n", params.flDiffusion);
+    ok(params.flDensity == 100.0f, "Got density %.8e%%.\n", params.flDensity);
+    ok(params.flHFReference == 5000.0f, "Got reference high frequency %.8e Hz.\n", params.flHFReference);
+
+    params.lRoom = -10001;
+    hr = IDirectSoundFXI3DL2Reverb_SetAllParameters(reverb, &params);
+    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
+    params.lRoom = 1;
+    hr = IDirectSoundFXI3DL2Reverb_SetAllParameters(reverb, &params);
+    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
+    params.lRoom = -900;
+    hr = IDirectSoundFXI3DL2Reverb_SetAllParameters(reverb, &params);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    memset(&params, 0xcc, sizeof(params));
+    hr = IDirectSoundFXI3DL2Reverb_GetAllParameters(reverb, &params);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(params.lRoom == -900, "Got room attenuation %d mB.\n", params.lRoom);
 
     ref = IDirectSoundFXI3DL2Reverb_Release(reverb);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
From ac528a492b719f6a8759d919710ca733f5acf167 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 27 Jul 2020 20:26:03 -0500
Subject: [PATCH] dsdmo: Add a stub equalizer effect.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/dsdmo.idl        |  8 +++++
 dlls/dsdmo/main.c           | 43 ++++++++++++++++++++++
 dlls/dsound/tests/dsound8.c | 71 +++++++++++++++----------------------
 3 files changed, 80 insertions(+), 42 deletions(-)

diff --git a/dlls/dsdmo/dsdmo.idl b/dlls/dsdmo/dsdmo.idl
index e5735b42f73..7f172084828 100644
--- a/dlls/dsdmo/dsdmo.idl
+++ b/dlls/dsdmo/dsdmo.idl
@@ -26,6 +26,14 @@
 ]
 coclass DirectSoundI3DL2ReverbDMO {}
 
+[
+    threading(both),
+    progid("Microsoft.DirectSoundParamEqDMO.1"),
+    vi_progid("Microsoft.DirectSoundParamEqDMO"),
+    uuid(120ced89-3bf4-4173-a132-3cb406cf3231)
+]
+coclass DirectSoundParamEqDMO {}
+
 [
     threading(both),
     progid("Microsoft.DirectSoundWavesReverbDMO.1"),
diff --git a/dlls/dsdmo/main.c b/dlls/dsdmo/main.c
index 5755c6f1444..482b8202db2 100644
--- a/dlls/dsdmo/main.c
+++ b/dlls/dsdmo/main.c
@@ -434,6 +434,48 @@ static void effect_init(struct effect *effect, IUnknown *outer, const struct eff
     effect->ops = ops;
 }
 
+struct eq
+{
+    struct effect effect;
+};
+
+static struct eq *impl_eq_from_effect(struct effect *iface)
+{
+    return CONTAINING_RECORD(iface, struct eq, effect);
+}
+
+static void *eq_query_interface(struct effect *iface, REFIID iid)
+{
+    return NULL;
+}
+
+static void eq_destroy(struct effect *iface)
+{
+    struct eq *effect = impl_eq_from_effect(iface);
+
+    free(effect);
+}
+
+static const struct effect_ops eq_ops =
+{
+    .destroy = eq_destroy,
+    .query_interface = eq_query_interface,
+};
+
+static HRESULT eq_create(IUnknown *outer, IUnknown **out)
+{
+    struct eq *object;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    effect_init(&object->effect, outer, &eq_ops);
+
+    TRACE("Created equalizer effect %p.\n", object);
+    *out = &object->effect.IUnknown_inner;
+    return S_OK;
+}
+
 struct reverb
 {
     struct effect effect;
@@ -787,6 +829,7 @@ static struct
 class_factories[] =
 {
     {&GUID_DSFX_STANDARD_I3DL2REVERB,   {{&class_factory_vtbl}, reverb_create}},
+    {&GUID_DSFX_STANDARD_PARAMEQ,       {{&class_factory_vtbl}, eq_create}},
     {&GUID_DSFX_WAVES_REVERB,           {{&class_factory_vtbl}, waves_reverb_create}},
 };
 
diff --git a/dlls/dsound/tests/dsound8.c b/dlls/dsound/tests/dsound8.c
index 702cd4b2ba3..05dfabbd253 100644
--- a/dlls/dsound/tests/dsound8.c
+++ b/dlls/dsound/tests/dsound8.c
@@ -1617,8 +1617,8 @@ static void test_effects(void)
 
     results[0] = 0xdeadbeef;
     hr = IDirectSoundBuffer8_SetFX(buffer8, 1, effects, results);
-    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(results[0] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[0]);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    ok(results[0] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[0]);
 
     hr = IDirectSoundBuffer8_Lock(buffer8, 0, 0, &ptr1, &size1, &ptr2, &size2, DSBLOCK_ENTIREBUFFER);
     ok(hr == DS_OK, "Got hr %#x.\n", hr);
@@ -1648,38 +1648,33 @@ static void test_effects(void)
     effects[0].guidDSFXClass = GUID_DSFX_STANDARD_PARAMEQ;
     results[0] = 0xdeadbeef;
     hr = IDirectSoundBuffer8_SetFX(buffer8, 1, effects, results);
-    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(results[0] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[0]);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    ok(results[0] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[0]);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IMediaObject, NULL);
-    todo_wine ok(hr == DSERR_INVALIDPARAM, "Got hr %#x.\n", hr);
+    ok(hr == DSERR_INVALIDPARAM, "Got hr %#x.\n", hr);
 
     dmo = (IMediaObject *)0xdeadbeef;
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &GUID_NULL, (void **)&dmo);
-    todo_wine ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
-    todo_wine ok(!dmo, "Got object %p.\n", dmo);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+    ok(!dmo, "Got object %p.\n", dmo);
 
     dmo = (IMediaObject *)0xdeadbeef;
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_NULL, 0, &IID_IMediaObject, (void **)&dmo);
-    todo_wine ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
+    ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
     ok(dmo == (IMediaObject *)0xdeadbeef, "Got object %p.\n", dmo);
 
     dmo = NULL;
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IMediaObject, (void **)&dmo);
-    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    if (hr == DS_OK)
-    {
-        ok(!!dmo, "Expected a non-NULL object.\n");
-        IMediaObject_Release(dmo);
-    }
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    ok(!!dmo, "Expected a non-NULL object.\n");
+    IMediaObject_Release(dmo);
 
     dmo = NULL;
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_DSFX_STANDARD_PARAMEQ, 0, &IID_IMediaObject, (void **)&dmo);
-    if (hr == DS_OK)
-    {
-        ok(!!dmo, "Expected a non-NULL object.\n");
-        IMediaObject_Release(dmo);
-    }
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    ok(!!dmo, "Expected a non-NULL object.\n");
+    IMediaObject_Release(dmo);
 
     dmo = (IMediaObject *)0xdeadbeef;
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 1, &IID_IMediaObject, (void **)&dmo);
@@ -1691,7 +1686,7 @@ static void test_effects(void)
     results[0] = results[1] = 0xdeadbeef;
     hr = IDirectSoundBuffer8_SetFX(buffer8, 2, effects, results);
     ok(hr == REGDB_E_CLASSNOTREG, "Got hr %#x.\n", hr);
-    todo_wine ok(results[0] == DSFXR_PRESENT, "Got result %#x.\n", results[0]);
+    ok(results[0] == DSFXR_PRESENT, "Got result %#x.\n", results[0]);
     ok(results[1] == DSFXR_UNKNOWN, "Got result %#x.\n", results[1]);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IMediaObject, (void **)&dmo);
@@ -1701,14 +1696,13 @@ static void test_effects(void)
     effects[1].guidDSFXClass = GUID_DSFX_STANDARD_I3DL2REVERB;
     results[0] = results[1] = 0xdeadbeef;
     hr = IDirectSoundBuffer8_SetFX(buffer8, 2, effects, results);
-    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(results[0] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[0]);
-    todo_wine ok(results[1] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[1]);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    ok(results[0] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[0]);
+    ok(results[1] == DSFXR_LOCSOFTWARE, "Got result %#x.\n", results[1]);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_DSFX_STANDARD_PARAMEQ, 0, &IID_IMediaObject, (void **)&dmo);
-    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    if (hr == DS_OK)
-        echo = dmo;
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    echo = dmo;
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8,
             &GUID_DSFX_STANDARD_I3DL2REVERB, 0, &IID_IMediaObject, (void **)&dmo);
     todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
@@ -1716,20 +1710,14 @@ static void test_effects(void)
         reverb = dmo;
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IMediaObject, (void **)&dmo);
-    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    if (hr == DS_OK)
-    {
-        ok(dmo == echo, "Expected %p, got %p.\n", echo, dmo);
-        IMediaObject_Release(dmo);
-    }
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    ok(dmo == echo, "Expected %p, got %p.\n", echo, dmo);
+    IMediaObject_Release(dmo);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 1, &IID_IMediaObject, (void **)&dmo);
-    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    if (hr == DS_OK)
-    {
-        ok(dmo == reverb, "Expected %p, got %p.\n", reverb, dmo);
-        IMediaObject_Release(dmo);
-    }
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(dmo == reverb, "Expected %p, got %p.\n", reverb, dmo);
+    IMediaObject_Release(dmo);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8,
             &GUID_DSFX_STANDARD_I3DL2REVERB, 1, &IID_IMediaObject, (void **)&dmo);
@@ -1748,13 +1736,12 @@ static void test_effects(void)
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0,
             &IID_IDirectSoundFXI3DL2Reverb, (void **)&unk);
-    todo_wine ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 1,
             &IID_IDirectSoundFXI3DL2Reverb, (void **)&unk);
-    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    if (hr == DS_OK)
-        IUnknown_Release(unk);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    IUnknown_Release(unk);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8,
             &GUID_DSFX_STANDARD_I3DL2REVERB, 0, &IID_IDirectSoundFXI3DL2Reverb, (void **)&unk);
From 861cfee25db57d4b89adb5efcf0215722fc462d2 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 27 Jul 2020 20:26:04 -0500
Subject: [PATCH] dsdmo: Stub IDirectSoundFXParamEq.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/main.c           | 56 +++++++++++++++++++++++++++++++++++++
 dlls/dsdmo/tests/dsdmo.c    | 17 +++++------
 dlls/dsound/tests/dsound8.c | 10 +++----
 3 files changed, 69 insertions(+), 14 deletions(-)

diff --git a/dlls/dsdmo/main.c b/dlls/dsdmo/main.c
index 482b8202db2..ff103be159e 100644
--- a/dlls/dsdmo/main.c
+++ b/dlls/dsdmo/main.c
@@ -437,6 +437,57 @@ static void effect_init(struct effect *effect, IUnknown *outer, const struct eff
 struct eq
 {
     struct effect effect;
+    IDirectSoundFXParamEq IDirectSoundFXParamEq_iface;
+};
+
+static struct eq *impl_from_IDirectSoundFXParamEq(IDirectSoundFXParamEq *iface)
+{
+    return CONTAINING_RECORD(iface, struct eq, IDirectSoundFXParamEq_iface);
+}
+
+static HRESULT WINAPI eq_params_QueryInterface(IDirectSoundFXParamEq *iface, REFIID iid, void **out)
+{
+    struct eq *effect = impl_from_IDirectSoundFXParamEq(iface);
+    return IUnknown_QueryInterface(effect->effect.outer_unk, iid, out);
+}
+
+static ULONG WINAPI eq_params_AddRef(IDirectSoundFXParamEq *iface)
+{
+    struct eq *effect = impl_from_IDirectSoundFXParamEq(iface);
+    return IUnknown_AddRef(effect->effect.outer_unk);
+}
+
+static ULONG WINAPI eq_params_Release(IDirectSoundFXParamEq *iface)
+{
+    struct eq *effect = impl_from_IDirectSoundFXParamEq(iface);
+    return IUnknown_Release(effect->effect.outer_unk);
+}
+
+static HRESULT WINAPI eq_params_SetAllParameters(IDirectSoundFXParamEq *iface, const DSFXParamEq *params)
+{
+    struct eq *effect = impl_from_IDirectSoundFXParamEq(iface);
+
+    FIXME("effect %p, params %p, stub!\n", effect, params);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI eq_params_GetAllParameters(IDirectSoundFXParamEq *iface, DSFXParamEq *params)
+{
+    struct eq *effect = impl_from_IDirectSoundFXParamEq(iface);
+
+    FIXME("effect %p, params %p, stub!\n", effect, params);
+
+    return E_NOTIMPL;
+}
+
+static const IDirectSoundFXParamEqVtbl eq_params_vtbl =
+{
+    eq_params_QueryInterface,
+    eq_params_AddRef,
+    eq_params_Release,
+    eq_params_SetAllParameters,
+    eq_params_GetAllParameters,
 };
 
 static struct eq *impl_eq_from_effect(struct effect *iface)
@@ -446,6 +497,10 @@ static struct eq *impl_eq_from_effect(struct effect *iface)
 
 static void *eq_query_interface(struct effect *iface, REFIID iid)
 {
+    struct eq *effect = impl_eq_from_effect(iface);
+
+    if (IsEqualGUID(iid, &IID_IDirectSoundFXParamEq))
+        return &effect->IDirectSoundFXParamEq_iface;
     return NULL;
 }
 
@@ -470,6 +525,7 @@ static HRESULT eq_create(IUnknown *outer, IUnknown **out)
         return E_OUTOFMEMORY;
 
     effect_init(&object->effect, outer, &eq_ops);
+    object->IDirectSoundFXParamEq_iface.lpVtbl = &eq_params_vtbl;
 
     TRACE("Created equalizer effect %p.\n", object);
     *out = &object->effect.IUnknown_inner;
diff --git a/dlls/dsdmo/tests/dsdmo.c b/dlls/dsdmo/tests/dsdmo.c
index 349e300f02e..c59361e5fcf 100644
--- a/dlls/dsdmo/tests/dsdmo.c
+++ b/dlls/dsdmo/tests/dsdmo.c
@@ -450,15 +450,16 @@ static void test_eq_parameters(void)
 
     hr = CoCreateInstance(&GUID_DSFX_STANDARD_PARAMEQ, NULL, CLSCTX_INPROC_SERVER,
             &IID_IDirectSoundFXParamEq, (void **)&eq);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
-    if (hr != S_OK)
-        return;
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IDirectSoundFXParamEq_GetAllParameters(eq, &params);
-    ok(hr == S_OK, "Got hr %#x.\n", hr);
-    ok(params.fCenter == 8000.0f, "Got center frequency %.8e Hz.\n", params.fCenter);
-    ok(params.fBandwidth == 12.0f, "Got band width %.8e semitones.\n", params.fBandwidth);
-    ok(params.fGain == 0.0f, "Got gain %.8e.\n", params.fGain);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    if (hr == S_OK)
+    {
+        ok(params.fCenter == 8000.0f, "Got center frequency %.8e Hz.\n", params.fCenter);
+        ok(params.fBandwidth == 12.0f, "Got band width %.8e semitones.\n", params.fBandwidth);
+        ok(params.fGain == 0.0f, "Got gain %.8e.\n", params.fGain);
+    }
 
     ref = IDirectSoundFXParamEq_Release(eq);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
@@ -526,7 +527,7 @@ START_TEST(dsdmo)
         {&GUID_DSFX_STANDARD_FLANGER,       &IID_IDirectSoundFXFlanger, TRUE},
         {&GUID_DSFX_STANDARD_GARGLE,        &IID_IDirectSoundFXGargle, TRUE},
         {&GUID_DSFX_STANDARD_I3DL2REVERB,   &IID_IDirectSoundFXI3DL2Reverb},
-        {&GUID_DSFX_STANDARD_PARAMEQ,       &IID_IDirectSoundFXParamEq, TRUE},
+        {&GUID_DSFX_STANDARD_PARAMEQ,       &IID_IDirectSoundFXParamEq},
         {&GUID_DSFX_WAVES_REVERB,           &IID_IDirectSoundFXWavesReverb},
     };
     unsigned int i;
diff --git a/dlls/dsound/tests/dsound8.c b/dlls/dsound/tests/dsound8.c
index 05dfabbd253..fcac31ba637 100644
--- a/dlls/dsound/tests/dsound8.c
+++ b/dlls/dsound/tests/dsound8.c
@@ -1724,15 +1724,13 @@ static void test_effects(void)
     todo_wine ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IDirectSoundFXParamEq, (void **)&unk);
-    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    if (hr == DS_OK)
-        IUnknown_Release(unk);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    IUnknown_Release(unk);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0,
             &IID_IDirectSoundFXParamEq, (void **)&unk);
-    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    if (hr == DS_OK)
-        IUnknown_Release(unk);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    IUnknown_Release(unk);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0,
             &IID_IDirectSoundFXI3DL2Reverb, (void **)&unk);
From 3ba24075f2740d379824edef7f56d3b0c73f6577 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 27 Jul 2020 20:26:05 -0500
Subject: [PATCH] dsdmo: Implement IDirectSoundFXParamEq parameters methods.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsdmo/main.c        | 19 +++++++++++++++----
 dlls/dsdmo/tests/dsdmo.c | 28 +++++++++++++++++++++-------
 2 files changed, 36 insertions(+), 11 deletions(-)

diff --git a/dlls/dsdmo/main.c b/dlls/dsdmo/main.c
index ff103be159e..57214b32752 100644
--- a/dlls/dsdmo/main.c
+++ b/dlls/dsdmo/main.c
@@ -438,6 +438,7 @@ struct eq
 {
     struct effect effect;
     IDirectSoundFXParamEq IDirectSoundFXParamEq_iface;
+    DSFXParamEq params;
 };
 
 static struct eq *impl_from_IDirectSoundFXParamEq(IDirectSoundFXParamEq *iface)
@@ -467,18 +468,24 @@ static HRESULT WINAPI eq_params_SetAllParameters(IDirectSoundFXParamEq *iface, c
 {
     struct eq *effect = impl_from_IDirectSoundFXParamEq(iface);
 
-    FIXME("effect %p, params %p, stub!\n", effect, params);
+    TRACE("effect %p, params %p.\n", effect, params);
 
-    return E_NOTIMPL;
+    EnterCriticalSection(&effect->effect.cs);
+    effect->params = *params;
+    LeaveCriticalSection(&effect->effect.cs);
+    return S_OK;
 }
 
 static HRESULT WINAPI eq_params_GetAllParameters(IDirectSoundFXParamEq *iface, DSFXParamEq *params)
 {
     struct eq *effect = impl_from_IDirectSoundFXParamEq(iface);
 
-    FIXME("effect %p, params %p, stub!\n", effect, params);
+    TRACE("effect %p, params %p.\n", effect, params);
 
-    return E_NOTIMPL;
+    EnterCriticalSection(&effect->effect.cs);
+    *params = effect->params;
+    LeaveCriticalSection(&effect->effect.cs);
+    return S_OK;
 }
 
 static const IDirectSoundFXParamEqVtbl eq_params_vtbl =
@@ -527,6 +534,10 @@ static HRESULT eq_create(IUnknown *outer, IUnknown **out)
     effect_init(&object->effect, outer, &eq_ops);
     object->IDirectSoundFXParamEq_iface.lpVtbl = &eq_params_vtbl;
 
+    object->params.fCenter = 8000.0f;
+    object->params.fBandwidth = 12.0f;
+    object->params.fGain = 0.0f;
+
     TRACE("Created equalizer effect %p.\n", object);
     *out = &object->effect.IUnknown_inner;
     return S_OK;
diff --git a/dlls/dsdmo/tests/dsdmo.c b/dlls/dsdmo/tests/dsdmo.c
index c59361e5fcf..1ecafeb7ceb 100644
--- a/dlls/dsdmo/tests/dsdmo.c
+++ b/dlls/dsdmo/tests/dsdmo.c
@@ -453,13 +453,27 @@ static void test_eq_parameters(void)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IDirectSoundFXParamEq_GetAllParameters(eq, &params);
-    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
-    if (hr == S_OK)
-    {
-        ok(params.fCenter == 8000.0f, "Got center frequency %.8e Hz.\n", params.fCenter);
-        ok(params.fBandwidth == 12.0f, "Got band width %.8e semitones.\n", params.fBandwidth);
-        ok(params.fGain == 0.0f, "Got gain %.8e.\n", params.fGain);
-    }
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(params.fCenter == 8000.0f, "Got center frequency %.8e Hz.\n", params.fCenter);
+    ok(params.fBandwidth == 12.0f, "Got band width %.8e semitones.\n", params.fBandwidth);
+    ok(params.fGain == 0.0f, "Got gain %.8e.\n", params.fGain);
+
+    params.fCenter = 79.0f;
+    hr = IDirectSoundFXParamEq_SetAllParameters(eq, &params);
+    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
+    params.fCenter = 16001.0f;
+    hr = IDirectSoundFXParamEq_SetAllParameters(eq, &params);
+    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
+    params.fCenter = 738.0f;
+    hr = IDirectSoundFXParamEq_SetAllParameters(eq, &params);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    memset(&params, 0xcc, sizeof(params));
+    hr = IDirectSoundFXParamEq_GetAllParameters(eq, &params);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(params.fCenter == 738.0f, "Got center frequency %.8e Hz.\n", params.fCenter);
+    ok(params.fBandwidth == 12.0f, "Got band width %.8e semitones.\n", params.fBandwidth);
+    ok(params.fGain == 0.0f, "Got gain %.8e.\n", params.fGain);
 
     ref = IDirectSoundFXParamEq_Release(eq);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
From eedbfe0c0d7c6575aa9b5d04f103bc05d4c7bf2d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Aug 2020 10:49:37 -0500
Subject: [PATCH] quartz/tests: Fix a test in test_basic_video().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/videorenderer.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/quartz/tests/videorenderer.c b/dlls/quartz/tests/videorenderer.c
index 9e6a618a36e..c2b6271021a 100644
--- a/dlls/quartz/tests/videorenderer.c
+++ b/dlls/quartz/tests/videorenderer.c
@@ -2733,6 +2733,7 @@ static void test_basic_video(void)
 
     vih.bmiHeader.biWidth = 16;
     vih.bmiHeader.biHeight = 16;
+    vih.bmiHeader.biSizeImage = 0;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
From 91625e43f461b73b96475ffbbb0ae29c21dc4d16 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 28 Jul 2020 20:29:42 -0500
Subject: [PATCH] dsound: Select the nth effect matching the given CLSID in
 GetObjectInPath().

Instead of selecting the nth effect overall and checking whether it matches.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Andrew Eikum <aeikum@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dsound/buffer.c        | 32 +++++++++++++++-----------------
 dlls/dsound/tests/dsound8.c | 24 ++++++++++--------------
 2 files changed, 25 insertions(+), 31 deletions(-)

diff --git a/dlls/dsound/buffer.c b/dlls/dsound/buffer.c
index ea428c08166..bc30a8a5448 100644
--- a/dlls/dsound/buffer.c
+++ b/dlls/dsound/buffer.c
@@ -845,27 +845,25 @@ static HRESULT WINAPI IDirectSoundBufferImpl_AcquireResources(IDirectSoundBuffer
 }
 
 static HRESULT WINAPI IDirectSoundBufferImpl_GetObjectInPath(IDirectSoundBuffer8 *iface,
-        REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, void **ppObject)
+        REFGUID clsid, DWORD index, REFGUID iid, void **out)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
+    IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
+    DWORD i, count = 0;
 
-	TRACE("(%p,%s,%u,%s,%p)\n",This,debugstr_guid(rguidObject),dwIndex,debugstr_guid(rguidInterface),ppObject);
+    TRACE("(%p,%s,%u,%s,%p)\n", This, debugstr_guid(clsid), index, debugstr_guid(iid), out);
 
-	if (dwIndex >= This->num_filters)
-		return DSERR_CONTROLUNAVAIL;
-
-	if (!ppObject)
-		return E_INVALIDARG;
+    if (!out)
+        return E_INVALIDARG;
 
-	if (IsEqualGUID(rguidObject, &This->filters[dwIndex].guid) || IsEqualGUID(rguidObject, &GUID_All_Objects)) {
-		if (SUCCEEDED(IMediaObject_QueryInterface(This->filters[dwIndex].obj, rguidInterface, ppObject)))
-			return DS_OK;
-		else
-			return E_NOINTERFACE;
-	} else {
-		WARN("control unavailable\n");
-		return DSERR_OBJECTNOTFOUND;
-	}
+    for (i = 0; i < This->num_filters; i++)
+    {
+        if (IsEqualGUID(clsid, &This->filters[i].guid) || IsEqualGUID(clsid, &GUID_All_Objects))
+        {
+            if (count++ == index)
+                return IMediaObject_QueryInterface(This->filters[i].obj, iid, out);
+        }
+    }
+    return DSERR_OBJECTNOTFOUND;
 }
 
 static HRESULT WINAPI IDirectSoundBufferImpl_Initialize(IDirectSoundBuffer8 *iface,
diff --git a/dlls/dsound/tests/dsound8.c b/dlls/dsound/tests/dsound8.c
index fcac31ba637..81c5710dbaf 100644
--- a/dlls/dsound/tests/dsound8.c
+++ b/dlls/dsound/tests/dsound8.c
@@ -1678,7 +1678,7 @@ static void test_effects(void)
 
     dmo = (IMediaObject *)0xdeadbeef;
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 1, &IID_IMediaObject, (void **)&dmo);
-    todo_wine ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
+    ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
     ok(dmo == (IMediaObject *)0xdeadbeef, "Got object %p.\n", dmo);
 
     effects[0].guidDSFXClass = GUID_DSFX_STANDARD_PARAMEQ;
@@ -1705,9 +1705,8 @@ static void test_effects(void)
     echo = dmo;
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8,
             &GUID_DSFX_STANDARD_I3DL2REVERB, 0, &IID_IMediaObject, (void **)&dmo);
-    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    if (hr == DS_OK)
-        reverb = dmo;
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    reverb = dmo;
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IMediaObject, (void **)&dmo);
     ok(hr == DS_OK, "Got hr %#x.\n", hr);
@@ -1716,12 +1715,12 @@ static void test_effects(void)
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 1, &IID_IMediaObject, (void **)&dmo);
     ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    todo_wine ok(dmo == reverb, "Expected %p, got %p.\n", reverb, dmo);
+    ok(dmo == reverb, "Expected %p, got %p.\n", reverb, dmo);
     IMediaObject_Release(dmo);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8,
             &GUID_DSFX_STANDARD_I3DL2REVERB, 1, &IID_IMediaObject, (void **)&dmo);
-    todo_wine ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
+    ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IDirectSoundFXParamEq, (void **)&unk);
     ok(hr == DS_OK, "Got hr %#x.\n", hr);
@@ -1743,14 +1742,11 @@ static void test_effects(void)
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8,
             &GUID_DSFX_STANDARD_I3DL2REVERB, 0, &IID_IDirectSoundFXI3DL2Reverb, (void **)&unk);
-    todo_wine ok(hr == DS_OK, "Got hr %#x.\n", hr);
-    if (hr == DS_OK)
-        IUnknown_Release(unk);
+    ok(hr == DS_OK, "Got hr %#x.\n", hr);
+    IUnknown_Release(unk);
 
-    if (echo)
-        IMediaObject_Release(echo);
-    if (reverb)
-        IMediaObject_Release(reverb);
+    IMediaObject_Release(echo);
+    IMediaObject_Release(reverb);
 
     got_Process = CreateEventA(NULL, TRUE, FALSE, NULL);
 
@@ -1786,7 +1782,7 @@ static void test_effects(void)
     ok(hr == DS_OK, "Got hr %#x.\n", hr);
 
     hr = IDirectSoundBuffer8_GetObjectInPath(buffer8, &GUID_All_Objects, 0, &IID_IMediaObject, (void **)&dmo);
-    todo_wine ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
+    ok(hr == DSERR_OBJECTNOTFOUND, "Got hr %#x.\n", hr);
 
     CloseHandle(got_Process);
     IDirectSoundBuffer8_Release(buffer8);
From 7bdb713bc47e741d59051bd3599dc0da12f441c2 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Wed, 5 Aug 2020 16:31:25 +0200
Subject: [PATCH] amstream/tests: Split test_IDirectDrawStreamSample().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 268 ++++++++++++++++++++-------------
 1 file changed, 167 insertions(+), 101 deletions(-)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index cf66538a7a9..1310e42cf2a 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -2543,106 +2543,6 @@ static void test_media_types(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
-static void test_IDirectDrawStreamSample(void)
-{
-    IDirectDrawMediaStream *ddraw_stream = NULL;
-    IDirectDrawStreamSample *sample = NULL;
-    IDirectDrawSurface *surface, *surface2;
-    IMediaStream *stream2, *stream = NULL;
-    DDSURFACEDESC desc = { sizeof(desc) };
-    IAMMultiMediaStream *mmstream;
-    IDirectDrawSurface7 *surface7;
-    HRESULT hr;
-    RECT rect;
-
-    if (!(mmstream = create_ammultimediastream()))
-        return;
-    if (!create_directdraw())
-    {
-        IAMMultiMediaStream_Release(mmstream);
-        return;
-    }
-
-    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-
-    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown*)pdd7, &MSPID_PrimaryVideo, 0, NULL);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-
-    hr = IAMMultiMediaStream_GetMediaStream(mmstream, &MSPID_PrimaryVideo, &stream);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-    if (FAILED(hr)) goto error;
-
-    hr = IMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (LPVOID*)&ddraw_stream);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-    if (FAILED(hr)) goto error;
-
-    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, &sample);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-
-    surface = NULL;
-    hr = IDirectDrawStreamSample_GetSurface(sample, &surface, &rect);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-    ok(surface != NULL, "got %p\n", surface);
-
-    /* Crashes on native. */
-    if (0)
-    {
-        hr = IDirectDrawStreamSample_GetMediaStream(sample, NULL);
-        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
-    }
-
-    hr = IDirectDrawStreamSample_GetMediaStream(sample, &stream2);
-    ok(hr == S_OK, "Got hr %#x.\n", hr);
-    ok(stream2 == stream, "Expected stream %p, got %p.\n", stream, stream2);
-    IMediaStream_Release(stream2);
-
-    hr = IDirectDrawSurface_QueryInterface(surface, &IID_IDirectDrawSurface7, (void **)&surface7);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-    IDirectDrawSurface7_Release(surface7);
-
-    hr = IDirectDrawSurface_GetSurfaceDesc(surface, &desc);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-    ok(desc.dwWidth == 100, "width %d\n", desc.dwWidth);
-    ok(desc.dwHeight == 100, "height %d\n", desc.dwHeight);
-    ok(desc.ddpfPixelFormat.dwFlags == DDPF_RGB, "format flags %08x\n", desc.ddpfPixelFormat.dwFlags);
-    ok(desc.ddpfPixelFormat.dwRGBBitCount, "dwRGBBitCount %d\n", desc.ddpfPixelFormat.dwRGBBitCount);
-    IDirectDrawSurface_Release(surface);
-    IDirectDrawStreamSample_Release(sample);
-
-    hr = IDirectDrawSurface7_QueryInterface(pdds7, &IID_IDirectDrawSurface, (void **)&surface);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-
-    EXPECT_REF(surface, 1);
-    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, surface, NULL, 0, &sample);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-    EXPECT_REF(surface, 2);
-
-    surface2 = NULL;
-    SetRectEmpty(&rect);
-    hr = IDirectDrawStreamSample_GetSurface(sample, &surface2, &rect);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-    ok(surface == surface2, "got %p\n", surface2);
-    ok(rect.right > 0 && rect.bottom > 0, "got %d, %d\n", rect.right, rect.bottom);
-    EXPECT_REF(surface, 3);
-    IDirectDrawSurface_Release(surface2);
-
-    hr = IDirectDrawStreamSample_GetSurface(sample, NULL, NULL);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-
-    IDirectDrawStreamSample_Release(sample);
-    IDirectDrawSurface_Release(surface);
-
-error:
-    if (ddraw_stream)
-        IDirectDrawMediaStream_Release(ddraw_stream);
-    if (stream)
-        IMediaStream_Release(stream);
-
-    release_directdraw();
-    IAMMultiMediaStream_Release(mmstream);
-}
-
 static IUnknown *create_audio_data(void)
 {
     IUnknown *audio_data = NULL;
@@ -5728,6 +5628,170 @@ static void test_audiostreamsample_get_audio_data(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_ddrawstream_create_sample(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IDirectDrawSurface *surface, *surface2;
+    DDSURFACEDESC desc = { sizeof(desc) };
+    IDirectDrawMediaStream *ddraw_stream;
+    IDirectDrawStreamSample *sample;
+    IMediaStream *stream;
+    IDirectDraw *ddraw;
+    HRESULT hr;
+    RECT rect;
+    ULONG ref;
+
+    hr = DirectDrawCreate(NULL, &ddraw, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDraw_SetCooperativeLevel(ddraw, NULL, DDSCL_NORMAL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)ddraw, &MSPID_PrimaryVideo, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (void **)&ddraw_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, NULL);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+    }
+
+    SetRectEmpty(&rect);
+    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, &rect, 0, &sample);
+    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
+
+    EXPECT_REF(stream, 3);
+    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, &sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine EXPECT_REF(stream, 4);
+
+    hr = IDirectDrawStreamSample_GetSurface(sample, NULL, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawStreamSample_GetSurface(sample, NULL, &rect);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawStreamSample_GetSurface(sample, &surface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(surface != NULL, "Expected non-NULL surface.\n");
+    IDirectDrawSurface_Release(surface);
+
+    surface = NULL;
+    hr = IDirectDrawStreamSample_GetSurface(sample, &surface, &rect);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(surface != NULL, "Expected non-NULL surface.\n");
+
+    hr = IDirectDrawSurface_GetSurfaceDesc(surface, &desc);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(desc.dwWidth == 100, "Expected width 100, got %d.\n", desc.dwWidth);
+    ok(desc.dwHeight == 100, "Expected height 100, got %d.\n", desc.dwHeight);
+    ok(desc.ddpfPixelFormat.dwFlags == DDPF_RGB, "Expected format flags DDPF_RGB, got %#x.\n", desc.ddpfPixelFormat.dwFlags);
+    ok(desc.ddpfPixelFormat.dwRGBBitCount, "Expected non-zero RGB bit count.\n");
+    IDirectDrawSurface_Release(surface);
+    IDirectDrawStreamSample_Release(sample);
+    EXPECT_REF(stream, 3);
+
+    memset(&desc, 0, sizeof(desc));
+    desc.dwSize = sizeof(desc);
+    desc.dwFlags = DDSD_CAPS;
+    desc.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
+    hr = IDirectDraw_CreateSurface(ddraw, &desc, &surface, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    EXPECT_REF(surface, 1);
+    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, surface, NULL, 0, &sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    EXPECT_REF(surface, 2);
+
+    surface2 = NULL;
+    SetRectEmpty(&rect);
+    hr = IDirectDrawStreamSample_GetSurface(sample, &surface2, &rect);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(surface2 == surface, "Expected surface %p, got %p.\n", surface, surface2);
+    ok(rect.right > 0 && rect.bottom > 0, "Got rect %d, %d.\n", rect.right, rect.bottom);
+    EXPECT_REF(surface, 3);
+    IDirectDrawSurface_Release(surface2);
+    EXPECT_REF(surface, 2);
+    IDirectDrawStreamSample_Release(sample);
+    EXPECT_REF(surface, 1);
+
+    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, surface, &rect, 0, &sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    IDirectDrawMediaStream_Release(ddraw_stream);
+    ref = IDirectDrawStreamSample_Release(sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IDirectDrawSurface_Release(surface);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IDirectDraw_Release(ddraw);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
+static void test_ddrawstreamsample_get_media_stream(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IDirectDrawMediaStream *ddraw_stream;
+    IDirectDrawStreamSample *sample;
+    IMediaStream *stream, *stream2;
+    IDirectDraw *ddraw;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = DirectDrawCreate(NULL, &ddraw, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDraw_SetCooperativeLevel(ddraw, NULL, DDSCL_NORMAL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, (IUnknown *)ddraw, &MSPID_PrimaryVideo, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (void **)&ddraw_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, &sample);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IDirectDrawStreamSample_GetMediaStream(sample, NULL);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+    }
+
+    todo_wine EXPECT_REF(stream, 4);
+    hr = IDirectDrawStreamSample_GetMediaStream(sample, &stream2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(stream2 == stream, "Expected stream %p, got %p.\n", stream, stream2);
+    todo_wine EXPECT_REF(stream, 5);
+    IMediaStream_Release(stream2);
+    todo_wine EXPECT_REF(stream, 4);
+
+    IDirectDrawMediaStream_Release(ddraw_stream);
+    ref = IDirectDrawStreamSample_Release(sample);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IDirectDraw_Release(ddraw);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 START_TEST(amstream)
 {
     const WCHAR *test_avi_path;
@@ -5744,7 +5808,6 @@ START_TEST(amstream)
     test_set_state();
     test_enum_media_types();
     test_media_types();
-    test_IDirectDrawStreamSample();
 
     test_avi_path = load_resource(L"test.avi");
 
@@ -5780,6 +5843,9 @@ START_TEST(amstream)
     test_ddrawstream_initialize();
     test_ddrawstream_getsetdirectdraw();
     test_ddrawstream_receive_connection();
+    test_ddrawstream_create_sample();
+
+    test_ddrawstreamsample_get_media_stream();
 
     test_ammediastream_join_am_multi_media_stream();
     test_ammediastream_join_filter();
From a4ddb5a1e6c0c94b344f5cf6d52b103538c378f0 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Wed, 5 Aug 2020 16:31:26 +0200
Subject: [PATCH] amstream: Return E_INVALIDARG when a rect but no surface is
 passed in IDirectDrawMediaStream::CreateSample().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    | 3 +++
 dlls/amstream/tests/amstream.c | 2 +-
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 4c94bacf52e..917fcad9c9b 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -442,6 +442,9 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_CreateSample(IDirectDrawMedia
     TRACE("stream %p, surface %p, rect %s, flags %#x, sample %p.\n",
             stream, surface, wine_dbgstr_rect(rect), flags, sample);
 
+    if (!surface && rect)
+        return E_INVALIDARG;
+
     EnterCriticalSection(&stream->cs);
     hr = ddrawstreamsample_create(stream, surface, rect, sample);
     LeaveCriticalSection(&stream->cs);
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 1310e42cf2a..383ea7e9362 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -5665,7 +5665,7 @@ static void test_ddrawstream_create_sample(void)
 
     SetRectEmpty(&rect);
     hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, &rect, 0, &sample);
-    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     EXPECT_REF(stream, 3);
     hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, &sample);
From a51897566340904afdbd42b4d1f81ee278cb8cae Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Wed, 5 Aug 2020 16:31:27 +0200
Subject: [PATCH] amstream: Increase parent IAMMediaStream refcount in
 IDirectDrawMediaStream::CreateSample().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    | 3 +++
 dlls/amstream/tests/amstream.c | 8 ++++----
 2 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 917fcad9c9b..0d3f2d0d4b8 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -1048,6 +1048,8 @@ static ULONG WINAPI ddraw_sample_Release(IDirectDrawStreamSample *iface)
         --sample->parent->sample_refs;
         LeaveCriticalSection(&sample->parent->cs);
 
+        IAMMediaStream_Release(&sample->parent->IAMMediaStream_iface);
+
         if (sample->surface)
             IDirectDrawSurface_Release(sample->surface);
         HeapFree(GetProcessHeap(), 0, sample);
@@ -1163,6 +1165,7 @@ static HRESULT ddrawstreamsample_create(struct ddraw_stream *parent, IDirectDraw
     object->IDirectDrawStreamSample_iface.lpVtbl = &DirectDrawStreamSample_Vtbl;
     object->ref = 1;
     object->parent = parent;
+    IAMMediaStream_AddRef(&parent->IAMMediaStream_iface);
     ++parent->sample_refs;
 
     if (surface)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 383ea7e9362..910ab11f525 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -5670,7 +5670,7 @@ static void test_ddrawstream_create_sample(void)
     EXPECT_REF(stream, 3);
     hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, &sample);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
-    todo_wine EXPECT_REF(stream, 4);
+    EXPECT_REF(stream, 4);
 
     hr = IDirectDrawStreamSample_GetSurface(sample, NULL, NULL);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
@@ -5773,13 +5773,13 @@ static void test_ddrawstreamsample_get_media_stream(void)
         ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     }
 
-    todo_wine EXPECT_REF(stream, 4);
+    EXPECT_REF(stream, 4);
     hr = IDirectDrawStreamSample_GetMediaStream(sample, &stream2);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(stream2 == stream, "Expected stream %p, got %p.\n", stream, stream2);
-    todo_wine EXPECT_REF(stream, 5);
+    EXPECT_REF(stream, 5);
     IMediaStream_Release(stream2);
-    todo_wine EXPECT_REF(stream, 4);
+    EXPECT_REF(stream, 4);
 
     IDirectDrawMediaStream_Release(ddraw_stream);
     ref = IDirectDrawStreamSample_Release(sample);
From 0beda8a480d4e5ced02841f0410c0724f7fb39d3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 15 Aug 2020 16:43:35 -0500
Subject: [PATCH] quartz: Reimplement AM_RENDEREX_RENDERTOEXISTINGRENDERERS by
 forbidding renderers from IFilterMapper2::EnumMatchingFilters().

Primarily to avoid unnecessarily creating filters like the VMR.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filtergraph.c | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 2c32b3bc436..4cef1004bdd 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -1130,7 +1130,7 @@ static HRESULT autoplug(struct filter_graph *graph, IPin *source, IPin *sink,
 
 static HRESULT autoplug_through_sink(struct filter_graph *graph, IPin *source,
         IBaseFilter *filter, IPin *middle_sink, IPin *sink,
-        BOOL render_to_existing, BOOL allow_renderers, unsigned int recursion_depth)
+        BOOL render_to_existing, unsigned int recursion_depth)
 {
     BOOL any = FALSE, all = TRUE;
     IPin *middle_source, *peer;
@@ -1195,7 +1195,7 @@ static HRESULT autoplug_through_sink(struct filter_graph *graph, IPin *source,
 
     if (!sink)
     {
-        if (all && (any || allow_renderers))
+        if (all)
             return S_OK;
         if (any)
             return VFW_S_PARTIAL_RENDER;
@@ -1209,7 +1209,7 @@ static HRESULT autoplug_through_sink(struct filter_graph *graph, IPin *source,
 
 static HRESULT autoplug_through_filter(struct filter_graph *graph, IPin *source,
         IBaseFilter *filter, IPin *sink, BOOL render_to_existing,
-        BOOL allow_renderers, unsigned int recursion_depth)
+        unsigned int recursion_depth)
 {
     IEnumPins *sink_enum;
     IPin *filter_sink;
@@ -1223,7 +1223,7 @@ static HRESULT autoplug_through_filter(struct filter_graph *graph, IPin *source,
     while (IEnumPins_Next(sink_enum, 1, &filter_sink, NULL) == S_OK)
     {
         hr = autoplug_through_sink(graph, source, filter, filter_sink, sink,
-                render_to_existing, allow_renderers, recursion_depth);
+                render_to_existing, recursion_depth);
         IPin_Release(filter_sink);
         if (SUCCEEDED(hr))
         {
@@ -1271,7 +1271,7 @@ static HRESULT autoplug(struct filter_graph *graph, IPin *source, IPin *sink,
     LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         if (SUCCEEDED(hr = autoplug_through_filter(graph, source, filter->filter,
-                sink, render_to_existing, TRUE, recursion_depth)))
+                sink, render_to_existing, recursion_depth)))
             return hr;
     }
 
@@ -1295,8 +1295,9 @@ static HRESULT autoplug(struct filter_graph *graph, IPin *source, IPin *sink,
 
         DeleteMediaType(mt);
 
-        if (FAILED(hr = IFilterMapper2_EnumMatchingFilters(mapper, &enummoniker, 0, FALSE,
-                MERIT_UNLIKELY, TRUE, 1, types, NULL, NULL, FALSE, FALSE, 0, NULL, NULL, NULL)))
+        if (FAILED(hr = IFilterMapper2_EnumMatchingFilters(mapper, &enummoniker,
+                0, FALSE, MERIT_UNLIKELY, TRUE, 1, types, NULL, NULL, FALSE,
+                render_to_existing, 0, NULL, NULL, NULL)))
             goto out;
 
         while (IEnumMoniker_Next(enummoniker, 1, &moniker, NULL) == S_OK)
@@ -1346,8 +1347,7 @@ static HRESULT autoplug(struct filter_graph *graph, IPin *source, IPin *sink,
                 continue;
             }
 
-            hr = autoplug_through_filter(graph, source, filter, sink,
-                    render_to_existing, !render_to_existing, recursion_depth);
+            hr = autoplug_through_filter(graph, source, filter, sink, render_to_existing, recursion_depth);
             if (SUCCEEDED(hr))
             {
                 IBaseFilter_Release(filter);
From bdf860033860973bf2b516a1083d5bea86ad8c14 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Thu, 6 Aug 2020 20:32:30 +0200
Subject: [PATCH] amstream: Return VFW_E_CANNOT_CONNECT in
 IAMMultiMediaStream::OpenFile() when no renderers are present and
 AMMSF_NORENDER is not specified.

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/multimedia.c     | 17 ++++++++++++++-
 dlls/amstream/tests/amstream.c | 38 ++++++++++++++++++++++++++++++++--
 2 files changed, 52 insertions(+), 3 deletions(-)

diff --git a/dlls/amstream/multimedia.c b/dlls/amstream/multimedia.c
index 414a903cf20..5425ef42a37 100644
--- a/dlls/amstream/multimedia.c
+++ b/dlls/amstream/multimedia.c
@@ -447,7 +447,22 @@ static HRESULT WINAPI multimedia_stream_OpenFile(IAMMultiMediaStream *iface,
     }
 
     if (SUCCEEDED(ret) && !(flags & AMMSF_NORENDER))
-        ret = IGraphBuilder_Render(This->graph, This->ipin);
+    {
+        IFilterGraph2 *graph;
+
+        if (SUCCEEDED(ret = IGraphBuilder_QueryInterface(This->graph, &IID_IFilterGraph2, (void **)&graph)))
+        {
+            ret = IFilterGraph2_RenderEx(graph, This->ipin, AM_RENDEREX_RENDERTOEXISTINGRENDERERS, NULL);
+            if (ret == VFW_E_CANNOT_RENDER) ret = VFW_E_CANNOT_CONNECT;
+            else if (ret == VFW_S_PARTIAL_RENDER) ret = S_OK;
+            IFilterGraph2_Release(graph);
+        }
+        else
+        {
+            FIXME("Failed to get IFilterGraph2 interface, hr %#x.\n", ret);
+            ret = IGraphBuilder_Render(This->graph, This->ipin);
+        }
+    }
 
     IMediaStreamFilter_SupportSeeking(This->filter, This->type == STREAMTYPE_READ);
 
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 910ab11f525..6a72f3ed891 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -283,13 +283,47 @@ static void test_openfile(const WCHAR *test_avi_path)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!graph, "Expected NULL graph.\n");
 
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(!!filter, "Expected non-NULL filter.\n");
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    check_interface(filter, &IID_IMediaSeeking, FALSE);
+
     hr = IAMMultiMediaStream_OpenFile(mmstream, test_avi_path, AMMSF_NORENDER);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
+    check_interface(filter, &IID_IMediaSeeking, FALSE);
+
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!!graph, "Expected non-NULL graph.\n");
+    IGraphBuilder_Release(graph);
+    IMediaStreamFilter_Release(filter);
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+    mmstream = create_ammultimediastream();
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!graph, "Expected NULL graph.\n");
+
+    hr = IAMMultiMediaStream_GetFilter(mmstream, &filter);
+    ok(!!filter, "Expected non-NULL filter.\n");
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    check_interface(filter, &IID_IMediaSeeking, FALSE);
+
+    hr = IAMMultiMediaStream_OpenFile(mmstream, test_avi_path, 0);
+    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x.\n", hr);
+
+    check_interface(filter, &IID_IMediaSeeking, FALSE);
+
     hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!!graph, "Expected non-NULL graph.\n");
     IGraphBuilder_Release(graph);
+    IMediaStreamFilter_Release(filter);
 
     ref = IAMMultiMediaStream_Release(mmstream);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
@@ -389,12 +423,12 @@ static void test_mmstream_get_duration(const WCHAR *test_avi_path)
     mmstream = create_ammultimediastream();
 
     hr = IAMMultiMediaStream_OpenFile(mmstream, test_avi_path, 0);
-    todo_wine ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x.\n", hr);
+    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x.\n", hr);
 
     duration = 0xdeadbeefdeadbeefULL;
     hr = IAMMultiMediaStream_GetDuration(mmstream, &duration);
     todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
-    todo_wine ok(duration == 0, "Got duration %s.\n", wine_dbgstr_longlong(duration));
+    ok(duration == 0, "Got duration %s.\n", wine_dbgstr_longlong(duration));
 
     ref = IAMMultiMediaStream_Release(mmstream);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
From 0a2bf907337bf787feac68b0da8345149a734c6a Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Thu, 6 Aug 2020 20:32:31 +0200
Subject: [PATCH] amstream: Return S_FALSE when IMediaSeeking::GetDuration()
 fails in IAMMultiMediaStream::GetDuration().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/multimedia.c     | 6 +++++-
 dlls/amstream/tests/amstream.c | 6 +++---
 2 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/dlls/amstream/multimedia.c b/dlls/amstream/multimedia.c
index 5425ef42a37..82ef4822344 100644
--- a/dlls/amstream/multimedia.c
+++ b/dlls/amstream/multimedia.c
@@ -181,7 +181,11 @@ static HRESULT WINAPI multimedia_stream_GetDuration(IAMMultiMediaStream *iface,
 
     if (!mmstream->media_seeking)
         return E_NOINTERFACE;
-    return IMediaSeeking_GetDuration(mmstream->media_seeking, duration);
+
+    if (IMediaSeeking_GetDuration(mmstream->media_seeking, duration) != S_OK)
+        return S_FALSE;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI multimedia_stream_Seek(IAMMultiMediaStream *iface, STREAM_TIME seek_time)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 6a72f3ed891..a25ae42a314 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -414,7 +414,7 @@ static void test_mmstream_get_duration(const WCHAR *test_avi_path)
 
     duration = 0xdeadbeefdeadbeefULL;
     hr = IAMMultiMediaStream_GetDuration(mmstream, &duration);
-    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(duration == 0, "Got duration %s.\n", wine_dbgstr_longlong(duration));
 
     ref = IAMMultiMediaStream_Release(mmstream);
@@ -427,7 +427,7 @@ static void test_mmstream_get_duration(const WCHAR *test_avi_path)
 
     duration = 0xdeadbeefdeadbeefULL;
     hr = IAMMultiMediaStream_GetDuration(mmstream, &duration);
-    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(duration == 0, "Got duration %s.\n", wine_dbgstr_longlong(duration));
 
     ref = IAMMultiMediaStream_Release(mmstream);
@@ -442,7 +442,7 @@ static void test_mmstream_get_duration(const WCHAR *test_avi_path)
 
     duration = 0xdeadbeefdeadbeefULL;
     hr = IAMMultiMediaStream_GetDuration(mmstream, &duration);
-    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(duration == 0, "Got duration %s.\n", wine_dbgstr_longlong(duration));
 
     ref = IAMMultiMediaStream_Release(mmstream);
From e13f5a1b43e994d4f5457f763f422452e572d722 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Thu, 20 Aug 2020 15:07:54 +0200
Subject: [PATCH] qcap/tests: Remove unused enumMediaTypes in
 test_smart_tee_filter() (Coverity).

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/tests/smartteefilter.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/dlls/qcap/tests/smartteefilter.c b/dlls/qcap/tests/smartteefilter.c
index f3a44c67c1f..1364beef161 100644
--- a/dlls/qcap/tests/smartteefilter.c
+++ b/dlls/qcap/tests/smartteefilter.c
@@ -2142,7 +2142,6 @@ static void test_smart_tee_filter(void)
     FILTER_INFO filterInfo;
     int pinNumber = 0;
     IMemInputPin *memInputPin = NULL;
-    IEnumMediaTypes *enumMediaTypes = NULL;
 
     hr = CoCreateInstance(&CLSID_SmartTee, NULL, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void**)&smartTeeFilter);
@@ -2213,8 +2212,6 @@ static void test_smart_tee_filter(void)
         IEnumPins_Release(enumPins);
     if (memInputPin)
         IMemInputPin_Release(memInputPin);
-    if (enumMediaTypes)
-        IEnumMediaTypes_Release(enumMediaTypes);
 }
 
 static void test_unconnected_filter_state(void)
From 5e1753f04dd2d67edba2b62f1644cb30528376c8 Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Thu, 20 Aug 2020 15:08:20 +0200
Subject: [PATCH] quartz: Close hfile when GetFileSizeEx fails in
 IFileSourceFilter::Load() (Coverity).

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/filesource.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/quartz/filesource.c b/dlls/quartz/filesource.c
index a553b8517e4..79df639ab4a 100644
--- a/dlls/quartz/filesource.c
+++ b/dlls/quartz/filesource.c
@@ -478,6 +478,7 @@ static HRESULT WINAPI FileSource_Load(IFileSourceFilter * iface, LPCOLESTR pszFi
     if (!GetFileSizeEx(hFile, &This->file_size))
     {
         WARN("Could not get file size.\n");
+        CloseHandle(hFile);
         return HRESULT_FROM_WIN32(GetLastError());
     }
 
From a53288e8c95d59b03eefe10f4963b555b04426aa Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 25 Aug 2020 20:30:51 +0200
Subject: [PATCH] amstream: Implement
 IMediaStreamFilter::ReferenceTimeToStreamTime().

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/filter.c         | 20 ++++++++++--
 dlls/amstream/tests/amstream.c | 59 ++++++++++++++++++++++++++++++++++
 2 files changed, 76 insertions(+), 3 deletions(-)

diff --git a/dlls/amstream/filter.c b/dlls/amstream/filter.c
index 13fd30c3a51..b63a0301d64 100644
--- a/dlls/amstream/filter.c
+++ b/dlls/amstream/filter.c
@@ -616,11 +616,25 @@ static HRESULT WINAPI filter_SupportSeeking(IMediaStreamFilter *iface, BOOL rend
     return E_NOINTERFACE;
 }
 
-static HRESULT WINAPI filter_ReferenceTimeToStreamTime(IMediaStreamFilter *iface, REFERENCE_TIME *pTime)
+static HRESULT WINAPI filter_ReferenceTimeToStreamTime(IMediaStreamFilter *iface, REFERENCE_TIME *time)
 {
-    FIXME("(%p)->(%p): Stub!\n", iface, pTime);
+    struct filter *filter = impl_from_IMediaStreamFilter(iface);
 
-    return E_NOTIMPL;
+    TRACE("filter %p, time %p.\n", filter, time);
+
+    EnterCriticalSection(&filter->cs);
+
+    if (!filter->clock)
+    {
+        LeaveCriticalSection(&filter->cs);
+        return S_FALSE;
+    }
+
+    *time -= filter->start_time;
+
+    LeaveCriticalSection(&filter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI filter_GetCurrentStreamTime(IMediaStreamFilter *iface, REFERENCE_TIME *time)
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index a25ae42a314..f4c033a1807 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -5436,6 +5436,64 @@ static void test_mediastreamfilter_get_current_stream_time(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_mediastreamfilter_reference_time_to_stream_time(void)
+{
+    IMediaStreamFilter *filter;
+    struct testclock clock;
+    REFERENCE_TIME time;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = CoCreateInstance(&CLSID_MediaStreamFilter, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IMediaStreamFilter, (void **)&filter);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    testclock_init(&clock);
+
+    hr = IMediaStreamFilter_ReferenceTimeToStreamTime(filter, NULL);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+
+    time = 0xdeadbeefdeadbeef;
+    hr = IMediaStreamFilter_ReferenceTimeToStreamTime(filter, &time);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(time == 0xdeadbeefdeadbeef, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    hr = IMediaStreamFilter_SetSyncSource(filter, &clock.IReferenceClock_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    clock.get_time_hr = E_FAIL;
+
+    /* Crashes on native. */
+    if (0)
+    {
+        hr = IMediaStreamFilter_ReferenceTimeToStreamTime(filter, NULL);
+        ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    }
+
+    time = 0xdeadbeefdeadbeef;
+    hr = IMediaStreamFilter_ReferenceTimeToStreamTime(filter, &time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(time == 0xdeadbeefdeadbeef, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    hr = IMediaStreamFilter_Run(filter, 23456789);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    time = 0xdeadbeefdeadbeef;
+    hr = IMediaStreamFilter_ReferenceTimeToStreamTime(filter, &time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(time == 0xdeadbeefdd47d2da, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    clock.time = 34567890;
+    clock.get_time_hr = S_OK;
+
+    time = 0xdeadbeefdeadbeef;
+    hr = IMediaStreamFilter_ReferenceTimeToStreamTime(filter, &time);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(time == 0xdeadbeefdd47d2da, "Got time %s.\n", wine_dbgstr_longlong(time));
+
+    ref = IMediaStreamFilter_Release(filter);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void test_ddrawstream_getsetdirectdraw(void)
 {
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
@@ -5892,6 +5950,7 @@ START_TEST(amstream)
     test_mediastreamfilter_get_duration();
     test_mediastreamfilter_get_stop_position();
     test_mediastreamfilter_get_current_stream_time();
+    test_mediastreamfilter_reference_time_to_stream_time();
 
     CoUninitialize();
 }
From 84f89605feb04c04d0ad31beb043915c269d1806 Mon Sep 17 00:00:00 2001
From: Jeff Smith <whydoubt@gmail.com>
Date: Fri, 28 Aug 2020 10:51:59 -0500
Subject: [PATCH] qcap/tests: Refactor interface testing.

Signed-off-by: Jeff Smith <whydoubt@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/tests/videocapture.c | 50 ++++++++++++++++++++--------------
 1 file changed, 30 insertions(+), 20 deletions(-)

diff --git a/dlls/qcap/tests/videocapture.c b/dlls/qcap/tests/videocapture.c
index 80d4899410a..326601a398c 100644
--- a/dlls/qcap/tests/videocapture.c
+++ b/dlls/qcap/tests/videocapture.c
@@ -174,7 +174,30 @@ static void test_stream_config(IPin *pin)
     IAMStreamConfig_Release(stream_config);
 }
 
-static void test_capture(IBaseFilter *filter)
+static void test_pin_interfaces(IPin *pin)
+{
+    todo_wine check_interface(pin, &IID_IAMBufferNegotiation, TRUE);
+    check_interface(pin, &IID_IAMStreamConfig, TRUE);
+    todo_wine check_interface(pin, &IID_IAMStreamControl, TRUE);
+    todo_wine check_interface(pin, &IID_IKsPin, TRUE);
+    check_interface(pin, &IID_IKsPropertySet, TRUE);
+    todo_wine check_interface(pin, &IID_IMediaSeeking, TRUE);
+    check_interface(pin, &IID_IPin, TRUE);
+    todo_wine check_interface(pin, &IID_IQualityControl, TRUE);
+    todo_wine check_interface(pin, &IID_ISpecifyPropertyPages, TRUE);
+
+    check_interface(pin, &IID_IAMCrossbar, FALSE);
+    check_interface(pin, &IID_IAMDroppedFrames, FALSE);
+    check_interface(pin, &IID_IAMFilterMiscFlags, FALSE);
+    check_interface(pin, &IID_IAMPushSource, FALSE);
+    check_interface(pin, &IID_IAMTVTuner, FALSE);
+    check_interface(pin, &IID_IAMVideoCompression, FALSE);
+    check_interface(pin, &IID_IAMVideoProcAmp, FALSE);
+    check_interface(pin, &IID_IPersistPropertyBag, FALSE);
+    check_interface(pin, &IID_IStreamBuilder, FALSE);
+}
+
+static void test_pins(IBaseFilter *filter)
 {
     IEnumPins *enum_pins;
     IPin *pin;
@@ -189,32 +212,18 @@ static void test_capture(IBaseFilter *filter)
         IPin_QueryDirection(pin, &pin_direction);
         if (pin_direction == PINDIR_OUTPUT)
         {
+            test_pin_interfaces(pin);
             test_media_types(pin);
             test_stream_config(pin);
-
-            todo_wine check_interface(pin, &IID_IAMBufferNegotiation, TRUE);
-            check_interface(pin, &IID_IAMStreamConfig, TRUE);
-            todo_wine check_interface(pin, &IID_IAMStreamControl, TRUE);
-            check_interface(pin, &IID_IKsPropertySet, TRUE);
-            todo_wine check_interface(pin, &IID_IMediaSeeking, TRUE);
-            check_interface(pin, &IID_IPin, TRUE);
-            todo_wine check_interface(pin, &IID_IQualityControl, TRUE);
-            todo_wine check_interface(pin, &IID_ISpecifyPropertyPages, TRUE);
-
-            check_interface(pin, &IID_IAMCrossbar, FALSE);
-            check_interface(pin, &IID_IAMDroppedFrames, FALSE);
-            check_interface(pin, &IID_IAMFilterMiscFlags, FALSE);
-            check_interface(pin, &IID_IAMPushSource, FALSE);
-            check_interface(pin, &IID_IAMTVTuner, FALSE);
-            check_interface(pin, &IID_IAMVideoCompression, FALSE);
-            check_interface(pin, &IID_IAMVideoProcAmp, FALSE);
-            check_interface(pin, &IID_IPersistPropertyBag, FALSE);
         }
         IPin_Release(pin);
     }
 
     IEnumPins_Release(enum_pins);
+}
 
+static void test_filter_interfaces(IBaseFilter *filter)
+{
     check_interface(filter, &IID_IAMFilterMiscFlags, TRUE);
     check_interface(filter, &IID_IAMVideoControl, TRUE);
     check_interface(filter, &IID_IAMVideoProcAmp, TRUE);
@@ -287,7 +296,8 @@ START_TEST(videocapture)
         hr = IMoniker_BindToObject(moniker, NULL, NULL, &IID_IBaseFilter, (void**)&filter);
         if (hr == S_OK)
         {
-            test_capture(filter);
+            test_filter_interfaces(filter);
+            test_pins(filter);
             test_misc_flags(filter);
             ref = IBaseFilter_Release(filter);
             ok(!ref, "Got outstanding refcount %d.\n", ref);
From 7bae2aaf95fa2dd6eae7dc1d688e7d4a82b10dde Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 28 Aug 2020 11:59:12 -0500
Subject: [PATCH] devenum: Correct the size of "name" in
 register_avicap_devices().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/devenum/createdevenum.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/devenum/createdevenum.c b/dlls/devenum/createdevenum.c
index c72bb683f96..f7b53ad271f 100644
--- a/dlls/devenum/createdevenum.c
+++ b/dlls/devenum/createdevenum.c
@@ -726,7 +726,7 @@ static void register_avicap_devices(void)
     REGFILTERPINS2 rgpins = {0};
     REGPINTYPES rgtypes;
     REGFILTER2 rgf;
-    WCHAR name[6];
+    WCHAR name[7];
     VARIANT var;
     HRESULT hr;
     int i = 0;
From f4d66140ad61597e918b94077f18dbb98f524e66 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 29 Aug 2020 12:37:35 -0500
Subject: [PATCH] quartz/vmr9: Avoid leaking the presenter's reference to the
 d3d9 device.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/vmr9.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 28123dcf7da..5f95f547e33 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -2622,6 +2622,8 @@ static ULONG WINAPI VMR9_ImagePresenter_Release(IVMRImagePresenter9 *iface)
                 IDirect3DSurface9_Release(surface);
         }
 
+        if (This->d3d9_dev)
+            IDirect3DDevice9_Release(This->d3d9_dev);
         free(This->d3d9_surfaces);
         This->d3d9_surfaces = NULL;
         This->num_surfaces = 0;
From b02de178ebef84ba8686f3e55cc3fd1a1a39f9b8 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 29 Aug 2020 12:37:37 -0500
Subject: [PATCH] amstream/tests: Avoid leaking "stream" in test_find_pin().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index f4c033a1807..746a9563030 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -1766,6 +1766,7 @@ static void test_find_pin(void)
 
     IPin_Release(pin2);
     IPin_Release(pin);
+    IMediaStream_Release(stream);
     IMediaStreamFilter_Release(filter);
     ref = IAMMultiMediaStream_Release(mmstream);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
From 5f71e720fd7532e72b6e506d5a856d63f51959b7 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 29 Aug 2020 12:37:38 -0500
Subject: [PATCH] amstream/tests: Get rid of test_renderfile().

It's not testing anything anymore that's not tested elsewhere.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/tests/amstream.c | 122 ---------------------------------
 1 file changed, 122 deletions(-)

diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 746a9563030..b9b40921977 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -102,9 +102,6 @@ static void _expect_ref(IUnknown* obj, ULONG ref, int line)
     ok_(__FILE__,line)(rc == ref, "expected refcount %d, got %d\n", ref, rc);
 }
 
-static IDirectDraw7* pdd7;
-static IDirectDrawSurface7* pdds7;
-
 static IAMMultiMediaStream *create_ammultimediastream(void)
 {
     IAMMultiMediaStream *stream = NULL;
@@ -114,50 +111,6 @@ static IAMMultiMediaStream *create_ammultimediastream(void)
     return stream;
 }
 
-static int create_directdraw(void)
-{
-    HRESULT hr;
-    IDirectDraw* pdd = NULL;
-    DDSURFACEDESC2 ddsd;
-
-    hr = DirectDrawCreate(NULL, &pdd, NULL);
-    ok(hr==DD_OK, "DirectDrawCreate returned: %x\n", hr);
-    if (hr != DD_OK)
-       goto error;
-
-    hr = IDirectDraw_QueryInterface(pdd, &IID_IDirectDraw7, (LPVOID*)&pdd7);
-    ok(hr==DD_OK, "QueryInterface returned: %x\n", hr);
-    if (hr != DD_OK) goto error;
-
-    hr = IDirectDraw7_SetCooperativeLevel(pdd7, GetDesktopWindow(), DDSCL_NORMAL);
-    ok(hr==DD_OK, "SetCooperativeLevel returned: %x\n", hr);
-
-    ZeroMemory(&ddsd, sizeof(ddsd));
-    ddsd.dwSize = sizeof(ddsd);
-    ddsd.dwFlags = DDSD_CAPS;
-    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
-    hr = IDirectDraw7_CreateSurface(pdd7, &ddsd, &pdds7, NULL);
-    ok(hr==DD_OK, "CreateSurface returned: %x\n", hr);
-
-    return TRUE;
-
-error:
-    if (pdds7)
-        IDirectDrawSurface7_Release(pdds7);
-    if (pdd7)
-        IDirectDraw7_Release(pdd7);
-    if (pdd)
-        IDirectDraw_Release(pdd);
-
-    return FALSE;
-}
-
-static void release_directdraw(void)
-{
-    IDirectDrawSurface7_Release(pdds7);
-    IDirectDraw7_Release(pdd7);
-}
-
 static ULONG get_refcount(void *iface)
 {
     IUnknown *unknown = iface;
@@ -449,74 +402,6 @@ static void test_mmstream_get_duration(const WCHAR *test_avi_path)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
-static void test_renderfile(const WCHAR *test_avi_path)
-{
-    IAMMultiMediaStream *pams;
-    HRESULT hr;
-    IMediaStream *pvidstream = NULL;
-    IDirectDrawMediaStream *pddstream = NULL;
-    IDirectDrawStreamSample *pddsample = NULL;
-    IDirectDrawSurface *surface;
-    RECT rect;
-
-    if (!(pams = create_ammultimediastream()))
-        return;
-    if (!create_directdraw())
-    {
-        IAMMultiMediaStream_Release(pams);
-        return;
-    }
-
-    hr = IAMMultiMediaStream_Initialize(pams, STREAMTYPE_READ, 0, NULL);
-    ok(hr==S_OK, "IAMMultiMediaStream_Initialize returned: %x\n", hr);
-
-    hr = IAMMultiMediaStream_AddMediaStream(pams, (IUnknown*)pdd7, &MSPID_PrimaryVideo, 0, NULL);
-    ok(hr==S_OK, "IAMMultiMediaStream_AddMediaStream returned: %x\n", hr);
-
-    hr = IAMMultiMediaStream_AddMediaStream(pams, NULL, &MSPID_PrimaryAudio, AMMSF_ADDDEFAULTRENDERER, NULL);
-    ok(hr == S_OK || hr == VFW_E_NO_AUDIO_HARDWARE, "Got hr %#x.\n", hr);
-
-    hr = IAMMultiMediaStream_OpenFile(pams, test_avi_path, 0);
-    ok(hr==S_OK, "IAMMultiMediaStream_OpenFile returned: %x\n", hr);
-
-    hr = IAMMultiMediaStream_GetMediaStream(pams, &MSPID_PrimaryVideo, &pvidstream);
-    ok(hr==S_OK, "IAMMultiMediaStream_GetMediaStream returned: %x\n", hr);
-    if (FAILED(hr)) goto error;
-
-    hr = IMediaStream_QueryInterface(pvidstream, &IID_IDirectDrawMediaStream, (LPVOID*)&pddstream);
-    ok(hr==S_OK, "IMediaStream_QueryInterface returned: %x\n", hr);
-    if (FAILED(hr)) goto error;
-
-    hr = IDirectDrawMediaStream_CreateSample(pddstream, NULL, NULL, 0, &pddsample);
-    ok(hr == S_OK, "IDirectDrawMediaStream_CreateSample returned: %x\n", hr);
-
-    surface = NULL;
-    hr = IDirectDrawStreamSample_GetSurface(pddsample, &surface, &rect);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-    ok(surface != NULL, "Expected non-NULL surface.\n");
-    IDirectDrawSurface_Release(surface);
-    IDirectDrawStreamSample_Release(pddsample);
-
-    hr = IDirectDrawSurface7_QueryInterface(pdds7, &IID_IDirectDrawSurface, (void**)&surface);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
-
-    EXPECT_REF(surface, 1);
-    hr = IDirectDrawMediaStream_CreateSample(pddstream, surface, &rect, 0, &pddsample);
-    ok(hr == S_OK, "IDirectDrawMediaStream_CreateSample returned: %x\n", hr);
-    EXPECT_REF(surface, 2);
-    IDirectDrawStreamSample_Release(pddsample);
-    IDirectDrawSurface_Release(surface);
-
-error:
-    if (pddstream)
-        IDirectDrawMediaStream_Release(pddstream);
-    if (pvidstream)
-        IMediaStream_Release(pvidstream);
-
-    release_directdraw();
-    IAMMultiMediaStream_Release(pams);
-}
-
 static const GUID test_mspid = {0x88888888};
 
 struct teststream
@@ -1405,11 +1290,6 @@ static void test_media_streams(void)
 
     if (!(pams = create_ammultimediastream()))
         return;
-    if (!create_directdraw())
-    {
-        IAMMultiMediaStream_Release(pams);
-        return;
-    }
 
     hr = IAMMultiMediaStream_Initialize(pams, STREAMTYPE_READ, 0, NULL);
     ok(hr == S_OK, "IAMMultiMediaStream_Initialize returned: %x\n", hr);
@@ -1604,7 +1484,6 @@ static void test_media_streams(void)
     if (media_stream_filter)
         IMediaStreamFilter_Release(media_stream_filter);
 
-    release_directdraw();
     IAMMultiMediaStream_Release(pams);
 }
 
@@ -5906,7 +5785,6 @@ START_TEST(amstream)
 
     test_openfile(test_avi_path);
     test_mmstream_get_duration(test_avi_path);
-    test_renderfile(test_avi_path);
 
     unload_resource(test_avi_path);
 
From e8bb3dbb7bcf22b9dcb7a136ad8b6b2c5f70b99d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 4 Sep 2020 17:21:41 -0500
Subject: [PATCH] qcap/avimux: Pass the correct field to CONTAINING_RECORD in
 impl_sink_from_strmbase_pin().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/avimux.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/qcap/avimux.c b/dlls/qcap/avimux.c
index ea73e420404..3f4d0f2cd6e 100644
--- a/dlls/qcap/avimux.c
+++ b/dlls/qcap/avimux.c
@@ -1257,7 +1257,7 @@ static const IQualityControlVtbl AviMuxOut_QualityControlVtbl = {
 
 static inline AviMuxIn *impl_sink_from_strmbase_pin(struct strmbase_pin *iface)
 {
-    return CONTAINING_RECORD(iface, AviMuxIn, pin.pin.IPin_iface);
+    return CONTAINING_RECORD(iface, AviMuxIn, pin.pin);
 }
 
 static HRESULT sink_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
From 7f86a153f18c4bbac74f6a1353db4dd819cf0b20 Mon Sep 17 00:00:00 2001
From: Jeff Smith <whydoubt@gmail.com>
Date: Tue, 8 Sep 2020 11:15:08 -0500
Subject: [PATCH] qcap/tests: Test effect of setting stream format on media
 type enumeration.

Signed-off-by: Jeff Smith <whydoubt@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/tests/videocapture.c | 61 ++++++++++++++++++++++++++++------
 1 file changed, 50 insertions(+), 11 deletions(-)

diff --git a/dlls/qcap/tests/videocapture.c b/dlls/qcap/tests/videocapture.c
index 326601a398c..8bda036e1d9 100644
--- a/dlls/qcap/tests/videocapture.c
+++ b/dlls/qcap/tests/videocapture.c
@@ -23,6 +23,12 @@
 #include "wine/test.h"
 #include "wine/strmbase.h"
 
+static BOOL compare_media_types(const AM_MEDIA_TYPE *a, const AM_MEDIA_TYPE *b)
+{
+    return !memcmp(a, b, offsetof(AM_MEDIA_TYPE, pbFormat))
+            && !memcmp(a->pbFormat, b->pbFormat, a->cbFormat);
+}
+
 #define check_interface(a, b, c) check_interface_(__LINE__, a, b, c)
 static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOOL supported)
 {
@@ -78,11 +84,11 @@ static void test_media_types(IPin *pin)
 static void test_stream_config(IPin *pin)
 {
     VIDEOINFOHEADER *video_info, *video_info2;
+    LONG depth, compression, count, size, i;
+    IEnumMediaTypes *enum_media_types;
     AM_MEDIA_TYPE *format, *format2;
-    VIDEO_STREAM_CONFIG_CAPS vscc;
     IAMStreamConfig *stream_config;
-    LONG depth, compression;
-    LONG count, size;
+    VIDEO_STREAM_CONFIG_CAPS vscc;
     HRESULT hr;
 
     hr = IPin_QueryInterface(pin, &IID_IAMStreamConfig, (void **)&stream_config);
@@ -96,6 +102,16 @@ static void test_stream_config(IPin *pin)
     hr = IAMStreamConfig_SetFormat(stream_config, format);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
+    /* After setting the format, a single media type is enumerated.
+     * This persists until the filter is released. */
+    IPin_EnumMediaTypes(pin, &enum_media_types);
+    hr = IEnumMediaTypes_Next(enum_media_types, 1, &format2, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    DeleteMediaType(format2);
+    hr = IEnumMediaTypes_Next(enum_media_types, 1, &format2, NULL);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    IEnumMediaTypes_Release(enum_media_types);
+
     format->majortype = MEDIATYPE_Audio;
     hr = IAMStreamConfig_SetFormat(stream_config, format);
     ok(hr == E_FAIL, "Got hr %#x.\n", hr);
@@ -162,14 +178,37 @@ static void test_stream_config(IPin *pin)
     hr = IAMStreamConfig_GetStreamCaps(stream_config, 100000, &format, (BYTE *)&vscc);
     ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
-    hr = IAMStreamConfig_GetStreamCaps(stream_config, 0, &format, (BYTE *)&vscc);
-    ok(hr == S_OK, "Got hr %#x.\n", hr);
-    ok(IsEqualGUID(&format->majortype, &MEDIATYPE_Video), "Got wrong majortype: %s.\n",
-            debugstr_guid(&MEDIATYPE_Video));
-    ok(IsEqualGUID(&vscc.guid, &FORMAT_VideoInfo)
-            || IsEqualGUID(&vscc.guid, &FORMAT_VideoInfo2), "Got wrong guid: %s.\n",
-            debugstr_guid(&vscc.guid));
-    FreeMediaType(format);
+    for (i = 0; i < count; ++i)
+    {
+        hr = IAMStreamConfig_GetStreamCaps(stream_config, i, &format, (BYTE *)&vscc);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(IsEqualGUID(&format->majortype, &MEDIATYPE_Video), "Got wrong majortype: %s.\n",
+                debugstr_guid(&MEDIATYPE_Video));
+        ok(IsEqualGUID(&vscc.guid, &FORMAT_VideoInfo)
+                || IsEqualGUID(&vscc.guid, &FORMAT_VideoInfo2), "Got wrong guid: %s.\n",
+                debugstr_guid(&vscc.guid));
+
+        hr = IAMStreamConfig_SetFormat(stream_config, format);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+        hr = IAMStreamConfig_GetFormat(stream_config, &format2);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(compare_media_types(format, format2), "Media types didn't match.\n");
+        DeleteMediaType(format2);
+
+        hr = IPin_EnumMediaTypes(pin, &enum_media_types);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        hr = IEnumMediaTypes_Next(enum_media_types, 1, &format2, NULL);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+        todo_wine_if (!compare_media_types(format, format2))
+            ok(compare_media_types(format, format2), "Media types didn't match.\n");
+
+        DeleteMediaType(format2);
+        IEnumMediaTypes_Release(enum_media_types);
+
+        DeleteMediaType(format);
+    }
 
     IAMStreamConfig_Release(stream_config);
 }
From 3757956e8fcec56fe536068770c45dd2894646c6 Mon Sep 17 00:00:00 2001
From: Jeff Smith <whydoubt@gmail.com>
Date: Tue, 8 Sep 2020 11:15:09 -0500
Subject: [PATCH] qcap: Calculate image size and pitch when setting format.

Signed-off-by: Jeff Smith <whydoubt@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/v4l.c | 30 +++++++++++-------------------
 1 file changed, 11 insertions(+), 19 deletions(-)

diff --git a/dlls/qcap/v4l.c b/dlls/qcap/v4l.c
index d8c5e168e14..94fe6b7dd0d 100644
--- a/dlls/qcap/v4l.c
+++ b/dlls/qcap/v4l.c
@@ -96,6 +96,8 @@ struct v4l_device
     struct caps *caps;
     LONG caps_count;
 
+    int image_size, image_pitch;
+
     struct strmbase_source *pin;
     int fd, mmap;
 
@@ -194,6 +196,8 @@ static BOOL set_caps(struct v4l_device *device, const struct caps *caps)
     }
 
     device->current_caps = caps;
+    device->image_size = width * height * caps->video_info.bmiHeader.biBitCount / 8;
+    device->image_pitch = width * caps->video_info.bmiHeader.biBitCount / 8;
 
     return TRUE;
 }
@@ -304,15 +308,11 @@ static HRESULT v4l_device_set_prop(struct video_capture_device *iface,
 static void reverse_image(struct v4l_device *device, LPBYTE output, const BYTE *input)
 {
     int inoffset, outoffset, pitch;
-    UINT width, height, depth;
 
-    width = device->current_caps->video_info.bmiHeader.biWidth;
-    height = device->current_caps->video_info.bmiHeader.biHeight;
-    depth = device->current_caps->video_info.bmiHeader.biBitCount / 8;
     /* the whole image needs to be reversed,
        because the dibs are messed up in windows */
-    outoffset = width * height * depth;
-    pitch = width * depth;
+    outoffset = device->image_size;
+    pitch = device->image_pitch;
     inoffset = 0;
     while (outoffset > 0)
     {
@@ -330,14 +330,8 @@ static DWORD WINAPI ReadThread(void *arg)
     HRESULT hr;
     IMediaSample *pSample = NULL;
     unsigned char *pTarget, *image_data;
-    unsigned int image_size;
-    UINT width, height, depth;
-
-    width = device->current_caps->video_info.bmiHeader.biWidth;
-    height = device->current_caps->video_info.bmiHeader.biHeight;
-    depth = device->current_caps->video_info.bmiHeader.biBitCount / 8;
-    image_size = width * height * depth;
-    if (!(image_data = heap_alloc(image_size)))
+
+    if (!(image_data = heap_alloc(device->image_size)))
     {
         ERR("Failed to allocate memory.\n");
         return 0;
@@ -363,15 +357,14 @@ static DWORD WINAPI ReadThread(void *arg)
         {
             int len;
             
-            len = width * height * depth;
-            IMediaSample_SetActualDataLength(pSample, len);
+            IMediaSample_SetActualDataLength(pSample, device->image_size);
 
             len = IMediaSample_GetActualDataLength(pSample);
             TRACE("Data length: %d KB\n", len / 1024);
 
             IMediaSample_GetPointer(pSample, &pTarget);
 
-            while (video_read(device->fd, image_data, image_size) == -1)
+            while (video_read(device->fd, image_data, device->image_size) == -1)
             {
                 if (errno != EAGAIN)
                 {
@@ -403,8 +396,7 @@ static void v4l_device_init_stream(struct video_capture_device *iface)
     HRESULT hr;
 
     req_props.cBuffers = 3;
-    req_props.cbBuffer = device->current_caps->video_info.bmiHeader.biWidth * device->current_caps->video_info.bmiHeader.biHeight;
-    req_props.cbBuffer = (req_props.cbBuffer * device->current_caps->video_info.bmiHeader.biBitCount) / 8;
+    req_props.cbBuffer = device->image_size;
     req_props.cbAlign = 1;
     req_props.cbPrefix = 0;
 
From 7712a48c8907059426ddb78a47184b2d218d822b Mon Sep 17 00:00:00 2001
From: Jeff Smith <whydoubt@gmail.com>
Date: Tue, 8 Sep 2020 11:15:10 -0500
Subject: [PATCH] qcap: Enumerate one media type if pin format has been set.

Signed-off-by: Jeff Smith <whydoubt@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qcap/qcap_private.h       |  1 +
 dlls/qcap/tests/videocapture.c |  7 ++-----
 dlls/qcap/v4l.c                | 16 ++++++++++++++++
 dlls/qcap/vfwcapture.c         | 15 ++-------------
 4 files changed, 21 insertions(+), 18 deletions(-)

diff --git a/dlls/qcap/qcap_private.h b/dlls/qcap/qcap_private.h
index 70a8c85ad47..bbbe2ef43ec 100644
--- a/dlls/qcap/qcap_private.h
+++ b/dlls/qcap/qcap_private.h
@@ -51,6 +51,7 @@ struct video_capture_device_ops
     HRESULT (*check_format)(struct video_capture_device *device, const AM_MEDIA_TYPE *mt);
     HRESULT (*set_format)(struct video_capture_device *device, const AM_MEDIA_TYPE *mt);
     HRESULT (*get_format)(struct video_capture_device *device, AM_MEDIA_TYPE *mt);
+    HRESULT (*get_media_type)(struct video_capture_device *device, unsigned int index, AM_MEDIA_TYPE *mt);
     HRESULT (*get_caps)(struct video_capture_device *device, LONG index, AM_MEDIA_TYPE **mt, VIDEO_STREAM_CONFIG_CAPS *caps);
     LONG (*get_caps_count)(struct video_capture_device *device);
     HRESULT (*get_prop_range)(struct video_capture_device *device, VideoProcAmpProperty property,
diff --git a/dlls/qcap/tests/videocapture.c b/dlls/qcap/tests/videocapture.c
index 8bda036e1d9..e8175f5df9a 100644
--- a/dlls/qcap/tests/videocapture.c
+++ b/dlls/qcap/tests/videocapture.c
@@ -109,7 +109,7 @@ static void test_stream_config(IPin *pin)
     ok(hr == S_OK, "Got hr %#x.\n", hr);
     DeleteMediaType(format2);
     hr = IEnumMediaTypes_Next(enum_media_types, 1, &format2, NULL);
-    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     IEnumMediaTypes_Release(enum_media_types);
 
     format->majortype = MEDIATYPE_Audio;
@@ -200,10 +200,7 @@ static void test_stream_config(IPin *pin)
         ok(hr == S_OK, "Got hr %#x.\n", hr);
         hr = IEnumMediaTypes_Next(enum_media_types, 1, &format2, NULL);
         ok(hr == S_OK, "Got hr %#x.\n", hr);
-
-        todo_wine_if (!compare_media_types(format, format2))
-            ok(compare_media_types(format, format2), "Media types didn't match.\n");
-
+        ok(compare_media_types(format, format2), "Media types didn't match.\n");
         DeleteMediaType(format2);
         IEnumMediaTypes_Release(enum_media_types);
 
diff --git a/dlls/qcap/v4l.c b/dlls/qcap/v4l.c
index 94fe6b7dd0d..b1d7e68d426 100644
--- a/dlls/qcap/v4l.c
+++ b/dlls/qcap/v4l.c
@@ -227,6 +227,21 @@ static HRESULT v4l_device_get_format(struct video_capture_device *iface, AM_MEDI
     return CopyMediaType(mt, &device->current_caps->media_type);
 }
 
+static HRESULT v4l_device_get_media_type(struct video_capture_device *iface,
+        unsigned int index, AM_MEDIA_TYPE *mt)
+{
+    struct v4l_device *device = v4l_device(iface);
+    unsigned int caps_count = (device->current_caps) ? 1 : device->caps_count;
+
+    if (index >= caps_count)
+        return VFW_S_NO_MORE_ITEMS;
+
+    if (device->current_caps)
+        return CopyMediaType(mt, &device->current_caps->media_type);
+
+    return CopyMediaType(mt, &device->caps[index].media_type);
+}
+
 static __u32 v4l2_cid_from_qcap_property(VideoProcAmpProperty property)
 {
     switch (property)
@@ -515,6 +530,7 @@ static const struct video_capture_device_ops v4l_device_ops =
     .check_format = v4l_device_check_format,
     .set_format = v4l_device_set_format,
     .get_format = v4l_device_get_format,
+    .get_media_type = v4l_device_get_media_type,
     .get_caps = v4l_device_get_caps,
     .get_caps_count = v4l_device_get_caps_count,
     .get_prop_range = v4l_device_get_prop_range,
diff --git a/dlls/qcap/vfwcapture.c b/dlls/qcap/vfwcapture.c
index 910be107b0b..c4df4cb1c81 100644
--- a/dlls/qcap/vfwcapture.c
+++ b/dlls/qcap/vfwcapture.c
@@ -521,21 +521,10 @@ static HRESULT source_query_accept(struct strmbase_pin *pin, const AM_MEDIA_TYPE
 }
 
 static HRESULT source_get_media_type(struct strmbase_pin *pin,
-        unsigned int index, AM_MEDIA_TYPE *pmt)
+        unsigned int index, AM_MEDIA_TYPE *mt)
 {
     VfwCapture *filter = impl_from_strmbase_pin(pin);
-    AM_MEDIA_TYPE *vfw_pmt;
-    HRESULT hr;
-
-    if (index >= filter->device->ops->get_caps_count(filter->device))
-        return VFW_S_NO_MORE_ITEMS;
-
-    if (SUCCEEDED(hr = filter->device->ops->get_caps(filter->device, index, &vfw_pmt, NULL)))
-    {
-        CopyMediaType(pmt, vfw_pmt);
-        DeleteMediaType(vfw_pmt);
-    }
-    return hr;
+    return filter->device->ops->get_media_type(filter->device, index, mt);
 }
 
 static HRESULT source_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
From 4765c5ffe2ad42be97ce29e09a6a5c01d5672f60 Mon Sep 17 00:00:00 2001
From: Pengpeng Dong <dongpengpeng@uniontech.com>
Date: Wed, 9 Sep 2020 10:07:18 -0500
Subject: [PATCH] quartz: Return E_POINTER from IVideoWindow::get_Visible() if
 "visible" is NULL.

Signed-off-by: Pengpeng Dong <dongpengpeng@uniontech.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/videorenderer.c | 3 +++
 dlls/quartz/window.c              | 3 +++
 2 files changed, 6 insertions(+)

diff --git a/dlls/quartz/tests/videorenderer.c b/dlls/quartz/tests/videorenderer.c
index c2b6271021a..448efe501b6 100644
--- a/dlls/quartz/tests/videorenderer.c
+++ b/dlls/quartz/tests/videorenderer.c
@@ -2257,6 +2257,9 @@ static void test_video_window(void)
     hr = IBaseFilter_QueryInterface(filter, &IID_IVideoWindow, (void **)&window);
     ok(hr == S_OK, "Got hr %#x.\n", hr);
 
+    hr = IVideoWindow_get_Visible(window, NULL);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
+
     hr = IVideoWindow_get_Caption(window, &caption);
     todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
diff --git a/dlls/quartz/window.c b/dlls/quartz/window.c
index 07e042eccdb..3983d43b08f 100644
--- a/dlls/quartz/window.c
+++ b/dlls/quartz/window.c
@@ -334,6 +334,9 @@ HRESULT WINAPI BaseControlWindowImpl_get_Visible(IVideoWindow *iface, LONG *visi
 
     TRACE("window %p, visible %p.\n", window, visible);
 
+    if (!visible)
+        return E_POINTER;
+
     *visible = IsWindowVisible(window->hwnd) ? OATRUE : OAFALSE;
     return S_OK;
 }
From 3f712c1d43122c120eee23fb980a631942fc9e78 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 10 Sep 2020 02:17:35 +0700
Subject: [PATCH] amstream: Implement AMDirectDrawStream::GetFormat.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    | 111 ++++++++++++-
 dlls/amstream/tests/amstream.c | 279 +++++++++++++++++++++++++++++++++
 2 files changed, 382 insertions(+), 8 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 0d3f2d0d4b8..e33dac58d94 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -28,6 +28,14 @@ WINE_DEFAULT_DEBUG_CHANNEL(amstream);
 
 static const WCHAR sink_id[] = L"I{A35FF56A-9FDA-11D0-8FDF-00C04FD9189D}";
 
+struct format
+{
+    DWORD flags;
+    DWORD width;
+    DWORD height;
+    DDPIXELFORMAT pf;
+};
+
 struct ddraw_stream
 {
     IAMMediaStream IAMMediaStream_iface;
@@ -47,6 +55,7 @@ struct ddraw_stream
     IPin *peer;
     IMemAllocator *allocator;
     AM_MEDIA_TYPE mt;
+    struct format format;
 };
 
 static HRESULT ddrawstreamsample_create(struct ddraw_stream *parent, IDirectDrawSurface *surface,
@@ -363,11 +372,46 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetFormat(IDirectDrawMediaStr
         DDSURFACEDESC *current_format, IDirectDrawPalette **palette,
         DDSURFACEDESC *desired_format, DWORD *flags)
 {
-    FIXME("(%p)->(%p,%p,%p,%p) stub!\n", iface, current_format, palette, desired_format,
-            flags);
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+
+    TRACE("stream %p, current_format %p, palette %p, desired_format %p, flags %p.\n", stream, current_format, palette,
+            desired_format, flags);
 
-    return MS_E_NOSTREAM;
+    EnterCriticalSection(&stream->cs);
+
+    if (!stream->peer)
+    {
+        LeaveCriticalSection(&stream->cs);
+        return MS_E_NOSTREAM;
+    }
+
+    if (current_format)
+    {
+        current_format->dwFlags = stream->format.flags | DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS;
+        current_format->dwWidth = stream->format.width;
+        current_format->dwHeight = stream->format.height;
+        current_format->ddpfPixelFormat = stream->format.pf;
+        current_format->ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY | DDSCAPS_OFFSCREENPLAIN;
+    }
+
+    if (palette)
+        *palette = NULL;
+
+    if (desired_format)
+    {
+        desired_format->dwFlags = DDSD_WIDTH | DDSD_HEIGHT;
+        desired_format->dwWidth = stream->format.width;
+        desired_format->dwHeight = stream->format.height;
+        desired_format->ddpfPixelFormat = stream->format.pf;
+        desired_format->ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY | DDSCAPS_OFFSCREENPLAIN;
+    }
+
+    if (flags)
+        *flags = 0;
+
+    LeaveCriticalSection(&stream->cs);
 
+    return S_OK;
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SetFormat(IDirectDrawMediaStream *iface,
@@ -638,7 +682,11 @@ static HRESULT WINAPI ddraw_sink_Connect(IPin *iface, IPin *peer, const AM_MEDIA
 static HRESULT WINAPI ddraw_sink_ReceiveConnection(IPin *iface, IPin *peer, const AM_MEDIA_TYPE *mt)
 {
     struct ddraw_stream *stream = impl_from_IPin(iface);
+    const VIDEOINFOHEADER *video_info;
     PIN_DIRECTION dir;
+    DWORD width;
+    DWORD height;
+    DDPIXELFORMAT pf = {sizeof(DDPIXELFORMAT)};
 
     TRACE("stream %p, peer %p, mt %p.\n", stream, peer, mt);
 
@@ -651,17 +699,56 @@ static HRESULT WINAPI ddraw_sink_ReceiveConnection(IPin *iface, IPin *peer, cons
     }
 
     if (!IsEqualGUID(&mt->majortype, &MEDIATYPE_Video)
-            || (!IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB8)
-                && !IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB24)
-                && !IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB32)
-                && !IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB555)
-                && !IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB565))
             || !IsEqualGUID(&mt->formattype, &FORMAT_VideoInfo))
     {
         LeaveCriticalSection(&stream->cs);
         return VFW_E_TYPE_NOT_ACCEPTED;
     }
 
+    video_info = (const VIDEOINFOHEADER *)mt->pbFormat;
+
+    width = video_info->bmiHeader.biWidth;
+    height = abs(video_info->bmiHeader.biHeight);
+    pf.dwFlags = DDPF_RGB;
+    if (IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB8))
+    {
+        pf.dwFlags |= DDPF_PALETTEINDEXED8;
+        pf.u1.dwRGBBitCount = 8;
+    }
+    else if (IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB555))
+    {
+        pf.u1.dwRGBBitCount = 16;
+        pf.u2.dwRBitMask = 0x7c00;
+        pf.u3.dwGBitMask = 0x03e0;
+        pf.u4.dwBBitMask = 0x001f;
+    }
+    else if (IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB565))
+    {
+        pf.u1.dwRGBBitCount = 16;
+        pf.u2.dwRBitMask = 0xf800;
+        pf.u3.dwGBitMask = 0x07e0;
+        pf.u4.dwBBitMask = 0x001f;
+    }
+    else if (IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB24))
+    {
+        pf.u1.dwRGBBitCount = 24;
+        pf.u2.dwRBitMask = 0xff0000;
+        pf.u3.dwGBitMask = 0x00ff00;
+        pf.u4.dwBBitMask = 0x0000ff;
+    }
+    else if (IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_RGB32))
+    {
+        pf.u1.dwRGBBitCount = 32;
+        pf.u2.dwRBitMask = 0xff0000;
+        pf.u3.dwGBitMask = 0x00ff00;
+        pf.u4.dwBBitMask = 0x0000ff;
+    }
+    else
+    {
+        LeaveCriticalSection(&stream->cs);
+        return VFW_E_TYPE_NOT_ACCEPTED;
+    }
+
     IPin_QueryDirection(peer, &dir);
     if (dir != PINDIR_OUTPUT)
     {
@@ -673,6 +760,11 @@ static HRESULT WINAPI ddraw_sink_ReceiveConnection(IPin *iface, IPin *peer, cons
     CopyMediaType(&stream->mt, mt);
     IPin_AddRef(stream->peer = peer);
 
+    stream->format.width = width;
+    stream->format.height = height;
+    if (!(stream->format.flags & DDSD_PIXELFORMAT))
+        stream->format.pf = pf;
+
     LeaveCriticalSection(&stream->cs);
 
     return S_OK;
@@ -981,6 +1073,9 @@ HRESULT ddraw_stream_create(IUnknown *outer, void **out)
     object->IPin_iface.lpVtbl = &ddraw_sink_vtbl;
     object->ref = 1;
 
+    object->format.width = 100;
+    object->format.height = 100;
+
     InitializeCriticalSection(&object->cs);
 
     TRACE("Created ddraw stream %p.\n", object);
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index b9b40921977..cb3604c65cb 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -51,6 +51,164 @@ static const AM_MEDIA_TYPE audio_mt =
     .pbFormat = (BYTE *)&audio_format,
 };
 
+static const VIDEOINFO rgb8_video_info =
+{
+    .bmiHeader.biSize = sizeof(BITMAPINFOHEADER),
+    .bmiHeader.biWidth = 333,
+    .bmiHeader.biHeight = -444,
+    .bmiHeader.biPlanes = 1,
+    .bmiHeader.biBitCount = 8,
+    .bmiHeader.biCompression = BI_RGB,
+};
+
+static const VIDEOINFO rgb555_video_info =
+{
+    .bmiHeader.biSize = sizeof(BITMAPINFOHEADER),
+    .bmiHeader.biWidth = 333,
+    .bmiHeader.biHeight = -444,
+    .bmiHeader.biPlanes = 1,
+    .bmiHeader.biBitCount = 16,
+    .bmiHeader.biCompression = BI_RGB,
+};
+
+static const VIDEOINFO rgb565_video_info =
+{
+    .bmiHeader.biSize = sizeof(BITMAPINFOHEADER),
+    .bmiHeader.biWidth = 333,
+    .bmiHeader.biHeight = -444,
+    .bmiHeader.biPlanes = 1,
+    .bmiHeader.biBitCount = 16,
+    .bmiHeader.biCompression = BI_BITFIELDS,
+    .dwBitMasks = {0xf800, 0x07e0, 0x001f},
+};
+
+static const VIDEOINFO rgb24_video_info =
+{
+    .bmiHeader.biSize = sizeof(BITMAPINFOHEADER),
+    .bmiHeader.biWidth = 333,
+    .bmiHeader.biHeight = -444,
+    .bmiHeader.biPlanes = 1,
+    .bmiHeader.biBitCount = 24,
+    .bmiHeader.biCompression = BI_RGB,
+};
+
+static const VIDEOINFO rgb32_video_info =
+{
+    .bmiHeader.biSize = sizeof(BITMAPINFOHEADER),
+    .bmiHeader.biWidth = 333,
+    .bmiHeader.biHeight = -444,
+    .bmiHeader.biPlanes = 1,
+    .bmiHeader.biBitCount = 32,
+    .bmiHeader.biCompression = BI_RGB,
+};
+
+static const AM_MEDIA_TYPE rgb8_mt =
+{
+    /* MEDIATYPE_Video, MEDIASUBTYPE_RGB8, FORMAT_VideoInfo */
+    .majortype = {0x73646976, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}},
+    .subtype = {0xe436eb7a, 0x524f, 0x11ce, {0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70}},
+    .formattype = {0x05589f80, 0xc356, 0x11ce, {0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a}},
+    .cbFormat = sizeof(VIDEOINFO),
+    .pbFormat = (BYTE *)&rgb8_video_info,
+};
+
+static const AM_MEDIA_TYPE rgb555_mt =
+{
+    /* MEDIATYPE_Video, MEDIASUBTYPE_RGB555, FORMAT_VideoInfo */
+    .majortype = {0x73646976, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}},
+    .subtype = {0xe436eb7c, 0x524f, 0x11ce, {0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70}},
+    .formattype = {0x05589f80, 0xc356, 0x11ce, {0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a}},
+    .cbFormat = sizeof(VIDEOINFO),
+    .pbFormat = (BYTE *)&rgb555_video_info,
+};
+
+static const AM_MEDIA_TYPE rgb565_mt =
+{
+    /* MEDIATYPE_Video, MEDIASUBTYPE_RGB565, FORMAT_VideoInfo */
+    .majortype = {0x73646976, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}},
+    .subtype = {0xe436eb7b, 0x524f, 0x11ce, {0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70}},
+    .formattype = {0x05589f80, 0xc356, 0x11ce, {0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a}},
+    .cbFormat = sizeof(VIDEOINFO),
+    .pbFormat = (BYTE *)&rgb565_video_info,
+};
+
+static const AM_MEDIA_TYPE rgb24_mt =
+{
+    /* MEDIATYPE_Video, MEDIASUBTYPE_RGB24, FORMAT_VideoInfo */
+    .majortype = {0x73646976, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}},
+    .subtype = {0xe436eb7d, 0x524f, 0x11ce, {0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70}},
+    .formattype = {0x05589f80, 0xc356, 0x11ce, {0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a}},
+    .cbFormat = sizeof(VIDEOINFO),
+    .pbFormat = (BYTE *)&rgb24_video_info,
+};
+
+static const AM_MEDIA_TYPE rgb32_mt =
+{
+    /* MEDIATYPE_Video, MEDIASUBTYPE_RGB32, FORMAT_VideoInfo */
+    .majortype = {0x73646976, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}},
+    .subtype = {0xe436eb7e, 0x524f, 0x11ce, {0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70}},
+    .formattype = {0x05589f80, 0xc356, 0x11ce, {0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a}},
+    .cbFormat = sizeof(VIDEOINFO),
+    .pbFormat = (BYTE *)&rgb32_video_info,
+};
+
+static const DDSURFACEDESC rgb8_format =
+{
+    .dwSize = sizeof(DDSURFACEDESC),
+    .dwFlags = DDSD_PIXELFORMAT,
+    .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+    .ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_PALETTEINDEXED8,
+    .ddpfPixelFormat.dwRGBBitCount = 8,
+};
+
+static const DDSURFACEDESC rgb555_format =
+{
+    .dwSize = sizeof(DDSURFACEDESC),
+    .dwFlags = DDSD_PIXELFORMAT,
+    .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+    .ddpfPixelFormat.dwFlags = DDPF_RGB,
+    .ddpfPixelFormat.dwRGBBitCount = 16,
+    .ddpfPixelFormat.dwRBitMask = 0x7c00,
+    .ddpfPixelFormat.dwGBitMask = 0x03e0,
+    .ddpfPixelFormat.dwBBitMask = 0x001f,
+};
+
+static const DDSURFACEDESC rgb565_format =
+{
+    .dwSize = sizeof(DDSURFACEDESC),
+    .dwFlags = DDSD_PIXELFORMAT,
+    .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+    .ddpfPixelFormat.dwFlags = DDPF_RGB,
+    .ddpfPixelFormat.dwRGBBitCount = 16,
+    .ddpfPixelFormat.dwRBitMask = 0xf800,
+    .ddpfPixelFormat.dwGBitMask = 0x07e0,
+    .ddpfPixelFormat.dwBBitMask = 0x001f,
+};
+
+static const DDSURFACEDESC rgb24_format =
+{
+    .dwSize = sizeof(DDSURFACEDESC),
+    .dwFlags = DDSD_PIXELFORMAT,
+    .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+    .ddpfPixelFormat.dwFlags = DDPF_RGB,
+    .ddpfPixelFormat.dwRGBBitCount = 24,
+    .ddpfPixelFormat.dwRBitMask = 0xff0000,
+    .ddpfPixelFormat.dwGBitMask = 0x00ff00,
+    .ddpfPixelFormat.dwBBitMask = 0x0000ff,
+};
+
+static const DDSURFACEDESC rgb32_format =
+{
+    .dwSize = sizeof(DDSURFACEDESC),
+    .dwFlags = DDSD_PIXELFORMAT,
+    .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+    .ddpfPixelFormat.dwFlags = DDPF_RGB,
+    .ddpfPixelFormat.dwRGBBitCount = 32,
+    .ddpfPixelFormat.dwRBitMask = 0xff0000,
+    .ddpfPixelFormat.dwGBitMask = 0x00ff00,
+    .ddpfPixelFormat.dwBBitMask = 0x0000ff,
+};
+
 static const WCHAR primary_video_sink_id[] = L"I{A35FF56A-9FDA-11D0-8FDF-00C04FD9189D}";
 static const WCHAR primary_audio_sink_id[] = L"I{A35FF56B-9FDA-11D0-8FDF-00C04FD9189D}";
 
@@ -4354,6 +4512,126 @@ static void test_ddrawstream_initialize(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+#define check_ddrawstream_get_format(a,b,c) check_ddrawstream_get_format_(__LINE__,a,b,c)
+static void check_ddrawstream_get_format_(int line, IDirectDrawMediaStream *stream,
+        const AM_MEDIA_TYPE *mt, const DDSURFACEDESC *expected_format)
+{
+    DDSURFACEDESC current_format;
+    DDSURFACEDESC desired_format;
+    struct testfilter source;
+    FILTER_INFO filter_info;
+    DDSURFACEDESC format;
+    PIN_INFO pin_info;
+    DWORD flags;
+    HRESULT hr;
+    IPin *pin;
+
+    hr = IDirectDrawMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IPin_QueryPinInfo(pin, &pin_info);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IBaseFilter_QueryFilterInfo(pin_info.pFilter, &filter_info);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    testfilter_init(&source);
+
+    hr = IFilterGraph_AddFilter(filter_info.pGraph, &source.filter.IBaseFilter_iface, L"source");
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IFilterGraph_ConnectDirect(filter_info.pGraph, &source.source.pin.IPin_iface, pin, mt);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawMediaStream_GetFormat(stream, NULL, NULL, NULL, NULL);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    memset(&current_format, 0xcc, sizeof(current_format));
+    current_format.dwSize = sizeof(current_format);
+    memset(&desired_format, 0xcc, sizeof(desired_format));
+    desired_format.dwSize = sizeof(desired_format);
+    flags = 0xdeadbeef;
+    hr = IDirectDrawMediaStream_GetFormat(stream, &current_format, NULL, &desired_format, &flags);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    memset(&format, 0xcc, sizeof(format));
+    format.dwSize = sizeof(format);
+    format.ddpfPixelFormat = expected_format->ddpfPixelFormat;
+    format.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS;
+    format.dwWidth = 333;
+    format.dwHeight = 444;
+    format.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
+    ok_(__FILE__, line)(memcmp(&current_format, &format, sizeof(DDSURFACEDESC)) == 0, "Current format didn't match.\n");
+    format.dwFlags = DDSD_WIDTH | DDSD_HEIGHT;
+    ok_(__FILE__, line)(memcmp(&desired_format, &format, sizeof(DDSURFACEDESC)) == 0, "Desired format didn't match.\n");
+
+    hr = IFilterGraph_Disconnect(filter_info.pGraph, &source.source.pin.IPin_iface);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IFilterGraph_Disconnect(filter_info.pGraph, pin);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IFilterGraph_RemoveFilter(filter_info.pGraph, &source.filter.IBaseFilter_iface);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    IFilterGraph_Release(filter_info.pGraph);
+    IBaseFilter_Release(pin_info.pFilter);
+    IPin_Release(pin);
+}
+
+static void test_ddrawstream_get_format(void)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IDirectDrawMediaStream *ddraw_stream;
+    DDSURFACEDESC current_format;
+    DDSURFACEDESC desired_format;
+    IDirectDrawPalette *palette;
+    IMediaStream *stream;
+    VIDEOINFO video_info;
+    AM_MEDIA_TYPE mt;
+    DWORD flags;
+    HRESULT hr;
+    ULONG ref;
+
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryVideo, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (void **)&ddraw_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    current_format.dwSize = sizeof(current_format);
+    desired_format.dwSize = sizeof(desired_format);
+    hr = IDirectDrawMediaStream_GetFormat(ddraw_stream, &current_format, &palette, &desired_format, &flags);
+    ok(hr == MS_E_NOSTREAM, "Got hr %#x.\n", hr);
+
+    video_info = rgb32_video_info;
+    video_info.rcSource.right = 222;
+    video_info.rcSource.bottom = 333;
+    video_info.rcTarget.right = 444;
+    video_info.rcTarget.bottom = 666;
+    mt = rgb32_mt;
+    mt.pbFormat = (BYTE *)&video_info;
+    check_ddrawstream_get_format(ddraw_stream, &mt, &rgb32_format);
+
+    video_info = rgb32_video_info;
+    video_info.bmiHeader.biHeight = 444;
+    mt = rgb32_mt;
+    mt.pbFormat = (BYTE *)&video_info;
+    check_ddrawstream_get_format(ddraw_stream, &mt, &rgb32_format);
+
+    check_ddrawstream_get_format(ddraw_stream, &rgb8_mt, &rgb8_format);
+    check_ddrawstream_get_format(ddraw_stream, &rgb555_mt, &rgb555_format);
+    check_ddrawstream_get_format(ddraw_stream, &rgb565_mt, &rgb565_format);
+    check_ddrawstream_get_format(ddraw_stream, &rgb24_mt, &rgb24_format);
+    check_ddrawstream_get_format(ddraw_stream, &rgb32_mt, &rgb32_format);
+
+    current_format.dwSize = sizeof(current_format);
+    desired_format.dwSize = sizeof(desired_format);
+    hr = IDirectDrawMediaStream_GetFormat(ddraw_stream, &current_format, &palette, &desired_format, &flags);
+    ok(hr == MS_E_NOSTREAM, "Got hr %#x.\n", hr);
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IDirectDrawMediaStream_Release(ddraw_stream);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void check_ammediastream_join_am_multi_media_stream(const CLSID *clsid)
 {
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
@@ -5815,6 +6093,7 @@ START_TEST(amstream)
     test_ddrawstream_getsetdirectdraw();
     test_ddrawstream_receive_connection();
     test_ddrawstream_create_sample();
+    test_ddrawstream_get_format();
 
     test_ddrawstreamsample_get_media_stream();
 
From 8c1204ffeeb68829a1dac9594e301cb1dd36df85 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 10 Sep 2020 02:17:36 +0700
Subject: [PATCH] amstream: Implement AMDirectDrawStream::SetFormat.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    |  81 ++++++++++-
 dlls/amstream/tests/amstream.c | 258 +++++++++++++++++++++++++++++++++
 2 files changed, 336 insertions(+), 3 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index e33dac58d94..542c315930d 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -415,11 +415,86 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetFormat(IDirectDrawMediaStr
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SetFormat(IDirectDrawMediaStream *iface,
-        const DDSURFACEDESC *pDDSurfaceDesc, IDirectDrawPalette *pDirectDrawPalette)
+        const DDSURFACEDESC *format, IDirectDrawPalette *palette)
 {
-    FIXME("(%p)->(%p,%p) stub!\n", iface, pDDSurfaceDesc, pDirectDrawPalette);
+    struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
 
-    return E_NOTIMPL;
+    TRACE("stream %p, format %p, palette %p.\n", stream, format, palette);
+
+    if (palette)
+        FIXME("Setting palette is not yet supported.\n");
+
+    if (!format)
+        return E_POINTER;
+
+    if (format->dwSize != sizeof(DDSURFACEDESC))
+        return E_INVALIDARG;
+
+    if (format->dwFlags & DDSD_PIXELFORMAT)
+    {
+        if (format->ddpfPixelFormat.dwSize != sizeof(DDPIXELFORMAT))
+            return DDERR_INVALIDSURFACETYPE;
+
+        if (format->ddpfPixelFormat.dwFlags & DDPF_FOURCC)
+        {
+            if (!format->ddpfPixelFormat.u1.dwRGBBitCount)
+                return E_INVALIDARG;
+        }
+        else
+        {
+            if (format->ddpfPixelFormat.dwFlags & (DDPF_YUV | DDPF_PALETTEINDEXED1 |
+                    DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXEDTO8))
+                return DDERR_INVALIDSURFACETYPE;
+
+            if (!(format->ddpfPixelFormat.dwFlags & DDPF_RGB))
+                return DDERR_INVALIDSURFACETYPE;
+
+            switch (format->ddpfPixelFormat.u1.dwRGBBitCount)
+            {
+            case 8:
+                if (!(format->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8))
+                    return DDERR_INVALIDSURFACETYPE;
+                break;
+            case 16:
+                if (format->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
+                    return DDERR_INVALIDSURFACETYPE;
+                if ((format->ddpfPixelFormat.u2.dwRBitMask != 0x7c00 ||
+                    format->ddpfPixelFormat.u3.dwGBitMask != 0x03e0 ||
+                    format->ddpfPixelFormat.u4.dwBBitMask != 0x001f) &&
+                    (format->ddpfPixelFormat.u2.dwRBitMask != 0xf800 ||
+                    format->ddpfPixelFormat.u3.dwGBitMask != 0x07e0 ||
+                    format->ddpfPixelFormat.u4.dwBBitMask != 0x001f))
+                    return DDERR_INVALIDSURFACETYPE;
+                break;
+            case 24:
+            case 32:
+                if (format->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
+                    return DDERR_INVALIDSURFACETYPE;
+                if (format->ddpfPixelFormat.u2.dwRBitMask != 0xff0000 ||
+                    format->ddpfPixelFormat.u3.dwGBitMask != 0x00ff00 ||
+                    format->ddpfPixelFormat.u4.dwBBitMask != 0x0000ff)
+                    return DDERR_INVALIDSURFACETYPE;
+                break;
+            default:
+                return DDERR_INVALIDSURFACETYPE;
+            }
+        }
+    }
+
+    EnterCriticalSection(&stream->cs);
+
+    stream->format.flags = format->dwFlags & (DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT);
+    if (format->dwFlags & (DDSD_WIDTH | DDSD_HEIGHT))
+    {
+        stream->format.width = format->dwWidth;
+        stream->format.height = format->dwHeight;
+    }
+    if (format->dwFlags & DDSD_PIXELFORMAT)
+        stream->format.pf = format->ddpfPixelFormat;
+
+    LeaveCriticalSection(&stream->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI ddraw_IDirectDrawMediaStream_GetDirectDraw(IDirectDrawMediaStream *iface,
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index cb3604c65cb..f081c58a2aa 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -209,6 +209,39 @@ static const DDSURFACEDESC rgb32_format =
     .ddpfPixelFormat.dwBBitMask = 0x0000ff,
 };
 
+static const DDSURFACEDESC argb32_format =
+{
+    .dwSize = sizeof(DDSURFACEDESC),
+    .dwFlags = DDSD_PIXELFORMAT,
+    .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+    .ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS,
+    .ddpfPixelFormat.dwRGBBitCount = 32,
+    .ddpfPixelFormat.dwRBitMask = 0xff0000,
+    .ddpfPixelFormat.dwGBitMask = 0x00ff00,
+    .ddpfPixelFormat.dwBBitMask = 0x0000ff,
+    .ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000,
+};
+
+static const DDSURFACEDESC yuy2_format =
+{
+    .dwSize = sizeof(DDSURFACEDESC),
+    .dwFlags = DDSD_PIXELFORMAT,
+    .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+    .ddpfPixelFormat.dwFlags = DDPF_FOURCC,
+    .ddpfPixelFormat.dwFourCC = MAKEFOURCC('Y', 'U', 'Y', '2'),
+    .ddpfPixelFormat.dwYUVBitCount = 16,
+};
+
+static const DDSURFACEDESC yv12_format =
+{
+    .dwSize = sizeof(DDSURFACEDESC),
+    .dwFlags = DDSD_PIXELFORMAT,
+    .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+    .ddpfPixelFormat.dwFlags = DDPF_FOURCC,
+    .ddpfPixelFormat.dwFourCC = MAKEFOURCC('Y', 'V', '1', '2'),
+    .ddpfPixelFormat.dwYUVBitCount = 12,
+};
+
 static const WCHAR primary_video_sink_id[] = L"I{A35FF56A-9FDA-11D0-8FDF-00C04FD9189D}";
 static const WCHAR primary_audio_sink_id[] = L"I{A35FF56B-9FDA-11D0-8FDF-00C04FD9189D}";
 
@@ -4632,6 +4665,230 @@ static void test_ddrawstream_get_format(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+#define check_ddrawstream_set_format(a,b,c,d) check_ddrawstream_set_format_(__LINE__,a,b,c,d)
+static void check_ddrawstream_set_format_(int line, IDirectDrawMediaStream *stream,
+        const DDSURFACEDESC *format, const AM_MEDIA_TYPE *mt, HRESULT expected_hr)
+{
+    struct testfilter source;
+    FILTER_INFO filter_info;
+    PIN_INFO pin_info;
+    HRESULT hr;
+    IPin *pin;
+
+    hr = IDirectDrawMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IPin_QueryPinInfo(pin, &pin_info);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IBaseFilter_QueryFilterInfo(pin_info.pFilter, &filter_info);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    testfilter_init(&source);
+
+    hr = IFilterGraph_AddFilter(filter_info.pGraph, &source.filter.IBaseFilter_iface, L"source");
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawMediaStream_SetFormat(stream, format, NULL);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x.\n", hr);
+
+    if (mt)
+    {
+        DDSURFACEDESC current_format;
+        DDSURFACEDESC desired_format;
+        DWORD flags;
+
+        hr = IFilterGraph_ConnectDirect(filter_info.pGraph, &source.source.pin.IPin_iface, pin, mt);
+        ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+        memset(&current_format, 0xcc, sizeof(current_format));
+        memset(&desired_format, 0xcc, sizeof(desired_format));
+        flags = 0xdeadbeef;
+        current_format.dwSize = sizeof(current_format);
+        desired_format.dwSize = sizeof(desired_format);
+        hr = IDirectDrawMediaStream_GetFormat(stream, &current_format, NULL, &desired_format, &flags);
+        ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+        if (format->dwFlags & DDSD_PIXELFORMAT)
+        {
+            ok_(__FILE__, line)(current_format.dwFlags == (DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_PIXELFORMAT),
+                    "Got current format flags %#x.\n", current_format.dwFlags);
+            ok_(__FILE__, line)(memcmp(&current_format.ddpfPixelFormat, &format->ddpfPixelFormat, sizeof(DDPIXELFORMAT)) == 0,
+                    "Current pixel format didn't match.\n");
+            ok_(__FILE__, line)(memcmp(&desired_format.ddpfPixelFormat, &format->ddpfPixelFormat, sizeof(DDPIXELFORMAT)) == 0,
+                    "Desired pixel format didn't match.\n");
+        }
+        else
+        {
+            ok_(__FILE__, line)(current_format.dwFlags == (DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS),
+                    "Got flags %#x.\n", current_format.dwFlags);
+        }
+        ok_(__FILE__, line)(desired_format.dwFlags == (DDSD_WIDTH | DDSD_HEIGHT),
+                "Got desired format flags %#x.\n", desired_format.dwFlags);
+        ok_(__FILE__, line)(current_format.ddsCaps.dwCaps == (DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY),
+                "Got current format caps %#x.\n", current_format.ddsCaps.dwCaps);
+        ok_(__FILE__, line)(desired_format.ddsCaps.dwCaps == (DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY),
+                "Got desired format caps %#x.\n", desired_format.ddsCaps.dwCaps);
+        ok_(__FILE__, line)(flags == 0, "Got flags %#x.\n", flags);
+
+        hr = IFilterGraph_Disconnect(filter_info.pGraph, &source.source.pin.IPin_iface);
+        ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+        hr = IFilterGraph_Disconnect(filter_info.pGraph, pin);
+        ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    }
+
+    hr = IFilterGraph_RemoveFilter(filter_info.pGraph, &source.filter.IBaseFilter_iface);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    IFilterGraph_Release(filter_info.pGraph);
+    IBaseFilter_Release(pin_info.pFilter);
+    IPin_Release(pin);
+}
+
+static void test_ddrawstream_set_format(void)
+{
+    static const DDSURFACEDESC rgb1_format =
+    {
+        .dwSize = sizeof(DDSURFACEDESC),
+        .dwFlags = DDSD_PIXELFORMAT,
+        .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+        .ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_PALETTEINDEXED1,
+        .ddpfPixelFormat.dwRGBBitCount = 1,
+    };
+    static const DDSURFACEDESC rgb2_format =
+    {
+        .dwSize = sizeof(DDSURFACEDESC),
+        .dwFlags = DDSD_PIXELFORMAT,
+        .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+        .ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_PALETTEINDEXED2,
+        .ddpfPixelFormat.dwRGBBitCount = 2,
+    };
+    static const DDSURFACEDESC rgb4_format =
+    {
+        .dwSize = sizeof(DDSURFACEDESC),
+        .dwFlags = DDSD_PIXELFORMAT,
+        .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+        .ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_PALETTEINDEXED4,
+        .ddpfPixelFormat.dwRGBBitCount = 4,
+    };
+    static const DDSURFACEDESC rgb4to8_format =
+    {
+        .dwSize = sizeof(DDSURFACEDESC),
+        .dwFlags = DDSD_PIXELFORMAT,
+        .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+        .ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_PALETTEINDEXEDTO8,
+        .ddpfPixelFormat.dwRGBBitCount = 4,
+    };
+    static const DDSURFACEDESC rgb332_format =
+    {
+        .dwSize = sizeof(DDSURFACEDESC),
+        .dwFlags = DDSD_PIXELFORMAT,
+        .ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT),
+        .ddpfPixelFormat.dwFlags = DDPF_RGB,
+        .ddpfPixelFormat.dwRGBBitCount = 8,
+        .ddpfPixelFormat.dwRBitMask = 0xe0,
+        .ddpfPixelFormat.dwGBitMask = 0x1c,
+        .ddpfPixelFormat.dwBBitMask = 0x03,
+    };
+
+    IDirectDrawMediaStream *ddraw_stream;
+    IAMMultiMediaStream *mmstream;
+    DDSURFACEDESC format;
+    IMediaStream *stream;
+    HRESULT hr;
+    ULONG ref;
+
+    mmstream = create_ammultimediastream();
+
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryVideo, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (void **)&ddraw_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    check_ddrawstream_set_format(ddraw_stream, &rgb8_format, &rgb8_mt, S_OK);
+    check_ddrawstream_set_format(ddraw_stream, &rgb555_format, &rgb555_mt, S_OK);
+    check_ddrawstream_set_format(ddraw_stream, &rgb565_format, &rgb565_mt, S_OK);
+    check_ddrawstream_set_format(ddraw_stream, &rgb24_format, &rgb24_mt, S_OK);
+    check_ddrawstream_set_format(ddraw_stream, &rgb32_format, &rgb32_mt, S_OK);
+    check_ddrawstream_set_format(ddraw_stream, &argb32_format, &rgb32_mt, S_OK);
+    check_ddrawstream_set_format(ddraw_stream, &yuy2_format, NULL, S_OK);
+    check_ddrawstream_set_format(ddraw_stream, &yv12_format, NULL, S_OK);
+
+    format = rgb32_format;
+    format.ddpfPixelFormat.dwFlags |= DDPF_ALPHAPIXELS | DDPF_ALPHA
+            | DDPF_COMPRESSED | DDPF_RGBTOYUV | DDPF_ZBUFFER | DDPF_ZPIXELS | DDPF_STENCILBUFFER
+            | DDPF_ALPHAPREMULT | DDPF_LUMINANCE | DDPF_BUMPLUMINANCE | DDPF_BUMPDUDV;
+    check_ddrawstream_set_format(ddraw_stream, &format, &rgb32_mt, S_OK);
+
+    format = yuy2_format;
+    format.ddpfPixelFormat.dwFlags |= DDPF_ALPHAPIXELS | DDPF_ALPHA
+            | DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXEDTO8 | DDPF_PALETTEINDEXED8
+            | DDPF_RGB | DDPF_COMPRESSED | DDPF_RGBTOYUV | DDPF_YUV | DDPF_ZBUFFER
+            | DDPF_PALETTEINDEXED1 | DDPF_PALETTEINDEXED2 | DDPF_ZPIXELS
+            | DDPF_STENCILBUFFER | DDPF_ALPHAPREMULT | DDPF_LUMINANCE
+            | DDPF_BUMPLUMINANCE | DDPF_BUMPDUDV;
+    check_ddrawstream_set_format(ddraw_stream, &format, NULL, S_OK);
+
+    format = rgb32_format;
+    format.dwFlags |= DDSD_CAPS;
+    format.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_VIDEOMEMORY;
+    check_ddrawstream_set_format(ddraw_stream, &format, &rgb32_mt, S_OK);
+
+    format = rgb8_format;
+    format.dwFlags = 0;
+    check_ddrawstream_set_format(ddraw_stream, &format, &rgb32_mt, S_OK);
+
+    check_ddrawstream_set_format(ddraw_stream, &rgb1_format, NULL, DDERR_INVALIDSURFACETYPE);
+    check_ddrawstream_set_format(ddraw_stream, &rgb2_format, NULL, DDERR_INVALIDSURFACETYPE);
+    check_ddrawstream_set_format(ddraw_stream, &rgb4_format, NULL, DDERR_INVALIDSURFACETYPE);
+    check_ddrawstream_set_format(ddraw_stream, &rgb4to8_format, NULL, DDERR_INVALIDSURFACETYPE);
+    check_ddrawstream_set_format(ddraw_stream, &rgb332_format, NULL, DDERR_INVALIDSURFACETYPE);
+
+    format = rgb8_format;
+    format.ddpfPixelFormat.dwFlags &= ~DDPF_RGB;
+    check_ddrawstream_set_format(ddraw_stream, &format, NULL, DDERR_INVALIDSURFACETYPE);
+
+    format = rgb8_format;
+    format.ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED1;
+    check_ddrawstream_set_format(ddraw_stream, &format, NULL, DDERR_INVALIDSURFACETYPE);
+
+    format = rgb32_format;
+    format.ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED8;
+    check_ddrawstream_set_format(ddraw_stream, &format, NULL, DDERR_INVALIDSURFACETYPE);
+
+    format = rgb32_format;
+    format.ddpfPixelFormat.dwFlags |= DDPF_YUV;
+    check_ddrawstream_set_format(ddraw_stream, &format, NULL, DDERR_INVALIDSURFACETYPE);
+
+    format = rgb565_format;
+    format.ddpfPixelFormat.dwRBitMask = 0x001f;
+    format.ddpfPixelFormat.dwGBitMask = 0x07e0;
+    format.ddpfPixelFormat.dwBBitMask = 0xf800;
+    check_ddrawstream_set_format(ddraw_stream, &format, NULL, DDERR_INVALIDSURFACETYPE);
+
+    format = rgb32_format;
+    format.ddpfPixelFormat.dwRBitMask = 0x00ff00;
+    format.ddpfPixelFormat.dwGBitMask = 0x0000ff;
+    format.ddpfPixelFormat.dwBBitMask = 0xff0000;
+    check_ddrawstream_set_format(ddraw_stream, &format, NULL, DDERR_INVALIDSURFACETYPE);
+
+    format = yuy2_format;
+    format.ddpfPixelFormat.dwYUVBitCount = 0;
+    check_ddrawstream_set_format(ddraw_stream, &format, NULL, E_INVALIDARG);
+
+    format = rgb32_format;
+    format.dwSize = sizeof(DDSURFACEDESC) + 1;
+    check_ddrawstream_set_format(ddraw_stream, &format, NULL, E_INVALIDARG);
+
+    format = rgb32_format;
+    format.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT) + 1;
+    check_ddrawstream_set_format(ddraw_stream, &format, NULL, DDERR_INVALIDSURFACETYPE);
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IDirectDrawMediaStream_Release(ddraw_stream);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+}
+
 static void check_ammediastream_join_am_multi_media_stream(const CLSID *clsid)
 {
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
@@ -6094,6 +6351,7 @@ START_TEST(amstream)
     test_ddrawstream_receive_connection();
     test_ddrawstream_create_sample();
     test_ddrawstream_get_format();
+    test_ddrawstream_set_format();
 
     test_ddrawstreamsample_get_media_stream();
 
From 337fcca4d1e0d494192d67786dbf1feeac87f592 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 10 Sep 2020 02:17:37 +0700
Subject: [PATCH] amstream: Reject incompatible media types in
 AMDirectDrawStream::ReceiveConnection.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    |  26 ++++++
 dlls/amstream/tests/amstream.c | 152 +++++++++++++++++++++++++++++++++
 2 files changed, 178 insertions(+)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index 542c315930d..c281c81d334 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -61,6 +61,26 @@ struct ddraw_stream
 static HRESULT ddrawstreamsample_create(struct ddraw_stream *parent, IDirectDrawSurface *surface,
     const RECT *rect, IDirectDrawStreamSample **ddraw_stream_sample);
 
+static BOOL is_format_compatible(struct ddraw_stream *stream,
+        DWORD width, DWORD height, const DDPIXELFORMAT *connection_pf)
+{
+    if (stream->format.flags & DDSD_HEIGHT)
+    {
+        if (stream->format.width != width || stream->format.height != height)
+            return FALSE;
+    }
+    if (stream->format.flags & DDSD_PIXELFORMAT)
+    {
+        if (stream->format.pf.dwFlags & DDPF_FOURCC)
+            return FALSE;
+        if (stream->format.pf.u1.dwRGBBitCount != connection_pf->u1.dwRGBBitCount)
+            return FALSE;
+        if (stream->format.pf.u1.dwRGBBitCount == 16 && stream->format.pf.u3.dwGBitMask != connection_pf->u3.dwGBitMask)
+            return FALSE;
+    }
+    return TRUE;
+}
+
 static inline struct ddraw_stream *impl_from_IAMMediaStream(IAMMediaStream *iface)
 {
     return CONTAINING_RECORD(iface, struct ddraw_stream, IAMMediaStream_iface);
@@ -824,6 +844,12 @@ static HRESULT WINAPI ddraw_sink_ReceiveConnection(IPin *iface, IPin *peer, cons
         return VFW_E_TYPE_NOT_ACCEPTED;
     }
 
+    if (!is_format_compatible(stream, width, height, &pf))
+    {
+        LeaveCriticalSection(&stream->cs);
+        return VFW_E_TYPE_NOT_ACCEPTED;
+    }
+
     IPin_QueryDirection(peer, &dir);
     if (dir != PINDIR_OUTPUT)
     {
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index f081c58a2aa..0b343b4912d 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -3353,13 +3353,34 @@ static void test_ddrawstream_receive_connection(void)
     IDirectDrawMediaStream *ddraw_stream;
     IAMMultiMediaStream *mmstream;
     struct testfilter source;
+    DDSURFACEDESC format;
     IMediaStream *stream;
+    VIDEOINFO video_info;
     AM_MEDIA_TYPE mt;
     HRESULT hr;
     ULONG ref;
     IPin *pin;
     int i;
 
+    static const VIDEOINFO yuy2_video_info =
+    {
+        .bmiHeader.biSize = sizeof(BITMAPINFOHEADER),
+        .bmiHeader.biWidth = 333,
+        .bmiHeader.biHeight = -444,
+        .bmiHeader.biPlanes = 1,
+        .bmiHeader.biBitCount = 16,
+        .bmiHeader.biCompression = MAKEFOURCC('Y', 'U', 'Y', '2'),
+    };
+
+    const AM_MEDIA_TYPE yuy2_mt =
+    {
+        .majortype = MEDIATYPE_Video,
+        .subtype = MEDIASUBTYPE_YUY2,
+        .formattype = FORMAT_VideoInfo,
+        .cbFormat = sizeof(VIDEOINFOHEADER),
+        .pbFormat = (BYTE *)&yuy2_video_info,
+    };
+
     const AM_MEDIA_TYPE video_mt =
     {
         .majortype = MEDIATYPE_Video,
@@ -3420,6 +3441,137 @@ static void test_ddrawstream_receive_connection(void)
         }
     }
 
+    format = rgb8_format;
+    format.dwFlags = DDSD_WIDTH;
+    format.dwWidth = 222;
+    format.dwHeight = 555;
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb32_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IPin_Disconnect(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    format = rgb8_format;
+    format.dwFlags = DDSD_HEIGHT;
+    format.dwWidth = 333;
+    format.dwHeight = 444;
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    video_info = rgb555_video_info;
+    video_info.bmiHeader.biWidth = 333;
+    video_info.bmiHeader.biHeight = 444;
+    mt = rgb555_mt;
+    mt.pbFormat = (BYTE *)&video_info;
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IPin_Disconnect(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb32_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IPin_Disconnect(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    video_info = rgb32_video_info;
+    video_info.bmiHeader.biWidth = 332;
+    video_info.bmiHeader.biHeight = 444;
+    mt = rgb32_mt;
+    mt.pbFormat = (BYTE *)&video_info;
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &mt);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+
+    video_info = rgb32_video_info;
+    video_info.bmiHeader.biWidth = 333;
+    video_info.bmiHeader.biHeight = 443;
+    mt = rgb32_mt;
+    mt.pbFormat = (BYTE *)&video_info;
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &mt);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &rgb8_format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb555_mt);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb8_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IPin_Disconnect(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &rgb555_format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb565_mt);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb555_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IPin_Disconnect(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &rgb565_format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb24_mt);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb565_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IPin_Disconnect(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &rgb24_format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb32_mt);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb24_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IPin_Disconnect(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &rgb32_format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb8_mt);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb32_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IPin_Disconnect(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &yuy2_format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &yuy2_mt);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+
+    format = yuy2_format;
+    format.ddpfPixelFormat.dwRBitMask = 0xf800;
+    format.ddpfPixelFormat.dwGBitMask = 0x07e0;
+    format.ddpfPixelFormat.dwBBitMask = 0x001f;
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb565_mt);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
+
+    format = rgb8_format;
+    format.dwFlags = 0;
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IPin_ReceiveConnection(pin, &source.source.pin.IPin_iface, &rgb565_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IPin_Disconnect(pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
     ref = IAMMultiMediaStream_Release(mmstream);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
     IPin_Release(pin);
From 47ab12402201b1b7f93e9505c60f5ef8755d55a3 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 10 Sep 2020 02:17:38 +0700
Subject: [PATCH] amstream: Reconnect if the new format is incompatible with
 the connection media type in AMDirectDrawStream::SetFormat.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    |  37 ++++++++++
 dlls/amstream/tests/amstream.c | 130 ++++++++++++++++++++++++++++++++-
 2 files changed, 166 insertions(+), 1 deletion(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index c281c81d334..d4f5b6cf184 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -51,6 +51,7 @@ struct ddraw_stream
     IDirectDraw *ddraw;
     CRITICAL_SECTION cs;
     IMediaStreamFilter *filter;
+    IFilterGraph *graph;
 
     IPin *peer;
     IMemAllocator *allocator;
@@ -294,6 +295,8 @@ static HRESULT WINAPI ddraw_IAMMediaStream_JoinFilterGraph(IAMMediaStream *iface
 
     TRACE("stream %p, filtergraph %p.\n", stream, filtergraph);
 
+    stream->graph = filtergraph;
+
     return S_OK;
 }
 
@@ -438,6 +441,10 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SetFormat(IDirectDrawMediaStr
         const DDSURFACEDESC *format, IDirectDrawPalette *palette)
 {
     struct ddraw_stream *stream = impl_from_IDirectDrawMediaStream(iface);
+    AM_MEDIA_TYPE old_media_type;
+    struct format old_format;
+    IPin *old_peer;
+    HRESULT hr;
 
     TRACE("stream %p, format %p, palette %p.\n", stream, format, palette);
 
@@ -503,6 +510,7 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SetFormat(IDirectDrawMediaStr
 
     EnterCriticalSection(&stream->cs);
 
+    old_format = stream->format;
     stream->format.flags = format->dwFlags & (DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT);
     if (format->dwFlags & (DDSD_WIDTH | DDSD_HEIGHT))
     {
@@ -512,6 +520,35 @@ static HRESULT WINAPI ddraw_IDirectDrawMediaStream_SetFormat(IDirectDrawMediaStr
     if (format->dwFlags & DDSD_PIXELFORMAT)
         stream->format.pf = format->ddpfPixelFormat;
 
+    if (stream->peer && !is_format_compatible(stream, old_format.width, old_format.height, &old_format.pf))
+    {
+        hr = CopyMediaType(&old_media_type, &stream->mt);
+        if (FAILED(hr))
+        {
+            stream->format = old_format;
+            LeaveCriticalSection(&stream->cs);
+            return hr;
+        }
+        old_peer = stream->peer;
+        IPin_AddRef(old_peer);
+
+        IFilterGraph_Disconnect(stream->graph, stream->peer);
+        IFilterGraph_Disconnect(stream->graph, &stream->IPin_iface);
+        hr = IFilterGraph_ConnectDirect(stream->graph, old_peer, &stream->IPin_iface, NULL);
+        if (FAILED(hr))
+        {
+            stream->format = old_format;
+            IFilterGraph_ConnectDirect(stream->graph, old_peer, &stream->IPin_iface, &old_media_type);
+            IPin_Release(old_peer);
+            FreeMediaType(&old_media_type);
+            LeaveCriticalSection(&stream->cs);
+            return DDERR_INVALIDSURFACETYPE;
+        }
+
+        IPin_Release(old_peer);
+        FreeMediaType(&old_media_type);
+    }
+
     LeaveCriticalSection(&stream->cs);
 
     return S_OK;
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 0b343b4912d..7c1be2b500e 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -923,6 +923,7 @@ struct testfilter
     IMediaSeeking IMediaSeeking_iface;
     LONGLONG current_position;
     LONGLONG stop_position;
+    const AM_MEDIA_TYPE *preferred_mt;
     HRESULT get_duration_hr;
     HRESULT get_stop_position_hr;
     HRESULT set_positions_hr;
@@ -983,6 +984,16 @@ static inline struct testfilter *impl_from_base_pin(struct strmbase_pin *iface)
     return CONTAINING_RECORD(iface, struct testfilter, source.pin);
 }
 
+static HRESULT testsource_get_media_type(struct strmbase_pin *iface, unsigned int index, AM_MEDIA_TYPE *mt)
+{
+    struct testfilter *filter = impl_from_base_pin(iface);
+
+    if (index < 1 && filter->preferred_mt)
+        return CopyMediaType(mt, filter->preferred_mt);
+
+    return VFW_S_NO_MORE_ITEMS;
+}
+
 static HRESULT testsource_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
 {
     struct testfilter *filter = impl_from_base_pin(iface);
@@ -997,6 +1008,25 @@ static HRESULT testsource_query_interface(struct strmbase_pin *iface, REFIID iid
     return S_OK;
 }
 
+static HRESULT WINAPI testsource_DecideAllocator(struct strmbase_source *iface, IMemInputPin *pin, IMemAllocator **alloc)
+{
+    ALLOCATOR_PROPERTIES props = {0};
+    HRESULT hr;
+
+    /* AMDirectDrawStream tries to use it's custom allocator and
+     * when it is able to do so it's behavior changes slightly
+     * (e.g. it uses dynamic format change instead of reconnecting in SetFormat).
+     * We don't yet implement the custom allocator so force the standard one for now. */
+    hr = BaseOutputPinImpl_InitAllocator(iface, alloc);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    IMemInputPin_GetAllocatorRequirements(pin, &props);
+    hr = iface->pFuncsTable->pfnDecideBufferSize(iface, *alloc, &props);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    return IMemInputPin_NotifyAllocator(pin, *alloc, FALSE);
+}
+
 static HRESULT WINAPI testsource_DecideBufferSize(struct strmbase_source *iface,
         IMemAllocator *alloc, ALLOCATOR_PROPERTIES *requested)
 {
@@ -1016,10 +1046,11 @@ static HRESULT WINAPI testsource_DecideBufferSize(struct strmbase_source *iface,
 
 static const struct strmbase_source_ops testsource_ops =
 {
+    .base.pin_get_media_type = testsource_get_media_type,
     .base.pin_query_interface = testsource_query_interface,
     .pfnAttemptConnection = BaseOutputPinImpl_AttemptConnection,
     .pfnDecideBufferSize = testsource_DecideBufferSize,
-    .pfnDecideAllocator = BaseOutputPinImpl_DecideAllocator,
+    .pfnDecideAllocator = testsource_DecideAllocator,
 };
 
 static void testfilter_init(struct testfilter *filter)
@@ -4942,10 +4973,17 @@ static void test_ddrawstream_set_format(void)
 
     IDirectDrawMediaStream *ddraw_stream;
     IAMMultiMediaStream *mmstream;
+    DDSURFACEDESC current_format;
+    DDSURFACEDESC desired_format;
+    struct testfilter source;
+    IGraphBuilder *graph;
     DDSURFACEDESC format;
     IMediaStream *stream;
+    VIDEOINFO video_info;
+    AM_MEDIA_TYPE mt;
     HRESULT hr;
     ULONG ref;
+    IPin *pin;
 
     mmstream = create_ammultimediastream();
 
@@ -5039,6 +5077,96 @@ static void test_ddrawstream_set_format(void)
     ref = IMediaStream_Release(stream);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 
+    mmstream = create_ammultimediastream();
+
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryVideo, 0, &stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (void **)&ddraw_stream);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!!graph, "Expected non-NULL graph.\n");
+
+    testfilter_init(&source);
+
+    hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, L"source");
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &rgb8_mt);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    source.preferred_mt = NULL;
+
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &rgb555_format, NULL);
+    ok(hr == DDERR_INVALIDSURFACETYPE, "Got hr %#x.\n", hr);
+    ok(IsEqualGUID(&source.source.pin.mt.subtype, &MEDIASUBTYPE_RGB8),
+            "Got subtype %s.\n", wine_dbgstr_guid(&source.source.pin.mt.subtype));
+    hr = IDirectDrawMediaStream_GetFormat(ddraw_stream, &current_format, NULL, &desired_format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(current_format.ddpfPixelFormat.dwRGBBitCount == 8,
+            "Got rgb bit count %u.\n", current_format.ddpfPixelFormat.dwRGBBitCount);
+    ok(desired_format.ddpfPixelFormat.dwRGBBitCount == 8,
+            "Got rgb bit count %u.\n", desired_format.ddpfPixelFormat.dwRGBBitCount);
+
+    format = rgb555_format;
+    format.dwFlags = 0;
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(IsEqualGUID(&source.source.pin.mt.subtype, &MEDIASUBTYPE_RGB8),
+            "Got subtype %s.\n", wine_dbgstr_guid(&source.source.pin.mt.subtype));
+
+    source.preferred_mt = &rgb555_mt;
+
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &rgb8_format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &rgb555_format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(IsEqualGUID(&source.source.pin.mt.subtype, &MEDIASUBTYPE_RGB555),
+            "Got subtype %s.\n", wine_dbgstr_guid(&source.source.pin.mt.subtype));
+    hr = IDirectDrawMediaStream_GetFormat(ddraw_stream, &current_format, NULL, &desired_format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(current_format.ddpfPixelFormat.dwRGBBitCount == 16,
+            "Got rgb bit count %u.\n", current_format.ddpfPixelFormat.dwRGBBitCount);
+    ok(desired_format.ddpfPixelFormat.dwRGBBitCount == 16,
+            "Got rgb bit count %u.\n", desired_format.ddpfPixelFormat.dwRGBBitCount);
+
+    video_info = rgb555_video_info;
+    video_info.bmiHeader.biWidth = 222;
+    video_info.bmiHeader.biHeight = -555;
+    mt = rgb555_mt;
+    mt.pbFormat = (BYTE *)&video_info;
+    source.preferred_mt = &mt;
+
+    format = rgb555_format;
+    format.dwFlags |= DDSD_WIDTH | DDSD_HEIGHT;
+    format.dwWidth = 222;
+    format.dwHeight = 555;
+    hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, &format, NULL);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(IsEqualGUID(&source.source.pin.mt.subtype, &MEDIASUBTYPE_RGB555),
+            "Got subtype %s.\n", wine_dbgstr_guid(&source.source.pin.mt.subtype));
+    ok(((VIDEOINFO *)source.source.pin.mt.pbFormat)->bmiHeader.biWidth == 222,
+            "Got width %d.\n", ((VIDEOINFO *)source.source.pin.mt.pbFormat)->bmiHeader.biWidth);
+    ok(((VIDEOINFO *)source.source.pin.mt.pbFormat)->bmiHeader.biHeight == -555,
+            "Got height %d.\n", ((VIDEOINFO *)source.source.pin.mt.pbFormat)->bmiHeader.biHeight);
+
+    hr = IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IGraphBuilder_Disconnect(graph, pin);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin);
+    IDirectDrawMediaStream_Release(ddraw_stream);
+    ref = IMediaStream_Release(stream);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void check_ammediastream_join_am_multi_media_stream(const CLSID *clsid)
From e64a2e112e12afbd64e27a9eee0acaa3f7dcaffd Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Thu, 10 Sep 2020 02:17:39 +0700
Subject: [PATCH] amstream: Use current format to create surface in
 AMDirectDrawStream::CreateSample.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/amstream/ddrawstream.c    |  25 +++--
 dlls/amstream/tests/amstream.c | 174 +++++++++++++++++++++++++++++++++
 2 files changed, 190 insertions(+), 9 deletions(-)

diff --git a/dlls/amstream/ddrawstream.c b/dlls/amstream/ddrawstream.c
index d4f5b6cf184..fdfe0374ab1 100644
--- a/dlls/amstream/ddrawstream.c
+++ b/dlls/amstream/ddrawstream.c
@@ -1420,15 +1420,22 @@ static HRESULT ddrawstreamsample_create(struct ddraw_stream *parent, IDirectDraw
 
         desc.dwSize = sizeof(desc);
         desc.dwFlags = DDSD_CAPS|DDSD_HEIGHT|DDSD_WIDTH|DDSD_PIXELFORMAT;
-        desc.dwHeight = 100;
-        desc.dwWidth = 100;
-        desc.ddpfPixelFormat.dwSize = sizeof(desc.ddpfPixelFormat);
-        desc.ddpfPixelFormat.dwFlags = DDPF_RGB;
-        desc.ddpfPixelFormat.u1.dwRGBBitCount = 32;
-        desc.ddpfPixelFormat.u2.dwRBitMask = 0xff0000;
-        desc.ddpfPixelFormat.u3.dwGBitMask = 0x00ff00;
-        desc.ddpfPixelFormat.u4.dwBBitMask = 0x0000ff;
-        desc.ddpfPixelFormat.u5.dwRGBAlphaBitMask = 0;
+        desc.dwHeight = parent->format.height;
+        desc.dwWidth = parent->format.width;
+        if (parent->format.flags & DDSD_PIXELFORMAT)
+        {
+            desc.ddpfPixelFormat = parent->format.pf;
+        }
+        else
+        {
+            desc.ddpfPixelFormat.dwSize = sizeof(desc.ddpfPixelFormat);
+            desc.ddpfPixelFormat.dwFlags = DDPF_RGB;
+            desc.ddpfPixelFormat.u1.dwRGBBitCount = 32;
+            desc.ddpfPixelFormat.u2.dwRBitMask = 0xff0000;
+            desc.ddpfPixelFormat.u3.dwGBitMask = 0x00ff00;
+            desc.ddpfPixelFormat.u4.dwBBitMask = 0x0000ff;
+            desc.ddpfPixelFormat.u5.dwRGBAlphaBitMask = 0;
+        }
         desc.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY|DDSCAPS_OFFSCREENPLAIN;
         desc.lpSurface = NULL;
 
diff --git a/dlls/amstream/tests/amstream.c b/dlls/amstream/tests/amstream.c
index 7c1be2b500e..1c0b36ea6c5 100644
--- a/dlls/amstream/tests/amstream.c
+++ b/dlls/amstream/tests/amstream.c
@@ -6415,6 +6415,83 @@ static void test_audiostreamsample_get_audio_data(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+#define get_ddrawstream_create_sample_desc(a,b,c,d) get_ddrawstream_create_sample_desc_(__LINE__,a,b,c,d)
+static void get_ddrawstream_create_sample_desc_(int line, const DDSURFACEDESC *format1,
+        const DDSURFACEDESC *format2, const AM_MEDIA_TYPE *mt, DDSURFACEDESC *desc)
+{
+    IAMMultiMediaStream *mmstream = create_ammultimediastream();
+    IDirectDrawMediaStream *ddraw_stream;
+    IDirectDrawStreamSample *sample;
+    IDirectDrawSurface *surface;
+    struct testfilter source;
+    IGraphBuilder *graph;
+    IMediaStream *stream;
+    HRESULT hr;
+    ULONG ref;
+    IPin *pin;
+
+    hr = IAMMultiMediaStream_Initialize(mmstream, STREAMTYPE_READ, 0, NULL);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_AddMediaStream(mmstream, NULL, &MSPID_PrimaryVideo, 0, &stream);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IDirectDrawMediaStream, (void **)&ddraw_stream);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IMediaStream_QueryInterface(stream, &IID_IPin, (void **)&pin);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    hr = IAMMultiMediaStream_GetFilterGraph(mmstream, &graph);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    testfilter_init(&source);
+
+    hr = IGraphBuilder_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    if (format1)
+    {
+        hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, format1, NULL);
+        ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    }
+    if (format2)
+    {
+        hr = IDirectDrawMediaStream_SetFormat(ddraw_stream, format2, NULL);
+        ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    }
+    if (mt)
+    {
+        hr = IGraphBuilder_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, mt);
+        ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+        hr = IGraphBuilder_Disconnect(graph, &source.source.pin.IPin_iface);
+        ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+        hr = IGraphBuilder_Disconnect(graph, pin);
+        ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    }
+
+    hr = IDirectDrawMediaStream_CreateSample(ddraw_stream, NULL, NULL, 0, &sample);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    hr = IDirectDrawStreamSample_GetSurface(sample, &surface, NULL);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+    ok_(__FILE__, line)(!!surface, "Expected non-NULL sufrace.\n");
+
+    desc->dwSize = sizeof(*desc);
+    hr = IDirectDrawSurface_GetSurfaceDesc(surface, desc);
+    ok_(__FILE__, line)(hr == S_OK, "Got hr %#x.\n", hr);
+
+    ref = IDirectDrawStreamSample_Release(sample);
+    ok_(__FILE__, line)(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IDirectDrawSurface_Release(surface);
+    ok_(__FILE__, line)(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IAMMultiMediaStream_Release(mmstream);
+    ok_(__FILE__, line)(!ref, "Got outstanding refcount %d.\n", ref);
+    ref = IGraphBuilder_Release(graph);
+    ok_(__FILE__, line)(!ref, "Got outstanding refcount %d.\n", ref);
+    IPin_Release(pin);
+    IDirectDrawMediaStream_Release(ddraw_stream);
+    ref = IMediaStream_Release(stream);
+    ok_(__FILE__, line)(!ref, "Got outstanding refcount %d.\n", ref);
+}
+
 static void test_ddrawstream_create_sample(void)
 {
     IAMMultiMediaStream *mmstream = create_ammultimediastream();
@@ -6422,6 +6499,8 @@ static void test_ddrawstream_create_sample(void)
     DDSURFACEDESC desc = { sizeof(desc) };
     IDirectDrawMediaStream *ddraw_stream;
     IDirectDrawStreamSample *sample;
+    DDSURFACEDESC format1;
+    DDSURFACEDESC format2;
     IMediaStream *stream;
     IDirectDraw *ddraw;
     HRESULT hr;
@@ -6523,6 +6602,101 @@ static void test_ddrawstream_create_sample(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IDirectDraw_Release(ddraw);
     ok(!ref, "Got outstanding refcount %d.\n", ref);
+
+    format1 = rgb8_format;
+    format1.dwFlags = 0;
+    format1.dwWidth = 333;
+    format1.dwHeight = 444;
+    get_ddrawstream_create_sample_desc(&format1, NULL, NULL, &desc);
+    ok(desc.dwWidth == 100, "Got width %u.\n", desc.dwWidth);
+    ok(desc.dwHeight == 100, "Got height %u.\n", desc.dwHeight);
+    ok(desc.ddpfPixelFormat.dwFlags == DDPF_RGB, "Got flags %#x.\n", desc.ddpfPixelFormat.dwFlags);
+    ok(desc.ddpfPixelFormat.dwRGBBitCount == 32, "Got rgb bit count %u.\n", desc.ddpfPixelFormat.dwRGBBitCount);
+    ok(desc.ddpfPixelFormat.dwRBitMask == 0xff0000, "Got r bit mask %#x.\n", desc.ddpfPixelFormat.dwRBitMask);
+    ok(desc.ddpfPixelFormat.dwGBitMask == 0x00ff00, "Got g bit mask %#x.\n", desc.ddpfPixelFormat.dwGBitMask);
+    ok(desc.ddpfPixelFormat.dwBBitMask == 0x0000ff, "Got b bit mask %#x.\n", desc.ddpfPixelFormat.dwBBitMask);
+
+    format1 = rgb8_format;
+    format1.dwFlags |= DDSD_WIDTH;
+    format1.dwWidth = 333;
+    format1.dwHeight = 444;
+    format2 = rgb8_format;
+    format2.dwFlags = 0;
+    get_ddrawstream_create_sample_desc(&format1, &format2, NULL, &desc);
+    ok(desc.dwWidth == 333, "Got width %u.\n", desc.dwWidth);
+    ok(desc.dwHeight == 444, "Got height %u.\n", desc.dwHeight);
+
+    format1 = rgb8_format;
+    format1.dwFlags |= DDSD_HEIGHT;
+    format1.dwWidth = 333;
+    format1.dwHeight = 444;
+    format2 = rgb8_format;
+    format2.dwFlags = 0;
+    get_ddrawstream_create_sample_desc(&format1, &format2, NULL, &desc);
+    ok(desc.dwWidth == 333, "Got width %u.\n", desc.dwWidth);
+    ok(desc.dwHeight == 444, "Got height %u.\n", desc.dwHeight);
+
+    get_ddrawstream_create_sample_desc(NULL, NULL, &rgb8_mt, &desc);
+    ok(desc.dwWidth == 333, "Got width %u.\n", desc.dwWidth);
+    ok(desc.dwHeight == 444, "Got height %u.\n", desc.dwHeight);
+    ok(desc.ddpfPixelFormat.dwFlags == DDPF_RGB, "Got flags %#x.\n", desc.ddpfPixelFormat.dwFlags);
+    ok(desc.ddpfPixelFormat.dwRGBBitCount == 32, "Got rgb bit count %u.\n", desc.ddpfPixelFormat.dwRGBBitCount);
+    ok(desc.ddpfPixelFormat.dwRBitMask == 0xff0000, "Got r bit mask %#x.\n", desc.ddpfPixelFormat.dwRBitMask);
+    ok(desc.ddpfPixelFormat.dwGBitMask == 0x00ff00, "Got g bit mask %#x.\n", desc.ddpfPixelFormat.dwGBitMask);
+    ok(desc.ddpfPixelFormat.dwBBitMask == 0x0000ff, "Got b bit mask %#x.\n", desc.ddpfPixelFormat.dwBBitMask);
+
+    get_ddrawstream_create_sample_desc(&rgb565_format, NULL, NULL, &desc);
+    ok(desc.dwWidth == 100, "Got width %u.\n", desc.dwWidth);
+    ok(desc.dwHeight == 100, "Got height %u.\n", desc.dwHeight);
+    ok(desc.ddpfPixelFormat.dwFlags == DDPF_RGB, "Got flags %#x.\n", desc.ddpfPixelFormat.dwFlags);
+    ok(desc.ddpfPixelFormat.dwRGBBitCount == 16, "Got rgb bit count %u.\n", desc.ddpfPixelFormat.dwRGBBitCount);
+    ok(desc.ddpfPixelFormat.dwRBitMask == 0xf800, "Got r bit mask %#x.\n", desc.ddpfPixelFormat.dwRBitMask);
+    ok(desc.ddpfPixelFormat.dwGBitMask == 0x07e0, "Got g bit mask %#x.\n", desc.ddpfPixelFormat.dwGBitMask);
+    ok(desc.ddpfPixelFormat.dwBBitMask == 0x001f, "Got b bit mask %#x.\n", desc.ddpfPixelFormat.dwBBitMask);
+
+    get_ddrawstream_create_sample_desc(&argb32_format, NULL, NULL, &desc);
+    ok(desc.dwWidth == 100, "Got width %u.\n", desc.dwWidth);
+    ok(desc.dwHeight == 100, "Got height %u.\n", desc.dwHeight);
+    ok(desc.ddpfPixelFormat.dwFlags == (DDPF_RGB | DDPF_ALPHAPIXELS), "Got flags %#x.\n", desc.ddpfPixelFormat.dwFlags);
+    ok(desc.ddpfPixelFormat.dwRGBBitCount == 32, "Got rgb bit count %u.\n", desc.ddpfPixelFormat.dwRGBBitCount);
+    ok(desc.ddpfPixelFormat.dwRBitMask == 0xff0000, "Got r bit mask %#x.\n", desc.ddpfPixelFormat.dwRBitMask);
+    ok(desc.ddpfPixelFormat.dwGBitMask == 0x00ff00, "Got g bit mask %#x.\n", desc.ddpfPixelFormat.dwGBitMask);
+    ok(desc.ddpfPixelFormat.dwBBitMask == 0x0000ff, "Got b bit mask %#x.\n", desc.ddpfPixelFormat.dwBBitMask);
+    ok(desc.ddpfPixelFormat.dwRGBAlphaBitMask == 0xff000000,
+            "Got alpha bit mask %#x.\n", desc.ddpfPixelFormat.dwBBitMask);
+
+    format1 = rgb32_format;
+    format1.dwFlags |= DDSD_CAPS;
+    format1.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_VIDEOMEMORY;
+    get_ddrawstream_create_sample_desc(&format1, NULL, NULL, &desc);
+    ok(desc.ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN, "Expected set DDSCAPS_OFFSCREENPLAIN.\n");
+    ok(desc.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY, "Expected set DDSCAPS_SYSTEMMEMORY.\n");
+    ok(!(desc.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY), "Expected unset DDSCAPS_VIDEOMEMORY.\n");
+    ok(desc.dwWidth == 100, "Got width %u.\n", desc.dwWidth);
+    ok(desc.dwHeight == 100, "Got height %u.\n", desc.dwHeight);
+    ok(desc.ddpfPixelFormat.dwFlags == DDPF_RGB, "Got flags %#x.\n", desc.ddpfPixelFormat.dwFlags);
+    ok(desc.ddpfPixelFormat.dwRGBBitCount == 32, "Got rgb bit count %u.\n", desc.ddpfPixelFormat.dwRGBBitCount);
+    ok(desc.ddpfPixelFormat.dwRBitMask == 0xff0000, "Got r bit mask %#x.\n", desc.ddpfPixelFormat.dwRBitMask);
+    ok(desc.ddpfPixelFormat.dwGBitMask == 0x00ff00, "Got g bit mask %#x.\n", desc.ddpfPixelFormat.dwGBitMask);
+    ok(desc.ddpfPixelFormat.dwBBitMask == 0x0000ff, "Got b bit mask %#x.\n", desc.ddpfPixelFormat.dwBBitMask);
+
+    format1 = rgb32_format;
+    format1.dwFlags |= DDSD_CKSRCBLT;
+    format1.ddckCKSrcBlt.dwColorSpaceLowValue = 0xff00ff;
+    format1.ddckCKSrcBlt.dwColorSpaceHighValue = 0xff00ff;
+    get_ddrawstream_create_sample_desc(&format1, NULL, NULL, &desc);
+    ok(!(desc.dwFlags & DDSD_CKSRCBLT), "Expected unset DDSD_CKSRCBLT.\n");
+    ok(desc.dwWidth == 100, "Got width %u.\n", desc.dwWidth);
+    ok(desc.dwHeight == 100, "Got height %u.\n", desc.dwHeight);
+    ok(desc.ddpfPixelFormat.dwFlags == DDPF_RGB, "Got flags %#x.\n", desc.ddpfPixelFormat.dwFlags);
+    ok(desc.ddpfPixelFormat.dwRGBBitCount == 32, "Got rgb bit count %u.\n", desc.ddpfPixelFormat.dwRGBBitCount);
+    ok(desc.ddpfPixelFormat.dwRBitMask == 0xff0000, "Got r bit mask %#x.\n", desc.ddpfPixelFormat.dwRBitMask);
+    ok(desc.ddpfPixelFormat.dwGBitMask == 0x00ff00, "Got g bit mask %#x.\n", desc.ddpfPixelFormat.dwGBitMask);
+    ok(desc.ddpfPixelFormat.dwBBitMask == 0x0000ff, "Got b bit mask %#x.\n", desc.ddpfPixelFormat.dwBBitMask);
+    ok(desc.ddckCKSrcBlt.dwColorSpaceLowValue == 0, "Got color key low value %#x.\n",
+            desc.ddckCKSrcBlt.dwColorSpaceLowValue);
+    ok(desc.ddckCKSrcBlt.dwColorSpaceHighValue == 0, "Got color key high value %#x.\n",
+            desc.ddckCKSrcBlt.dwColorSpaceHighValue);
 }
 
 static void test_ddrawstreamsample_get_media_stream(void)
From 574fd3d3effa13ad1d4b0ed39d2155a7c03cb9e2 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 17 Sep 2020 14:25:35 +0300
Subject: [PATCH] dxva2: Implement CreateSurface().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dxva2/main.c        | 37 ++++++++++++++++++++++++---
 dlls/dxva2/tests/dxva2.c | 54 ++++++++++++++++++++++++++++------------
 2 files changed, 71 insertions(+), 20 deletions(-)

diff --git a/dlls/dxva2/main.c b/dlls/dxva2/main.c
index dd949b3d316..15d65a58344 100644
--- a/dlls/dxva2/main.c
+++ b/dlls/dxva2/main.c
@@ -19,6 +19,7 @@
 #define COBJMACROS
 
 #include <stdarg.h>
+#include <limits.h>
 #include "windef.h"
 #include "winbase.h"
 #include "d3d9.h"
@@ -132,12 +133,40 @@ static ULONG WINAPI device_manager_processor_service_Release(IDirectXVideoProces
 
 static HRESULT WINAPI device_manager_processor_service_CreateSurface(IDirectXVideoProcessorService *iface,
         UINT width, UINT height, UINT backbuffers, D3DFORMAT format, D3DPOOL pool, DWORD usage, DWORD dxvaType,
-        IDirect3DSurface9 **surface, HANDLE *shared_handle)
+        IDirect3DSurface9 **surfaces, HANDLE *shared_handle)
 {
-    FIXME("%p, %u, %u, %u, %u, %u, %u, %u, %p, %p.\n", iface, width, height, backbuffers, format, pool, usage, dxvaType,
-            surface, shared_handle);
+    struct device_manager *manager = impl_from_IDirectXVideoProcessorService(iface);
+    unsigned int i, j;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %u, %u, %u, %u, %u, %u, %p, %p.\n", iface, width, height, backbuffers, format, pool, usage, dxvaType,
+            surfaces, shared_handle);
+
+    if (backbuffers >= UINT_MAX)
+        return E_INVALIDARG;
+
+    memset(surfaces, 0, (backbuffers + 1) * sizeof(*surfaces));
+
+    for (i = 0; i < backbuffers + 1; ++i)
+    {
+        if (FAILED(hr = IDirect3DDevice9_CreateOffscreenPlainSurface(manager->device, width, height, format,
+                pool, &surfaces[i], NULL)))
+            break;
+    }
+
+    if (FAILED(hr))
+    {
+        for (j = 0; j < i; ++j)
+        {
+            if (surfaces[j])
+            {
+                IDirect3DSurface9_Release(surfaces[j]);
+                surfaces[j] = NULL;
+            }
+        }
+    }
+
+    return hr;
 }
 
 static HRESULT WINAPI device_manager_processor_service_RegisterVideoProcessorSoftwareDevice(
diff --git a/dlls/dxva2/tests/dxva2.c b/dlls/dxva2/tests/dxva2.c
index 49b192a1fad..58b0231420d 100644
--- a/dlls/dxva2/tests/dxva2.c
+++ b/dlls/dxva2/tests/dxva2.c
@@ -59,13 +59,31 @@ static IDirect3DDevice9 *create_device(IDirect3D9 *d3d9, HWND focus_window)
     return device;
 }
 
+static void test_surface_desc(IDirect3DSurface9 *surface)
+{
+    D3DSURFACE_DESC desc = { 0 };
+    HRESULT hr;
+
+    hr = IDirect3DSurface9_GetDesc(surface, &desc);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    ok(desc.Format == D3DFMT_X8R8G8B8, "Unexpected format %d.\n", desc.Format);
+    ok(desc.Type == D3DRTYPE_SURFACE, "Unexpected type %d.\n", desc.Type);
+    ok(desc.Usage == 0, "Unexpected usage %d.\n", desc.Usage);
+    ok(desc.Pool == D3DPOOL_DEFAULT, "Unexpected pool %d.\n", desc.Pool);
+    ok(desc.MultiSampleType == D3DMULTISAMPLE_NONE, "Unexpected multisample type %d.\n", desc.MultiSampleType);
+    ok(desc.MultiSampleQuality == 0, "Unexpected multisample quality %d.\n", desc.MultiSampleQuality);
+    ok(desc.Width == 64, "Unexpected width %u.\n", desc.Width);
+    ok(desc.Height == 64, "Unexpected height %u.\n", desc.Height);
+}
+
 static void test_device_manager(void)
 {
     IDirectXVideoProcessorService *processor_service;
     IDirectXVideoAccelerationService *accel_service;
     IDirect3DDevice9 *device, *device2, *device3;
     IDirect3DDeviceManager9 *manager;
-    IDirect3DSurface9 *surface;
+    IDirect3DSurface9 *surfaces[2];
     int refcount, refcount2;
     HANDLE handle, handle1;
     IDirect3D9 *d3d;
@@ -262,12 +280,20 @@ static void test_device_manager(void)
     hr = DXVA2CreateVideoService(device, &IID_IDirectXVideoAccelerationService, (void **)&accel_service);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    surfaces[0] = surfaces[1] = NULL;
+    hr = IDirectXVideoAccelerationService_CreateSurface(accel_service, 64, 64, 0, D3DFMT_X8R8G8B8,
+            D3DPOOL_DEFAULT, 0, DXVA2_VideoProcessorRenderTarget, surfaces, NULL);
+    ok(hr == S_OK, "Failed to create a surface, hr %#x.\n", hr);
+    ok(!!surfaces[0] && !surfaces[1], "Unexpected surfaces.\n");
+    IDirect3DSurface9_Release(surfaces[0]);
+
     hr = IDirectXVideoAccelerationService_CreateSurface(accel_service, 64, 64, 1, D3DFMT_X8R8G8B8,
-            D3DPOOL_DEFAULT, 0, DXVA2_VideoProcessorRenderTarget, &surface, NULL);
-todo_wine
+            D3DPOOL_DEFAULT, 0, DXVA2_VideoProcessorRenderTarget, surfaces, NULL);
     ok(hr == S_OK, "Failed to create a surface, hr %#x.\n", hr);
-    if (SUCCEEDED(hr))
-        IDirect3DSurface9_Release(surface);
+    ok(!!surfaces[0] && !!surfaces[1], "Unexpected surfaces.\n");
+    test_surface_desc(surfaces[0]);
+    IDirect3DSurface9_Release(surfaces[0]);
+    IDirect3DSurface9_Release(surfaces[1]);
 
     IDirectXVideoAccelerationService_Release(accel_service);
 
@@ -281,20 +307,16 @@ todo_wine
     hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
-    hr = IDirectXVideoAccelerationService_CreateSurface(accel_service, 64, 64, 1, D3DFMT_X8R8G8B8,
-            D3DPOOL_DEFAULT, 0, DXVA2_VideoProcessorRenderTarget, &surface, NULL);
-todo_wine
+    hr = IDirectXVideoAccelerationService_CreateSurface(accel_service, 64, 64, 0, D3DFMT_X8R8G8B8,
+            D3DPOOL_DEFAULT, 0, DXVA2_VideoProcessorRenderTarget, surfaces, NULL);
     ok(hr == S_OK, "Failed to create a surface, hr %#x.\n", hr);
 
-    if (SUCCEEDED(hr))
-    {
-        hr = IDirect3DSurface9_GetDevice(surface, &device3);
-        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-        ok(device2 == device3, "Unexpected device.\n");
-        IDirect3DDevice9_Release(device3);
+    hr = IDirect3DSurface9_GetDevice(surfaces[0], &device3);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(device2 == device3, "Unexpected device.\n");
+    IDirect3DDevice9_Release(device3);
 
-        IDirect3DSurface9_Release(surface);
-    }
+    IDirect3DSurface9_Release(surfaces[0]);
 
     IDirectXVideoAccelerationService_Release(accel_service);
 
From 88f47823e1e8e188379162f1cf785808f9edb981 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 17 Sep 2020 14:25:36 +0300
Subject: [PATCH] dxva2: Return single software device for
 GetVideoProcessorDeviceGuids().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dxva2/Makefile.in |  2 +-
 dlls/dxva2/main.c      | 10 ++++++++--
 2 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/dlls/dxva2/Makefile.in b/dlls/dxva2/Makefile.in
index e3fc2fd6c3a..d331512f019 100644
--- a/dlls/dxva2/Makefile.in
+++ b/dlls/dxva2/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = dxva2.dll
-IMPORTS   = uuid
+IMPORTS   = uuid ole32
 IMPORTLIB = dxva2
 
 EXTRADLLFLAGS = -mno-cygwin
diff --git a/dlls/dxva2/main.c b/dlls/dxva2/main.c
index 15d65a58344..22a35c4fbb3 100644
--- a/dlls/dxva2/main.c
+++ b/dlls/dxva2/main.c
@@ -180,9 +180,15 @@ static HRESULT WINAPI device_manager_processor_service_RegisterVideoProcessorSof
 static HRESULT WINAPI device_manager_processor_service_GetVideoProcessorDeviceGuids(
         IDirectXVideoProcessorService *iface, const DXVA2_VideoDesc *video_desc, UINT *count, GUID **guids)
 {
-    FIXME("%p, %p, %p, %p.\n", iface, video_desc, count, guids);
+    FIXME("%p, %p, %p, %p semi-stub.\n", iface, video_desc, count, guids);
 
-    return E_NOTIMPL;
+    if (!(*guids = CoTaskMemAlloc(sizeof(**guids))))
+        return E_OUTOFMEMORY;
+
+    memcpy(*guids, &DXVA2_VideoProcSoftwareDevice, sizeof(**guids));
+    *count = 1;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI device_manager_processor_service_GetVideoProcessorRenderTargets(
From 97136a8707412614b4a0266d402674bfb3b6e111 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 18 Sep 2020 17:25:15 +0300
Subject: [PATCH] dxva2: Return some static render target formats.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dxva2/main.c            | 18 +++++++++++++++++-
 dlls/dxva2/tests/Makefile.in |  2 +-
 dlls/dxva2/tests/dxva2.c     | 23 ++++++++++++++++++++++-
 3 files changed, 40 insertions(+), 3 deletions(-)

diff --git a/dlls/dxva2/main.c b/dlls/dxva2/main.c
index 22a35c4fbb3..6ebc4f00186 100644
--- a/dlls/dxva2/main.c
+++ b/dlls/dxva2/main.c
@@ -195,7 +195,23 @@ static HRESULT WINAPI device_manager_processor_service_GetVideoProcessorRenderTa
         IDirectXVideoProcessorService *iface, REFGUID deviceguid, const DXVA2_VideoDesc *video_desc, UINT *count,
         D3DFORMAT **formats)
 {
-    FIXME("%p, %s, %p, %p, %p.\n", iface, debugstr_guid(deviceguid), video_desc, count, formats);
+    TRACE("%p, %s, %p, %p, %p.\n", iface, debugstr_guid(deviceguid), video_desc, count, formats);
+
+    if (IsEqualGUID(deviceguid, &DXVA2_VideoProcSoftwareDevice))
+    {
+        /* FIXME: filter some input formats */
+
+        if (!(*formats = CoTaskMemAlloc(2 * sizeof(**formats))))
+            return E_OUTOFMEMORY;
+
+        *count = 2;
+        (*formats)[0] = D3DFMT_X8R8G8B8;
+        (*formats)[1] = D3DFMT_A8R8G8B8;
+
+        return S_OK;
+    }
+    else
+        FIXME("Unsupported device %s.\n", debugstr_guid(deviceguid));
 
     return E_NOTIMPL;
 }
diff --git a/dlls/dxva2/tests/Makefile.in b/dlls/dxva2/tests/Makefile.in
index c86c5ab42fc..ccd03940a24 100644
--- a/dlls/dxva2/tests/Makefile.in
+++ b/dlls/dxva2/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = dxva2.dll
-IMPORTS   = dxva2 user32 d3d9
+IMPORTS   = dxva2 user32 d3d9 ole32
 
 C_SRCS = \
 	dxva2.c
diff --git a/dlls/dxva2/tests/dxva2.c b/dlls/dxva2/tests/dxva2.c
index 58b0231420d..f5b28ed3f8d 100644
--- a/dlls/dxva2/tests/dxva2.c
+++ b/dlls/dxva2/tests/dxva2.c
@@ -82,13 +82,16 @@ static void test_device_manager(void)
     IDirectXVideoProcessorService *processor_service;
     IDirectXVideoAccelerationService *accel_service;
     IDirect3DDevice9 *device, *device2, *device3;
+    IDirectXVideoProcessorService *proc_service;
     IDirect3DDeviceManager9 *manager;
     IDirect3DSurface9 *surfaces[2];
+    DXVA2_VideoDesc video_desc;
     int refcount, refcount2;
     HANDLE handle, handle1;
+    D3DFORMAT *formats;
+    UINT token, count;
     IDirect3D9 *d3d;
     HWND window;
-    UINT token;
     HRESULT hr;
     RECT rect;
 
@@ -297,6 +300,24 @@ static void test_device_manager(void)
 
     IDirectXVideoAccelerationService_Release(accel_service);
 
+    /* RT formats. */
+    hr = DXVA2CreateVideoService(device, &IID_IDirectXVideoProcessorService, (void **)&proc_service);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    memset(&video_desc, 0, sizeof(video_desc));
+    video_desc.SampleWidth = 64;
+    video_desc.SampleHeight = 64;
+    video_desc.Format = D3DFMT_A8R8G8B8;
+
+    count = 0;
+    hr = IDirectXVideoProcessorService_GetVideoProcessorRenderTargets(proc_service, &DXVA2_VideoProcSoftwareDevice,
+            &video_desc, &count, &formats);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(count, "Unexpected format count %u.\n", count);
+    CoTaskMemFree(formats);
+
+    IDirectXVideoProcessorService_Release(proc_service);
+
     hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
