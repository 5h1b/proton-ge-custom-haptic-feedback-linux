From 38aeedcc80b53d98ac52b5a8ecf225025f82bb5e Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 25 May 2020 21:57:47 +0300
Subject: [PATCH] include: Add IMFMediaEngineEx definition.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 include/mfmediaengine.idl | 73 +++++++++++++++++++++++++++++++++++++++
 include/mftransform.idl   |  6 ++++
 2 files changed, 79 insertions(+)

diff --git a/include/mfmediaengine.idl b/include/mfmediaengine.idl
index 556d2fba2ba..e5d91a57322 100644
--- a/include/mfmediaengine.idl
+++ b/include/mfmediaengine.idl
@@ -194,6 +194,79 @@ interface IMFMediaEngine : IUnknown
     HRESULT OnVideoStreamTick([out] LONGLONG *time);
 }
 
+typedef enum MF_MEDIA_ENGINE_STATISTIC
+{
+    MF_MEDIA_ENGINE_STATISTIC_FRAMES_RENDERED,
+    MF_MEDIA_ENGINE_STATISTIC_FRAMES_DROPPED,
+    MF_MEDIA_ENGINE_STATISTIC_BYTES_DOWNLOADED,
+    MF_MEDIA_ENGINE_STATISTIC_BUFFER_PROGRESS,
+    MF_MEDIA_ENGINE_STATISTIC_FRAMES_PER_SECOND,
+    MF_MEDIA_ENGINE_STATISTIC_PLAYBACK_JITTER,
+    MF_MEDIA_ENGINE_STATISTIC_FRAMES_CORRUPTED,
+    MF_MEDIA_ENGINE_STATISTIC_TOTAL_FRAME_DELAY,
+} MF_MEDIA_ENGINE_STATISTIC;
+
+typedef enum MF_MEDIA_ENGINE_S3D_PACKING_MODE
+{
+    MF_MEDIA_ENGINE_S3D_PACKING_MODE_NONE,
+    MF_MEDIA_ENGINE_S3D_PACKING_MODE_SIDE_BY_SIDE,
+    MF_MEDIA_ENGINE_S3D_PACKING_MODE_TOP_BOTTOM
+} MF_MEDIA_ENGINE_S3D_PACKING_MODE;
+
+typedef enum MF_MEDIA_ENGINE_SEEK_MODE
+{
+    MF_MEDIA_ENGINE_SEEK_MODE_NORMAL,
+    MF_MEDIA_ENGINE_SEEK_MODE_APPROXIMATE,
+} MF_MEDIA_ENGINE_SEEK_MODE;
+
+[
+    object,
+    uuid(83015ead-b1e6-40d0-a98a-37145ffe1ad1),
+    local,
+    pointer_default(unique)
+]
+interface IMFMediaEngineEx : IMFMediaEngine
+{
+    HRESULT SetSourceFromByteStream([in] IMFByteStream *bytestream, [in] BSTR url);
+    HRESULT GetStatistics([in] MF_MEDIA_ENGINE_STATISTIC stat_id, [out] PROPVARIANT *stat);
+    HRESULT UpdateVideoStream([in] const MFVideoNormalizedRect *src,
+            [in] const RECT *dst, [in] const MFARGB *border_color);
+    double GetBalance();
+    HRESULT SetBalance([in] double balance);
+    BOOL IsPlaybackRateSupported([in] double rate);
+    HRESULT FrameStep([in] BOOL forward);
+    HRESULT GetResourceCharacteristics([out] DWORD *flags);
+    HRESULT GetPresentationAttribute([in] REFGUID attribute, [out] PROPVARIANT *value);
+    HRESULT GetNumberOfStreams([out] DWORD *stream_count);
+    HRESULT GetStreamAttribute([in] DWORD stream_index, [in] REFGUID attribute, [out] PROPVARIANT *value);
+    HRESULT GetStreamSelection([in] DWORD stream_index, [out] BOOL *enabled);
+    HRESULT SetStreamSelection([in] DWORD stream_index, [in] BOOL enabled);
+    HRESULT ApplyStreamSelections();
+    HRESULT IsProtected([out] BOOL *protected);
+    HRESULT InsertVideoEffect([in] IUnknown *effect, [in] BOOL is_optional);
+    HRESULT InsertAudioEffect([in] IUnknown *effect, [in] BOOL is_optional);
+    HRESULT RemoveAllEffects();
+    HRESULT SetTimelineMarkerTimer([in] double timeout);
+    HRESULT GetTimelineMarkerTimer([out] double *timeout);
+    HRESULT CancelTimelineMarkerTimer();
+    BOOL IsStereo3D();
+    HRESULT GetStereo3DFramePackingMode([out] MF_MEDIA_ENGINE_S3D_PACKING_MODE *mode);
+    HRESULT SetStereo3DFramePackingMode([in] MF_MEDIA_ENGINE_S3D_PACKING_MODE mode);
+    HRESULT GetStereo3DRenderMode([out] MF3DVideoOutputType *output_type);
+    HRESULT SetStereo3DRenderMode([in] MF3DVideoOutputType output_type);
+    HRESULT EnableWindowlessSwapchainMode([in] BOOL enable);
+    HRESULT GetVideoSwapchainHandle([out] HANDLE *swapchain);
+    HRESULT EnableHorizontalMirrorMode([in] BOOL enable);
+    HRESULT GetAudioStreamCategory([out] UINT32 *category);
+    HRESULT SetAudioStreamCategory([in] UINT32 category);
+    HRESULT GetAudioEndpointRole([out] UINT32 *role);
+    HRESULT SetAudioEndpointRole([in] UINT32 role);
+    HRESULT GetRealTimeMode([out] BOOL *enabled);
+    HRESULT SetRealTimeMode([in] BOOL enable);
+    HRESULT SetCurrentTimeEx([in] double seektime, [in] MF_MEDIA_ENGINE_SEEK_MODE mode);
+    HRESULT EnableTimeUpdateTimer([in] BOOL enable);
+}
+
 [
     object,
     uuid(4d645ace-26aa-4688-9be1-df3516990b93),
diff --git a/include/mftransform.idl b/include/mftransform.idl
index 6b9c79572aa..1b402a5cc77 100644
--- a/include/mftransform.idl
+++ b/include/mftransform.idl
@@ -107,6 +107,12 @@ enum _MFT_DRAIN_TYPE
     MFT_DRAIN_NO_TAILS      = 0x00000001
 };
 
+typedef enum _MF3DVideoOutputType
+{
+    MF3DVideoOutputType_BaseView,
+    MF3DVideoOutputType_Stereo
+} MF3DVideoOutputType;
+
 typedef struct _MFT_INPUT_STREAM_INFO
 {
     LONGLONG hnsMaxLatency;
From ba920246e502afe7bc664c1881d528a27e980101 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 25 May 2020 22:14:23 +0300
Subject: [PATCH] mfplat: Add Media Engine attributes to tracing.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/main.c | 32 +++++++++++++++++++++++++++++++-
 1 file changed, 31 insertions(+), 1 deletion(-)

diff --git a/dlls/mfplat/main.c b/dlls/mfplat/main.c
index 0a5958acb2d..ea6a0659c5c 100644
--- a/dlls/mfplat/main.c
+++ b/dlls/mfplat/main.c
@@ -39,6 +39,7 @@
 
 #include "mfplat_private.h"
 #include "mfreadwrite.h"
+#include "mfmediaengine.h"
 #include "propvarutil.h"
 #include "strsafe.h"
 
@@ -1559,6 +1560,7 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_MT_MPEG2_TIMECODE),
         X(MF_PMP_SERVER_CONTEXT),
         X(MFT_SUPPORT_DYNAMIC_FORMAT_CHANGE),
+        X(MF_MEDIA_ENGINE_TRACK_ID),
         X(MF_MT_CUSTOM_VIDEO_PRIMARIES),
         X(MF_MT_TIMESTAMP_CAN_BE_DTS),
         X(MFT_CODEC_MERIT_Attribute),
@@ -1566,10 +1568,12 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_LOW_LATENCY),
         X(MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS),
         X(MF_MT_MPEG2_FLAGS),
+        X(MF_MEDIA_ENGINE_AUDIO_CATEGORY),
         X(MF_MT_PIXEL_ASPECT_RATIO),
         X(MF_TOPOLOGY_ENABLE_XVP_FOR_PLAYBACK),
         X(MFT_CONNECTED_STREAM_ATTRIBUTE),
         X(MF_MT_REALTIME_CONTENT),
+        X(MF_MEDIA_ENGINE_CONTENT_PROTECTION_FLAGS),
         X(MF_MT_WRAPPED_TYPE),
         X(MF_MT_DRM_FLAGS),
         X(MF_MT_AVG_BITRATE),
@@ -1583,6 +1587,7 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_SOURCE_READER_ENABLE_ADVANCED_VIDEO_PROCESSING),
         X(MF_MT_AM_FORMAT_TYPE),
         X(MF_SESSION_APPROX_EVENT_OCCURRENCE_TIME),
+        X(MF_MEDIA_ENGINE_SYNCHRONOUS_CLOSE),
         X(MF_MT_H264_MAX_MB_PER_SEC),
         X(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_MAX_BUFFERS),
         X(MF_MT_AUDIO_BLOCK_ALIGNMENT),
@@ -1597,10 +1602,13 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_MT_H264_SUPPORTED_SLICE_MODES),
         X(MF_PD_LAST_MODIFIED_TIME),
         X(MF_PD_PLAYBACK_ELEMENT_ID),
+        X(MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE9),
         X(MF_MT_ALL_SAMPLES_INDEPENDENT),
         X(MF_PD_PREFERRED_LANGUAGE),
         X(MF_PD_PLAYBACK_BOUNDARY_TIME),
+        X(MF_MEDIA_ENGINE_TELEMETRY_APPLICATION_ID),
         X(MF_ACTIVATE_MFT_LOCKED),
+        X(MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT),
         X(MF_SOURCE_READER_ENABLE_VIDEO_PROCESSING),
         X(MF_MT_FRAME_SIZE),
         X(MF_MT_H264_SIMULCAST_SUPPORT),
@@ -1612,9 +1620,13 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_MT_PALETTE),
         X(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_PROVIDER_DEVICE_ID),
         X(MF_TOPOLOGY_STATIC_PLAYBACK_OPTIMIZATIONS),
+        X(MF_MEDIA_ENGINE_NEEDKEY_CALLBACK),
         X(MF_MT_GEOMETRIC_APERTURE),
         X(MF_MT_ORIGINAL_WAVE_FORMAT_TAG),
         X(MF_MT_DV_AAUX_SRC_PACK_1),
+        X(MF_MEDIA_ENGINE_STREAM_CONTAINS_ALPHA_CHANNEL),
+        X(MF_MEDIA_ENGINE_MEDIA_PLAYER_MODE),
+        X(MF_MEDIA_ENGINE_EXTENSION),
         X(MF_MT_DEFAULT_STRIDE),
         X(MF_MT_ARBITRARY_FORMAT),
         X(MF_TRANSFORM_CATEGORY_Attribute),
@@ -1632,12 +1644,14 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME),
         X(MF_MT_VIDEO_ROTATION),
         X(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_SYMBOLIC_LINK),
+        X(MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE11),
         X(MF_MT_USER_DATA),
         X(MF_MT_MIN_MASTERING_LUMINANCE),
         X(MF_EVENT_STREAM_METADATA_SYSTEMID),
         X(MF_MT_AUDIO_CHANNEL_MASK),
         X(MF_SOURCE_READER_DISCONNECT_MEDIASOURCE_ON_SHUTDOWN),
         X(MF_READWRITE_DISABLE_CONVERTERS),
+        X(MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE_EDGE),
         X(MF_MT_MINIMUM_DISPLAY_APERTURE),
         X(MFSampleExtension_Token),
         X(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_CATEGORY),
@@ -1646,12 +1660,13 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_DISABLE_FRAME_CORRUPTION_INFO),
         X(MF_TOPOLOGY_ENUMERATE_SOURCE_TYPES),
         X(MF_MT_VIDEO_NO_FRAME_ORDERING),
+        X(MF_MEDIA_ENGINE_PLAYBACK_VISUAL),
         X(MF_MT_VIDEO_CHROMA_SITING),
         X(MF_AUDIO_RENDERER_ATTRIBUTE_STREAM_CATEGORY),
         X(MFSampleExtension_3DVideo_SampleFormat),
         X(MF_MT_H264_RESOLUTION_SCALING),
-        X(MF_MT_MPEG2_LEVEL),
         X(MF_MT_VIDEO_LEVEL),
+        X(MF_MT_MPEG2_LEVEL),
         X(MF_SAMPLEGRABBERSINK_SAMPLE_TIME_OFFSET),
         X(MF_MT_SAMPLE_SIZE),
         X(MF_MT_AAC_PAYLOAD_TYPE),
@@ -1682,6 +1697,7 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_BYTESTREAM_ORIGIN_NAME),
         X(MF_BYTESTREAM_CONTENT_TYPE),
         X(MF_MT_DEPTH_MEASUREMENT),
+        X(MF_MEDIA_ENGINE_COMPATIBILITY_MODE_WIN10),
         X(MF_MT_VIDEO_3D_NUM_VIEWS),
         X(MF_BYTESTREAM_DURATION),
         X(MF_SD_SAMI_LANGUAGE),
@@ -1701,6 +1717,8 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_MT_VIDEO_3D_FIRST_IS_LEFT),
         X(MFT_DECODER_FINAL_VIDEO_RESOLUTION_HINT),
         X(MF_PD_ADAPTIVE_STREAMING),
+        X(MF_MEDIA_ENGINE_SOURCE_RESOLVER_CONFIG_STORE),
+        X(MF_MEDIA_ENGINE_COMPATIBILITY_MODE_WWA_EDGE),
         X(MF_MT_H264_SUPPORTED_USAGES),
         X(MFT_PREFERRED_OUTPUTTYPE_Attribute),
         X(MFSampleExtension_Timestamp),
@@ -1708,6 +1726,7 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_MT_SUBTYPE),
         X(MF_TRANSFORM_ASYNC),
         X(MF_TOPONODE_STREAMID),
+        X(MF_MEDIA_ENGINE_PLAYBACK_HWND),
         X(MF_TOPONODE_NOSHUTDOWN_ON_REMOVE),
         X(MF_MT_VIDEO_LIGHTING),
         X(MF_SD_MUTUALLY_EXCLUSIVE),
@@ -1722,9 +1741,11 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_SINK_WRITER_D3D_MANAGER),
         X(MFSampleExtension_3DVideo),
         X(MF_MT_H264_USAGE),
+        X(MF_MEDIA_ENGINE_EME_CALLBACK),
         X(MF_EVENT_SOURCE_FAKE_START),
         X(MF_EVENT_SOURCE_PROJECTSTART),
         X(MF_EVENT_SOURCE_ACTUAL_START),
+        X(MF_MEDIA_ENGINE_CONTENT_PROTECTION_MANAGER),
         X(MF_MT_AUDIO_SAMPLES_PER_BLOCK),
         X(MFT_ENUM_HARDWARE_URL_Attribute),
         X(MF_SOURCE_READER_ASYNC_CALLBACK),
@@ -1741,6 +1762,7 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_MT_SPATIAL_AUDIO_MAX_METADATA_ITEMS),
         X(MF_MT_MPEG2_ONE_FRAME_PER_PACKET),
         X(MF_MT_INTERLACE_MODE),
+        X(MF_MEDIA_ENGINE_CALLBACK),
         X(MF_MT_VIDEO_RENDERER_EXTENSION_PROFILE),
         X(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_HW_SOURCE),
         X(MF_MT_AUDIO_PREFER_WAVEFORMATEX),
@@ -1767,9 +1789,11 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_EVENT_START_PRESENTATION_TIME),
         X(MF_EVENT_SESSIONCAPS),
         X(MF_EVENT_PRESENTATION_TIME_OFFSET),
+        X(MF_MEDIA_ENGINE_AUDIO_ENDPOINT_ROLE),
         X(MF_EVENT_SESSIONCAPS_DELTA),
         X(MF_EVENT_START_PRESENTATION_TIME_AT_OUTPUT),
         X(MFSampleExtension_DecodeTimestamp),
+        X(MF_MEDIA_ENGINE_COMPATIBILITY_MODE),
         X(MF_MT_VIDEO_H264_NO_FMOASO),
         X(MF_MT_AVG_BIT_ERROR_RATE),
         X(MF_MT_VIDEO_PRIMARIES),
@@ -1777,7 +1801,9 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_MT_H264_RATE_CONTROL_MODES),
         X(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK),
         X(MF_READWRITE_D3D_OPTIONAL),
+        X(MF_MEDIA_ENGINE_DXGI_MANAGER),
         X(MF_READWRITE_MMCSS_CLASS_AUDIO),
+        X(MF_MEDIA_ENGINE_COREWINDOW),
         X(MF_SOURCE_READER_DISABLE_CAMERA_PLUGINS),
         X(MF_MT_MPEG4_TRACK_TYPE),
         X(MF_MT_PAN_SCAN_APERTURE),
@@ -1785,6 +1811,7 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_MT_ORIGINAL_4CC),
         X(MF_PD_AUDIO_ISVARIABLEBITRATE),
         X(MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS),
+        X(MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE),
         X(MF_AUDIO_RENDERER_ATTRIBUTE_SESSION_ID),
         X(MF_MT_MPEG2_CONTENT_PACKET),
         X(MFT_PROCESS_LOCAL_Attribute),
@@ -1793,6 +1820,7 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_MT_VIDEO_NOMINAL_RANGE),
         X(MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION),
         X(MF_MT_MPEG_SEQUENCE_HEADER),
+        X(MF_MEDIA_ENGINE_OPM_HWND),
         X(MF_MT_AUDIO_SAMPLES_PER_SECOND),
         X(MF_MT_SPATIAL_AUDIO_DATA_PRESENT),
         X(MF_MT_FRAME_RATE),
@@ -1822,6 +1850,7 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_TOPOLOGY_DXVA_MODE),
         X(MF_TOPONODE_LOCKED),
         X(MF_TOPONODE_WORKQUEUE_ID),
+        X(MF_MEDIA_ENGINE_CONTINUE_ON_CODEC_ERROR),
         X(MF_TOPONODE_WORKQUEUE_MMCSS_CLASS),
         X(MF_TOPONODE_DECRYPTOR),
         X(MF_EVENT_DO_THINNING),
@@ -1829,6 +1858,7 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_TOPOLOGY_HARDWARE_MODE),
         X(MF_SOURCE_READER_DISABLE_DXVA),
         X(MF_MT_FORWARD_CUSTOM_NALU),
+        X(MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE10),
         X(MF_TOPONODE_ERROR_MAJORTYPE),
         X(MF_MT_SECURE),
         X(MFT_FIELDOFUSE_UNLOCK_Attribute),
From d45d34cdf5c2fc4b73aa6c07ff04079cdb9fe752 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 26 May 2020 01:58:46 +0300
Subject: [PATCH] include: Add CResamplerMediaObject class id.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 include/wmcodecdsp.idl | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/include/wmcodecdsp.idl b/include/wmcodecdsp.idl
index d4547cd8816..61381bee6d4 100644
--- a/include/wmcodecdsp.idl
+++ b/include/wmcodecdsp.idl
@@ -25,3 +25,8 @@ cpp_quote("DEFINE_GUID(MEDIASUBTYPE_I420,0x30323449,0x0000,0x0010,0x80,0x00,0x00
     uuid(bbeea841-0a63-4f52-a7ab-a9b3a84ed38a)
 ]
 coclass CMP3DecMediaObject {}
+
+[
+    uuid(f447b69e-1884-4a7e-8055-346f74d6edb3)
+]
+coclass CResamplerMediaObject {}
From e2c681a8976bb31378fd946497da485e5ef73fad Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 28 May 2020 18:54:16 +0300
Subject: [PATCH] include: Add Media Engine events constants.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 include/mfmediaengine.idl | 43 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 43 insertions(+)

diff --git a/include/mfmediaengine.idl b/include/mfmediaengine.idl
index e5d91a57322..4ea3d834cf2 100644
--- a/include/mfmediaengine.idl
+++ b/include/mfmediaengine.idl
@@ -94,6 +94,49 @@ typedef enum MF_MEDIA_ENGINE_CREATEFLAGS
     MF_MEDIA_ENGINE_CREATEFLAGS_MASK = 0x1f
 } MF_MEDIA_ENGINE_CREATEFLAGS;
 
+typedef enum MF_MEDIA_ENGINE_EVENT
+{
+    MF_MEDIA_ENGINE_EVENT_LOADSTART = 1,
+    MF_MEDIA_ENGINE_EVENT_PROGRESS = 2,
+    MF_MEDIA_ENGINE_EVENT_SUSPEND = 3,
+    MF_MEDIA_ENGINE_EVENT_ABORT = 4,
+    MF_MEDIA_ENGINE_EVENT_ERROR = 5,
+    MF_MEDIA_ENGINE_EVENT_EMPTIED = 6,
+    MF_MEDIA_ENGINE_EVENT_STALLED = 7,
+    MF_MEDIA_ENGINE_EVENT_PLAY = 8,
+    MF_MEDIA_ENGINE_EVENT_PAUSE = 9,
+    MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA = 10,
+    MF_MEDIA_ENGINE_EVENT_LOADEDDATA = 11,
+    MF_MEDIA_ENGINE_EVENT_WAITING = 12,
+    MF_MEDIA_ENGINE_EVENT_PLAYING = 13,
+    MF_MEDIA_ENGINE_EVENT_CANPLAY = 14,
+    MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH = 15,
+    MF_MEDIA_ENGINE_EVENT_SEEKING = 16,
+    MF_MEDIA_ENGINE_EVENT_SEEKED = 17,
+    MF_MEDIA_ENGINE_EVENT_TIMEUPDATE = 18,
+    MF_MEDIA_ENGINE_EVENT_ENDED = 19,
+    MF_MEDIA_ENGINE_EVENT_RATECHANGE = 20,
+    MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE = 21,
+    MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE = 22,
+    MF_MEDIA_ENGINE_EVENT_FORMATCHANGE = 1000,
+    MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS  = 1001,
+    MF_MEDIA_ENGINE_EVENT_TIMELINE_MARKER = 1002,
+    MF_MEDIA_ENGINE_EVENT_BALANCECHANGE = 1003,
+    MF_MEDIA_ENGINE_EVENT_DOWNLOADCOMPLETE = 1004,
+    MF_MEDIA_ENGINE_EVENT_BUFFERINGSTARTED = 1005,
+    MF_MEDIA_ENGINE_EVENT_BUFFERINGENDED = 1006,
+    MF_MEDIA_ENGINE_EVENT_FRAMESTEPCOMPLETED = 1007,
+    MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE = 1008,
+    MF_MEDIA_ENGINE_EVENT_FIRSTFRAMEREADY = 1009,
+    MF_MEDIA_ENGINE_EVENT_TRACKSCHANGE = 1010,
+    MF_MEDIA_ENGINE_EVENT_OPMINFO = 1011,
+    MF_MEDIA_ENGINE_EVENT_RESOURCELOST = 1012,
+    MF_MEDIA_ENGINE_EVENT_DELAYLOADEVENT_CHANGED = 1013,
+    MF_MEDIA_ENGINE_EVENT_STREAMRENDERINGERROR = 1014,
+    MF_MEDIA_ENGINE_EVENT_SUPPORTEDRATES_CHANGED = 1015,
+    MF_MEDIA_ENGINE_EVENT_AUDIOENDPOINTCHANGE = 1016,
+} MF_MEDIA_ENGINE_EVENT;
+
 [
     object,
     uuid(fc0e10d2-ab2a-4501-a951-06bb1075184c),
From 9de7895e4e4707b2c8fb164887a40bfe915ed580 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 28 May 2020 18:54:17 +0300
Subject: [PATCH] mfmediaengine/tests: Use global factory instance.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/tests/mfmediaengine.c | 85 +++++++++++++++++++-----
 1 file changed, 69 insertions(+), 16 deletions(-)

diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index 2bbc79fb6c8..14d9eed453e 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -35,6 +35,8 @@
 
 static HRESULT (WINAPI *pMFCreateDXGIDeviceManager)(UINT *token, IMFDXGIDeviceManager **manager);
 
+static IMFMediaEngineClassFactory *factory;
+
 #define EXPECT_REF(obj,ref) _expect_ref((IUnknown*)obj, ref, __LINE__)
 static void _expect_ref(IUnknown *obj, ULONG ref, int line)
 {
@@ -114,25 +116,20 @@ static void test_factory(void)
     UINT token;
     HRESULT hr;
 
-    CoInitialize(NULL);
-
-    hr = CoCreateInstance(&CLSID_MFMediaEngineClassFactory, NULL, CLSCTX_INPROC_SERVER,
-                          &IID_IMFMediaEngineClassFactory, (void **)&factory);
-    ok(hr == S_OK || broken(hr == REGDB_E_CLASSNOTREG) /* pre-win8 */,
-       "Failed to create class factory, hr %#x.\n", hr);
-
-    hr = CoCreateInstance(&CLSID_MFMediaEngineClassFactory, (IUnknown *)factory, CLSCTX_INPROC_SERVER,
-                          &IID_IMFMediaEngineClassFactory, (void **)&factory2);
-    ok(hr == CLASS_E_NOAGGREGATION || broken(hr == REGDB_E_CLASSNOTREG) /* pre-win8 */,
-       "Unexpected hr %#x.\n", hr);
-
-    if (!factory)
+    hr = CoCreateInstance(&CLSID_MFMediaEngineClassFactory, NULL, CLSCTX_INPROC_SERVER, &IID_IMFMediaEngineClassFactory,
+            (void **)&factory);
+    ok(hr == S_OK || broken(hr == REGDB_E_CLASSNOTREG) /* pre-win8 */, "Failed to create class factory, hr %#x.\n", hr);
+    if (FAILED(hr))
     {
-        win_skip("Not IMFMediaEngineClassFactory support.\n");
-        CoUninitialize();
+        win_skip("Media Engine is not supported.\n");
         return;
     }
 
+    /* Aggregation is not supported. */
+    hr = CoCreateInstance(&CLSID_MFMediaEngineClassFactory, (IUnknown *)factory, CLSCTX_INPROC_SERVER,
+            &IID_IMFMediaEngineClassFactory, (void **)&factory2);
+    ok(hr == CLASS_E_NOAGGREGATION, "Unexpected hr %#x.\n", hr);
+
     hr = pMFCreateDXGIDeviceManager(&token, &manager);
     ok(hr == S_OK, "MFCreateDXGIDeviceManager failed: %#x.\n", hr);
     hr = MFCreateAttributes(&attributes, 3);
@@ -163,20 +160,76 @@ static void test_factory(void)
     IMFAttributes_Release(attributes);
     IMFDXGIDeviceManager_Release(manager);
     IMFMediaEngineClassFactory_Release(factory);
+}
 
-    CoUninitialize();
+static void test_CreateInstance(void)
+{
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *notify = &notify_impl.IMFMediaEngineNotify_iface;
+    IMFDXGIDeviceManager *manager;
+    IMFMediaEngine *media_engine;
+    IMFAttributes *attributes;
+    UINT token;
+    HRESULT hr;
+
+    hr = pMFCreateDXGIDeviceManager(&token, &manager);
+    ok(hr == S_OK, "Failed to create dxgi device manager, hr %#x.\n", hr);
+
+    hr = MFCreateAttributes(&attributes, 3);
+    ok(hr == S_OK, "Failed to create attributes, hr %#x.\n", hr);
+
+    hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_WAITFORSTABLE_STATE,
+            attributes, &media_engine);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFAttributes_SetUnknown(attributes, &MF_MEDIA_ENGINE_OPM_HWND, NULL);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
+
+    hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_WAITFORSTABLE_STATE,
+            attributes, &media_engine);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
+
+    IMFAttributes_DeleteAllItems(attributes);
+
+    hr = IMFAttributes_SetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, (IUnknown *)notify);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
+    hr = IMFAttributes_SetUINT32(attributes, &MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT, DXGI_FORMAT_UNKNOWN);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
+
+    hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_WAITFORSTABLE_STATE, attributes, &media_engine);
+    ok(hr == S_OK, "Failed to create media engine, hr %#x.\n", hr);
+
+    IMFMediaEngine_Release(media_engine);
+    IMFAttributes_Release(attributes);
+    IMFDXGIDeviceManager_Release(manager);
 }
 
 START_TEST(mfmediaengine)
 {
     HRESULT hr;
 
+    CoInitialize(NULL);
+
+    hr = CoCreateInstance(&CLSID_MFMediaEngineClassFactory, NULL, CLSCTX_INPROC_SERVER, &IID_IMFMediaEngineClassFactory,
+            (void **)&factory);
+    if (FAILED(hr))
+    {
+        win_skip("Media Engine is not supported.\n");
+        CoUninitialize();
+        return;
+    }
+
     init_functions();
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
     ok(hr == S_OK, "MFStartup failed: %#x.\n", hr);
 
     test_factory();
+    test_CreateInstance();
+
+    IMFMediaEngineClassFactory_Release(factory);
+
+    CoUninitialize();
 
     MFShutdown();
 }
From a8ee0575fdb38c8f5724a4a3448d331c61514acf Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 28 May 2020 18:54:18 +0300
Subject: [PATCH] mfmediaengine/tests: Add some tests for shutdown state.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/tests/Makefile.in     |   2 +-
 dlls/mfmediaengine/tests/mfmediaengine.c | 196 +++++++++++++++++++++++
 2 files changed, 197 insertions(+), 1 deletion(-)

diff --git a/dlls/mfmediaengine/tests/Makefile.in b/dlls/mfmediaengine/tests/Makefile.in
index d508db9f6f5..88758f7a613 100644
--- a/dlls/mfmediaengine/tests/Makefile.in
+++ b/dlls/mfmediaengine/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = mfmediaengine.dll
-IMPORTS   = ole32 mfplat mfmediaengine mfuuid uuid
+IMPORTS   = ole32 mfplat mfmediaengine oleaut32 mfuuid uuid
 
 C_SRCS = \
 	mfmediaengine.c
diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index 14d9eed453e..07bd8c81e67 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -105,6 +105,34 @@ static IMFMediaEngineNotifyVtbl media_engine_notify_vtbl =
     media_engine_notify_EventNotify,
 };
 
+static IMFMediaEngine *create_media_engine(IMFMediaEngineNotify *callback)
+{
+    IMFDXGIDeviceManager *manager;
+    IMFMediaEngine *media_engine;
+    IMFAttributes *attributes;
+    UINT token;
+    HRESULT hr;
+
+    hr = pMFCreateDXGIDeviceManager(&token, &manager);
+    ok(hr == S_OK, "Failed to create dxgi device manager, hr %#x.\n", hr);
+
+    hr = MFCreateAttributes(&attributes, 3);
+    ok(hr == S_OK, "Failed to create attributes, hr %#x.\n", hr);
+
+    hr = IMFAttributes_SetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, (IUnknown *)callback);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
+    hr = IMFAttributes_SetUINT32(attributes, &MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT, DXGI_FORMAT_UNKNOWN);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
+
+    hr = IMFMediaEngineClassFactory_CreateInstance(factory, 0, attributes, &media_engine);
+    ok(hr == S_OK, "Failed to create media engine, hr %#x.\n", hr);
+
+    IMFAttributes_Release(attributes);
+    IMFDXGIDeviceManager_Release(manager);
+
+    return media_engine;
+}
+
 static void test_factory(void)
 {
     struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
@@ -204,6 +232,173 @@ static void test_CreateInstance(void)
     IMFDXGIDeviceManager_Release(manager);
 }
 
+static void test_Shutdown(void)
+{
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *callback = &notify_impl.IMFMediaEngineNotify_iface;
+    IMFMediaTimeRange *time_range;
+    IMFMediaEngine *media_engine;
+    unsigned int state;
+    DWORD cx, cy;
+    double val;
+    HRESULT hr;
+    BSTR str;
+
+    media_engine = create_media_engine(callback);
+
+    hr = IMFMediaEngine_Shutdown(media_engine);
+todo_wine
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
+
+    hr = IMFMediaEngine_Shutdown(media_engine);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN || broken(hr == S_OK) /* before win10 */, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaEngine_SetSource(media_engine, NULL);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaEngine_GetCurrentSource(media_engine, &str);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    state = IMFMediaEngine_GetNetworkState(media_engine);
+    ok(!state, "Unexpected state %d.\n", state);
+
+    /* Preload mode is still accessible. */
+    state = IMFMediaEngine_GetPreload(media_engine);
+todo_wine
+    ok(!state, "Unexpected state %d.\n", state);
+
+    hr = IMFMediaEngine_SetPreload(media_engine, MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    state = IMFMediaEngine_GetPreload(media_engine);
+todo_wine
+    ok(state == MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC, "Unexpected state %d.\n", state);
+
+    hr = IMFMediaEngine_GetBuffered(media_engine, &time_range);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaEngine_Load(media_engine);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    str = SysAllocString(L"video/mp4");
+    hr = IMFMediaEngine_CanPlayType(media_engine, str, &state);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+    SysFreeString(str);
+
+    state = IMFMediaEngine_GetReadyState(media_engine);
+    ok(!state, "Unexpected state %d.\n", state);
+
+    state = IMFMediaEngine_IsSeeking(media_engine);
+    ok(!state, "Unexpected state %d.\n", state);
+
+    val = IMFMediaEngine_GetCurrentTime(media_engine);
+    ok(val == 0.0, "Unexpected time %f.\n", val);
+
+    hr = IMFMediaEngine_SetCurrentTime(media_engine, 1.0);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    val = IMFMediaEngine_GetStartTime(media_engine);
+    ok(val == 0.0, "Unexpected time %f.\n", val);
+
+    state = IMFMediaEngine_IsPaused(media_engine);
+todo_wine
+    ok(!!state, "Unexpected state %d.\n", state);
+
+    val = IMFMediaEngine_GetDefaultPlaybackRate(media_engine);
+todo_wine
+    ok(val == 1.0, "Unexpected rate %f.\n", val);
+
+    hr = IMFMediaEngine_SetDefaultPlaybackRate(media_engine, 2.0);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    val = IMFMediaEngine_GetPlaybackRate(media_engine);
+todo_wine
+    ok(val == 1.0, "Unexpected rate %f.\n", val);
+
+    hr = IMFMediaEngine_GetPlayed(media_engine, &time_range);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaEngine_GetSeekable(media_engine, &time_range);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    state = IMFMediaEngine_IsEnded(media_engine);
+    ok(!state, "Unexpected state %d.\n", state);
+
+    /* Autoplay mode is still accessible. */
+    state = IMFMediaEngine_GetAutoPlay(media_engine);
+    ok(!state, "Unexpected state.\n");
+
+    hr = IMFMediaEngine_SetAutoPlay(media_engine, TRUE);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    state = IMFMediaEngine_GetAutoPlay(media_engine);
+todo_wine
+    ok(!!state, "Unexpected state.\n");
+
+    /* Loop mode is still accessible. */
+    state = IMFMediaEngine_GetLoop(media_engine);
+    ok(!state, "Unexpected state.\n");
+
+    hr = IMFMediaEngine_SetLoop(media_engine, TRUE);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    state = IMFMediaEngine_GetLoop(media_engine);
+todo_wine
+    ok(!!state, "Unexpected state.\n");
+
+    hr = IMFMediaEngine_Play(media_engine);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaEngine_Pause(media_engine);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    state = IMFMediaEngine_GetMuted(media_engine);
+    ok(!state, "Unexpected state.\n");
+
+    hr = IMFMediaEngine_SetMuted(media_engine, TRUE);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    val = IMFMediaEngine_GetVolume(media_engine);
+todo_wine
+    ok(val == 1.0, "Unexpected value %f.\n", val);
+
+    val = IMFMediaEngine_SetVolume(media_engine, 2.0);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    state = IMFMediaEngine_HasVideo(media_engine);
+    ok(!state, "Unexpected state.\n");
+
+    state = IMFMediaEngine_HasAudio(media_engine);
+    ok(!state, "Unexpected state.\n");
+
+    hr = IMFMediaEngine_GetNativeVideoSize(media_engine, &cx, &cy);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaEngine_GetVideoAspectRatio(media_engine, &cx, &cy);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
+    IMFMediaEngine_Release(media_engine);
+}
+
 START_TEST(mfmediaengine)
 {
     HRESULT hr;
@@ -226,6 +421,7 @@ START_TEST(mfmediaengine)
 
     test_factory();
     test_CreateInstance();
+    test_Shutdown();
 
     IMFMediaEngineClassFactory_Release(factory);
 
From 5007c2bd365a62db4d804738b214bffbd84fd5cc Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 28 May 2020 18:54:19 +0300
Subject: [PATCH] mfmediaengine: Add shut down state.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c                | 38 ++++++++++++++++++------
 dlls/mfmediaengine/tests/mfmediaengine.c |  2 --
 2 files changed, 29 insertions(+), 11 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 050743e7e33..0c082a87f5f 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -54,16 +54,24 @@ enum media_engine_mode
     MEDIA_ENGINE_FRAME_SERVER_MODE,
 };
 
+/* Used with create flags. */
+enum media_engine_flags
+{
+    /* MF_MEDIA_ENGINE_CREATEFLAGS_MASK is 0x1f. */
+    FLAGS_ENGINE_SHUT_DOWN = 0x20,
+};
+
 struct media_engine
 {
     IMFMediaEngine IMFMediaEngine_iface;
     LONG refcount;
-    DWORD flags;
     IMFMediaEngineNotify *callback;
     UINT64 playback_hwnd;
     DXGI_FORMAT output_format;
     IMFDXGIDeviceManager *dxgi_manager;
     enum media_engine_mode mode;
+    unsigned int flags;
+    CRITICAL_SECTION cs;
 };
 
 static inline struct media_engine *impl_from_IMFMediaEngine(IMFMediaEngine *iface)
@@ -104,6 +112,7 @@ static void free_media_engine(struct media_engine *engine)
         IMFMediaEngineNotify_Release(engine->callback);
     if (engine->dxgi_manager)
         IMFDXGIDeviceManager_Release(engine->dxgi_manager);
+    DeleteCriticalSection(&engine->cs);
     heap_free(engine);
 }
 
@@ -395,9 +404,19 @@ static HRESULT WINAPI media_engine_GetVideoAspectRatio(IMFMediaEngine *iface, DW
 
 static HRESULT WINAPI media_engine_Shutdown(IMFMediaEngine *iface)
 {
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    HRESULT hr = S_OK;
+
     FIXME("(%p): stub.\n", iface);
 
-    return E_NOTIMPL;
+    EnterCriticalSection(&engine->cs);
+    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else
+        engine->flags |= FLAGS_ENGINE_SHUT_DOWN;
+    LeaveCriticalSection(&engine->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI media_engine_TransferVideoFrame(IMFMediaEngine *iface, IUnknown *surface,
@@ -490,10 +509,15 @@ static ULONG WINAPI media_engine_factory_Release(IMFMediaEngineClassFactory *ifa
     return 1;
 }
 
-static HRESULT init_media_engine(IMFAttributes *attributes, struct media_engine *engine)
+static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct media_engine *engine)
 {
     HRESULT hr;
 
+    engine->IMFMediaEngine_iface.lpVtbl = &media_engine_vtbl;
+    engine->refcount = 1;
+    engine->flags = flags & MF_MEDIA_ENGINE_CREATEFLAGS_MASK;
+    InitializeCriticalSection(&engine->cs);
+
     hr = IMFAttributes_GetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, &IID_IMFMediaEngineNotify,
                                   (void **)&engine->callback);
     if (FAILED(hr))
@@ -522,7 +546,7 @@ static HRESULT WINAPI media_engine_factory_CreateInstance(IMFMediaEngineClassFac
     struct media_engine *object;
     HRESULT hr;
 
-    TRACE("(%p, %#x, %p, %p).\n", iface, flags, attributes, engine);
+    TRACE("%p, %#x, %p, %p.\n", iface, flags, attributes, engine);
 
     if (!attributes || !engine)
         return E_POINTER;
@@ -531,17 +555,13 @@ static HRESULT WINAPI media_engine_factory_CreateInstance(IMFMediaEngineClassFac
     if (!object)
         return E_OUTOFMEMORY;
 
-    hr = init_media_engine(attributes, object);
+    hr = init_media_engine(flags, attributes, object);
     if (FAILED(hr))
     {
         free_media_engine(object);
         return hr;
     }
 
-    object->IMFMediaEngine_iface.lpVtbl = &media_engine_vtbl;
-    object->refcount = 1;
-    object->flags = flags;
-
     *engine = &object->IMFMediaEngine_iface;
 
     return S_OK;
diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index 07bd8c81e67..d3c15566a43 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -247,11 +247,9 @@ static void test_Shutdown(void)
     media_engine = create_media_engine(callback);
 
     hr = IMFMediaEngine_Shutdown(media_engine);
-todo_wine
     ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     hr = IMFMediaEngine_Shutdown(media_engine);
-todo_wine
     ok(hr == MF_E_SHUTDOWN || broken(hr == S_OK) /* before win10 */, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEngine_SetSource(media_engine, NULL);
From e5b25e874e0c572ed78f4ce423bd6d4d59f51a6e Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 28 May 2020 18:54:20 +0300
Subject: [PATCH] mfmediaengine: Keep auto-play flag.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c                | 28 +++++++++++++++++++++---
 dlls/mfmediaengine/tests/mfmediaengine.c |  1 -
 2 files changed, 25 insertions(+), 4 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 0c082a87f5f..7053a3afea3 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -59,6 +59,7 @@ enum media_engine_flags
 {
     /* MF_MEDIA_ENGINE_CREATEFLAGS_MASK is 0x1f. */
     FLAGS_ENGINE_SHUT_DOWN = 0x20,
+    FLAGS_ENGINE_AUTO_PLAY = 0x40,
 };
 
 struct media_engine
@@ -74,6 +75,14 @@ struct media_engine
     CRITICAL_SECTION cs;
 };
 
+static void media_engine_set_flag(struct media_engine *engine, unsigned int mask, BOOL value)
+{
+    if (value)
+        engine->flags |= mask;
+    else
+        engine->flags &= ~mask;
+}
+
 static inline struct media_engine *impl_from_IMFMediaEngine(IMFMediaEngine *iface)
 {
     return CONTAINING_RECORD(iface, struct media_engine, IMFMediaEngine_iface);
@@ -306,16 +315,29 @@ static BOOL WINAPI media_engine_IsEnded(IMFMediaEngine *iface)
 
 static BOOL WINAPI media_engine_GetAutoPlay(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    BOOL value;
 
-    return FALSE;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+    value = !!(engine->flags & FLAGS_ENGINE_AUTO_PLAY);
+    LeaveCriticalSection(&engine->cs);
+
+    return value;
 }
 
 static HRESULT WINAPI media_engine_SetAutoPlay(IMFMediaEngine *iface, BOOL autoplay)
 {
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+
     FIXME("(%p, %d): stub.\n", iface, autoplay);
 
-    return E_NOTIMPL;
+    EnterCriticalSection(&engine->cs);
+    media_engine_set_flag(engine, FLAGS_ENGINE_AUTO_PLAY, autoplay);
+    LeaveCriticalSection(&engine->cs);
+
+    return S_OK;
 }
 
 static BOOL WINAPI media_engine_GetLoop(IMFMediaEngine *iface)
diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index d3c15566a43..8f6c4ca75bb 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -338,7 +338,6 @@ todo_wine
     ok(!state, "Unexpected state.\n");
 
     hr = IMFMediaEngine_SetAutoPlay(media_engine, TRUE);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     state = IMFMediaEngine_GetAutoPlay(media_engine);
From 8805f0429e598e71c5a4b6519d11415282675ae8 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 28 May 2020 18:54:21 +0300
Subject: [PATCH] mfmediaengine: Keep loop flag.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c                | 20 +++++++++++++++++---
 dlls/mfmediaengine/tests/mfmediaengine.c |  3 ---
 2 files changed, 17 insertions(+), 6 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 7053a3afea3..eef485e315b 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -60,6 +60,7 @@ enum media_engine_flags
     /* MF_MEDIA_ENGINE_CREATEFLAGS_MASK is 0x1f. */
     FLAGS_ENGINE_SHUT_DOWN = 0x20,
     FLAGS_ENGINE_AUTO_PLAY = 0x40,
+    FLAGS_ENGINE_LOOP = 0x80,
 };
 
 struct media_engine
@@ -342,16 +343,29 @@ static HRESULT WINAPI media_engine_SetAutoPlay(IMFMediaEngine *iface, BOOL autop
 
 static BOOL WINAPI media_engine_GetLoop(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    BOOL value;
 
-    return FALSE;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+    value = !!(engine->flags & FLAGS_ENGINE_LOOP);
+    LeaveCriticalSection(&engine->cs);
+
+    return value;
 }
 
 static HRESULT WINAPI media_engine_SetLoop(IMFMediaEngine *iface, BOOL loop)
 {
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+
     FIXME("(%p, %d): stub.\n", iface, loop);
 
-    return E_NOTIMPL;
+    EnterCriticalSection(&engine->cs);
+    media_engine_set_flag(engine, FLAGS_ENGINE_LOOP, loop);
+    LeaveCriticalSection(&engine->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI media_engine_Play(IMFMediaEngine *iface)
diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index 8f6c4ca75bb..504464b5272 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -341,7 +341,6 @@ todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     state = IMFMediaEngine_GetAutoPlay(media_engine);
-todo_wine
     ok(!!state, "Unexpected state.\n");
 
     /* Loop mode is still accessible. */
@@ -349,11 +348,9 @@ todo_wine
     ok(!state, "Unexpected state.\n");
 
     hr = IMFMediaEngine_SetLoop(media_engine, TRUE);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     state = IMFMediaEngine_GetLoop(media_engine);
-todo_wine
     ok(!!state, "Unexpected state.\n");
 
     hr = IMFMediaEngine_Play(media_engine);
From f465187f411b2d0b83fee25051d6b4d2c17e4ff8 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 29 May 2020 21:28:38 +0300
Subject: [PATCH] mfmediaengine: Create media session instance.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/Makefile.in |  2 +-
 dlls/mfmediaengine/main.c      | 78 ++++++++++++++++++++++++++++++++++
 2 files changed, 79 insertions(+), 1 deletion(-)

diff --git a/dlls/mfmediaengine/Makefile.in b/dlls/mfmediaengine/Makefile.in
index 292baa8001e..2278e87a645 100644
--- a/dlls/mfmediaengine/Makefile.in
+++ b/dlls/mfmediaengine/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = mfmediaengine.dll
 IMPORTLIB = mfmediaengine
-IMPORTS = mfuuid uuid
+IMPORTS = mf mfuuid uuid
 
 EXTRADLLFLAGS = -mno-cygwin
 
diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index eef485e315b..77466e99931 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -66,6 +66,7 @@ enum media_engine_flags
 struct media_engine
 {
     IMFMediaEngine IMFMediaEngine_iface;
+    IMFAsyncCallback session_events;
     LONG refcount;
     IMFMediaEngineNotify *callback;
     UINT64 playback_hwnd;
@@ -73,6 +74,7 @@ struct media_engine
     IMFDXGIDeviceManager *dxgi_manager;
     enum media_engine_mode mode;
     unsigned int flags;
+    IMFMediaSession *session;
     CRITICAL_SECTION cs;
 };
 
@@ -89,6 +91,70 @@ static inline struct media_engine *impl_from_IMFMediaEngine(IMFMediaEngine *ifac
     return CONTAINING_RECORD(iface, struct media_engine, IMFMediaEngine_iface);
 }
 
+static struct media_engine *impl_from_session_events_IMFAsyncCallback(IMFAsyncCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_engine, session_events);
+}
+
+static HRESULT WINAPI media_engine_session_events_QueryInterface(IMFAsyncCallback *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(riid, &IID_IMFAsyncCallback) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFAsyncCallback_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI media_engine_session_events_AddRef(IMFAsyncCallback *iface)
+{
+    struct media_engine *engine = impl_from_session_events_IMFAsyncCallback(iface);
+    return IMFMediaEngine_AddRef(&engine->IMFMediaEngine_iface);
+}
+
+static ULONG WINAPI media_engine_session_events_Release(IMFAsyncCallback *iface)
+{
+    struct media_engine *engine = impl_from_session_events_IMFAsyncCallback(iface);
+    return IMFMediaEngine_Release(&engine->IMFMediaEngine_iface);
+}
+
+static HRESULT WINAPI media_engine_session_events_GetParameters(IMFAsyncCallback *iface, DWORD *flags, DWORD *queue)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_engine_session_events_Invoke(IMFAsyncCallback *iface, IMFAsyncResult *result)
+{
+    struct media_engine *engine = impl_from_session_events_IMFAsyncCallback(iface);
+    IMFMediaEvent *event = NULL;
+    HRESULT hr;
+
+    if (FAILED(hr = IMFMediaSession_EndGetEvent(engine->session, result, &event)))
+        WARN("Failed to get session event, hr %#x.\n", hr);
+
+    if (event)
+        IMFMediaEvent_Release(event);
+
+    if (FAILED(hr = IMFMediaSession_BeginGetEvent(engine->session, iface, NULL)))
+        WARN("Failed to subscribe to session events, hr %#x.\n", hr);
+
+    return S_OK;
+}
+
+static const IMFAsyncCallbackVtbl media_engine_session_events_vtbl =
+{
+    media_engine_session_events_QueryInterface,
+    media_engine_session_events_AddRef,
+    media_engine_session_events_Release,
+    media_engine_session_events_GetParameters,
+    media_engine_session_events_Invoke,
+};
+
 static HRESULT WINAPI media_engine_QueryInterface(IMFMediaEngine *iface, REFIID riid, void **obj)
 {
     TRACE("(%p, %s, %p).\n", iface, debugstr_guid(riid), obj);
@@ -122,6 +188,8 @@ static void free_media_engine(struct media_engine *engine)
         IMFMediaEngineNotify_Release(engine->callback);
     if (engine->dxgi_manager)
         IMFDXGIDeviceManager_Release(engine->dxgi_manager);
+    if (engine->session)
+        IMFMediaSession_Release(engine->session);
     DeleteCriticalSection(&engine->cs);
     heap_free(engine);
 }
@@ -449,7 +517,10 @@ static HRESULT WINAPI media_engine_Shutdown(IMFMediaEngine *iface)
     if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
         hr = MF_E_SHUTDOWN;
     else
+    {
         engine->flags |= FLAGS_ENGINE_SHUT_DOWN;
+        IMFMediaSession_Shutdown(engine->session);
+    }
     LeaveCriticalSection(&engine->cs);
 
     return hr;
@@ -550,6 +621,7 @@ static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct
     HRESULT hr;
 
     engine->IMFMediaEngine_iface.lpVtbl = &media_engine_vtbl;
+    engine->session_events.lpVtbl = &media_engine_session_events_vtbl;
     engine->refcount = 1;
     engine->flags = flags & MF_MEDIA_ENGINE_CREATEFLAGS_MASK;
     InitializeCriticalSection(&engine->cs);
@@ -559,6 +631,12 @@ static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct
     if (FAILED(hr))
         return MF_E_ATTRIBUTENOTFOUND;
 
+    if (FAILED(hr = MFCreateMediaSession(NULL, &engine->session)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaSession_BeginGetEvent(engine->session, &engine->session_events, NULL)))
+        return hr;
+
     IMFAttributes_GetUINT64(attributes, &MF_MEDIA_ENGINE_PLAYBACK_HWND, &engine->playback_hwnd);
     IMFAttributes_GetUnknown(attributes, &MF_MEDIA_ENGINE_DXGI_MANAGER, &IID_IMFDXGIDeviceManager,
                              (void **)&engine->dxgi_manager);
From 41af1d1e710b0895f5aee04b178cdb59a283a40d Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 29 May 2020 21:28:39 +0300
Subject: [PATCH] mfmediaengine: Send "play" event on Play().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c                | 41 +++++++++++++++++++++---
 dlls/mfmediaengine/tests/mfmediaengine.c | 33 ++++++++++++++++++-
 2 files changed, 68 insertions(+), 6 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 77466e99931..13cbeb4b8db 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -61,6 +61,8 @@ enum media_engine_flags
     FLAGS_ENGINE_SHUT_DOWN = 0x20,
     FLAGS_ENGINE_AUTO_PLAY = 0x40,
     FLAGS_ENGINE_LOOP = 0x80,
+    FLAGS_ENGINE_PAUSED = 0x100,
+    FLAGS_ENGINE_WAITING = 0x200,
 };
 
 struct media_engine
@@ -328,9 +330,16 @@ static double WINAPI media_engine_GetDuration(IMFMediaEngine *iface)
 
 static BOOL WINAPI media_engine_IsPaused(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    BOOL value;
 
-    return FALSE;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+    value = !!(engine->flags & FLAGS_ENGINE_PAUSED);
+    LeaveCriticalSection(&engine->cs);
+
+    return value;
 }
 
 static double WINAPI media_engine_GetDefaultPlaybackRate(IMFMediaEngine *iface)
@@ -438,9 +447,31 @@ static HRESULT WINAPI media_engine_SetLoop(IMFMediaEngine *iface, BOOL loop)
 
 static HRESULT WINAPI media_engine_Play(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    PROPVARIANT var;
 
-    return E_NOTIMPL;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+
+    IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS, 0, 0);
+
+    if (!(engine->flags & FLAGS_ENGINE_WAITING))
+    {
+        engine->flags &= ~FLAGS_ENGINE_PAUSED;
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PLAY, 0, 0);
+
+        var.vt = VT_EMPTY;
+        IMFMediaSession_Start(engine->session, &GUID_NULL, &var);
+
+        engine->flags |= FLAGS_ENGINE_WAITING;
+    }
+
+    IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_WAITING, 0, 0);
+
+    LeaveCriticalSection(&engine->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI media_engine_Pause(IMFMediaEngine *iface)
@@ -623,7 +654,7 @@ static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct
     engine->IMFMediaEngine_iface.lpVtbl = &media_engine_vtbl;
     engine->session_events.lpVtbl = &media_engine_session_events_vtbl;
     engine->refcount = 1;
-    engine->flags = flags & MF_MEDIA_ENGINE_CREATEFLAGS_MASK;
+    engine->flags = (flags & MF_MEDIA_ENGINE_CREATEFLAGS_MASK) | FLAGS_ENGINE_PAUSED;
     InitializeCriticalSection(&engine->cs);
 
     hr = IMFAttributes_GetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, &IID_IMFMediaEngineNotify,
diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index 504464b5272..e7cb6432b92 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -307,7 +307,6 @@ todo_wine
     ok(val == 0.0, "Unexpected time %f.\n", val);
 
     state = IMFMediaEngine_IsPaused(media_engine);
-todo_wine
     ok(!!state, "Unexpected state %d.\n", state);
 
     val = IMFMediaEngine_GetDefaultPlaybackRate(media_engine);
@@ -393,6 +392,37 @@ todo_wine
     IMFMediaEngine_Release(media_engine);
 }
 
+static void test_Play(void)
+{
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *callback = &notify_impl.IMFMediaEngineNotify_iface;
+    IMFMediaEngine *media_engine;
+    HRESULT hr;
+    BOOL ret;
+
+    media_engine = create_media_engine(callback);
+
+    ret = IMFMediaEngine_IsPaused(media_engine);
+    ok(ret, "Unexpected state %d.\n", ret);
+
+    hr = IMFMediaEngine_Play(media_engine);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    ret = IMFMediaEngine_IsPaused(media_engine);
+    ok(!ret, "Unexpected state %d.\n", ret);
+
+    hr = IMFMediaEngine_Play(media_engine);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaEngine_Shutdown(media_engine);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    ret = IMFMediaEngine_IsPaused(media_engine);
+    ok(!ret, "Unexpected state %d.\n", ret);
+
+    IMFMediaEngine_Release(media_engine);
+}
+
 START_TEST(mfmediaengine)
 {
     HRESULT hr;
@@ -416,6 +446,7 @@ START_TEST(mfmediaengine)
     test_factory();
     test_CreateInstance();
     test_Shutdown();
+    test_Play();
 
     IMFMediaEngineClassFactory_Release(factory);
 
From 58f468038013db22ba1905d57df0eb58caad5dbb Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 29 May 2020 21:28:40 +0300
Subject: [PATCH] mfmediaengine: Send "pause" event on Pause().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c                | 21 +++++++++++++++++++--
 dlls/mfmediaengine/tests/mfmediaengine.c | 17 +++++++++++++++++
 2 files changed, 36 insertions(+), 2 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 13cbeb4b8db..fcef1be048f 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -476,9 +476,26 @@ static HRESULT WINAPI media_engine_Play(IMFMediaEngine *iface)
 
 static HRESULT WINAPI media_engine_Pause(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+
+    if (!(engine->flags & FLAGS_ENGINE_PAUSED))
+    {
+        engine->flags &= ~FLAGS_ENGINE_WAITING;
+        engine->flags |= FLAGS_ENGINE_PAUSED;
+
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_TIMEUPDATE, 0, 0);
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PAUSE, 0, 0);
+    }
+
+    IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS, 0, 0);
+
+    LeaveCriticalSection(&engine->cs);
+
+    return S_OK;
 }
 
 static BOOL WINAPI media_engine_GetMuted(IMFMediaEngine *iface)
diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index e7cb6432b92..a3db611e9fc 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -421,6 +421,23 @@ static void test_Play(void)
     ok(!ret, "Unexpected state %d.\n", ret);
 
     IMFMediaEngine_Release(media_engine);
+
+    /* Play -> Pause */
+    media_engine = create_media_engine(callback);
+
+    hr = IMFMediaEngine_Play(media_engine);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    ret = IMFMediaEngine_IsPaused(media_engine);
+    ok(!ret, "Unexpected state %d.\n", ret);
+
+    hr = IMFMediaEngine_Pause(media_engine);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    ret = IMFMediaEngine_IsPaused(media_engine);
+    ok(!!ret, "Unexpected state %d.\n", ret);
+
+    IMFMediaEngine_Release(media_engine);
 }
 
 START_TEST(mfmediaengine)
From 6fa8ff69300d167b34a4c4b079ae6d5924ba1fc4 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 2 Jun 2020 11:41:04 +0300
Subject: [PATCH] mfmediaengine: Send "ratechange" event for both default and
 playback rate changes.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c                | 60 ++++++++++++++++++++----
 dlls/mfmediaengine/tests/mfmediaengine.c | 32 +++++++++++--
 2 files changed, 81 insertions(+), 11 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index fcef1be048f..b9bf3c7027b 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -76,6 +76,8 @@ struct media_engine
     IMFDXGIDeviceManager *dxgi_manager;
     enum media_engine_mode mode;
     unsigned int flags;
+    double playback_rate;
+    double default_playback_rate;
     IMFMediaSession *session;
     CRITICAL_SECTION cs;
 };
@@ -344,30 +346,70 @@ static BOOL WINAPI media_engine_IsPaused(IMFMediaEngine *iface)
 
 static double WINAPI media_engine_GetDefaultPlaybackRate(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    double rate;
 
-    return 0.0;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+    rate = engine->default_playback_rate;
+    LeaveCriticalSection(&engine->cs);
+
+    return rate;
 }
 
 static HRESULT WINAPI media_engine_SetDefaultPlaybackRate(IMFMediaEngine *iface, double rate)
 {
-    FIXME("(%p, %f): stub.\n", iface, rate);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %f.\n", iface, rate);
+
+    EnterCriticalSection(&engine->cs);
+    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (engine->default_playback_rate != rate)
+    {
+        engine->default_playback_rate = rate;
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_RATECHANGE, 0, 0);
+    }
+    LeaveCriticalSection(&engine->cs);
+
+    return hr;
 }
 
 static double WINAPI media_engine_GetPlaybackRate(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    double rate;
 
-    return 0.0;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+    rate = engine->playback_rate;
+    LeaveCriticalSection(&engine->cs);
+
+    return rate;
 }
 
 static HRESULT WINAPI media_engine_SetPlaybackRate(IMFMediaEngine *iface, double rate)
 {
-    FIXME("(%p, %f): stub.\n", iface, rate);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %f.\n", iface, rate);
+
+    EnterCriticalSection(&engine->cs);
+    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (engine->playback_rate != rate)
+    {
+        engine->playback_rate = rate;
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_RATECHANGE, 0, 0);
+    }
+    LeaveCriticalSection(&engine->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI media_engine_GetPlayed(IMFMediaEngine *iface, IMFMediaTimeRange **played)
@@ -672,6 +714,8 @@ static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct
     engine->session_events.lpVtbl = &media_engine_session_events_vtbl;
     engine->refcount = 1;
     engine->flags = (flags & MF_MEDIA_ENGINE_CREATEFLAGS_MASK) | FLAGS_ENGINE_PAUSED;
+    engine->default_playback_rate = 1.0;
+    engine->playback_rate = 1.0;
     InitializeCriticalSection(&engine->cs);
 
     hr = IMFAttributes_GetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, &IID_IMFMediaEngineNotify,
diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index a3db611e9fc..4079e9aa70f 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -310,15 +310,12 @@ todo_wine
     ok(!!state, "Unexpected state %d.\n", state);
 
     val = IMFMediaEngine_GetDefaultPlaybackRate(media_engine);
-todo_wine
     ok(val == 1.0, "Unexpected rate %f.\n", val);
 
     hr = IMFMediaEngine_SetDefaultPlaybackRate(media_engine, 2.0);
-todo_wine
     ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     val = IMFMediaEngine_GetPlaybackRate(media_engine);
-todo_wine
     ok(val == 1.0, "Unexpected rate %f.\n", val);
 
     hr = IMFMediaEngine_GetPlayed(media_engine, &time_range);
@@ -440,6 +437,34 @@ static void test_Play(void)
     IMFMediaEngine_Release(media_engine);
 }
 
+static void test_playback_rate(void)
+{
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *callback = &notify_impl.IMFMediaEngineNotify_iface;
+    IMFMediaEngine *media_engine;
+    double rate;
+    HRESULT hr;
+
+    media_engine = create_media_engine(callback);
+
+    rate = IMFMediaEngine_GetDefaultPlaybackRate(media_engine);
+    ok(rate == 1.0, "Unexpected default rate.\n");
+
+    rate = IMFMediaEngine_GetPlaybackRate(media_engine);
+    ok(rate == 1.0, "Unexpected default rate.\n");
+
+    hr = IMFMediaEngine_SetPlaybackRate(media_engine, 0.0);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    rate = IMFMediaEngine_GetPlaybackRate(media_engine);
+    ok(rate == 0.0, "Unexpected default rate.\n");
+
+    hr = IMFMediaEngine_SetDefaultPlaybackRate(media_engine, 0.0);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    IMFMediaEngine_Release(media_engine);
+}
+
 START_TEST(mfmediaengine)
 {
     HRESULT hr;
@@ -464,6 +489,7 @@ START_TEST(mfmediaengine)
     test_CreateInstance();
     test_Shutdown();
     test_Play();
+    test_playback_rate();
 
     IMFMediaEngineClassFactory_Release(factory);
 
From daa119581a5a7f739242764c158944bfabc680ce Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 2 Jun 2020 11:41:05 +0300
Subject: [PATCH] mfmediaengine: Send "volumechange" event on muted state
 change.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c                | 29 ++++++++++++++++++---
 dlls/mfmediaengine/tests/mfmediaengine.c | 32 ++++++++++++++++++++++--
 2 files changed, 55 insertions(+), 6 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index b9bf3c7027b..731bccb581d 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -63,6 +63,7 @@ enum media_engine_flags
     FLAGS_ENGINE_LOOP = 0x80,
     FLAGS_ENGINE_PAUSED = 0x100,
     FLAGS_ENGINE_WAITING = 0x200,
+    FLAGS_ENGINE_MUTED = 0x400,
 };
 
 struct media_engine
@@ -542,16 +543,36 @@ static HRESULT WINAPI media_engine_Pause(IMFMediaEngine *iface)
 
 static BOOL WINAPI media_engine_GetMuted(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    BOOL ret;
 
-    return FALSE;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+    ret = !!(engine->flags & FLAGS_ENGINE_MUTED);
+    LeaveCriticalSection(&engine->cs);
+
+    return ret;
 }
 
 static HRESULT WINAPI media_engine_SetMuted(IMFMediaEngine *iface, BOOL muted)
 {
-    FIXME("(%p, %d): stub.\n", iface, muted);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %d.\n", iface, muted);
+
+    EnterCriticalSection(&engine->cs);
+    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (!!(engine->flags & FLAGS_ENGINE_MUTED) ^ !!muted)
+    {
+        media_engine_set_flag(engine, FLAGS_ENGINE_MUTED, muted);
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE, 0, 0);
+    }
+    LeaveCriticalSection(&engine->cs);
+
+    return hr;
 }
 
 static double WINAPI media_engine_GetVolume(IMFMediaEngine *iface)
diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index 4079e9aa70f..0839d1d4451 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -361,14 +361,13 @@ todo_wine
     ok(!state, "Unexpected state.\n");
 
     hr = IMFMediaEngine_SetMuted(media_engine, TRUE);
-todo_wine
     ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     val = IMFMediaEngine_GetVolume(media_engine);
 todo_wine
     ok(val == 1.0, "Unexpected value %f.\n", val);
 
-    val = IMFMediaEngine_SetVolume(media_engine, 2.0);
+    hr = IMFMediaEngine_SetVolume(media_engine, 2.0);
 todo_wine
     ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
@@ -465,6 +464,34 @@ static void test_playback_rate(void)
     IMFMediaEngine_Release(media_engine);
 }
 
+static void test_mute(void)
+{
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *callback = &notify_impl.IMFMediaEngineNotify_iface;
+    IMFMediaEngine *media_engine;
+    HRESULT hr;
+    BOOL ret;
+
+    media_engine = create_media_engine(callback);
+
+    ret = IMFMediaEngine_GetMuted(media_engine);
+    ok(!ret, "Unexpected state.\n");
+
+    hr = IMFMediaEngine_SetMuted(media_engine, TRUE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    ret = IMFMediaEngine_GetMuted(media_engine);
+    ok(ret, "Unexpected state.\n");
+
+    hr = IMFMediaEngine_Shutdown(media_engine);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    ret = IMFMediaEngine_GetMuted(media_engine);
+    ok(ret, "Unexpected state.\n");
+
+    IMFMediaEngine_Release(media_engine);
+}
+
 START_TEST(mfmediaengine)
 {
     HRESULT hr;
@@ -490,6 +517,7 @@ START_TEST(mfmediaengine)
     test_Shutdown();
     test_Play();
     test_playback_rate();
+    test_mute();
 
     IMFMediaEngineClassFactory_Release(factory);
 
From e9cc1d58b4e5aa6c19a5d15f2da1675b635f95a4 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 2 Jun 2020 11:41:06 +0300
Subject: [PATCH] mfmediaengine: Send "volumechange" event on volume change.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c                | 30 ++++++++++++++++++++----
 dlls/mfmediaengine/tests/mfmediaengine.c |  2 --
 2 files changed, 26 insertions(+), 6 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 731bccb581d..59006e64ca7 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -79,6 +79,7 @@ struct media_engine
     unsigned int flags;
     double playback_rate;
     double default_playback_rate;
+    double volume;
     IMFMediaSession *session;
     CRITICAL_SECTION cs;
 };
@@ -577,16 +578,36 @@ static HRESULT WINAPI media_engine_SetMuted(IMFMediaEngine *iface, BOOL muted)
 
 static double WINAPI media_engine_GetVolume(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    double volume;
 
-    return 0.0;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+    volume = engine->volume;
+    LeaveCriticalSection(&engine->cs);
+
+    return volume;
 }
 
 static HRESULT WINAPI media_engine_SetVolume(IMFMediaEngine *iface, double volume)
 {
-    FIXME("(%p, %f): stub.\n", iface, volume);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %f.\n", iface, volume);
+
+    EnterCriticalSection(&engine->cs);
+    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (volume != engine->volume)
+    {
+        engine->volume = volume;
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE, 0, 0);
+    }
+    LeaveCriticalSection(&engine->cs);
+
+    return hr;
 }
 
 static BOOL WINAPI media_engine_HasVideo(IMFMediaEngine *iface)
@@ -737,6 +758,7 @@ static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct
     engine->flags = (flags & MF_MEDIA_ENGINE_CREATEFLAGS_MASK) | FLAGS_ENGINE_PAUSED;
     engine->default_playback_rate = 1.0;
     engine->playback_rate = 1.0;
+    engine->volume = 1.0;
     InitializeCriticalSection(&engine->cs);
 
     hr = IMFAttributes_GetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, &IID_IMFMediaEngineNotify,
diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index 0839d1d4451..a5b80ef25f4 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -364,11 +364,9 @@ todo_wine
     ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     val = IMFMediaEngine_GetVolume(media_engine);
-todo_wine
     ok(val == 1.0, "Unexpected value %f.\n", val);
 
     hr = IMFMediaEngine_SetVolume(media_engine, 2.0);
-todo_wine
     ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     state = IMFMediaEngine_HasVideo(media_engine);
From 13aafb43a3fcdb00b74eb8bbd0cb7722aa5cba99 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 2 Jun 2020 11:41:07 +0300
Subject: [PATCH] mfmediaengine: Propagate error out on missing callback
 attribute.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 59006e64ca7..5ec179614d0 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -762,9 +762,9 @@ static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct
     InitializeCriticalSection(&engine->cs);
 
     hr = IMFAttributes_GetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, &IID_IMFMediaEngineNotify,
-                                  (void **)&engine->callback);
+            (void **)&engine->callback);
     if (FAILED(hr))
-        return MF_E_ATTRIBUTENOTFOUND;
+        return hr;
 
     if (FAILED(hr = MFCreateMediaSession(NULL, &engine->session)))
         return hr;
From 4bbb7b664934fff53add6141753d69c937bc2ce5 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 2 Jun 2020 12:35:13 +0300
Subject: [PATCH] mfmediaengine: Duplicate configuration attributes.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/Makefile.in |  2 +-
 dlls/mfmediaengine/main.c      | 25 +++++++++++++++----------
 2 files changed, 16 insertions(+), 11 deletions(-)

diff --git a/dlls/mfmediaengine/Makefile.in b/dlls/mfmediaengine/Makefile.in
index 2278e87a645..cb593cb7edf 100644
--- a/dlls/mfmediaengine/Makefile.in
+++ b/dlls/mfmediaengine/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = mfmediaengine.dll
 IMPORTLIB = mfmediaengine
-IMPORTS = mf mfuuid uuid
+IMPORTS = mfplat mf mfuuid uuid
 
 EXTRADLLFLAGS = -mno-cygwin
 
diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 5ec179614d0..d698b53c38b 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -23,6 +23,7 @@
 #include "windef.h"
 #include "winbase.h"
 
+#include "mfapi.h"
 #include "mfmediaengine.h"
 #include "mferror.h"
 #include "dxgi.h"
@@ -72,9 +73,7 @@ struct media_engine
     IMFAsyncCallback session_events;
     LONG refcount;
     IMFMediaEngineNotify *callback;
-    UINT64 playback_hwnd;
-    DXGI_FORMAT output_format;
-    IMFDXGIDeviceManager *dxgi_manager;
+    IMFAttributes *attributes;
     enum media_engine_mode mode;
     unsigned int flags;
     double playback_rate;
@@ -192,10 +191,10 @@ static void free_media_engine(struct media_engine *engine)
 {
     if (engine->callback)
         IMFMediaEngineNotify_Release(engine->callback);
-    if (engine->dxgi_manager)
-        IMFDXGIDeviceManager_Release(engine->dxgi_manager);
     if (engine->session)
         IMFMediaSession_Release(engine->session);
+    if (engine->attributes)
+        IMFAttributes_Release(engine->attributes);
     DeleteCriticalSection(&engine->cs);
     heap_free(engine);
 }
@@ -750,6 +749,8 @@ static ULONG WINAPI media_engine_factory_Release(IMFMediaEngineClassFactory *ifa
 
 static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct media_engine *engine)
 {
+    DXGI_FORMAT output_format;
+    UINT64 playback_hwnd;
     HRESULT hr;
 
     engine->IMFMediaEngine_iface.lpVtbl = &media_engine_vtbl;
@@ -772,11 +773,15 @@ static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct
     if (FAILED(hr = IMFMediaSession_BeginGetEvent(engine->session, &engine->session_events, NULL)))
         return hr;
 
-    IMFAttributes_GetUINT64(attributes, &MF_MEDIA_ENGINE_PLAYBACK_HWND, &engine->playback_hwnd);
-    IMFAttributes_GetUnknown(attributes, &MF_MEDIA_ENGINE_DXGI_MANAGER, &IID_IMFDXGIDeviceManager,
-                             (void **)&engine->dxgi_manager);
-    hr = IMFAttributes_GetUINT32(attributes, &MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT, &engine->output_format);
-    if (engine->playback_hwnd) /* FIXME: handle MF_MEDIA_ENGINE_PLAYBACK_VISUAL */
+    if (FAILED(hr = MFCreateAttributes(&engine->attributes, 0)))
+        return hr;
+
+    if (FAILED(hr = IMFAttributes_CopyAllItems(attributes, engine->attributes)))
+        return hr;
+
+    IMFAttributes_GetUINT64(attributes, &MF_MEDIA_ENGINE_PLAYBACK_HWND, &playback_hwnd);
+    hr = IMFAttributes_GetUINT32(attributes, &MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT, &output_format);
+    if (playback_hwnd) /* FIXME: handle MF_MEDIA_ENGINE_PLAYBACK_VISUAL */
         engine->mode = MEDIA_ENGINE_RENDERING_MODE;
     else
     {
From f151550e56df5e1b93b42844d66073f99c58b0d6 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 2 Jun 2020 11:41:09 +0300
Subject: [PATCH] mfmediaengine: Forward buffering events to user callback.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index d698b53c38b..b9a5fb46d6f 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -137,10 +137,32 @@ static HRESULT WINAPI media_engine_session_events_Invoke(IMFAsyncCallback *iface
 {
     struct media_engine *engine = impl_from_session_events_IMFAsyncCallback(iface);
     IMFMediaEvent *event = NULL;
+    MediaEventType event_type;
     HRESULT hr;
 
     if (FAILED(hr = IMFMediaSession_EndGetEvent(engine->session, result, &event)))
+    {
         WARN("Failed to get session event, hr %#x.\n", hr);
+        goto failed;
+    }
+
+    if (FAILED(hr = IMFMediaEvent_GetType(event, &event_type)))
+    {
+        WARN("Failed to get event type, hr %#x.\n", hr);
+        goto failed;
+    }
+
+    switch (event_type)
+    {
+        case MEBufferingStarted:
+        case MEBufferingStopped:
+
+            IMFMediaEngineNotify_EventNotify(engine->callback, event_type == MEBufferingStarted ?
+                    MF_MEDIA_ENGINE_EVENT_BUFFERINGSTARTED : MF_MEDIA_ENGINE_EVENT_BUFFERINGENDED, 0, 0);
+            break;
+    }
+
+failed:
 
     if (event)
         IMFMediaEvent_Release(event);
From 68b5a0574c8ad6d1df27b3641f6be7ecbb6d4f4d Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 2 Jun 2020 11:43:42 +0300
Subject: [PATCH] mf/session: Handle source buffering events.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/session.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index ba30733fe5c..39b5e1a5377 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -2867,6 +2867,23 @@ static HRESULT WINAPI session_events_callback_Invoke(IMFAsyncCallback *iface, IM
             LeaveCriticalSection(&session->cs);
 
             break;
+
+        case MEBufferingStarted:
+        case MEBufferingStopped:
+
+            EnterCriticalSection(&session->cs);
+            if (session_get_media_source(session, (IMFMediaSource *)event_source))
+            {
+                if (event_type == MEBufferingStarted)
+                    IMFPresentationClock_Pause(session->clock);
+                else
+                    IMFPresentationClock_Start(session->clock, PRESENTATION_CURRENT_POSITION);
+
+                IMFMediaEventQueue_QueueEvent(session->event_queue, event);
+            }
+            LeaveCriticalSection(&session->cs);
+            break;
+
         case MENewStream:
             stream = (IMFMediaStream *)value.punkVal;
 
From 04c2df85cb766d535f1522e162f2780043d305ac Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 3 Jun 2020 20:08:37 +0300
Subject: [PATCH] include: Add more Media Foundation error codes.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 include/mferror.h | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/include/mferror.h b/include/mferror.h
index 523800d7f02..28910d25682 100644
--- a/include/mferror.h
+++ b/include/mferror.h
@@ -77,12 +77,28 @@
 #define MF_E_DISABLED_IN_SAFEMODE                     _HRESULT_TYPEDEF_(0xc00d36ef)
 #define MF_E_CANNOT_PARSE_BYTESTREAM                  _HRESULT_TYPEDEF_(0xc00d36f0)
 #define MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS  _HRESULT_TYPEDEF_(0xc00d36f1)
+#define MF_E_CANNOT_CREATE_SINK                       _HRESULT_TYPEDEF_(0xc00d36fa)
 #define MF_E_BYTESTREAM_UNKNOWN_LENGTH                _HRESULT_TYPEDEF_(0xc00d36fb)
+#define MF_E_SESSION_PAUSEWHILESTOPPED                _HRESULT_TYPEDEF_(0xc00d36fc)
+#define MF_S_ACTIVATE_REPLACED                        _HRESULT_TYPEDEF_(0x000d36fd)
+#define MF_E_FORMAT_CHANGE_NOT_SUPPORTED              _HRESULT_TYPEDEF_(0xc00d36fe)
 #define MF_E_INVALID_WORKQUEUE                        _HRESULT_TYPEDEF_(0xc00d36ff)
+#define MF_E_DRM_UNSUPPORTED                          _HRESULT_TYPEDEF_(0xc00d3700)
+#define MF_E_UNAUTHORIZED                             _HRESULT_TYPEDEF_(0xc00d3701)
+#define MF_E_OUT_OF_RANGE                             _HRESULT_TYPEDEF_(0xc00d3702)
+#define MF_E_INVALID_CODEC_MERIT                      _HRESULT_TYPEDEF_(0xc00d3703)
+#define MF_E_HW_MFT_FAILED_START_STREAMING            _HRESULT_TYPEDEF_(0xc00d3704)
+#define MF_E_OPERATION_IN_PROGRESS                    _HRESULT_TYPEDEF_(0xc00d3705)
+#define MF_E_HARDWARE_DRM_UNSUPPORTED                 _HRESULT_TYPEDEF_(0xc00d3706)
+#define MF_E_DURATION_TOO_LONG                        _HRESULT_TYPEDEF_(0xc00d3707)
 #define MF_E_NO_EVENTS_AVAILABLE                      _HRESULT_TYPEDEF_(0xc00d3e80)
 #define MF_E_INVALID_STATE_TRANSITION                 _HRESULT_TYPEDEF_(0xc00d3e82)
 #define MF_E_END_OF_STREAM                            _HRESULT_TYPEDEF_(0xc00d3e84)
 #define MF_E_SHUTDOWN                                 _HRESULT_TYPEDEF_(0xc00d3e85)
+#define MF_E_MP3_NOT_FOUND                            _HRESULT_TYPEDEF_(0xc00d3e86)
+#define MF_E_MP3_OUT_OF_DATA                          _HRESULT_TYPEDEF_(0xc00d3e87)
+#define MF_E_MP3_NOTMP3                               _HRESULT_TYPEDEF_(0xc00d3e88)
+#define MF_E_MP3_NOTSUPPORTED                         _HRESULT_TYPEDEF_(0xc00d3e89)
 #define MF_E_NO_DURATION                              _HRESULT_TYPEDEF_(0xc00d3e8a)
 #define MF_E_INVALID_FORMAT                           _HRESULT_TYPEDEF_(0xc00d3e8c)
 #define MF_E_PROPERTY_NOT_FOUND                       _HRESULT_TYPEDEF_(0xc00d3e8d)
@@ -90,9 +106,17 @@
 #define MF_E_PROPERTY_NOT_ALLOWED                     _HRESULT_TYPEDEF_(0xc00d3e8f)
 #define MF_E_MEDIA_SOURCE_NOT_STARTED                 _HRESULT_TYPEDEF_(0xc00d3e91)
 #define MF_E_UNSUPPORTED_FORMAT                       _HRESULT_TYPEDEF_(0xc00d3e98)
+#define MF_E_MP3_BAD_CRC                              _HRESULT_TYPEDEF_(0xc00d3e99)
+#define MF_E_NOT_PROTECTED                            _HRESULT_TYPEDEF_(0xc00d3e9a)
 #define MF_E_MEDIA_SOURCE_WRONGSTATE                  _HRESULT_TYPEDEF_(0xc00d3e9b)
 #define MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED         _HRESULT_TYPEDEF_(0xc00d3e9c)
+#define MF_E_CANNOT_FIND_KEYFRAME_SAMPLE              _HRESULT_TYPEDEF_(0xc00d3e9d)
 #define MF_E_UNSUPPORTED_CHARACTERISTICS              _HRESULT_TYPEDEF_(0xc00d3e9e)
+#define MF_E_NO_AUDIO_RECORDING_DEVICE                _HRESULT_TYPEDEF_(0xc00d3e9f)
+#define MF_E_AUDIO_RECORDING_DEVICE_IN_USE            _HRESULT_TYPEDEF_(0xc00d3ea0)
+#define MF_E_AUDIO_RECORDING_DEVICE_INVALIDATED       _HRESULT_TYPEDEF_(0xc00d3ea1)
+#define MF_E_VIDEO_RECORDING_DEVICE_INVALIDATED       _HRESULT_TYPEDEF_(0xc00d3ea2)
+#define MF_E_VIDEO_RECORDING_DEVICE_PREEMPTED         _HRESULT_TYPEDEF_(0xc00d3ea3)
 
 #define MF_E_STREAMSINK_REMOVED                       _HRESULT_TYPEDEF_(0xc00d4a38)
 #define MF_E_STREAMSINKS_OUT_OF_SYNC                  _HRESULT_TYPEDEF_(0xc00d4a3a)
From c1a12f10b34c7f78e7f5f50a78a80f7db5a74ddd Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 3 Jun 2020 20:08:38 +0300
Subject: [PATCH] mfmediaengine: Set media type flags on source resolution.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c | 203 ++++++++++++++++++++++++++++++++++++--
 1 file changed, 193 insertions(+), 10 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index b9a5fb46d6f..4136382566d 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -65,12 +65,15 @@ enum media_engine_flags
     FLAGS_ENGINE_PAUSED = 0x100,
     FLAGS_ENGINE_WAITING = 0x200,
     FLAGS_ENGINE_MUTED = 0x400,
+    FLAGS_ENGINE_HAS_AUDIO = 0x800,
+    FLAGS_ENGINE_HAS_VIDEO = 0x1000,
 };
 
 struct media_engine
 {
     IMFMediaEngine IMFMediaEngine_iface;
     IMFAsyncCallback session_events;
+    IMFAsyncCallback load_handler;
     LONG refcount;
     IMFMediaEngineNotify *callback;
     IMFAttributes *attributes;
@@ -80,6 +83,7 @@ struct media_engine
     double default_playback_rate;
     double volume;
     IMFMediaSession *session;
+    IMFSourceResolver *resolver;
     CRITICAL_SECTION cs;
 };
 
@@ -101,7 +105,12 @@ static struct media_engine *impl_from_session_events_IMFAsyncCallback(IMFAsyncCa
     return CONTAINING_RECORD(iface, struct media_engine, session_events);
 }
 
-static HRESULT WINAPI media_engine_session_events_QueryInterface(IMFAsyncCallback *iface, REFIID riid, void **obj)
+static struct media_engine *impl_from_load_handler_IMFAsyncCallback(IMFAsyncCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_engine, load_handler);
+}
+
+static HRESULT WINAPI media_engine_callback_QueryInterface(IMFAsyncCallback *iface, REFIID riid, void **obj)
 {
     if (IsEqualIID(riid, &IID_IMFAsyncCallback) ||
             IsEqualIID(riid, &IID_IUnknown))
@@ -128,7 +137,7 @@ static ULONG WINAPI media_engine_session_events_Release(IMFAsyncCallback *iface)
     return IMFMediaEngine_Release(&engine->IMFMediaEngine_iface);
 }
 
-static HRESULT WINAPI media_engine_session_events_GetParameters(IMFAsyncCallback *iface, DWORD *flags, DWORD *queue)
+static HRESULT WINAPI media_engine_callback_GetParameters(IMFAsyncCallback *iface, DWORD *flags, DWORD *queue)
 {
     return E_NOTIMPL;
 }
@@ -175,13 +184,142 @@ static HRESULT WINAPI media_engine_session_events_Invoke(IMFAsyncCallback *iface
 
 static const IMFAsyncCallbackVtbl media_engine_session_events_vtbl =
 {
-    media_engine_session_events_QueryInterface,
+    media_engine_callback_QueryInterface,
     media_engine_session_events_AddRef,
     media_engine_session_events_Release,
-    media_engine_session_events_GetParameters,
+    media_engine_callback_GetParameters,
     media_engine_session_events_Invoke,
 };
 
+static ULONG WINAPI media_engine_load_handler_AddRef(IMFAsyncCallback *iface)
+{
+    struct media_engine *engine = impl_from_load_handler_IMFAsyncCallback(iface);
+    return IMFMediaEngine_AddRef(&engine->IMFMediaEngine_iface);
+}
+
+static ULONG WINAPI media_engine_load_handler_Release(IMFAsyncCallback *iface)
+{
+    struct media_engine *engine = impl_from_load_handler_IMFAsyncCallback(iface);
+    return IMFMediaEngine_Release(&engine->IMFMediaEngine_iface);
+}
+
+static HRESULT media_engine_create_topology(struct media_engine *engine, IMFMediaSource *source)
+{
+    IMFStreamDescriptor *sd_audio = NULL, *sd_video = NULL;
+    unsigned int stream_count = 0, i;
+    IMFPresentationDescriptor *pd;
+    HRESULT hr;
+
+    if (FAILED(hr = IMFMediaSource_CreatePresentationDescriptor(source, &pd)))
+        return hr;
+
+    if (FAILED(hr = IMFPresentationDescriptor_GetStreamDescriptorCount(pd, &stream_count)))
+        WARN("Failed to get stream count, hr %#x.\n", hr);
+
+    /* Enable first video stream and first audio stream. */
+
+    for (i = 0; i < stream_count; ++i)
+    {
+        IMFMediaTypeHandler *type_handler;
+        IMFStreamDescriptor *sd;
+        BOOL selected;
+
+        IMFPresentationDescriptor_DeselectStream(pd, i);
+
+        if (sd_audio && sd_video)
+            continue;
+
+        IMFPresentationDescriptor_GetStreamDescriptorByIndex(pd, i, &selected, &sd);
+
+        if (SUCCEEDED(IMFStreamDescriptor_GetMediaTypeHandler(sd, &type_handler)))
+        {
+            GUID major = { 0 };
+
+            IMFMediaTypeHandler_GetMajorType(type_handler, &major);
+
+            if (IsEqualGUID(&major, &MFMediaType_Audio) && !sd_audio)
+            {
+                sd_audio = sd;
+                IMFStreamDescriptor_AddRef(sd_audio);
+                IMFPresentationDescriptor_SelectStream(pd, i);
+            }
+            else if (IsEqualGUID(&major, &MFMediaType_Video) && !sd_video && !(engine->flags & MF_MEDIA_ENGINE_AUDIOONLY))
+            {
+                sd_video = sd;
+                IMFStreamDescriptor_AddRef(sd_video);
+                IMFPresentationDescriptor_SelectStream(pd, i);
+            }
+
+            IMFMediaTypeHandler_Release(type_handler);
+        }
+    }
+
+    if (!sd_video && !sd_audio)
+    {
+        IMFPresentationDescriptor_Release(pd);
+        return E_UNEXPECTED;
+    }
+
+    if (sd_video)
+        engine->flags |= FLAGS_ENGINE_HAS_VIDEO;
+    if (sd_audio)
+        engine->flags |= FLAGS_ENGINE_HAS_AUDIO;
+
+    /* TODO: set duration */
+
+    if (sd_video)
+        IMFStreamDescriptor_Release(sd_video);
+    if (sd_audio)
+        IMFStreamDescriptor_Release(sd_audio);
+
+    IMFPresentationDescriptor_Release(pd);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI media_engine_load_handler_Invoke(IMFAsyncCallback *iface, IMFAsyncResult *result)
+{
+    struct media_engine *engine = impl_from_load_handler_IMFAsyncCallback(iface);
+    MF_OBJECT_TYPE obj_type;
+    IMFMediaSource *source;
+    IUnknown *object = NULL;
+    HRESULT hr;
+
+    EnterCriticalSection(&engine->cs);
+
+    IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_LOADSTART, 0, 0);
+
+    if (FAILED(hr = IMFSourceResolver_EndCreateObjectFromURL(engine->resolver, result, &obj_type, &object)))
+        WARN("Failed to create source object, hr %#x.\n", hr);
+
+    if (object)
+    {
+        if (SUCCEEDED(hr = IUnknown_QueryInterface(object, &IID_IMFMediaSource, (void **)&source)))
+        {
+            hr = media_engine_create_topology(engine, source);
+            IMFMediaSource_Release(source);
+        }
+        IUnknown_Release(object);
+    }
+
+    if (FAILED(hr))
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_ERROR,
+            MF_MEDIA_ENGINE_ERR_SRC_NOT_SUPPORTED, hr);
+
+    LeaveCriticalSection(&engine->cs);
+
+    return S_OK;
+}
+
+static const IMFAsyncCallbackVtbl media_engine_load_handler_vtbl =
+{
+    media_engine_callback_QueryInterface,
+    media_engine_load_handler_AddRef,
+    media_engine_load_handler_Release,
+    media_engine_callback_GetParameters,
+    media_engine_load_handler_Invoke,
+};
+
 static HRESULT WINAPI media_engine_QueryInterface(IMFMediaEngine *iface, REFIID riid, void **obj)
 {
     TRACE("(%p, %s, %p).\n", iface, debugstr_guid(riid), obj);
@@ -217,6 +355,8 @@ static void free_media_engine(struct media_engine *engine)
         IMFMediaSession_Release(engine->session);
     if (engine->attributes)
         IMFAttributes_Release(engine->attributes);
+    if (engine->resolver)
+        IMFSourceResolver_Release(engine->resolver);
     DeleteCriticalSection(&engine->cs);
     heap_free(engine);
 }
@@ -257,9 +397,34 @@ static HRESULT WINAPI media_engine_SetSourceElements(IMFMediaEngine *iface, IMFM
 
 static HRESULT WINAPI media_engine_SetSource(IMFMediaEngine *iface, BSTR url)
 {
-    FIXME("(%p, %s): stub.\n", iface, debugstr_w(url));
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %s.\n", iface, debugstr_w(url));
+
+    EnterCriticalSection(&engine->cs);
+
+    IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS, 0, 0);
+
+    if (url)
+    {
+        IPropertyStore *props = NULL;
+        unsigned int flags;
+
+        flags = MF_RESOLUTION_MEDIASOURCE;
+        if (engine->flags & MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS)
+            flags |= MF_RESOLUTION_DISABLE_LOCAL_PLUGINS;
+
+        IMFAttributes_GetUnknown(engine->attributes, &MF_MEDIA_ENGINE_SOURCE_RESOLVER_CONFIG_STORE,
+                &IID_IPropertyStore, (void **)&props);
+        hr = IMFSourceResolver_BeginCreateObjectFromURL(engine->resolver, url, flags, props, NULL, &engine->load_handler, NULL);
+        if (props)
+            IPropertyStore_Release(props);
+    }
+
+    LeaveCriticalSection(&engine->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI media_engine_GetCurrentSource(IMFMediaEngine *iface, BSTR *url)
@@ -633,16 +798,30 @@ static HRESULT WINAPI media_engine_SetVolume(IMFMediaEngine *iface, double volum
 
 static BOOL WINAPI media_engine_HasVideo(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    BOOL value;
 
-    return FALSE;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+    value = !!(engine->flags & FLAGS_ENGINE_HAS_VIDEO);
+    LeaveCriticalSection(&engine->cs);
+
+    return value;
 }
 
 static BOOL WINAPI media_engine_HasAudio(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    BOOL value;
 
-    return FALSE;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+    value = !!(engine->flags & FLAGS_ENGINE_HAS_AUDIO);
+    LeaveCriticalSection(&engine->cs);
+
+    return value;
 }
 
 static HRESULT WINAPI media_engine_GetNativeVideoSize(IMFMediaEngine *iface, DWORD *cx, DWORD *cy)
@@ -777,6 +956,7 @@ static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct
 
     engine->IMFMediaEngine_iface.lpVtbl = &media_engine_vtbl;
     engine->session_events.lpVtbl = &media_engine_session_events_vtbl;
+    engine->load_handler.lpVtbl = &media_engine_load_handler_vtbl;
     engine->refcount = 1;
     engine->flags = (flags & MF_MEDIA_ENGINE_CREATEFLAGS_MASK) | FLAGS_ENGINE_PAUSED;
     engine->default_playback_rate = 1.0;
@@ -795,6 +975,9 @@ static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct
     if (FAILED(hr = IMFMediaSession_BeginGetEvent(engine->session, &engine->session_events, NULL)))
         return hr;
 
+    if (FAILED(hr = MFCreateSourceResolver(&engine->resolver)))
+        return hr;
+
     if (FAILED(hr = MFCreateAttributes(&engine->attributes, 0)))
         return hr;
 
From 3e784ab4a63dbf7029bf16bb14a24672b8b66008 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 3 Jun 2020 20:08:39 +0300
Subject: [PATCH] mfmediaengine: Set presentation duration attribute.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c | 30 +++++++++++++++++++++++++++---
 1 file changed, 27 insertions(+), 3 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 4136382566d..e39009b30b4 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -18,6 +18,7 @@
 
 #define COBJMACROS
 
+#include <math.h>
 #include <stdarg.h>
 
 #include "windef.h"
@@ -82,6 +83,7 @@ struct media_engine
     double playback_rate;
     double default_playback_rate;
     double volume;
+    double duration;
     IMFMediaSession *session;
     IMFSourceResolver *resolver;
     CRITICAL_SECTION cs;
@@ -208,6 +210,7 @@ static HRESULT media_engine_create_topology(struct media_engine *engine, IMFMedi
     IMFStreamDescriptor *sd_audio = NULL, *sd_video = NULL;
     unsigned int stream_count = 0, i;
     IMFPresentationDescriptor *pd;
+    UINT64 duration;
     HRESULT hr;
 
     if (FAILED(hr = IMFMediaSource_CreatePresentationDescriptor(source, &pd)))
@@ -265,7 +268,20 @@ static HRESULT media_engine_create_topology(struct media_engine *engine, IMFMedi
     if (sd_audio)
         engine->flags |= FLAGS_ENGINE_HAS_AUDIO;
 
-    /* TODO: set duration */
+    /* Assume live source if duration was not provided. */
+    if (SUCCEEDED(IMFPresentationDescriptor_GetUINT64(pd, &MF_PD_DURATION, &duration)))
+    {
+        /* Convert 100ns to seconds. */
+        engine->duration = duration / 10000000;
+    }
+    else
+        engine->duration = INFINITY;
+
+    IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE, 0, 0);
+    IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA, 0, 0);
+    IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_LOADEDDATA, 0, 0);
+
+    /* TODO: set up topology nodes */
 
     if (sd_video)
         IMFStreamDescriptor_Release(sd_video);
@@ -513,9 +529,16 @@ static double WINAPI media_engine_GetStartTime(IMFMediaEngine *iface)
 
 static double WINAPI media_engine_GetDuration(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    double value;
 
-    return 0.0;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+    value = engine->duration;
+    LeaveCriticalSection(&engine->cs);
+
+    return value;
 }
 
 static BOOL WINAPI media_engine_IsPaused(IMFMediaEngine *iface)
@@ -962,6 +985,7 @@ static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct
     engine->default_playback_rate = 1.0;
     engine->playback_rate = 1.0;
     engine->volume = 1.0;
+    engine->duration = NAN;
     InitializeCriticalSection(&engine->cs);
 
     hr = IMFAttributes_GetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, &IID_IMFMediaEngineNotify,
From 63d8cfa8f98181754c893655734cdbd69778ea5d Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 3 Jun 2020 20:08:40 +0300
Subject: [PATCH] mfmediaengine/tests: Add some tests for error property.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/tests/mfmediaengine.c | 55 ++++++++++++++++++++++++
 1 file changed, 55 insertions(+)

diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index a5b80ef25f4..59154c8d4f0 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -490,6 +490,60 @@ static void test_mute(void)
     IMFMediaEngine_Release(media_engine);
 }
 
+static void test_error(void)
+{
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *callback = &notify_impl.IMFMediaEngineNotify_iface;
+    IMFMediaEngine *media_engine;
+    IMFMediaError *eo, *eo2;
+    HRESULT hr;
+
+    media_engine = create_media_engine(callback);
+
+    eo = (void *)0xdeadbeef;
+    hr = IMFMediaEngine_GetError(media_engine, &eo);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!eo, "Unexpected instance.\n");
+}
+    hr = IMFMediaEngine_SetErrorCode(media_engine, MF_MEDIA_ENGINE_ERR_ENCRYPTED + 1);
+todo_wine
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaEngine_SetErrorCode(media_engine, MF_MEDIA_ENGINE_ERR_ABORTED);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    eo = NULL;
+    hr = IMFMediaEngine_GetError(media_engine, &eo);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!!eo, "Unexpected instance.\n");
+}
+    eo2 = NULL;
+    hr = IMFMediaEngine_GetError(media_engine, &eo2);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(eo2 != eo, "Unexpected instance.\n");
+}
+    if (eo2)
+        IMFMediaError_Release(eo2);
+    if (eo)
+        IMFMediaError_Release(eo);
+
+    hr = IMFMediaEngine_SetErrorCode(media_engine, MF_MEDIA_ENGINE_ERR_NOERROR);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    eo = (void *)0xdeadbeef;
+    hr = IMFMediaEngine_GetError(media_engine, &eo);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!eo, "Unexpected instance.\n");
+}
+    IMFMediaEngine_Release(media_engine);
+}
+
 START_TEST(mfmediaengine)
 {
     HRESULT hr;
@@ -516,6 +570,7 @@ START_TEST(mfmediaengine)
     test_Play();
     test_playback_rate();
     test_mute();
+    test_error();
 
     IMFMediaEngineClassFactory_Release(factory);
 
From 48c3a30650354f2ee5079533353a297850b6ec58 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 3 Jun 2020 20:08:41 +0300
Subject: [PATCH] mfmediaengine: Implement error object.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c                | 124 ++++++++++++++++++++++-
 dlls/mfmediaengine/tests/mfmediaengine.c |  28 +++++
 2 files changed, 150 insertions(+), 2 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index e39009b30b4..d77b1e4afee 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -89,6 +89,126 @@ struct media_engine
     CRITICAL_SECTION cs;
 };
 
+struct media_error
+{
+    IMFMediaError IMFMediaError_iface;
+    LONG refcount;
+    unsigned int code;
+    HRESULT extended_code;
+};
+
+static struct media_error *impl_from_IMFMediaError(IMFMediaError *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_error, IMFMediaError_iface);
+}
+
+static HRESULT WINAPI media_error_QueryInterface(IMFMediaError *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IMFMediaError) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFMediaError_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI media_error_AddRef(IMFMediaError *iface)
+{
+    struct media_error *me = impl_from_IMFMediaError(iface);
+    ULONG refcount = InterlockedIncrement(&me->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI media_error_Release(IMFMediaError *iface)
+{
+    struct media_error *me = impl_from_IMFMediaError(iface);
+    ULONG refcount = InterlockedDecrement(&me->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+        heap_free(me);
+
+    return refcount;
+}
+
+static USHORT WINAPI media_error_GetErrorCode(IMFMediaError *iface)
+{
+    struct media_error *me = impl_from_IMFMediaError(iface);
+    TRACE("%p.\n", iface);
+    return me->code;
+}
+
+static HRESULT WINAPI media_error_GetExtendedErrorCode(IMFMediaError *iface)
+{
+    struct media_error *me = impl_from_IMFMediaError(iface);
+    TRACE("%p.\n", iface);
+    return me->extended_code;
+}
+
+static HRESULT WINAPI media_error_SetErrorCode(IMFMediaError *iface, MF_MEDIA_ENGINE_ERR code)
+{
+    struct media_error *me = impl_from_IMFMediaError(iface);
+
+    TRACE("%p, %u.\n", iface, code);
+
+    if ((unsigned int)code > MF_MEDIA_ENGINE_ERR_ENCRYPTED)
+        return E_INVALIDARG;
+
+    me->code = code;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI media_error_SetExtendedErrorCode(IMFMediaError *iface, HRESULT code)
+{
+    struct media_error *me = impl_from_IMFMediaError(iface);
+
+    TRACE("%p, %#x.\n", iface, code);
+
+    me->extended_code = code;
+
+    return S_OK;
+}
+
+static const IMFMediaErrorVtbl media_error_vtbl =
+{
+    media_error_QueryInterface,
+    media_error_AddRef,
+    media_error_Release,
+    media_error_GetErrorCode,
+    media_error_GetExtendedErrorCode,
+    media_error_SetErrorCode,
+    media_error_SetExtendedErrorCode,
+};
+
+static HRESULT create_media_error(IMFMediaError **ret)
+{
+    struct media_error *object;
+
+    *ret = NULL;
+
+    if (!(object = heap_alloc_zero(sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFMediaError_iface.lpVtbl = &media_error_vtbl;
+    object->refcount = 1;
+
+    *ret = &object->IMFMediaError_iface;
+
+    return S_OK;
+}
+
 static void media_engine_set_flag(struct media_engine *engine, unsigned int mask, BOOL value)
 {
     if (value)
@@ -1060,9 +1180,9 @@ static HRESULT WINAPI media_engine_factory_CreateTimeRange(IMFMediaEngineClassFa
 
 static HRESULT WINAPI media_engine_factory_CreateError(IMFMediaEngineClassFactory *iface, IMFMediaError **error)
 {
-    FIXME("(%p, %p): stub.\n", iface, error);
+    TRACE("%p, %p.\n", iface, error);
 
-    return E_NOTIMPL;
+    return create_media_error(error);
 }
 
 static const IMFMediaEngineClassFactoryVtbl media_engine_factory_vtbl =
diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index 59154c8d4f0..2f114db7e9e 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -496,6 +496,7 @@ static void test_error(void)
     IMFMediaEngineNotify *callback = &notify_impl.IMFMediaEngineNotify_iface;
     IMFMediaEngine *media_engine;
     IMFMediaError *eo, *eo2;
+    unsigned int code;
     HRESULT hr;
 
     media_engine = create_media_engine(callback);
@@ -542,6 +543,33 @@ todo_wine {
     ok(!eo, "Unexpected instance.\n");
 }
     IMFMediaEngine_Release(media_engine);
+
+    /* Error object. */
+    hr = IMFMediaEngineClassFactory_CreateError(factory, &eo);
+    ok(hr == S_OK, "Failed to create error object, hr %#x.\n", hr);
+
+    code = IMFMediaError_GetErrorCode(eo);
+    ok(code == MF_MEDIA_ENGINE_ERR_NOERROR, "Unexpected code %u.\n", code);
+
+    hr = IMFMediaError_GetExtendedErrorCode(eo);
+    ok(hr == S_OK, "Unexpected code %#x.\n", hr);
+
+    hr = IMFMediaError_SetErrorCode(eo, MF_MEDIA_ENGINE_ERR_ENCRYPTED + 1);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaError_SetErrorCode(eo, MF_MEDIA_ENGINE_ERR_ABORTED);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    code = IMFMediaError_GetErrorCode(eo);
+    ok(code == MF_MEDIA_ENGINE_ERR_ABORTED, "Unexpected code %u.\n", code);
+
+    hr = IMFMediaError_SetExtendedErrorCode(eo, E_FAIL);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaError_GetExtendedErrorCode(eo);
+    ok(hr == E_FAIL, "Unexpected code %#x.\n", hr);
+
+    IMFMediaError_Release(eo);
 }
 
 START_TEST(mfmediaengine)
From 4d56ed9d02bafd0fd4f7438c5dd78714a00b1e9f Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 4 Jun 2020 13:41:45 +0300
Subject: [PATCH] mfmediaengine: Implement error property.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c                | 39 +++++++++++++++++++++---
 dlls/mfmediaengine/tests/mfmediaengine.c | 32 ++++++++++---------
 2 files changed, 51 insertions(+), 20 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index d77b1e4afee..dba55bb937d 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -84,6 +84,7 @@ struct media_engine
     double default_playback_rate;
     double volume;
     double duration;
+    MF_MEDIA_ENGINE_ERR error_code;
     IMFMediaSession *session;
     IMFSourceResolver *resolver;
     CRITICAL_SECTION cs;
@@ -512,16 +513,44 @@ static ULONG WINAPI media_engine_Release(IMFMediaEngine *iface)
 
 static HRESULT WINAPI media_engine_GetError(IMFMediaEngine *iface, IMFMediaError **error)
 {
-    FIXME("(%p, %p): stub.\n", iface, error);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, error);
+
+    *error = NULL;
+
+    EnterCriticalSection(&engine->cs);
+    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (engine->error_code)
+    {
+        if (SUCCEEDED(hr = create_media_error(error)))
+            IMFMediaError_SetErrorCode(*error, engine->error_code);
+    }
+    LeaveCriticalSection(&engine->cs);
+
+    return hr;
 }
 
-static HRESULT WINAPI media_engine_SetErrorCode(IMFMediaEngine *iface, MF_MEDIA_ENGINE_ERR error)
+static HRESULT WINAPI media_engine_SetErrorCode(IMFMediaEngine *iface, MF_MEDIA_ENGINE_ERR code)
 {
-    FIXME("(%p, %d): stub.\n", iface, error);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u.\n", iface, code);
+
+    if ((unsigned int)code > MF_MEDIA_ENGINE_ERR_ENCRYPTED)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&engine->cs);
+    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else
+        engine->error_code = code;
+    LeaveCriticalSection(&engine->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI media_engine_SetSourceElements(IMFMediaEngine *iface, IMFMediaEngineSrcElements *elements)
diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index 2f114db7e9e..660e5b95331 100644
--- a/dlls/mfmediaengine/tests/mfmediaengine.c
+++ b/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -503,45 +503,47 @@ static void test_error(void)
 
     eo = (void *)0xdeadbeef;
     hr = IMFMediaEngine_GetError(media_engine, &eo);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!eo, "Unexpected instance.\n");
-}
+
     hr = IMFMediaEngine_SetErrorCode(media_engine, MF_MEDIA_ENGINE_ERR_ENCRYPTED + 1);
-todo_wine
     ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEngine_SetErrorCode(media_engine, MF_MEDIA_ENGINE_ERR_ABORTED);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     eo = NULL;
     hr = IMFMediaEngine_GetError(media_engine, &eo);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!!eo, "Unexpected instance.\n");
-}
+
     eo2 = NULL;
     hr = IMFMediaEngine_GetError(media_engine, &eo2);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(eo2 != eo, "Unexpected instance.\n");
-}
-    if (eo2)
-        IMFMediaError_Release(eo2);
-    if (eo)
-        IMFMediaError_Release(eo);
+
+    IMFMediaError_Release(eo2);
+    IMFMediaError_Release(eo);
 
     hr = IMFMediaEngine_SetErrorCode(media_engine, MF_MEDIA_ENGINE_ERR_NOERROR);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     eo = (void *)0xdeadbeef;
     hr = IMFMediaEngine_GetError(media_engine, &eo);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!eo, "Unexpected instance.\n");
-}
+
+    hr = IMFMediaEngine_Shutdown(media_engine);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
+
+    eo = (void *)0xdeadbeef;
+    hr = IMFMediaEngine_GetError(media_engine, &eo);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+    ok(!eo, "Unexpected instance.\n");
+
+    hr = IMFMediaEngine_SetErrorCode(media_engine, MF_MEDIA_ENGINE_ERR_NOERROR);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
+
     IMFMediaEngine_Release(media_engine);
 
     /* Error object. */
From fae575cee92ed98b5084f64ed27fd5519e4d65bf Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 4 Jun 2020 13:41:46 +0300
Subject: [PATCH] mfmediaengine: Fully initialize error state.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index dba55bb937d..7693205238a 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -85,6 +85,7 @@ struct media_engine
     double volume;
     double duration;
     MF_MEDIA_ENGINE_ERR error_code;
+    HRESULT extended_code;
     IMFMediaSession *session;
     IMFSourceResolver *resolver;
     CRITICAL_SECTION cs;
@@ -440,8 +441,12 @@ static HRESULT WINAPI media_engine_load_handler_Invoke(IMFAsyncCallback *iface,
     }
 
     if (FAILED(hr))
-        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_ERROR,
-            MF_MEDIA_ENGINE_ERR_SRC_NOT_SUPPORTED, hr);
+    {
+        engine->error_code = MF_MEDIA_ENGINE_ERR_SRC_NOT_SUPPORTED;
+        engine->extended_code = hr;
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_ERROR, engine->error_code,
+                engine->extended_code);
+    }
 
     LeaveCriticalSection(&engine->cs);
 
@@ -526,7 +531,10 @@ static HRESULT WINAPI media_engine_GetError(IMFMediaEngine *iface, IMFMediaError
     else if (engine->error_code)
     {
         if (SUCCEEDED(hr = create_media_error(error)))
+        {
             IMFMediaError_SetErrorCode(*error, engine->error_code);
+            IMFMediaError_SetExtendedErrorCode(*error, engine->extended_code);
+        }
     }
     LeaveCriticalSection(&engine->cs);
 
From 496a7035accadee1924f14ae609b3b8fd39c3cfd Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 4 Jun 2020 13:41:47 +0300
Subject: [PATCH] mfmediaengine: Implement GetCurrentSource().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/Makefile.in |  2 +-
 dlls/mfmediaengine/main.c      | 24 ++++++++++++++++++++++--
 2 files changed, 23 insertions(+), 3 deletions(-)

diff --git a/dlls/mfmediaengine/Makefile.in b/dlls/mfmediaengine/Makefile.in
index cb593cb7edf..b97e9eec331 100644
--- a/dlls/mfmediaengine/Makefile.in
+++ b/dlls/mfmediaengine/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = mfmediaengine.dll
 IMPORTLIB = mfmediaengine
-IMPORTS = mfplat mf mfuuid uuid
+IMPORTS = oleaut32 mfplat mf mfuuid uuid
 
 EXTRADLLFLAGS = -mno-cygwin
 
diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 7693205238a..2f4a38936c4 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -88,6 +88,7 @@ struct media_engine
     HRESULT extended_code;
     IMFMediaSession *session;
     IMFSourceResolver *resolver;
+    BSTR current_source;
     CRITICAL_SECTION cs;
 };
 
@@ -499,6 +500,7 @@ static void free_media_engine(struct media_engine *engine)
         IMFAttributes_Release(engine->attributes);
     if (engine->resolver)
         IMFSourceResolver_Release(engine->resolver);
+    SysFreeString(engine->current_source);
     DeleteCriticalSection(&engine->cs);
     heap_free(engine);
 }
@@ -577,6 +579,11 @@ static HRESULT WINAPI media_engine_SetSource(IMFMediaEngine *iface, BSTR url)
 
     EnterCriticalSection(&engine->cs);
 
+    SysFreeString(engine->current_source);
+    engine->current_source = NULL;
+    if (url)
+        engine->current_source = SysAllocString(url);
+
     IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS, 0, 0);
 
     if (url)
@@ -602,9 +609,22 @@ static HRESULT WINAPI media_engine_SetSource(IMFMediaEngine *iface, BSTR url)
 
 static HRESULT WINAPI media_engine_GetCurrentSource(IMFMediaEngine *iface, BSTR *url)
 {
-    FIXME("(%p, %p): stub.\n", iface, url);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, url);
+
+    *url = NULL;
+
+    EnterCriticalSection(&engine->cs);
+    if (engine->current_source)
+    {
+        if (!(*url = SysAllocString(engine->current_source)))
+            hr = E_OUTOFMEMORY;
+    }
+    LeaveCriticalSection(&engine->cs);
+
+    return hr;
 }
 
 static USHORT WINAPI media_engine_GetNetworkState(IMFMediaEngine *iface)
From b643cefdc0fccba846c545e73d342394be6d798f Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 4 Jun 2020 13:41:48 +0300
Subject: [PATCH] mfmediaengine: Update ready state property during resolution.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c | 19 +++++++++++++++++--
 include/mfmediaengine.idl |  9 +++++++++
 2 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 2f4a38936c4..fee5f6338d5 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -86,6 +86,7 @@ struct media_engine
     double duration;
     MF_MEDIA_ENGINE_ERR error_code;
     HRESULT extended_code;
+    MF_MEDIA_ENGINE_READY ready_state;
     IMFMediaSession *session;
     IMFSourceResolver *resolver;
     BSTR current_source;
@@ -400,8 +401,13 @@ static HRESULT media_engine_create_topology(struct media_engine *engine, IMFMedi
     else
         engine->duration = INFINITY;
 
+    engine->ready_state = MF_MEDIA_ENGINE_READY_HAVE_METADATA;
+
     IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE, 0, 0);
     IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA, 0, 0);
+
+    engine->ready_state = MF_MEDIA_ENGINE_READY_HAVE_ENOUGH_DATA;
+
     IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_LOADEDDATA, 0, 0);
 
     /* TODO: set up topology nodes */
@@ -584,6 +590,8 @@ static HRESULT WINAPI media_engine_SetSource(IMFMediaEngine *iface, BSTR url)
     if (url)
         engine->current_source = SysAllocString(url);
 
+    engine->ready_state = MF_MEDIA_ENGINE_READY_HAVE_NOTHING;
+
     IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS, 0, 0);
 
     if (url)
@@ -671,9 +679,16 @@ static HRESULT WINAPI media_engine_CanPlayType(IMFMediaEngine *iface, BSTR type,
 
 static USHORT WINAPI media_engine_GetReadyState(IMFMediaEngine *iface)
 {
-    FIXME("(%p): stub.\n", iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
+    unsigned short state;
 
-    return 0;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&engine->cs);
+    state = engine->ready_state;
+    LeaveCriticalSection(&engine->cs);
+
+    return state;
 }
 
 static BOOL WINAPI media_engine_IsSeeking(IMFMediaEngine *iface)
diff --git a/include/mfmediaengine.idl b/include/mfmediaengine.idl
index 4ea3d834cf2..b914cb3600b 100644
--- a/include/mfmediaengine.idl
+++ b/include/mfmediaengine.idl
@@ -137,6 +137,15 @@ typedef enum MF_MEDIA_ENGINE_EVENT
     MF_MEDIA_ENGINE_EVENT_AUDIOENDPOINTCHANGE = 1016,
 } MF_MEDIA_ENGINE_EVENT;
 
+typedef enum MF_MEDIA_ENGINE_READY
+{
+    MF_MEDIA_ENGINE_READY_HAVE_NOTHING,
+    MF_MEDIA_ENGINE_READY_HAVE_METADATA,
+    MF_MEDIA_ENGINE_READY_HAVE_CURRENT_DATA,
+    MF_MEDIA_ENGINE_READY_HAVE_FUTURE_DATA,
+    MF_MEDIA_ENGINE_READY_HAVE_ENOUGH_DATA,
+} MF_MEDIA_ENGINE_READY;
+
 [
     object,
     uuid(fc0e10d2-ab2a-4501-a951-06bb1075184c),
From a82fa9207d6875a096c0cbf2694d45cc98a201d8 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 4 Jun 2020 13:41:49 +0300
Subject: [PATCH] mfmediaengine: Set up audio output branch.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfmediaengine/main.c | 77 ++++++++++++++++++++++++++++++++++++++-
 1 file changed, 75 insertions(+), 2 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index fee5f6338d5..d93e2b2f38c 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -329,11 +329,55 @@ static ULONG WINAPI media_engine_load_handler_Release(IMFAsyncCallback *iface)
     return IMFMediaEngine_Release(&engine->IMFMediaEngine_iface);
 }
 
+static HRESULT media_engine_create_source_node(IMFMediaSource *source, IMFPresentationDescriptor *pd, IMFStreamDescriptor *sd,
+        IMFTopologyNode **node)
+{
+    HRESULT hr;
+
+    if (FAILED(hr = MFCreateTopologyNode(MF_TOPOLOGY_SOURCESTREAM_NODE, node)))
+        return hr;
+
+    IMFTopologyNode_SetUnknown(*node, &MF_TOPONODE_SOURCE, (IUnknown *)source);
+    IMFTopologyNode_SetUnknown(*node, &MF_TOPONODE_PRESENTATION_DESCRIPTOR, (IUnknown *)pd);
+    IMFTopologyNode_SetUnknown(*node, &MF_TOPONODE_STREAM_DESCRIPTOR, (IUnknown *)sd);
+
+    return S_OK;
+}
+
+static HRESULT media_engine_create_audio_renderer(struct media_engine *engine, IMFTopologyNode **node)
+{
+    unsigned int category, role;
+    IMFActivate *sar_activate;
+    HRESULT hr;
+
+    *node = NULL;
+
+    if (FAILED(hr = MFCreateAudioRendererActivate(&sar_activate)))
+        return hr;
+
+    /* Configuration attributes keys differ between Engine and SAR. */
+    if (SUCCEEDED(IMFAttributes_GetUINT32(engine->attributes, &MF_MEDIA_ENGINE_AUDIO_CATEGORY, &category)))
+        IMFActivate_SetUINT32(sar_activate, &MF_AUDIO_RENDERER_ATTRIBUTE_STREAM_CATEGORY, category);
+    if (SUCCEEDED(IMFAttributes_GetUINT32(engine->attributes, &MF_MEDIA_ENGINE_AUDIO_ENDPOINT_ROLE, &role)))
+        IMFActivate_SetUINT32(sar_activate, &MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ROLE, role);
+
+    if (SUCCEEDED(hr = MFCreateTopologyNode(MF_TOPOLOGY_OUTPUT_NODE, node)))
+    {
+        IMFTopologyNode_SetObject(*node, (IUnknown *)sar_activate);
+        IMFTopologyNode_SetUINT32(*node, &MF_TOPONODE_NOSHUTDOWN_ON_REMOVE, FALSE);
+    }
+
+    IMFActivate_Release(sar_activate);
+
+    return hr;
+}
+
 static HRESULT media_engine_create_topology(struct media_engine *engine, IMFMediaSource *source)
 {
     IMFStreamDescriptor *sd_audio = NULL, *sd_video = NULL;
     unsigned int stream_count = 0, i;
     IMFPresentationDescriptor *pd;
+    IMFTopology *topology;
     UINT64 duration;
     HRESULT hr;
 
@@ -410,7 +454,36 @@ static HRESULT media_engine_create_topology(struct media_engine *engine, IMFMedi
 
     IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_LOADEDDATA, 0, 0);
 
-    /* TODO: set up topology nodes */
+    /* TODO: set up video stream nodes */
+
+    if (SUCCEEDED(hr = MFCreateTopology(&topology)))
+    {
+        IMFTopologyNode *sar_node = NULL, *audio_src = NULL;
+
+        if (sd_audio)
+        {
+            if (FAILED(hr = media_engine_create_source_node(source, pd, sd_audio, &audio_src)))
+                WARN("Failed to create audio source node, hr %#x.\n", hr);
+
+            if (FAILED(hr = media_engine_create_audio_renderer(engine, &sar_node)))
+                WARN("Failed to create audio renderer node, hr %#x.\n", hr);
+
+            if (sar_node && audio_src)
+            {
+                IMFTopology_AddNode(topology, audio_src);
+                IMFTopology_AddNode(topology, sar_node);
+                IMFTopologyNode_ConnectOutput(audio_src, 0, sar_node, 0);
+            }
+
+            if (sar_node)
+                IMFTopologyNode_Release(sar_node);
+            if (audio_src)
+                IMFTopologyNode_Release(audio_src);
+        }
+    }
+
+    if (topology)
+        IMFTopology_Release(topology);
 
     if (sd_video)
         IMFStreamDescriptor_Release(sd_video);
@@ -419,7 +492,7 @@ static HRESULT media_engine_create_topology(struct media_engine *engine, IMFMedi
 
     IMFPresentationDescriptor_Release(pd);
 
-    return S_OK;
+    return hr;
 }
 
 static HRESULT WINAPI media_engine_load_handler_Invoke(IMFAsyncCallback *iface, IMFAsyncResult *result)
From 17529582402ebe27ef975fc7dcb8353f4f95e629 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 7 Jun 2020 17:23:32 -0500
Subject: [PATCH] evr: Free type libraries on process detach (Valgrind).

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/evr.c         |  1 -
 dlls/evr/evr_private.h |  1 +
 dlls/evr/main.c        | 19 +++++++++----------
 3 files changed, 10 insertions(+), 11 deletions(-)

diff --git a/dlls/evr/evr.c b/dlls/evr/evr.c
index 911075de338..001839026b2 100644
--- a/dlls/evr/evr.c
+++ b/dlls/evr/evr.c
@@ -24,7 +24,6 @@
 
 #include "evr_private.h"
 #include "d3d9.h"
-#include "wine/strmbase.h"
 
 #include "initguid.h"
 #include "dxva2api.h"
diff --git a/dlls/evr/evr_private.h b/dlls/evr/evr_private.h
index 65dcbb7a9bc..ad47bd28b78 100644
--- a/dlls/evr/evr_private.h
+++ b/dlls/evr/evr_private.h
@@ -21,6 +21,7 @@
 
 #include "dshow.h"
 #include "evr.h"
+#include "wine/strmbase.h"
 
 HRESULT evr_filter_create(IUnknown *outer_unk, void **ppv) DECLSPEC_HIDDEN;
 
diff --git a/dlls/evr/main.c b/dlls/evr/main.c
index 000ed7c55be..921e63535f9 100644
--- a/dlls/evr/main.c
+++ b/dlls/evr/main.c
@@ -36,18 +36,17 @@ static HINSTANCE instance_evr;
 
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, LPVOID reserved)
 {
-    TRACE("(%p, %d, %p)\n", instance, reason, reserved);
-
-    switch (reason)
+    if (reason == DLL_WINE_PREATTACH)
+        return FALSE; /* prefer native version */
+    else if (reason == DLL_PROCESS_ATTACH)
     {
-        case DLL_WINE_PREATTACH:
-            return FALSE;    /* prefer native version */
-        case DLL_PROCESS_ATTACH:
-            instance_evr = instance;
-            DisableThreadLibraryCalls(instance);
-            break;
+        instance_evr = instance;
+        DisableThreadLibraryCalls(instance);
+    }
+    else if (reason == DLL_PROCESS_DETACH && !reserved)
+    {
+        strmbase_release_typelibs();
     }
-
     return TRUE;
 }
 
From a18bc50f2f38b9ab771b4e6ef11ccede4f0814cd Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Tue, 9 Jun 2020 01:00:55 +0700
Subject: [PATCH] winegstreamer: Commit allocator before pausing the stream.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 299a7ddf56e..7c38e421f9b 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1391,6 +1391,15 @@ static HRESULT gstdemux_init_stream(struct strmbase_filter *iface)
     if (!filter->container)
         return VFW_E_NOT_CONNECTED;
 
+    for (i = 0; i < filter->source_count; ++i)
+    {
+        if (SUCCEEDED(pin_hr = BaseOutputPinImpl_Active(&filter->sources[i]->pin)))
+            hr = pin_hr;
+    }
+
+    if (FAILED(hr))
+        return hr;
+
     if (filter->no_more_pads_event)
         ResetEvent(filter->no_more_pads_event);
 
@@ -1422,11 +1431,6 @@ static HRESULT gstdemux_init_stream(struct strmbase_filter *iface)
                 stop_type, seeking->llStop * 100));
     }
 
-    for (i = 0; i < filter->source_count; ++i)
-    {
-        if (SUCCEEDED(pin_hr = BaseOutputPinImpl_Active(&filter->sources[i]->pin)))
-            hr = pin_hr;
-    }
     return hr;
 }
 
From 1e079a0ca40f5f67ac4ecd4a3291ce299069e608 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 10 Jun 2020 15:52:55 -0500
Subject: [PATCH] winegstreamer: Don't query our own source pad to convert
 duration.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 7c38e421f9b..19d36cd233c 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1139,21 +1139,23 @@ static gboolean query_function(GstPad *pad, GstObject *parent, GstQuery *query)
 {
     struct gstdemux *This = gst_pad_get_element_private(pad);
     GstFormat format;
-    int ret;
-    LONGLONG duration;
 
     TRACE("filter %p, type %s.\n", This, GST_QUERY_TYPE_NAME(query));
 
     switch (GST_QUERY_TYPE(query)) {
         case GST_QUERY_DURATION:
-            gst_query_parse_duration (query, &format, NULL);
-            if (format == GST_FORMAT_PERCENT) {
-                gst_query_set_duration (query, GST_FORMAT_PERCENT, GST_FORMAT_PERCENT_MAX);
+            gst_query_parse_duration(query, &format, NULL);
+            if (format == GST_FORMAT_PERCENT)
+            {
+                gst_query_set_duration(query, GST_FORMAT_PERCENT, GST_FORMAT_PERCENT_MAX);
                 return TRUE;
             }
-            ret = gst_pad_query_convert (pad, GST_FORMAT_BYTES, This->filesize, format, &duration);
-            gst_query_set_duration(query, format, duration);
-            return ret;
+            else if (format == GST_FORMAT_BYTES)
+            {
+                gst_query_set_duration(query, GST_FORMAT_BYTES, This->filesize);
+                return TRUE;
+            }
+            return FALSE;
         case GST_QUERY_SEEKING:
             gst_query_parse_seeking (query, &format, NULL, NULL, NULL);
             if (format != GST_FORMAT_BYTES)
From 9cc742d258f4cb3289f0729518123c04049c524c Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 10 Jun 2020 15:52:56 -0500
Subject: [PATCH] winegstreamer: Calculate duration independently per pin.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 19d36cd233c..a0fdba9ff2c 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1621,13 +1621,13 @@ static BOOL gstdecoder_init_gst(struct gstdemux *filter)
 
     WaitForSingleObject(filter->no_more_pads_event, INFINITE);
 
-    if (!gst_pad_query_duration(filter->sources[0]->their_src, GST_FORMAT_TIME, &duration))
-        ERR("Failed to query duration.\n");
     for (i = 0; i < filter->source_count; ++i)
     {
         struct gstdemux_source *pin = filter->sources[i];
         const HANDLE events[2] = {pin->caps_event, filter->error_event};
 
+        if (!gst_pad_query_duration(filter->sources[i]->their_src, GST_FORMAT_TIME, &duration))
+            ERR("Failed to query duration.\n");
         pin->seek.llDuration = pin->seek.llStop = duration / 100;
         pin->seek.llCurrent = 0;
         if (WaitForMultipleObjects(2, events, FALSE, INFINITE))
@@ -2464,13 +2464,13 @@ static BOOL avi_splitter_init_gst(struct gstdemux *filter)
 
     WaitForSingleObject(filter->no_more_pads_event, INFINITE);
 
-    if (!gst_pad_query_duration(filter->sources[0]->their_src, GST_FORMAT_TIME, &duration))
-        ERR("Failed to query duration.\n");
     for (i = 0; i < filter->source_count; ++i)
     {
         struct gstdemux_source *pin = filter->sources[i];
         const HANDLE events[2] = {pin->caps_event, filter->error_event};
 
+        if (!gst_pad_query_duration(filter->sources[i]->their_src, GST_FORMAT_TIME, &duration))
+            ERR("Failed to query duration.\n");
         pin->seek.llDuration = pin->seek.llStop = duration / 100;
         pin->seek.llCurrent = 0;
         if (WaitForMultipleObjects(2, events, FALSE, INFINITE))
From d492f7bbf818ba35a0bb8a7be2d814c0ba8acc5a Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 17 Jun 2020 14:59:32 +0300
Subject: [PATCH] evr/tests: Add basic creation test for default mixer object.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/Makefile.in       |  4 ++-
 dlls/evr/evr.spec          |  2 +-
 dlls/evr/mixer.c           | 28 ++++++++++++++++++++
 dlls/evr/tests/Makefile.in |  2 +-
 dlls/evr/tests/evr.c       | 32 ++++++++++++++++++++++
 include/evr.idl            | 54 ++++++++++++++++++++++++++++++++++++++
 6 files changed, 119 insertions(+), 3 deletions(-)
 create mode 100644 dlls/evr/mixer.c

diff --git a/dlls/evr/Makefile.in b/dlls/evr/Makefile.in
index 053d80e61d7..8f971dca06f 100644
--- a/dlls/evr/Makefile.in
+++ b/dlls/evr/Makefile.in
@@ -1,10 +1,12 @@
 MODULE    = evr.dll
+IMPORTLIB = evr
 IMPORTS   = mfuuid strmiids strmbase uuid ole32 oleaut32
 
 EXTRADLLFLAGS = -mno-cygwin
 
 C_SRCS = \
 	evr.c \
-	main.c
+	main.c \
+	mixer.c
 
 IDL_SRCS = evr_classes.idl
diff --git a/dlls/evr/evr.spec b/dlls/evr/evr.spec
index c78900c5762..ea87f16da15 100644
--- a/dlls/evr/evr.spec
+++ b/dlls/evr/evr.spec
@@ -13,7 +13,7 @@
 @ stub MFCreateVideoMediaTypeFromSubtype
 @ stub MFCreateVideoMediaTypeFromVideoInfoHeader2
 @ stub MFCreateVideoMediaTypeFromVideoInfoHeader
-@ stub MFCreateVideoMixer
+@ stdcall MFCreateVideoMixer(ptr ptr ptr ptr)
 @ stub MFCreateVideoMixerAndPresenter
 @ stub MFCreateVideoOTA
 @ stub MFCreateVideoPresenter2
diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
new file mode 100644
index 00000000000..fe2f4bab1df
--- /dev/null
+++ b/dlls/evr/mixer.c
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2020 Nikolay Sivov
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "wine/debug.h"
+#include "evr.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(evr);
+
+HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
+{
+    FIXME("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
+    return E_NOTIMPL;
+}
diff --git a/dlls/evr/tests/Makefile.in b/dlls/evr/tests/Makefile.in
index 8dc11e5e558..529c5354508 100644
--- a/dlls/evr/tests/Makefile.in
+++ b/dlls/evr/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = evr.dll
-IMPORTS   = mfuuid strmiids uuid ole32 oleaut32
+IMPORTS   = mfuuid strmiids uuid dxguid ole32 oleaut32 evr
 
 C_SRCS = \
 	evr.c
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 489b7b949db..adb2b777a2e 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -22,6 +22,7 @@
 #include "dshow.h"
 #include "wine/test.h"
 #include "d3d9.h"
+#include "evr.h"
 #include "initguid.h"
 #include "dxva2api.h"
 
@@ -337,6 +338,36 @@ static void test_pin_info(void)
     ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
+static void test_default_mixer(void)
+{
+    IMFTransform *transform;
+    IUnknown *unk;
+    HRESULT hr;
+
+    hr = MFCreateVideoMixer(NULL, &IID_IDirect3DDevice9, &IID_IMFTransform, (void **)&transform);
+todo_wine
+    ok(hr == S_OK, "Failed to create default mixer, hr %#x.\n", hr);
+    if (FAILED(hr))
+        return;
+
+    hr = IMFTransform_QueryInterface(transform, &IID_IMFTopologyServiceLookupClient, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
+    hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoDeviceID, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
+    IMFTransform_Release(transform);
+
+    hr = MFCreateVideoMixer(NULL, &IID_IMFTransform, &IID_IMFTransform, (void **)&transform);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    hr = CoCreateInstance(&CLSID_MFVideoMixer9, NULL, CLSCTX_INPROC_SERVER, &IID_IMFTransform, (void **)&transform);
+    ok(hr == S_OK, "Failed to create default mixer, hr %#x.\n", hr);
+    IMFTransform_Release(transform);
+}
+
 START_TEST(evr)
 {
     CoInitialize(NULL);
@@ -346,6 +377,7 @@ START_TEST(evr)
     test_enum_pins();
     test_find_pin();
     test_pin_info();
+    test_default_mixer();
 
     CoUninitialize();
 }
diff --git a/include/evr.idl b/include/evr.idl
index 3768b41b16e..39b4853b2e3 100644
--- a/include/evr.idl
+++ b/include/evr.idl
@@ -107,3 +107,57 @@ interface IMFVideoRenderer : IUnknown
         [in] IMFVideoPresenter *pVideoPresenter
     );
 }
+
+typedef enum _MF_SERVICE_LOOKUP_TYPE
+{
+    MF_SERVICE_LOOKUP_UPSTREAM,
+    MF_SERVICE_LOOKUP_UPSTREAM_DIRECT,
+    MF_SERVICE_LOOKUP_DOWNSTREAM,
+    MF_SERVICE_LOOKUP_DOWNSTREAM_DIRECT,
+    MF_SERVICE_LOOKUP_ALL,
+    MF_SERVICE_LOOKUP_GLOBAL,
+} MF_SERVICE_LOOKUP_TYPE;
+
+[
+    object,
+    uuid(fa993889-4383-415a-a930-dd472a8cf6f7),
+    local
+]
+interface IMFTopologyServiceLookup : IUnknown
+{
+    HRESULT LookupService(
+        [in] MF_SERVICE_LOOKUP_TYPE lookup_type,
+        [in] DWORD index,
+        [in] REFGUID service,
+        [in] REFIID riid,
+        [out, iid_is(riid)] void **objects,
+        [in, out] DWORD *num_objects
+    );
+}
+
+[
+    object,
+    uuid(fa99388a-4383-415a-a930-dd472a8cf6f7),
+    local
+]
+interface IMFTopologyServiceLookupClient : IUnknown
+{
+    HRESULT InitServicePointers(
+        [in] IMFTopologyServiceLookup *service_lookup
+    );
+    HRESULT ReleaseServicePointers();
+}
+
+[
+    object,
+    uuid(a38d9567-5a9c-4f3c-b293-8eb415b279ba),
+    local
+]
+interface IMFVideoDeviceID : IUnknown
+{
+    HRESULT GetDeviceID(
+        [out] IID *device_id
+    );
+}
+
+cpp_quote("HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj);")
From c09be94f63282f169cae6db8339514e076d323ba Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 17 Jun 2020 14:59:33 +0300
Subject: [PATCH] evr: Add IMFTransform stub for default video mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/Makefile.in     |   2 +-
 dlls/evr/evr_classes.idl |   9 +-
 dlls/evr/evr_private.h   |   2 +-
 dlls/evr/main.c          |   1 +
 dlls/evr/mixer.c         | 280 ++++++++++++++++++++++++++++++++++++++-
 dlls/evr/tests/evr.c     |  11 +-
 6 files changed, 294 insertions(+), 11 deletions(-)

diff --git a/dlls/evr/Makefile.in b/dlls/evr/Makefile.in
index 8f971dca06f..bf3048f62ee 100644
--- a/dlls/evr/Makefile.in
+++ b/dlls/evr/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = evr.dll
 IMPORTLIB = evr
-IMPORTS   = mfuuid strmiids strmbase uuid ole32 oleaut32
+IMPORTS   = mfuuid strmiids strmbase uuid dxguid ole32 oleaut32
 
 EXTRADLLFLAGS = -mno-cygwin
 
diff --git a/dlls/evr/evr_classes.idl b/dlls/evr/evr_classes.idl
index 20a346ac67a..31f0d34fe75 100644
--- a/dlls/evr/evr_classes.idl
+++ b/dlls/evr/evr_classes.idl
@@ -18,11 +18,16 @@
 
 #pragma makedep register
 
-#include "strmif.idl"
-
 [
     helpstring("Enhanced Video Renderer"),
     threading(both),
     uuid(fa10746c-9b63-4b6c-bc49-fc300ea5f256)
 ]
 coclass EnhancedVideoRenderer { interface IBaseFilter; }
+
+[
+    helpstring("MF Video Mixer"),
+    threading(both),
+    uuid(e474e05a-ab65-4f6a-827c-218b1baaf31f)
+]
+coclass MFVideoMixer9 { interface IMFTransform; }
diff --git a/dlls/evr/evr_private.h b/dlls/evr/evr_private.h
index ad47bd28b78..5698eb0c21e 100644
--- a/dlls/evr/evr_private.h
+++ b/dlls/evr/evr_private.h
@@ -24,6 +24,6 @@
 #include "wine/strmbase.h"
 
 HRESULT evr_filter_create(IUnknown *outer_unk, void **ppv) DECLSPEC_HIDDEN;
-
+HRESULT evr_mixer_create(IUnknown *outer_unk, void **ppv) DECLSPEC_HIDDEN;
 
 #endif /* __EVR_PRIVATE_INCLUDED__ */
diff --git a/dlls/evr/main.c b/dlls/evr/main.c
index 921e63535f9..85c81f13604 100644
--- a/dlls/evr/main.c
+++ b/dlls/evr/main.c
@@ -71,6 +71,7 @@ struct object_creation_info
 static const struct object_creation_info object_creation[] =
 {
     { &CLSID_EnhancedVideoRenderer, evr_filter_create },
+    { &CLSID_MFVideoMixer9, evr_mixer_create },
 };
 
 static HRESULT WINAPI classfactory_QueryInterface(IClassFactory *iface, REFIID riid, void **ppobj)
diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index fe2f4bab1df..41d63c8aab5 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -16,13 +16,289 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#define COBJMACROS
+
 #include "wine/debug.h"
 #include "evr.h"
+#include "d3d9.h"
+
+#include "evr_classes.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(evr);
 
-HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
+struct video_mixer
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+};
+
+static struct video_mixer *impl_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_mixer, IMFTransform_iface);
+}
+
+static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(riid, &IID_IMFTransform) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFTransform_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI video_mixer_transform_AddRef(IMFTransform *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&mixer->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI video_mixer_transform_Release(IMFTransform *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&mixer->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+        free(mixer);
+
+    return refcount;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum,
+        DWORD *input_maximum, DWORD *output_minimum, DWORD *output_maximum)
+{
+    FIXME("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    FIXME("%p, %p, %p.\n", iface, inputs, outputs);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    FIXME("%p, %u, %p, %u, %p.\n", iface, input_size, inputs, output_size, outputs);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
 {
-    FIXME("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
+    FIXME("%p, %u, %p.\n", iface, id, info);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    FIXME("%p, %u, %p.\n", iface, id, info);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("%p, %p.\n", iface, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    FIXME("%p, %u.\n", iface, id);
+
     return E_NOTIMPL;
 }
+
+static HRESULT WINAPI video_mixer_transform_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    FIXME("%p, %u, %p.\n", iface, streams, ids);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("%p, %u, %p.\n", iface, id, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("%p, %p.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("%p, %s, %s.\n", iface, wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("%p, %u, %p.\n", iface, id, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("%p, %u, %#lx.\n", iface, message, param);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    FIXME("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_transform_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    FIXME("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    return E_NOTIMPL;
+}
+
+static const IMFTransformVtbl video_mixer_transform_vtbl =
+{
+    video_mixer_transform_QueryInterface,
+    video_mixer_transform_AddRef,
+    video_mixer_transform_Release,
+    video_mixer_transform_GetStreamLimits,
+    video_mixer_transform_GetStreamCount,
+    video_mixer_transform_GetStreamIDs,
+    video_mixer_transform_GetInputStreamInfo,
+    video_mixer_transform_GetOutputStreamInfo,
+    video_mixer_transform_GetAttributes,
+    video_mixer_transform_GetInputStreamAttributes,
+    video_mixer_transform_GetOutputStreamAttributes,
+    video_mixer_transform_DeleteInputStream,
+    video_mixer_transform_AddInputStreams,
+    video_mixer_transform_GetInputAvailableType,
+    video_mixer_transform_GetOutputAvailableType,
+    video_mixer_transform_SetInputType,
+    video_mixer_transform_SetOutputType,
+    video_mixer_transform_GetInputCurrentType,
+    video_mixer_transform_GetOutputCurrentType,
+    video_mixer_transform_GetInputStatus,
+    video_mixer_transform_GetOutputStatus,
+    video_mixer_transform_SetOutputBounds,
+    video_mixer_transform_ProcessEvent,
+    video_mixer_transform_ProcessMessage,
+    video_mixer_transform_ProcessInput,
+    video_mixer_transform_ProcessOutput,
+};
+
+HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
+
+    *obj = NULL;
+
+    if (!IsEqualIID(riid_device, &IID_IDirect3DDevice9))
+        return E_INVALIDARG;
+
+    return CoCreateInstance(&CLSID_MFVideoMixer9, owner, CLSCTX_INPROC_SERVER, riid, obj);
+}
+
+HRESULT evr_mixer_create(IUnknown *outer, void **out)
+{
+    struct video_mixer *object;
+
+    if (outer)
+        return E_NOINTERFACE;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFTransform_iface.lpVtbl = &video_mixer_transform_vtbl;
+    object->refcount = 1;
+
+    *out = &object->IMFTransform_iface;
+
+    return S_OK;
+}
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index adb2b777a2e..c4b1a561576 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -345,18 +345,19 @@ static void test_default_mixer(void)
     HRESULT hr;
 
     hr = MFCreateVideoMixer(NULL, &IID_IDirect3DDevice9, &IID_IMFTransform, (void **)&transform);
-todo_wine
     ok(hr == S_OK, "Failed to create default mixer, hr %#x.\n", hr);
-    if (FAILED(hr))
-        return;
 
     hr = IMFTransform_QueryInterface(transform, &IID_IMFTopologyServiceLookupClient, (void **)&unk);
+todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    IUnknown_Release(unk);
+    if (SUCCEEDED(hr))
+        IUnknown_Release(unk);
 
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoDeviceID, (void **)&unk);
+todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    IUnknown_Release(unk);
+    if (SUCCEEDED(hr))
+        IUnknown_Release(unk);
 
     IMFTransform_Release(transform);
 
From 8d791562133469554dbd6f9fe9aee04fd024dc40 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 17 Jun 2020 14:59:34 +0300
Subject: [PATCH] evr: Add IMFVideoDeviceID to default mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 66 ++++++++++++++++++++++++++++++++++++++++----
 dlls/evr/tests/evr.c | 16 ++++++++---
 2 files changed, 73 insertions(+), 9 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 41d63c8aab5..97eaf976fc8 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -29,6 +29,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(evr);
 struct video_mixer
 {
     IMFTransform IMFTransform_iface;
+    IMFVideoDeviceID IMFVideoDeviceID_iface;
     LONG refcount;
 };
 
@@ -37,19 +38,35 @@ static struct video_mixer *impl_from_IMFTransform(IMFTransform *iface)
     return CONTAINING_RECORD(iface, struct video_mixer, IMFTransform_iface);
 }
 
+static struct video_mixer *impl_from_IMFVideoDeviceID(IMFVideoDeviceID *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_mixer, IMFVideoDeviceID_iface);
+}
+
 static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
 {
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
     if (IsEqualIID(riid, &IID_IMFTransform) ||
             IsEqualIID(riid, &IID_IUnknown))
     {
         *obj = iface;
-        IMFTransform_AddRef(iface);
-        return S_OK;
+    }
+    else if (IsEqualIID(riid, &IID_IMFVideoDeviceID))
+    {
+        *obj = &mixer->IMFVideoDeviceID_iface;
+    }
+    else
+    {
+        WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+        *obj = NULL;
+        return E_NOINTERFACE;
     }
 
-    WARN("Unsupported interface %s.\n", debugstr_guid(riid));
-    *obj = NULL;
-    return E_NOINTERFACE;
+    IUnknown_AddRef((IUnknown *)*obj);
+    return S_OK;
 }
 
 static ULONG WINAPI video_mixer_transform_AddRef(IMFTransform *iface)
@@ -273,6 +290,44 @@ static const IMFTransformVtbl video_mixer_transform_vtbl =
     video_mixer_transform_ProcessOutput,
 };
 
+static HRESULT WINAPI video_mixer_device_id_QueryInterface(IMFVideoDeviceID *iface, REFIID riid, void **obj)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoDeviceID(iface);
+    return IMFTransform_QueryInterface(&mixer->IMFTransform_iface, riid, obj);
+}
+
+static ULONG WINAPI video_mixer_device_id_AddRef(IMFVideoDeviceID *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoDeviceID(iface);
+    return IMFTransform_AddRef(&mixer->IMFTransform_iface);
+}
+
+static ULONG WINAPI video_mixer_device_id_Release(IMFVideoDeviceID *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoDeviceID(iface);
+    return IMFTransform_Release(&mixer->IMFTransform_iface);
+}
+
+static HRESULT WINAPI video_mixer_device_id_GetDeviceID(IMFVideoDeviceID *iface, IID *device_id)
+{
+    TRACE("%p, %p.\n", iface, device_id);
+
+    if (!device_id)
+        return E_POINTER;
+
+    memcpy(device_id, &IID_IDirect3DDevice9, sizeof(*device_id));
+
+    return S_OK;
+}
+
+static const IMFVideoDeviceIDVtbl video_mixer_device_id_vtbl =
+{
+    video_mixer_device_id_QueryInterface,
+    video_mixer_device_id_AddRef,
+    video_mixer_device_id_Release,
+    video_mixer_device_id_GetDeviceID,
+};
+
 HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -296,6 +351,7 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
         return E_OUTOFMEMORY;
 
     object->IMFTransform_iface.lpVtbl = &video_mixer_transform_vtbl;
+    object->IMFVideoDeviceID_iface.lpVtbl = &video_mixer_device_id_vtbl;
     object->refcount = 1;
 
     *out = &object->IMFTransform_iface;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index c4b1a561576..7fa6136b0e9 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -340,9 +340,11 @@ static void test_pin_info(void)
 
 static void test_default_mixer(void)
 {
+    IMFVideoDeviceID *deviceid;
     IMFTransform *transform;
     IUnknown *unk;
     HRESULT hr;
+    IID iid;
 
     hr = MFCreateVideoMixer(NULL, &IID_IDirect3DDevice9, &IID_IMFTransform, (void **)&transform);
     ok(hr == S_OK, "Failed to create default mixer, hr %#x.\n", hr);
@@ -353,11 +355,17 @@ todo_wine
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 
-    hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoDeviceID, (void **)&unk);
-todo_wine
+    hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoDeviceID, (void **)&deviceid);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    if (SUCCEEDED(hr))
-        IUnknown_Release(unk);
+
+    hr = IMFVideoDeviceID_GetDeviceID(deviceid, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDeviceID_GetDeviceID(deviceid, &iid);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(IsEqualIID(&iid, &IID_IDirect3DDevice9), "Unexpected id %s.\n", wine_dbgstr_guid(&iid));
+
+    IMFVideoDeviceID_Release(deviceid);
 
     IMFTransform_Release(transform);
 
From 186ed57ba5c9dc9e791d234372e2318e3a1f8628 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 17 Jun 2020 14:59:35 +0300
Subject: [PATCH] evr: Add IMFTopologyServiceLookupClient stub for default
 mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 54 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c |  4 +---
 2 files changed, 55 insertions(+), 3 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 97eaf976fc8..3101d17ffdb 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -30,6 +30,7 @@ struct video_mixer
 {
     IMFTransform IMFTransform_iface;
     IMFVideoDeviceID IMFVideoDeviceID_iface;
+    IMFTopologyServiceLookupClient IMFTopologyServiceLookupClient_iface;
     LONG refcount;
 };
 
@@ -43,6 +44,11 @@ static struct video_mixer *impl_from_IMFVideoDeviceID(IMFVideoDeviceID *iface)
     return CONTAINING_RECORD(iface, struct video_mixer, IMFVideoDeviceID_iface);
 }
 
+static struct video_mixer *impl_from_IMFTopologyServiceLookupClient(IMFTopologyServiceLookupClient *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_mixer, IMFTopologyServiceLookupClient_iface);
+}
+
 static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
 {
     struct video_mixer *mixer = impl_from_IMFTransform(iface);
@@ -58,6 +64,10 @@ static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface,
     {
         *obj = &mixer->IMFVideoDeviceID_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFTopologyServiceLookupClient))
+    {
+        *obj = &mixer->IMFTopologyServiceLookupClient_iface;
+    }
     else
     {
         WARN("Unsupported interface %s.\n", debugstr_guid(riid));
@@ -328,6 +338,49 @@ static const IMFVideoDeviceIDVtbl video_mixer_device_id_vtbl =
     video_mixer_device_id_GetDeviceID,
 };
 
+static HRESULT WINAPI video_mixer_service_client_QueryInterface(IMFTopologyServiceLookupClient *iface,
+        REFIID riid, void **obj)
+{
+    struct video_mixer *mixer = impl_from_IMFTopologyServiceLookupClient(iface);
+    return IMFTransform_QueryInterface(&mixer->IMFTransform_iface, riid, obj);
+}
+
+static ULONG WINAPI video_mixer_service_client_AddRef(IMFTopologyServiceLookupClient *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFTopologyServiceLookupClient(iface);
+    return IMFTransform_AddRef(&mixer->IMFTransform_iface);
+}
+
+static ULONG WINAPI video_mixer_service_client_Release(IMFTopologyServiceLookupClient *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFTopologyServiceLookupClient(iface);
+    return IMFTransform_Release(&mixer->IMFTransform_iface);
+}
+
+static HRESULT WINAPI video_mixer_service_client_InitServicePointers(IMFTopologyServiceLookupClient *iface,
+        IMFTopologyServiceLookup *service_lookup)
+{
+    FIXME("%p, %p.\n", iface, service_lookup);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_service_client_ReleaseServicePointers(IMFTopologyServiceLookupClient *iface)
+{
+    FIXME("%p.\n", iface);
+
+    return E_NOTIMPL;
+}
+
+static const IMFTopologyServiceLookupClientVtbl video_mixer_service_client_vtbl =
+{
+    video_mixer_service_client_QueryInterface,
+    video_mixer_service_client_AddRef,
+    video_mixer_service_client_Release,
+    video_mixer_service_client_InitServicePointers,
+    video_mixer_service_client_ReleaseServicePointers,
+};
+
 HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -352,6 +405,7 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
 
     object->IMFTransform_iface.lpVtbl = &video_mixer_transform_vtbl;
     object->IMFVideoDeviceID_iface.lpVtbl = &video_mixer_device_id_vtbl;
+    object->IMFTopologyServiceLookupClient_iface.lpVtbl = &video_mixer_service_client_vtbl;
     object->refcount = 1;
 
     *out = &object->IMFTransform_iface;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 7fa6136b0e9..56fb1680b07 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -350,10 +350,8 @@ static void test_default_mixer(void)
     ok(hr == S_OK, "Failed to create default mixer, hr %#x.\n", hr);
 
     hr = IMFTransform_QueryInterface(transform, &IID_IMFTopologyServiceLookupClient, (void **)&unk);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    if (SUCCEEDED(hr))
-        IUnknown_Release(unk);
+    IUnknown_Release(unk);
 
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoDeviceID, (void **)&deviceid);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
From d6e5b6ca0241bf0f70691e0c5cb0d6fe24b61ad4 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 18 Jun 2020 14:43:44 +0300
Subject: [PATCH] evr: Implement stream managment methods for default mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 178 +++++++++++++++++++++++++++++++++++++++----
 dlls/evr/tests/evr.c | 114 +++++++++++++++++++++++++++
 2 files changed, 276 insertions(+), 16 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 3101d17ffdb..f9f1f4b0c34 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -21,17 +21,30 @@
 #include "wine/debug.h"
 #include "evr.h"
 #include "d3d9.h"
+#include "mferror.h"
 
 #include "evr_classes.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(evr);
 
+#define MAX_MIXER_INPUT_STREAMS 16
+
+struct input_stream
+{
+    unsigned int id;
+};
+
 struct video_mixer
 {
     IMFTransform IMFTransform_iface;
     IMFVideoDeviceID IMFVideoDeviceID_iface;
     IMFTopologyServiceLookupClient IMFTopologyServiceLookupClient_iface;
     LONG refcount;
+
+    struct input_stream inputs[MAX_MIXER_INPUT_STREAMS];
+    unsigned int input_ids[MAX_MIXER_INPUT_STREAMS];
+    unsigned int input_count;
+    CRITICAL_SECTION cs;
 };
 
 static struct video_mixer *impl_from_IMFTransform(IMFTransform *iface)
@@ -49,6 +62,21 @@ static struct video_mixer *impl_from_IMFTopologyServiceLookupClient(IMFTopologyS
     return CONTAINING_RECORD(iface, struct video_mixer, IMFTopologyServiceLookupClient_iface);
 }
 
+static int video_mixer_compare_input_id(const void *a, const void *b)
+{
+    const unsigned int *key = a;
+    const struct input_stream *input = b;
+
+    if (*key > input->id) return 1;
+    if (*key < input->id) return -1;
+    return 0;
+}
+
+static struct input_stream * video_mixer_get_input(const struct video_mixer *mixer, unsigned int id)
+{
+    return bsearch(&id, mixer->inputs, mixer->input_count, sizeof(*mixer->inputs), video_mixer_compare_input_id);
+}
+
 static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
 {
     struct video_mixer *mixer = impl_from_IMFTransform(iface);
@@ -97,7 +125,10 @@ static ULONG WINAPI video_mixer_transform_Release(IMFTransform *iface)
     TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
+    {
+        DeleteCriticalSection(&mixer->cs);
         free(mixer);
+    }
 
     return refcount;
 }
@@ -105,38 +136,81 @@ static ULONG WINAPI video_mixer_transform_Release(IMFTransform *iface)
 static HRESULT WINAPI video_mixer_transform_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum,
         DWORD *input_maximum, DWORD *output_minimum, DWORD *output_maximum)
 {
-    FIXME("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
+    TRACE("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
 
-    return E_NOTIMPL;
+    *input_minimum = 1;
+    *input_maximum = 16;
+    *output_minimum = 1;
+    *output_maximum = 1;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_mixer_transform_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
 {
-    FIXME("%p, %p, %p.\n", iface, inputs, outputs);
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %p.\n", iface, inputs, outputs);
+
+    EnterCriticalSection(&mixer->cs);
+    if (inputs) *inputs = mixer->input_count;
+    if (outputs) *outputs = 1;
+    LeaveCriticalSection(&mixer->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_mixer_transform_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
         DWORD output_size, DWORD *outputs)
 {
-    FIXME("%p, %u, %p, %u, %p.\n", iface, input_size, inputs, output_size, outputs);
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %u, %p.\n", iface, input_size, inputs, output_size, outputs);
+
+    EnterCriticalSection(&mixer->cs);
+    if (mixer->input_count > input_size || !output_size)
+        hr = MF_E_BUFFERTOOSMALL;
+    else if (inputs)
+        memcpy(inputs, mixer->input_ids, mixer->input_count * sizeof(*inputs));
+    if (outputs) *outputs = 0;
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_mixer_transform_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
 {
-    FIXME("%p, %u, %p.\n", iface, id, info);
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    struct input_stream *input;
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p.\n", iface, id, info);
+
+    EnterCriticalSection(&mixer->cs);
+    if (!(input = video_mixer_get_input(mixer, id)))
+        hr = MF_E_INVALIDSTREAMNUMBER;
+    else
+    {
+        memset(info, 0, sizeof(*info));
+        if (id)
+            info->dwFlags |= MFT_INPUT_STREAM_REMOVABLE | MFT_INPUT_STREAM_OPTIONAL;
+    }
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_mixer_transform_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
 {
-    FIXME("%p, %u, %p.\n", iface, id, info);
+    TRACE("%p, %u, %p.\n", iface, id, info);
 
-    return E_NOTIMPL;
+    if (id)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    memset(info, 0, sizeof(*info));
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_mixer_transform_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
@@ -157,23 +231,93 @@ static HRESULT WINAPI video_mixer_transform_GetInputStreamAttributes(IMFTransfor
 static HRESULT WINAPI video_mixer_transform_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
         IMFAttributes **attributes)
 {
-    FIXME("%p, %u, %p.\n", iface, id, attributes);
+    TRACE("%p, %u, %p.\n", iface, id, attributes);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI video_mixer_transform_DeleteInputStream(IMFTransform *iface, DWORD id)
 {
-    FIXME("%p, %u.\n", iface, id);
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    struct input_stream *input;
+    HRESULT hr = S_OK;
+    unsigned int idx;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u.\n", iface, id);
+
+    EnterCriticalSection(&mixer->cs);
+
+    /* Can't delete reference stream. */
+    if (!id || !(input = video_mixer_get_input(mixer, id)))
+        hr = MF_E_INVALIDSTREAMNUMBER;
+    else
+    {
+        mixer->input_count--;
+        idx = input - mixer->inputs;
+        if (idx < mixer->input_count)
+        {
+            memmove(&mixer->inputs[idx], &mixer->inputs[idx + 1], (mixer->input_count - idx) * sizeof(*mixer->inputs));
+            memmove(&mixer->input_ids[idx], &mixer->input_ids[idx + 1], (mixer->input_count - idx) *
+                    sizeof(*mixer->input_ids));
+        }
+    }
+
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
-static HRESULT WINAPI video_mixer_transform_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+static int video_mixer_add_input_sort_compare(const void *a, const void *b)
 {
-    FIXME("%p, %u, %p.\n", iface, streams, ids);
+    const struct input_stream *left = a, *right = b;
+    return left->id != right->id ? (left->id < right->id ? -1 : 1) : 0;
+};
 
-    return E_NOTIMPL;
+static HRESULT WINAPI video_mixer_transform_AddInputStreams(IMFTransform *iface, DWORD count, DWORD *ids)
+{
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    struct input_stream inputs[MAX_MIXER_INPUT_STREAMS] = { {0} };
+    unsigned int i, len;
+    HRESULT hr = S_OK;
+
+    TRACE("%p, %u, %p.\n", iface, count, ids);
+
+    if (!ids)
+        return E_POINTER;
+
+    EnterCriticalSection(&mixer->cs);
+    if (count > ARRAY_SIZE(mixer->inputs) - mixer->input_count)
+        hr = E_INVALIDARG;
+    else
+    {
+        /* Test for collisions. */
+        memcpy(inputs, mixer->inputs, mixer->input_count * sizeof(*inputs));
+        for (i = 0; i < count; ++i)
+            inputs[i + mixer->input_count].id = ids[i];
+
+        len = mixer->input_count + count;
+
+        qsort(inputs, len, sizeof(*inputs), video_mixer_add_input_sort_compare);
+
+        for (i = 1; i < len; ++i)
+        {
+            if (inputs[i - 1].id == inputs[i].id)
+            {
+                hr = E_INVALIDARG;
+                break;
+            }
+        }
+
+        if (SUCCEEDED(hr))
+        {
+            memcpy(&mixer->input_ids[mixer->input_count], ids, count * sizeof(*ids));
+            memcpy(mixer->inputs, inputs, len * sizeof(*inputs));
+            mixer->input_count += count;
+        }
+    }
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_mixer_transform_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
@@ -407,6 +551,8 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
     object->IMFVideoDeviceID_iface.lpVtbl = &video_mixer_device_id_vtbl;
     object->IMFTopologyServiceLookupClient_iface.lpVtbl = &video_mixer_service_client_vtbl;
     object->refcount = 1;
+    object->input_count = 1;
+    InitializeCriticalSection(&object->cs);
 
     *out = &object->IMFTransform_iface;
 
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 56fb1680b07..db20fa76643 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -25,6 +25,7 @@
 #include "evr.h"
 #include "initguid.h"
 #include "dxva2api.h"
+#include "mferror.h"
 
 static const WCHAR sink_id[] = {'E','V','R',' ','I','n','p','u','t','0',0};
 
@@ -340,8 +341,16 @@ static void test_pin_info(void)
 
 static void test_default_mixer(void)
 {
+    DWORD input_min, input_max, output_min, output_max;
+    MFT_OUTPUT_STREAM_INFO output_info;
+    MFT_INPUT_STREAM_INFO input_info;
+    DWORD input_count, output_count;
     IMFVideoDeviceID *deviceid;
+    DWORD input_id, output_id;
+    IMFAttributes *attributes, *attributes2;
     IMFTransform *transform;
+    unsigned int i;
+    DWORD ids[16];
     IUnknown *unk;
     HRESULT hr;
     IID iid;
@@ -365,6 +374,111 @@ static void test_default_mixer(void)
 
     IMFVideoDeviceID_Release(deviceid);
 
+    /* Stream configuration. */
+    input_count = output_count = 0;
+    hr = IMFTransform_GetStreamCount(transform, &input_count, &output_count);
+    ok(hr == S_OK, "Failed to get stream count, hr %#x.\n", hr);
+    ok(input_count == 1 && output_count == 1, "Unexpected stream count %u/%u.\n", input_count, output_count);
+
+    hr = IMFTransform_GetStreamLimits(transform, &input_min, &input_max, &output_min, &output_max);
+    ok(hr == S_OK, "Failed to get stream limits, hr %#x.\n", hr);
+    ok(input_min == 1 && input_max == 16 && output_min == 1 && output_max == 1, "Unexpected stream limits %u/%u, %u/%u.\n",
+            input_min, input_max, output_min, output_max);
+
+    hr = IMFTransform_GetInputStreamInfo(transform, 1, &input_info);
+    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_GetOutputStreamInfo(transform, 1, &output_info);
+    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#x.\n", hr);
+
+    memset(&input_info, 0xcc, sizeof(input_info));
+    hr = IMFTransform_GetInputStreamInfo(transform, 0, &input_info);
+    ok(hr == S_OK, "Failed to get input info, hr %#x.\n", hr);
+
+    memset(&output_info, 0xcc, sizeof(output_info));
+    hr = IMFTransform_GetOutputStreamInfo(transform, 0, &output_info);
+    ok(hr == S_OK, "Failed to get input info, hr %#x.\n", hr);
+    ok(!(output_info.dwFlags & (MFT_OUTPUT_STREAM_PROVIDES_SAMPLES | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES)),
+            "Unexpected output flags %#x.\n", output_info.dwFlags);
+
+    hr = IMFTransform_GetStreamIDs(transform, 1, &input_id, 1, &output_id);
+    ok(hr == S_OK, "Failed to get input info, hr %#x.\n", hr);
+    ok(input_id == 0 && output_id == 0, "Unexpected stream ids.\n");
+
+    hr = IMFTransform_GetInputStreamAttributes(transform, 1, &attributes);
+todo_wine
+    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_GetOutputStreamAttributes(transform, 1, &attributes);
+    ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_GetOutputStreamAttributes(transform, 0, &attributes);
+    ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_AddInputStreams(transform, 16, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_AddInputStreams(transform, 16, ids);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    memset(ids, 0, sizeof(ids));
+    hr = IMFTransform_AddInputStreams(transform, 15, ids);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    for (i = 0; i < ARRAY_SIZE(ids); ++i)
+        ids[i] = i + 1;
+
+    hr = IMFTransform_AddInputStreams(transform, 15, ids);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    input_count = output_count = 0;
+    hr = IMFTransform_GetStreamCount(transform, &input_count, &output_count);
+    ok(hr == S_OK, "Failed to get stream count, hr %#x.\n", hr);
+    ok(input_count == 16 && output_count == 1, "Unexpected stream count %u/%u.\n", input_count, output_count);
+
+    memset(&input_info, 0, sizeof(input_info));
+    hr = IMFTransform_GetInputStreamInfo(transform, 1, &input_info);
+    ok(hr == S_OK, "Failed to get input info, hr %#x.\n", hr);
+    ok((input_info.dwFlags & (MFT_INPUT_STREAM_REMOVABLE | MFT_INPUT_STREAM_OPTIONAL)) ==
+            (MFT_INPUT_STREAM_REMOVABLE | MFT_INPUT_STREAM_OPTIONAL), "Unexpected flags %#x.\n", input_info.dwFlags);
+
+    attributes = NULL;
+    hr = IMFTransform_GetInputStreamAttributes(transform, 0, &attributes);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!!attributes, "Unexpected attributes.\n");
+}
+    attributes2 = NULL;
+    hr = IMFTransform_GetInputStreamAttributes(transform, 0, &attributes2);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(attributes == attributes2, "Unexpected instance.\n");
+
+    if (attributes2)
+        IMFAttributes_Release(attributes2);
+    if (attributes)
+        IMFAttributes_Release(attributes);
+
+    attributes = NULL;
+    hr = IMFTransform_GetInputStreamAttributes(transform, 1, &attributes);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!!attributes, "Unexpected attributes.\n");
+}
+    if (attributes)
+        IMFAttributes_Release(attributes);
+
+    hr = IMFTransform_DeleteInputStream(transform, 0);
+    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_DeleteInputStream(transform, 1);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    input_count = output_count = 0;
+    hr = IMFTransform_GetStreamCount(transform, &input_count, &output_count);
+    ok(hr == S_OK, "Failed to get stream count, hr %#x.\n", hr);
+    ok(input_count == 15 && output_count == 1, "Unexpected stream count %u/%u.\n", input_count, output_count);
+
     IMFTransform_Release(transform);
 
     hr = MFCreateVideoMixer(NULL, &IID_IMFTransform, &IID_IMFTransform, (void **)&transform);
From 68374e43158590164e7038a951d8a8d3d12d136b Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 18 Jun 2020 14:43:45 +0300
Subject: [PATCH] evr: Create attributes for input mixer streams.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/Makefile.in |  1 +
 dlls/evr/mixer.c     | 44 ++++++++++++++++++++++++++++++++++++++++++--
 dlls/evr/tests/evr.c | 16 ++++------------
 3 files changed, 47 insertions(+), 14 deletions(-)

diff --git a/dlls/evr/Makefile.in b/dlls/evr/Makefile.in
index bf3048f62ee..5671511f6ae 100644
--- a/dlls/evr/Makefile.in
+++ b/dlls/evr/Makefile.in
@@ -1,6 +1,7 @@
 MODULE    = evr.dll
 IMPORTLIB = evr
 IMPORTS   = mfuuid strmiids strmbase uuid dxguid ole32 oleaut32
+DELAYIMPORTS = mfplat
 
 EXTRADLLFLAGS = -mno-cygwin
 
diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index f9f1f4b0c34..d1529c015d7 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -21,6 +21,7 @@
 #include "wine/debug.h"
 #include "evr.h"
 #include "d3d9.h"
+#include "mfapi.h"
 #include "mferror.h"
 
 #include "evr_classes.h"
@@ -32,6 +33,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(evr);
 struct input_stream
 {
     unsigned int id;
+    IMFAttributes *attributes;
 };
 
 struct video_mixer
@@ -77,6 +79,12 @@ static struct input_stream * video_mixer_get_input(const struct video_mixer *mix
     return bsearch(&id, mixer->inputs, mixer->input_count, sizeof(*mixer->inputs), video_mixer_compare_input_id);
 }
 
+static void video_mixer_init_input(struct input_stream *stream)
+{
+    if (SUCCEEDED(MFCreateAttributes(&stream->attributes, 1)))
+        IMFAttributes_SetUINT32(stream->attributes, &MF_SA_REQUIRED_SAMPLE_COUNT, 1);
+}
+
 static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
 {
     struct video_mixer *mixer = impl_from_IMFTransform(iface);
@@ -121,11 +129,17 @@ static ULONG WINAPI video_mixer_transform_Release(IMFTransform *iface)
 {
     struct video_mixer *mixer = impl_from_IMFTransform(iface);
     ULONG refcount = InterlockedDecrement(&mixer->refcount);
+    unsigned int i;
 
     TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
+        for (i = 0; i < mixer->input_count; ++i)
+        {
+            if (mixer->inputs[i].attributes)
+                IMFAttributes_Release(mixer->inputs[i].attributes);
+        }
         DeleteCriticalSection(&mixer->cs);
         free(mixer);
     }
@@ -223,9 +237,26 @@ static HRESULT WINAPI video_mixer_transform_GetAttributes(IMFTransform *iface, I
 static HRESULT WINAPI video_mixer_transform_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
         IMFAttributes **attributes)
 {
-    FIXME("%p, %u, %p.\n", iface, id, attributes);
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    struct input_stream *input;
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p.\n", iface, id, attributes);
+
+    EnterCriticalSection(&mixer->cs);
+
+    if (!(input = video_mixer_get_input(mixer, id)))
+        hr = MF_E_INVALIDSTREAMNUMBER;
+    else
+    {
+        *attributes = input->attributes;
+        if (*attributes)
+            IMFAttributes_AddRef(*attributes);
+    }
+
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_mixer_transform_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
@@ -256,6 +287,8 @@ static HRESULT WINAPI video_mixer_transform_DeleteInputStream(IMFTransform *ifac
         idx = input - mixer->inputs;
         if (idx < mixer->input_count)
         {
+            if (mixer->inputs[idx].attributes)
+                IMFAttributes_Release(mixer->inputs[idx].attributes);
             memmove(&mixer->inputs[idx], &mixer->inputs[idx + 1], (mixer->input_count - idx) * sizeof(*mixer->inputs));
             memmove(&mixer->input_ids[idx], &mixer->input_ids[idx + 1], (mixer->input_count - idx) *
                     sizeof(*mixer->input_ids));
@@ -277,6 +310,7 @@ static HRESULT WINAPI video_mixer_transform_AddInputStreams(IMFTransform *iface,
 {
     struct video_mixer *mixer = impl_from_IMFTransform(iface);
     struct input_stream inputs[MAX_MIXER_INPUT_STREAMS] = { {0} };
+    struct input_stream *input;
     unsigned int i, len;
     HRESULT hr = S_OK;
 
@@ -310,6 +344,11 @@ static HRESULT WINAPI video_mixer_transform_AddInputStreams(IMFTransform *iface,
 
         if (SUCCEEDED(hr))
         {
+            for (i = 0; i < count; ++i)
+            {
+                if ((input = bsearch(&ids[i], inputs, len, sizeof(*inputs), video_mixer_compare_input_id)))
+                    video_mixer_init_input(input);
+            }
             memcpy(&mixer->input_ids[mixer->input_count], ids, count * sizeof(*ids));
             memcpy(mixer->inputs, inputs, len * sizeof(*inputs));
             mixer->input_count += count;
@@ -552,6 +591,7 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
     object->IMFTopologyServiceLookupClient_iface.lpVtbl = &video_mixer_service_client_vtbl;
     object->refcount = 1;
     object->input_count = 1;
+    video_mixer_init_input(&object->inputs[0]);
     InitializeCriticalSection(&object->cs);
 
     *out = &object->IMFTransform_iface;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index db20fa76643..be004d9eae4 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -406,7 +406,6 @@ static void test_default_mixer(void)
     ok(input_id == 0 && output_id == 0, "Unexpected stream ids.\n");
 
     hr = IMFTransform_GetInputStreamAttributes(transform, 1, &attributes);
-todo_wine
     ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#x.\n", hr);
 
     hr = IMFTransform_GetOutputStreamAttributes(transform, 1, &attributes);
@@ -444,29 +443,22 @@ todo_wine
 
     attributes = NULL;
     hr = IMFTransform_GetInputStreamAttributes(transform, 0, &attributes);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!!attributes, "Unexpected attributes.\n");
-}
+
     attributes2 = NULL;
     hr = IMFTransform_GetInputStreamAttributes(transform, 0, &attributes2);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(attributes == attributes2, "Unexpected instance.\n");
 
-    if (attributes2)
-        IMFAttributes_Release(attributes2);
-    if (attributes)
-        IMFAttributes_Release(attributes);
+    IMFAttributes_Release(attributes2);
+    IMFAttributes_Release(attributes);
 
     attributes = NULL;
     hr = IMFTransform_GetInputStreamAttributes(transform, 1, &attributes);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!!attributes, "Unexpected attributes.\n");
-}
-    if (attributes)
-        IMFAttributes_Release(attributes);
+    IMFAttributes_Release(attributes);
 
     hr = IMFTransform_DeleteInputStream(transform, 0);
     ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#x.\n", hr);
From 6548fc437192fd852c1a91130382c56e92e68ac2 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 18 Jun 2020 14:43:46 +0300
Subject: [PATCH] evr: Add IMFVideoMixerControl2 stub for the mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 87 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c |  4 ++
 include/evr.idl      | 38 +++++++++++++++++++
 3 files changed, 129 insertions(+)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index d1529c015d7..b651a56bff5 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -41,6 +41,7 @@ struct video_mixer
     IMFTransform IMFTransform_iface;
     IMFVideoDeviceID IMFVideoDeviceID_iface;
     IMFTopologyServiceLookupClient IMFTopologyServiceLookupClient_iface;
+    IMFVideoMixerControl2 IMFVideoMixerControl2_iface;
     LONG refcount;
 
     struct input_stream inputs[MAX_MIXER_INPUT_STREAMS];
@@ -64,6 +65,11 @@ static struct video_mixer *impl_from_IMFTopologyServiceLookupClient(IMFTopologyS
     return CONTAINING_RECORD(iface, struct video_mixer, IMFTopologyServiceLookupClient_iface);
 }
 
+static struct video_mixer *impl_from_IMFVideoMixerControl2(IMFVideoMixerControl2 *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_mixer, IMFVideoMixerControl2_iface);
+}
+
 static int video_mixer_compare_input_id(const void *a, const void *b)
 {
     const unsigned int *key = a;
@@ -104,6 +110,11 @@ static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface,
     {
         *obj = &mixer->IMFTopologyServiceLookupClient_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFVideoMixerControl2) ||
+            IsEqualIID(riid, &IID_IMFVideoMixerControl))
+    {
+        *obj = &mixer->IMFVideoMixerControl2_iface;
+    }
     else
     {
         WARN("Unsupported interface %s.\n", debugstr_guid(riid));
@@ -564,6 +575,81 @@ static const IMFTopologyServiceLookupClientVtbl video_mixer_service_client_vtbl
     video_mixer_service_client_ReleaseServicePointers,
 };
 
+static HRESULT WINAPI video_mixer_control_QueryInterface(IMFVideoMixerControl2 *iface, REFIID riid, void **obj)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoMixerControl2(iface);
+    return IMFTransform_QueryInterface(&mixer->IMFTransform_iface, riid, obj);
+}
+
+static ULONG WINAPI video_mixer_control_AddRef(IMFVideoMixerControl2 *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoMixerControl2(iface);
+    return IMFTransform_AddRef(&mixer->IMFTransform_iface);
+}
+
+static ULONG WINAPI video_mixer_control_Release(IMFVideoMixerControl2 *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoMixerControl2(iface);
+    return IMFTransform_Release(&mixer->IMFTransform_iface);
+}
+
+static HRESULT WINAPI video_mixer_control_SetStreamZOrder(IMFVideoMixerControl2 *iface, DWORD stream_id, DWORD zorder)
+{
+    FIXME("%p, %u, %u.\n", iface, stream_id, zorder);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_control_GetStreamZOrder(IMFVideoMixerControl2 *iface, DWORD stream_id, DWORD *zorder)
+{
+    FIXME("%p, %u, %p.\n", iface, stream_id, zorder);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_control_SetStreamOutputRect(IMFVideoMixerControl2 *iface, DWORD stream_id,
+        const MFVideoNormalizedRect *rect)
+{
+    FIXME("%p, %u, %p.\n", iface, stream_id, rect);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_control_GetStreamOutputRect(IMFVideoMixerControl2 *iface, DWORD stream_id,
+        MFVideoNormalizedRect *rect)
+{
+    FIXME("%p, %u, %p.\n", iface, stream_id, rect);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_control_SetMixingPrefs(IMFVideoMixerControl2 *iface, DWORD flags)
+{
+    FIXME("%p, %#x.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_control_GetMixingPrefs(IMFVideoMixerControl2 *iface, DWORD *flags)
+{
+    FIXME("%p, %p.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static const IMFVideoMixerControl2Vtbl video_mixer_control_vtbl =
+{
+    video_mixer_control_QueryInterface,
+    video_mixer_control_AddRef,
+    video_mixer_control_Release,
+    video_mixer_control_SetStreamZOrder,
+    video_mixer_control_GetStreamZOrder,
+    video_mixer_control_SetStreamOutputRect,
+    video_mixer_control_GetStreamOutputRect,
+    video_mixer_control_SetMixingPrefs,
+    video_mixer_control_GetMixingPrefs,
+};
+
 HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -589,6 +675,7 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
     object->IMFTransform_iface.lpVtbl = &video_mixer_transform_vtbl;
     object->IMFVideoDeviceID_iface.lpVtbl = &video_mixer_device_id_vtbl;
     object->IMFTopologyServiceLookupClient_iface.lpVtbl = &video_mixer_service_client_vtbl;
+    object->IMFVideoMixerControl2_iface.lpVtbl = &video_mixer_control_vtbl;
     object->refcount = 1;
     object->input_count = 1;
     video_mixer_init_input(&object->inputs[0]);
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index be004d9eae4..9cf5d419198 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -362,6 +362,10 @@ static void test_default_mixer(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
+    hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoMixerControl, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoDeviceID, (void **)&deviceid);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
diff --git a/include/evr.idl b/include/evr.idl
index 39b4853b2e3..83603b92ccd 100644
--- a/include/evr.idl
+++ b/include/evr.idl
@@ -160,4 +160,42 @@ interface IMFVideoDeviceID : IUnknown
     );
 }
 
+[
+    object,
+    uuid(a5c6c53f-c202-4aa5-9695-175ba8c508a5)
+]
+interface IMFVideoMixerControl : IUnknown
+{
+    HRESULT SetStreamZOrder(
+        [in] DWORD stream_id,
+        [in] DWORD zorder
+    );
+    HRESULT GetStreamZOrder(
+        [in] DWORD stream_id,
+        [out] DWORD *zorder
+    );
+    HRESULT SetStreamOutputRect(
+        [in] DWORD stream_id,
+        [in] const MFVideoNormalizedRect *rect
+    );
+    HRESULT GetStreamOutputRect(
+        [in] DWORD stream_id,
+        [out] MFVideoNormalizedRect *rect
+    );
+}
+
+[
+    object,
+    uuid(8459616d-966e-4930-b658-54fa7e5a16d3)
+]
+interface IMFVideoMixerControl2 : IMFVideoMixerControl
+{
+    HRESULT SetMixingPrefs(
+        [in] DWORD flags
+    );
+    HRESULT GetMixingPrefs(
+        [out] DWORD *flags
+    );
+}
+
 cpp_quote("HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj);")
From 613446d018b792b10d067314831901437b4ff6e5 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 10 Jun 2020 15:52:57 -0500
Subject: [PATCH] winegstreamer: Try to convert the duration from bytes if the
 pad doesn't support querying time directly.

This can help mpegaudioparse report a usable duration, and presumably also
other elements built from baseparse.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 40 +++++++++++++++++++++--------------
 1 file changed, 24 insertions(+), 16 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index a0fdba9ff2c..e7d8a0b98c6 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1324,6 +1324,26 @@ static HRESULT GST_Connect(struct gstdemux *This, IPin *pConnectPin)
     return S_OK;
 }
 
+static LONGLONG query_duration(GstPad *pad)
+{
+    gint64 duration, byte_length;
+
+    if (gst_pad_query_duration(pad, GST_FORMAT_TIME, &duration))
+        return duration / 100;
+
+    WARN("Failed to query time duration; trying to convert from byte length.\n");
+
+    /* To accurately get a duration for the stream, we want to only consider the
+     * length of that stream. Hence, query for the pad duration, instead of
+     * using the file duration. */
+    if (gst_pad_query_duration(pad, GST_FORMAT_BYTES, &byte_length)
+            && gst_pad_query_convert(pad, GST_FORMAT_BYTES, byte_length, GST_FORMAT_TIME, &duration))
+        return duration / 100;
+
+    ERR("Failed to query duration.\n");
+    return 0;
+}
+
 static inline struct gstdemux_source *impl_from_IMediaSeeking(IMediaSeeking *iface)
 {
     return CONTAINING_RECORD(iface, struct gstdemux_source, seek.IMediaSeeking_iface);
@@ -1583,7 +1603,6 @@ static const struct strmbase_sink_ops sink_ops =
 static BOOL gstdecoder_init_gst(struct gstdemux *filter)
 {
     GstElement *element = gst_element_factory_make("decodebin", NULL);
-    LONGLONG duration;
     unsigned int i;
     int ret;
 
@@ -1626,9 +1645,7 @@ static BOOL gstdecoder_init_gst(struct gstdemux *filter)
         struct gstdemux_source *pin = filter->sources[i];
         const HANDLE events[2] = {pin->caps_event, filter->error_event};
 
-        if (!gst_pad_query_duration(filter->sources[i]->their_src, GST_FORMAT_TIME, &duration))
-            ERR("Failed to query duration.\n");
-        pin->seek.llDuration = pin->seek.llStop = duration / 100;
+        pin->seek.llDuration = pin->seek.llStop = query_duration(pin->their_src);
         pin->seek.llCurrent = 0;
         if (WaitForMultipleObjects(2, events, FALSE, INFINITE))
             return FALSE;
@@ -2314,7 +2331,6 @@ static BOOL wave_parser_init_gst(struct gstdemux *filter)
     static const WCHAR source_name[] = {'o','u','t','p','u','t',0};
     struct gstdemux_source *pin;
     GstElement *element;
-    LONGLONG duration;
     HANDLE events[2];
     int ret;
 
@@ -2353,9 +2369,7 @@ static BOOL wave_parser_init_gst(struct gstdemux *filter)
         return FALSE;
     }
 
-    if (!gst_pad_query_duration(pin->their_src, GST_FORMAT_TIME, &duration))
-        ERR("Failed to query duration.\n");
-    pin->seek.llDuration = pin->seek.llStop = duration / 100;
+    pin->seek.llDuration = pin->seek.llStop = query_duration(pin->their_src);
     pin->seek.llCurrent = 0;
 
     events[0] = pin->caps_event;
@@ -2428,7 +2442,6 @@ static const struct strmbase_sink_ops avi_splitter_sink_ops =
 static BOOL avi_splitter_init_gst(struct gstdemux *filter)
 {
     GstElement *element = gst_element_factory_make("avidemux", NULL);
-    LONGLONG duration;
     unsigned int i;
     int ret;
 
@@ -2469,9 +2482,7 @@ static BOOL avi_splitter_init_gst(struct gstdemux *filter)
         struct gstdemux_source *pin = filter->sources[i];
         const HANDLE events[2] = {pin->caps_event, filter->error_event};
 
-        if (!gst_pad_query_duration(filter->sources[i]->their_src, GST_FORMAT_TIME, &duration))
-            ERR("Failed to query duration.\n");
-        pin->seek.llDuration = pin->seek.llStop = duration / 100;
+        pin->seek.llDuration = pin->seek.llStop = query_duration(pin->their_src);
         pin->seek.llCurrent = 0;
         if (WaitForMultipleObjects(2, events, FALSE, INFINITE))
             return FALSE;
@@ -2550,7 +2561,6 @@ static BOOL mpeg_splitter_init_gst(struct gstdemux *filter)
     static const WCHAR source_name[] = {'A','u','d','i','o',0};
     struct gstdemux_source *pin;
     GstElement *element;
-    LONGLONG duration;
     HANDLE events[2];
     int ret;
 
@@ -2593,9 +2603,7 @@ static BOOL mpeg_splitter_init_gst(struct gstdemux *filter)
     if (WaitForMultipleObjects(2, events, FALSE, INFINITE))
         return FALSE;
 
-    if (!gst_pad_query_duration(pin->their_src, GST_FORMAT_TIME, &duration))
-        ERR("Failed to query duration.\n");
-    pin->seek.llDuration = pin->seek.llStop = duration / 100;
+    pin->seek.llDuration = pin->seek.llStop = query_duration(pin->their_src);
     pin->seek.llCurrent = 0;
 
     events[0] = pin->caps_event;
From bd28efb4c702f3119043d8d365fdc7ba98cd8b7d Mon Sep 17 00:00:00 2001
From: Akihiro Sagawa <sagawa.aki@gmail.com>
Date: Sat, 13 Jun 2020 10:34:22 -0500
Subject: [PATCH] winegstreamer: Also wait for EOS events when retrieving
 duration.

The mpegaudioparse element will not send a duration-changed message if no
Xing or VBRI headers are present.

Signed-off-by: Akihiro Sagawa <sagawa.aki@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/quartz/tests/mpegsplit.c |   8 ++++----
 dlls/quartz/tests/rsrc.rc     |   2 +-
 dlls/quartz/tests/test.mp3    | Bin 2349 -> 2157 bytes
 dlls/winegstreamer/gstdemux.c |  13 ++++++++++---
 4 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/dlls/quartz/tests/mpegsplit.c b/dlls/quartz/tests/mpegsplit.c
index 9bfd7e3bb19..e407fe44eeb 100644
--- a/dlls/quartz/tests/mpegsplit.c
+++ b/dlls/quartz/tests/mpegsplit.c
@@ -523,13 +523,13 @@ static void test_media_types(void)
 {
     MPEG1WAVEFORMAT expect_wfx =
     {
-        {WAVE_FORMAT_MPEG, 1, 48000, 8000, 192, 0, sizeof(MPEG1WAVEFORMAT) - sizeof(WAVEFORMATEX)},
-        ACM_MPEG_LAYER3, 64000, ACM_MPEG_SINGLECHANNEL, 0, 1, ACM_MPEG_PROTECTIONBIT | ACM_MPEG_ID_MPEG1, 0, 0
+        {WAVE_FORMAT_MPEG, 1, 48000, 4000, 96, 0, sizeof(MPEG1WAVEFORMAT) - sizeof(WAVEFORMATEX)},
+        ACM_MPEG_LAYER3, 32000, ACM_MPEG_SINGLECHANNEL, 4096, 1, ACM_MPEG_ORIGINALHOME | ACM_MPEG_PROTECTIONBIT | ACM_MPEG_ID_MPEG1, 0, 0
     };
     static const MPEGLAYER3WAVEFORMAT expect_mp3_wfx =
     {
-        {WAVE_FORMAT_MPEGLAYER3, 1, 48000, 8000, 1, 0, sizeof(MPEGLAYER3WAVEFORMAT) - sizeof(WAVEFORMATEX)},
-        MPEGLAYER3_ID_MPEG, 0, 192, 1, 0
+        {WAVE_FORMAT_MPEGLAYER3, 1, 48000, 4000, 1, 0, sizeof(MPEGLAYER3WAVEFORMAT) - sizeof(WAVEFORMATEX)},
+        MPEGLAYER3_ID_MPEG, 0, 96, 1, 0
     };
 
     const WCHAR *filename = load_resource(L"test.mp3");
diff --git a/dlls/quartz/tests/rsrc.rc b/dlls/quartz/tests/rsrc.rc
index 753415cf8de..d28c2bd6edc 100644
--- a/dlls/quartz/tests/rsrc.rc
+++ b/dlls/quartz/tests/rsrc.rc
@@ -28,7 +28,7 @@ test.avi RCDATA "test.avi"
 /* @makedep: test.mpg */
 test.mpg RCDATA "test.mpg"
 
-/* ffmpeg -f lavfi -i "sine=frequency=500" -t 0.5 -ar 48000 -b:a 32k -f mp3 -acodec mp3 test.mp3 */
+/* ffmpeg -f lavfi -i "sine=frequency=500" -t 0.5 -ar 48000 -b:a 32k -f mp3 -acodec mp3 -write_xing 0 test.mp3 */
 /* @makedep: test.mp3 */
 test.mp3 RCDATA "test.mp3"
 
diff --git a/dlls/quartz/tests/test.mp3 b/dlls/quartz/tests/test.mp3
index 78d8dd2af62027147a3f169a8306b601ab37c3b6..b35e6b77d1315fa5b742085226ecd0cefbdf4896 100644
GIT binary patch
literal 2157
zcmbuAeN+=?7RKLX5(p&H2n1OJb`rG$i5L}K^lZ07AQ&;x5DB4_j|8k%v<H?(#iW5r
z11(jlcm!8bF<AKug&<1HN0orkMRvQoDux0Uad8cTpe~_^eC$l(viraD$IN@qJ?D4c
zd!OgIvo&lz3E<E2sGU0n*!LX(Ad&Lm?hV0#>ox_h<?-xQ$7}wzXFC8S5<?!PM0qE3
zD{gF*06?hTgaG2Mn|(yA#(meh_1_OsnBtk<`rBi-w5$oTnY3<M%;}fyt$B;Ccd_c}
zz4y}%^ZFUG+m!038R51z#L{(sPib{{GQjx|AZ5H8;QJ8x9fo#YWrm4v|AD7-O?Hk7
z;>}S{I>S@~kh+J#G#{|FeLOZbE!gc}7xU-@L&Fv>ME>bT1MSr!uas`vwAOEA!g^(J
zNxAO0##$RBU-o7GGMw*>LNiPnwQm=q*C#0tf6{r0x!3pad-|uXvS$&QGv<pPEPzO=
z0v1a<y*<k+!d*v4#gvanEVj5N+2sxWRozEf!ibKMZ22jtHDV2y#<}x~wAw|(`CR_!
zSDa5nNq|YO>I*|q2R~B#{(#R7Dr{C%G}RtCg_uh>W-Ds0hXncenr5PH(aq<I>L1+C
zHrAT|qzGC<xg?>vKw2*%<7Q{n(G4lnvwti&Fj9^n2q8p)^B1GgRVD)r@KGI<bUDM?
zN#{-p*r-CdL=fUFU&WHG-u^@rIKi3EJmS&gM!N3zPZ5Zc<bC7h@+@-dcS9ch%`dWy
zkMH(em=y{E`PiUW13`Cr-!F<2i9dAWd~X0fWUeyw5*4Ukd5>w8uvEvFfApxu%eJPx
z`KdC;2%G7-|KCU`|GaUox~M8~dhGVqm9;Pd5%8$H+uoanHul}1$%{iG{C8I;#!qWM
zu;6@O6l!34Q2!c^Xrbh_>Y;ow1vV=c|LtPwy~R1{=?v+;u|vO(^ILwimITn92+?f;
zA40@}Zc1x>LC=}&^$9Il3&XYqW5)>?^$=b@$1ct1`HOM>3N-X@Oa|vK;fNZt>#N~X
zICZb-*M_Ud8B;%0YCo_^>S#ol14;&0r;GR$Lu!kBp2_DpRf#)lo>BQS1*!mb!GdjY
zQo(>gM?Ub<Rmv`^*JfVWf%7?N=yRqAKL5`gd{aEfp!XsWZ)HpUoJhLr1r@Yob`{+7
z(X<elv7dbc;jLICImS7OwLH=>SFM^{)vd0FOGu!oW5BLE&R?gq&j<65N}p7U=?lfS
z@oKiWuTdYe*wlZXx2<bJ5OO!}Kl1RP59e;a81m^d&0+%Vs2Md5W4GV9g;KeTCOvDd
zg)yH+gzbzrneJ-8-jaaxH>1#mV?L?+q!NtZq>|CikuZ2;BZmM~+(wyp0q(MhE}%;3
zd4!;YQ?iwD=g-qDX)WC~#qHCkry&9%kvu>#acK!flQB4-4?+!?|1o_tF#l^l$@P|(
zzN92frkWl-c$&ClR`eYopz$$+!wN;hS$?p*94<5@pOMX9k?k9{^*74y2odsGI}p1+
z&$R7QfFZIlW$L<7`~C>d->QRtblm@-V?LG$E4}N(=UB2j{8g$Lx;);UA+F!h_&{^b
zb$;MmaUZ4LOxqt@!bWcG&EJk5NodZQ^K4XA_G${%r{iKv5*h?GAUVlW*UHBEks$Q6
zBfp>PlUUe(Xi2_AZ~p3vwph1^eR$jOv~OjhvBl0z{8%c;w6F}y`<r%Z8*0k9iPDt&
zUj@ok`3P@0?6t*_<pU&T+_^9DD39a(7+t8@!B2P02U8~8Hd3mRQ2_aZ<F1>z?wrZ5
zUCVmA`p2&ITBGlkkKgteeE|^{18gw~4c_if72%AVJw^1N4^d}hZJPtOf8SjdbrI()
z^q4>0sJ+=htygwn^Z!2WXdE#2)Q{E*O+CXTNs#9Ezx3!*rPEml%c5HeEEtIw^8Gy_
zBGQXTZ)sq6Ry3A{xv|C+B$sUZpA=iq;QZYvG=%Z-{RY|nNtWouF}IFRXXcGyQYg%i
zh9s-w*r~VIe`*qXV)0k4Y?|CRmy<RAk1~|N|E|KWd{GIPbLX{3h#}9Ogv##nM!E3>
z&fgC(f4brOGuOf28|HB_SOSib34U#oK$@=y-8`{Y<ZG7Yh7%0#B49mbd2&Yv1$BaV
zxO==2xb!)^qA5qg<nefEth~aYQ>M``NJ-o$&WahFpN2x`m~MD}-}q+<7!%zfJhxiv
zirL2(wY;beaGzNkplT+bW`w>v_>rU_(n-?!GjmPCHT58Z#M0%&3!eS)FO8xQv0y#^
zgETHYI6ni0-st-ol)O?sl)F%U`vcBLb?rPyzP`~vCjJPM-yXX_!1;RMoUxDJcm)Nz
OoI!mtOjxMC{oy|-dh)yg

literal 2349
zcmb7_dsGuw8o+Nd0Yab%kpL211E`?kG4iV5Yk-7;KpQIo1%VJyIHnYi<s}c9@Mu{)
zx=;-$76lYxv4m#?K}(8K5xNDX7+zI$wT73~<>6T{uycv_Y<JJ;IsX2bxpVHFU%vb0
z`|fyi94G){;lFPmm$<J20Pzh^JnZCb>xkNJMYpcZsxQln{__8NR1dvBKO9Spi1&aI
z0NMbs2)00+2r$SV0zO1Qa0HS-fJ5>KB#=@_HGvEwC+LO@5R5@42<9Nm1n`%MAR~w%
zol*Gkjt%by+Mvkye)+qnxA)~m!`lE*bQyvE;W&Cax9XNN4**h)3kJxMcSp#?ob`IG
z?`Otv78R_mOaHgWH|tfTIFjyHg`0NNqY)ml4Y@HKXW2JZyT_JE9^b9o+D@mx%y;@%
zB|oa7#xnx?$zo2t*_L%<fR%=X52Qxtg1#N7m=>Ys?}#qxoYrFLkie&O4oi0}@V@<9
z&;(WXz(9nX3^v~r6ofVJuP751pPfq!RqZ^#I#^Wcj!^*V$YY}x(#aDsM$oS*ruZ`T
zdPX?dF+|8e7Tu-ISVSK%N*iNEz*^DPR}(MWk$BR@k~Tp7d!#Ncs5@IA{poh!m!j(_
zb15lGh9%#W&o{N}VD})#GDU;D<EC9b%{^>L)qH3T^y}bADN~<K__MQw70Jr3`$eaJ
zO=ZVn+`sbdqPga{z{|+rg7$RE&i&NrmEBjPYFcHMXP?Yg3oy4Yc{a%_E0|Tpiq=jW
zox@l7bB`9;;jVM{TlEp>H^3=YOa}XoCzgo_4-omu!-874J}hD3f;E*boiuO{PTl{j
zYrAsN`&x7R!%#Wd0@U#G3Nd+w%pDDk5=MJCjowU=_A9tfX0(C5AoxS6fmf*sT~n3~
z{YE5@Sth-w#}kW(@ke(FuiModTFP>X4elzAU-R0wg+^)EGZ{@vpgzL|Ee)6A*3281
z1xqpldV>?<l}RBEB<yRK;9Pvm<G-ZonvQh#IV5h5ZVafEE<^u1qJEegONY$`;;hJc
zrk8Ig{o3le{&JSM;C_KXCy;u6R(B-kGL79UwEB3yj{J{|dowYwRoh8e!}W^KfsU2u
z9fUGp^+tDoQ+C3SwV_v=REEoZelnHvbujds17wQ1#z(OMOG6@OnV7G|XQVH(kIK=5
zqLcEd!MxSOw-aL8RE|pf8p)^z`M^d-6KGwTKd`q&cTuOWrn`N)rd3+$(PS$*OQRHY
zk8((X)R{5CgNM*>1t^r?<8NYed~L<&>wUPzvh<`SD@ol&X^A$ylVx+zyZ}Qtd~n7f
z=V*w~$|qK|PN7=w{3zpoKowUCB7_ZP=2&kk{W8lUxmJ;5+yCIqR#$!Kw}JVwC>?ee
zBqG9dMEz6`Y}41V9^OAjeoh@66I@WN7hkx|yU^dIYR=e`t~YZv4s-jz(rVtaR69S>
zTB6t28jFx@n!QZ{zrz{&9dP6ZQ%`3&8>D5e<Y$|SW%J+Uy~4trM*hUYZ%dN?$x3cA
zjZ!~4=}X$Tl9?DL-dk6r9W#w5)h_JZytq_?mwHDwGy{z@77^mily3NbwC5c3yW)sa
zU7zV{|7d&l^v?K<flpCjJRD~`nf=KN&2-r`S>yN=SNr%MwvnU%KOLgpM%#<YE7$5y
z90bsh;mAvM{@=#`L+5uVD0!-L^*(NU{lcESUfwhQtt4Lh6<+GI?x!X>W7|j8h{g~1
zi2s(>SMualn?gmKRW19KVg@B~jB113EhejE5^B!zDL*Rod*a9#)0j=vPZF}yzYp7r
z=0eUTw(dGroeMyjmrj)WV3-^dxP=rA=FwH(eiSg$-mgr$exweQ3<-?p;TDnUY6F^T
zFf_;YS=d11^gw^vFY(atha>q!{)zK}h#%I^`4Qgs4$Ifbt`TJ&DXh(~>A=x*fr{hv
z_EwU+3*+}#nETy7lvAR4_O(}u7AdL)hV)|lI8O8NH@{Jb+KIN%p`Q<k{2Q}xZNl&@
zVI)(@>$tg{e%Y)@dMIV?Sdpl_gj!xLi7C#s`vgHAw!SFT%=_n^{bG)B#-*!9ZH*Q7
z39Rn?D}mx%)(1bUwd_OUoRqyn<vyuD^ao`kPu2cZL^zc4G*@qXK<|l(@xEzO{#h!e
z;1`SE+eO_OMVqrEuTp2yz55?kx^sBuRPsQ_W<!LG4Y`>FT80PFM>?PFzf-%QC0c_1
zaKHg?>jx1si1T^5qD!v_9${P{&$q7fWZWGr*6&f++rjOOKR8vL|8eePjEovmE@@*e
zXuPin($|S5kpj$2G;wbfDGv_2=!H0TfmPPfe^^Xe%hUyrgt$0MXhP&C$^>Ioyku=?
z%@HtB6pb@GDRC^Uoyw#Lt)FWN-WY=yzPCs(m5Tc3xtDImzWI!n-L9EeVk^I*!CML`
z{CT6H+ZlTY&mKi>Xbbd<0L4+=zeN5^i2mj28)Y-(m7O0Nr^$TX{J0LbE-toCE1&cC
zy+D7g_?D7s*h8HEr?Q@rZ=f3QEBTZ4(EkOlg^S#;H{w8?^Em4Qi}WY!-*@Ui<!$R8

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index e7d8a0b98c6..b9c91245f82 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -79,7 +79,7 @@ struct gstdemux_source
     GstPad *their_src, *post_sink, *post_src, *my_sink;
     GstElement *flip;
     AM_MEDIA_TYPE mt;
-    HANDLE caps_event;
+    HANDLE caps_event, eos_event;
     GstSegment *segment;
     SourceSeeking seek;
 };
@@ -699,6 +699,8 @@ static gboolean event_sink(GstPad *pad, GstObject *parent, GstEvent *event)
         case GST_EVENT_EOS:
             if (pin->pin.pin.peer)
                 IPin_EndOfStream(pin->pin.pin.peer);
+            else
+                SetEvent(pin->eos_event);
             return TRUE;
         case GST_EVENT_FLUSH_START:
             if (impl_from_strmbase_filter(pin->pin.pin.filter)->ignore_flush) {
@@ -2129,6 +2131,7 @@ static void free_source_pin(struct gstdemux_source *pin)
     }
     gst_object_unref(pin->my_sink);
     CloseHandle(pin->caps_event);
+    CloseHandle(pin->eos_event);
     FreeMediaType(&pin->mt);
     gst_segment_free(pin->segment);
 
@@ -2161,6 +2164,7 @@ static struct gstdemux_source *create_pin(struct gstdemux *filter, const WCHAR *
 
     strmbase_source_init(&pin->pin, &filter->filter, name, &source_ops);
     pin->caps_event = CreateEventW(NULL, FALSE, FALSE, NULL);
+    pin->eos_event = CreateEventW(NULL, FALSE, FALSE, NULL);
     pin->segment = gst_segment_new();
     gst_segment_init(pin->segment, GST_FORMAT_TIME);
     pin->IQualityControl_iface.lpVtbl = &GSTOutPin_QualityControl_Vtbl;
@@ -2561,7 +2565,8 @@ static BOOL mpeg_splitter_init_gst(struct gstdemux *filter)
     static const WCHAR source_name[] = {'A','u','d','i','o',0};
     struct gstdemux_source *pin;
     GstElement *element;
-    HANDLE events[2];
+    HANDLE events[3];
+    DWORD res;
     int ret;
 
     if (!(element = gst_element_factory_make("mpegaudioparse", NULL)))
@@ -2600,7 +2605,9 @@ static BOOL mpeg_splitter_init_gst(struct gstdemux *filter)
 
     events[0] = filter->duration_event;
     events[1] = filter->error_event;
-    if (WaitForMultipleObjects(2, events, FALSE, INFINITE))
+    events[2] = pin->eos_event;
+    res = WaitForMultipleObjects(3, events, FALSE, INFINITE);
+    if (res == 1)
         return FALSE;
 
     pin->seek.llDuration = pin->seek.llStop = query_duration(pin->their_src);
From d085e5ba72883928bc193ee41955064d6069261d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 18 Jun 2020 21:50:41 -0500
Subject: [PATCH] winegstreamer: Clear the "colorimetry" and "chroma-site"
 fields in amt_to_gst_caps_video().

These fields don't prevent us from connecting, but they may force videoconvert
to do an expensive conversion where not necessary.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index b9c91245f82..75ddb3082e6 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -416,8 +416,8 @@ static GstCaps *amt_to_gst_caps_video(const AM_MEDIA_TYPE *mt)
         /* Clear some fields that shouldn't prevent us from connecting. */
         for (i = 0; i < gst_caps_get_size(caps); ++i)
         {
-            gst_structure_remove_field(gst_caps_get_structure(caps, i), "framerate");
-            gst_structure_remove_field(gst_caps_get_structure(caps, i), "pixel-aspect-ratio");
+            gst_structure_remove_fields(gst_caps_get_structure(caps, i),
+                    "framerate", "pixel-aspect-ratio", "colorimetry", "chroma-site", NULL);
         }
     }
     return caps;
From 930dc23c7c9a9221aad19ebf468c3838f86427b3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 22 Jun 2020 17:56:03 -0500
Subject: [PATCH] winegstreamer: Prefer YUV formats to RGB ones.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 75ddb3082e6..11ca8f90bb0 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1677,17 +1677,19 @@ static HRESULT gstdecoder_source_get_media_type(struct gstdemux_source *pin,
 {
     static const GstVideoFormat video_formats[] =
     {
-        /* Roughly ordered by preference from videoflip. */
+        /* Try to prefer YUV formats over RGB ones. Most decoders output in the
+         * YUV color space, and it's generally much less expensive for
+         * videoconvert to do YUV -> YUV transformations. */
         GST_VIDEO_FORMAT_AYUV,
-        GST_VIDEO_FORMAT_BGRA,
-        GST_VIDEO_FORMAT_BGRx,
-        GST_VIDEO_FORMAT_BGR,
         GST_VIDEO_FORMAT_I420,
         GST_VIDEO_FORMAT_YV12,
         GST_VIDEO_FORMAT_YUY2,
         GST_VIDEO_FORMAT_UYVY,
         GST_VIDEO_FORMAT_YVYU,
         GST_VIDEO_FORMAT_NV12,
+        GST_VIDEO_FORMAT_BGRA,
+        GST_VIDEO_FORMAT_BGRx,
+        GST_VIDEO_FORMAT_BGR,
     };
 
     if (!index)
From fd25ba65e0eb9fedfb2cdfa2b7a4b16e0401dfdf Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 22 Jun 2020 17:56:04 -0500
Subject: [PATCH] winegstreamer: Avoid performing color matrix conversions in
 videoconvert.

This reduces the time videoconvert takes to process I420 -> YV12 from 15 ms to 0.8 ms on my system.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 11ca8f90bb0..8f89935b82b 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1022,6 +1022,9 @@ static void init_new_decoded_pad(GstElement *bin, GstPad *pad, struct gstdemux *
             goto out;
         }
 
+        /* Avoid expensive color matrix conversions. */
+        gst_util_set_object_arg(G_OBJECT(vconv), "matrix-mode", "none");
+
         /* GStreamer outputs RGB video top-down, but DirectShow expects bottom-up. */
         if (!(flip = gst_element_factory_make("videoflip", NULL)))
         {
From 0c8babdbcca1f74ea54b9466b7d5fe3899880cd4 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 19 Jun 2020 16:36:27 +0300
Subject: [PATCH] mf: Set clipping window attribute for EVR activator.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/main.c     |  8 +++++++-
 dlls/mf/tests/mf.c | 11 ++++++++++-
 include/mfidl.idl  |  2 ++
 3 files changed, 19 insertions(+), 2 deletions(-)

diff --git a/dlls/mf/main.c b/dlls/mf/main.c
index 15c9e5e3c9a..3546caa6912 100644
--- a/dlls/mf/main.c
+++ b/dlls/mf/main.c
@@ -1291,12 +1291,18 @@ static const struct activate_funcs evr_activate_funcs =
 
 HRESULT WINAPI MFCreateVideoRendererActivate(HWND hwnd, IMFActivate **activate)
 {
+    HRESULT hr;
+
     TRACE("%p, %p.\n", hwnd, activate);
 
     if (!activate)
         return E_POINTER;
 
-    return create_activation_object(hwnd, &evr_activate_funcs, activate);
+    hr = create_activation_object(hwnd, &evr_activate_funcs, activate);
+    if (SUCCEEDED(hr))
+        IMFActivate_SetUINT64(*activate, &MF_ACTIVATE_VIDEO_WINDOW, (ULONG_PTR)hwnd);
+
+    return hr;
 }
 
 struct simple_type_handler
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index c79ae69f91d..d252bab9b3b 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3228,7 +3228,8 @@ static void test_evr(void)
 {
     IMFMediaSink *sink, *sink2;
     IMFActivate *activate;
-    DWORD flags;
+    DWORD flags, count;
+    UINT64 value;
     HRESULT hr;
 
     hr = CoInitialize(NULL);
@@ -3240,6 +3241,14 @@ static void test_evr(void)
     hr = MFCreateVideoRendererActivate(NULL, &activate);
     ok(hr == S_OK, "Failed to create activate object, hr %#x.\n", hr);
 
+    hr = IMFActivate_GetCount(activate, &count);
+    ok(hr == S_OK, "Failed to get attribute count, hr %#x.\n", hr);
+    ok(count == 1, "Unexpected count %u.\n", count);
+
+    hr = IMFActivate_GetUINT64(activate, &MF_ACTIVATE_VIDEO_WINDOW, &value);
+    ok(hr == S_OK, "Failed to get attribute, hr %#x.\n", hr);
+    ok(!value, "Unexpected value.\n");
+
     hr = IMFActivate_ActivateObject(activate, &IID_IMFMediaSink, (void **)&sink);
 todo_wine
     ok(hr == S_OK, "Failed to activate, hr %#x.\n", hr);
diff --git a/include/mfidl.idl b/include/mfidl.idl
index 89b1bdd05b8..2955d0d2f3b 100644
--- a/include/mfidl.idl
+++ b/include/mfidl.idl
@@ -1151,4 +1151,6 @@ cpp_quote("EXTERN_GUID(MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ID, 0xb10aaec3, 0xef
 cpp_quote("EXTERN_GUID(MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ROLE, 0x6ba644ff, 0x27c5, 0x4d02, 0x98, 0x87, 0xc2, 0x86, 0x19, 0xfd, 0xb9, 0x1b);")
 cpp_quote("EXTERN_GUID(MF_AUDIO_RENDERER_ATTRIBUTE_STREAM_CATEGORY, 0xa9770471, 0x92ec, 0x4df4, 0x94, 0xfe, 0x81, 0xc3, 0x6f, 0x0c, 0x3a, 0x7a);")
 
+cpp_quote("EXTERN_GUID(MF_ACTIVATE_VIDEO_WINDOW, 0x9a2dbbdd, 0xf57e, 0x4162, 0x82, 0xb9, 0x68, 0x31, 0x37, 0x76, 0x82, 0xd3);")
+
 cpp_quote("EXTERN_GUID(CLSID_VideoProcessorMFT, 0x88753b26, 0x5b24, 0x49bd, 0xb2, 0xe7, 0xc, 0x44, 0x5c, 0x78, 0xc9, 0x82);")
From 9d9975c3b2840bf945e7e6dde9315583d493a6a7 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 19 Jun 2020 16:36:28 +0300
Subject: [PATCH] mfplat: Add EVR activator attributes to tracing.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/main.c |  7 +++++++
 include/mfidl.idl  | 16 ++++++++++++++++
 2 files changed, 23 insertions(+)

diff --git a/dlls/mfplat/main.c b/dlls/mfplat/main.c
index ea6a0659c5c..6cd409d63b7 100644
--- a/dlls/mfplat/main.c
+++ b/dlls/mfplat/main.c
@@ -1646,12 +1646,18 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_SYMBOLIC_LINK),
         X(MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE11),
         X(MF_MT_USER_DATA),
+        X(MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID),
         X(MF_MT_MIN_MASTERING_LUMINANCE),
+        X(MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE),
+        X(MF_ACTIVATE_CUSTOM_VIDEO_MIXER_FLAGS),
+        X(MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_CLSID),
         X(MF_EVENT_STREAM_METADATA_SYSTEMID),
+        X(MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_ACTIVATE),
         X(MF_MT_AUDIO_CHANNEL_MASK),
         X(MF_SOURCE_READER_DISCONNECT_MEDIASOURCE_ON_SHUTDOWN),
         X(MF_READWRITE_DISABLE_CONVERTERS),
         X(MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE_EDGE),
+        X(MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS),
         X(MF_MT_MINIMUM_DISPLAY_APERTURE),
         X(MFSampleExtension_Token),
         X(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_CATEGORY),
@@ -1806,6 +1812,7 @@ const char *debugstr_attr(const GUID *guid)
         X(MF_MEDIA_ENGINE_COREWINDOW),
         X(MF_SOURCE_READER_DISABLE_CAMERA_PLUGINS),
         X(MF_MT_MPEG4_TRACK_TYPE),
+        X(MF_ACTIVATE_VIDEO_WINDOW),
         X(MF_MT_PAN_SCAN_APERTURE),
         X(MF_TOPOLOGY_RESOLUTION_STATUS),
         X(MF_MT_ORIGINAL_4CC),
diff --git a/include/mfidl.idl b/include/mfidl.idl
index 2955d0d2f3b..912e62ca350 100644
--- a/include/mfidl.idl
+++ b/include/mfidl.idl
@@ -1027,6 +1027,16 @@ interface IMFAudioPolicy : IUnknown
     HRESULT GetIconPath([out] LPWSTR *path);
 }
 
+enum
+{
+    MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL = 0x00000001,
+};
+
+enum
+{
+    MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL = 0x00000001,
+};
+
 cpp_quote("#ifdef __cplusplus")
 cpp_quote("static inline HRESULT MFSetAttributeSize(IMFAttributes *attributes, REFGUID key, UINT32 width, UINT32 height)")
 cpp_quote("{")
@@ -1152,5 +1162,11 @@ cpp_quote("EXTERN_GUID(MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ROLE, 0x6ba644ff, 0x
 cpp_quote("EXTERN_GUID(MF_AUDIO_RENDERER_ATTRIBUTE_STREAM_CATEGORY, 0xa9770471, 0x92ec, 0x4df4, 0x94, 0xfe, 0x81, 0xc3, 0x6f, 0x0c, 0x3a, 0x7a);")
 
 cpp_quote("EXTERN_GUID(MF_ACTIVATE_VIDEO_WINDOW, 0x9a2dbbdd, 0xf57e, 0x4162, 0x82, 0xb9, 0x68, 0x31, 0x37, 0x76, 0x82, 0xd3);")
+cpp_quote("EXTERN_GUID(MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID, 0xba491360, 0xbe50, 0x451e, 0x95, 0xab, 0x6d, 0x4a, 0xcc, 0xc7, 0xda, 0xd8);")
+cpp_quote("EXTERN_GUID(MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE, 0xba491361, 0xbe50, 0x451e, 0x95, 0xab, 0x6d, 0x4a, 0xcc, 0xc7, 0xda, 0xd8);")
+cpp_quote("EXTERN_GUID(MF_ACTIVATE_CUSTOM_VIDEO_MIXER_FLAGS, 0xba491362, 0xbe50, 0x451e, 0x95, 0xab, 0x6d, 0x4a, 0xcc, 0xc7, 0xda, 0xd8);")
+cpp_quote("EXTERN_GUID(MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_CLSID, 0xba491364, 0xbe50, 0x451e, 0x95, 0xab, 0x6d, 0x4a, 0xcc, 0xc7, 0xda, 0xd8);")
+cpp_quote("EXTERN_GUID(MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_ACTIVATE, 0xba491365, 0xbe50, 0x451e, 0x95, 0xab, 0x6d, 0x4a, 0xcc, 0xc7, 0xda, 0xd8);")
+cpp_quote("EXTERN_GUID(MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS, 0xba491366, 0xbe50, 0x451e, 0x95, 0xab, 0x6d, 0x4a, 0xcc, 0xc7, 0xda, 0xd8);")
 
 cpp_quote("EXTERN_GUID(CLSID_VideoProcessorMFT, 0x88753b26, 0x5b24, 0x49bd, 0xb2, 0xe7, 0xc, 0x44, 0x5c, 0x78, 0xc9, 0x82);")
From 1b95c1b5117f94b024a1b538b65f65a707d22f3d Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 19 Jun 2020 16:36:29 +0300
Subject: [PATCH] evr/tests: Add some tests for surface samples.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/evr.spec          |   2 +-
 dlls/evr/mixer.c           |   7 ++
 dlls/evr/tests/Makefile.in |   2 +-
 dlls/evr/tests/evr.c       | 142 +++++++++++++++++++++++++++++++++++++
 include/evr.idl            |  21 ++++++
 include/mfidl.idl          |  13 ++++
 6 files changed, 185 insertions(+), 2 deletions(-)

diff --git a/dlls/evr/evr.spec b/dlls/evr/evr.spec
index ea87f16da15..214f2b81d85 100644
--- a/dlls/evr/evr.spec
+++ b/dlls/evr/evr.spec
@@ -19,7 +19,7 @@
 @ stub MFCreateVideoPresenter2
 @ stub MFCreateVideoPresenter
 @ stub MFCreateVideoSampleAllocator
-@ stub MFCreateVideoSampleFromSurface
+@ stdcall MFCreateVideoSampleFromSurface(ptr ptr)
 @ stub MFGetPlaneSize
 @ stub MFGetStrideForBitmapInfoHeader
 @ stub MFGetUncompressedVideoFormat
diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index b651a56bff5..eaea037b693 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -685,3 +685,10 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
 
     return S_OK;
 }
+
+HRESULT WINAPI MFCreateVideoSampleFromSurface(IUnknown *surface, IMFSample **sample)
+{
+    FIXME("%p, %p.\n", surface, sample);
+
+    return E_NOTIMPL;
+}
diff --git a/dlls/evr/tests/Makefile.in b/dlls/evr/tests/Makefile.in
index 529c5354508..8253c4d7fb4 100644
--- a/dlls/evr/tests/Makefile.in
+++ b/dlls/evr/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = evr.dll
-IMPORTS   = mfuuid strmiids uuid dxguid ole32 oleaut32 evr
+IMPORTS   = mfuuid strmiids uuid dxguid ole32 oleaut32 evr d3d9 user32
 
 C_SRCS = \
 	evr.c
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 9cf5d419198..9365856d1eb 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -29,6 +29,36 @@
 
 static const WCHAR sink_id[] = {'E','V','R',' ','I','n','p','u','t','0',0};
 
+static HWND create_window(void)
+{
+    RECT r = {0, 0, 640, 480};
+
+    AdjustWindowRect(&r, WS_OVERLAPPEDWINDOW | WS_VISIBLE, FALSE);
+
+    return CreateWindowA("static", "d3d9_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+            0, 0, r.right - r.left, r.bottom - r.top, NULL, NULL, NULL, NULL);
+}
+
+static IDirect3DDevice9 *create_device(IDirect3D9 *d3d9, HWND focus_window)
+{
+    D3DPRESENT_PARAMETERS present_parameters = {0};
+    IDirect3DDevice9 *device = NULL;
+
+    present_parameters.BackBufferWidth = 640;
+    present_parameters.BackBufferHeight = 480;
+    present_parameters.BackBufferFormat = D3DFMT_A8R8G8B8;
+    present_parameters.SwapEffect = D3DSWAPEFFECT_DISCARD;
+    present_parameters.hDeviceWindow = focus_window;
+    present_parameters.Windowed = TRUE;
+    present_parameters.EnableAutoDepthStencil = TRUE;
+    present_parameters.AutoDepthStencilFormat = D3DFMT_D24S8;
+
+    IDirect3D9_CreateDevice(d3d9, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, focus_window,
+            D3DCREATE_HARDWARE_VERTEXPROCESSING, &present_parameters, &device);
+
+    return device;
+}
+
 static IBaseFilter *create_evr(void)
 {
     IBaseFilter *filter = NULL;
@@ -485,6 +515,117 @@ static void test_default_mixer(void)
     IMFTransform_Release(transform);
 }
 
+static void test_surface_sample(void)
+{
+    IDirect3DSurface9 *backbuffer = NULL;
+    IMFMediaBuffer *buffer, *buffer2;
+    IDirect3DSwapChain9 *swapchain;
+    IDirect3DDevice9 *device;
+    DWORD count, length;
+    IMFSample *sample;
+    LONGLONG duration;
+    IDirect3D9 *d3d;
+    IUnknown *unk;
+    HWND window;
+    HRESULT hr;
+    BYTE *data;
+
+    window = create_window();
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+    ok(!!d3d, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d, window)))
+    {
+        skip("Failed to create a D3D device, skipping tests.\n");
+        goto done;
+    }
+
+    hr = IDirect3DDevice9_GetSwapChain(device, 0, &swapchain);
+    ok(SUCCEEDED(hr), "Failed to get the implicit swapchain (%08x)\n", hr);
+
+    hr = IDirect3DSwapChain9_GetBackBuffer(swapchain, 0, D3DBACKBUFFER_TYPE_MONO, &backbuffer);
+    ok(SUCCEEDED(hr), "Failed to get the back buffer (%08x)\n", hr);
+    ok(backbuffer != NULL, "The back buffer is NULL\n");
+
+    IDirect3DSwapChain9_Release(swapchain);
+
+    hr = MFCreateVideoSampleFromSurface((IUnknown *)backbuffer, &sample);
+todo_wine
+    ok(hr == S_OK, "Failed to create surface sample, hr %#x.\n", hr);
+    if (FAILED(hr)) goto done;
+
+    hr = IMFSample_QueryInterface(sample, &IID_IMFTrackedSample, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
+    hr = IMFSample_QueryInterface(sample, &IID_IMFDesiredSample, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
+    hr = IMFSample_GetCount(sample, &count);
+    ok(hr == S_OK, "Failed to get attribute count, hr %#x.\n", hr);
+    ok(!count, "Unexpected attribute count.\n");
+
+    hr = IMFSample_GetBufferCount(sample, &count);
+    ok(hr == S_OK, "Failed to get buffer count, hr %#x.\n", hr);
+    ok(count == 1, "Unexpected attribute count.\n");
+
+    hr = IMFSample_GetTotalLength(sample, &length);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+    ok(!length, "Unexpected length %u.\n", length);
+
+    hr = IMFSample_GetSampleDuration(sample, &duration);
+    ok(hr == MF_E_NO_SAMPLE_DURATION, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFSample_GetSampleTime(sample, &duration);
+    ok(hr == MF_E_NO_SAMPLE_TIMESTAMP, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFSample_GetBufferByIndex(sample, 0, &buffer);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaBuffer_GetMaxLength(buffer, &length);
+    ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaBuffer_GetCurrentLength(buffer, &length);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+    ok(!length, "Unexpected length %u.\n", length);
+
+    hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL);
+    ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer, (void **)&unk);
+    ok(hr == E_NOINTERFACE, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFSample_AddBuffer(sample, buffer);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFSample_GetBufferCount(sample, &count);
+    ok(hr == S_OK, "Failed to get buffer count, hr %#x.\n", hr);
+    ok(count == 2, "Unexpected attribute count.\n");
+
+    hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer2);
+    ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFSample_CopyToBuffer(sample, buffer);
+    ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFSample_RemoveAllBuffers(sample);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFSample_GetBufferCount(sample, &count);
+    ok(hr == S_OK, "Failed to get buffer count, hr %#x.\n", hr);
+    ok(!count, "Unexpected attribute count.\n");
+
+    IMFMediaBuffer_Release(buffer);
+
+    IMFSample_Release(sample);
+
+done:
+    if (backbuffer)
+        IDirect3DSurface9_Release(backbuffer);
+    IDirect3D9_Release(d3d);
+    DestroyWindow(window);
+}
+
 START_TEST(evr)
 {
     CoInitialize(NULL);
@@ -495,6 +636,7 @@ START_TEST(evr)
     test_find_pin();
     test_pin_info();
     test_default_mixer();
+    test_surface_sample();
 
     CoUninitialize();
 }
diff --git a/include/evr.idl b/include/evr.idl
index 83603b92ccd..43afca1201a 100644
--- a/include/evr.idl
+++ b/include/evr.idl
@@ -198,4 +198,25 @@ interface IMFVideoMixerControl2 : IMFVideoMixerControl
     );
 }
 
+[
+    object,
+    uuid(56c294d0-753e-4260-8d61-a3d8820b1d54),
+    local
+]
+interface IMFDesiredSample : IUnknown
+{
+    HRESULT GetDesiredSampleTimeAndDuration(
+        [out] LONGLONG *sample_time,
+        [out] LONGLONG *sample_duration
+    );
+
+    void SetDesiredSampleTimeAndDuration(
+        [in] LONGLONG sample_time,
+        [in] LONGLONG sample_duration
+    );
+
+    void Clear();
+}
+
 cpp_quote("HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj);")
+cpp_quote("HRESULT WINAPI MFCreateVideoSampleFromSurface(IUnknown *surface, IMFSample **sample);")
diff --git a/include/mfidl.idl b/include/mfidl.idl
index 912e62ca350..35419756b5c 100644
--- a/include/mfidl.idl
+++ b/include/mfidl.idl
@@ -934,6 +934,19 @@ interface IMFQualityAdviseLimits : IUnknown
     HRESULT GetMinimumQualityLevel([out] MF_QUALITY_LEVEL *level);
 }
 
+[
+    object,
+    uuid(245bf8e9-0755-40f7-88a5-ae0f18d55e17),
+    local
+]
+interface IMFTrackedSample : IUnknown
+{
+    HRESULT SetAllocator(
+        [in] IMFAsyncCallback *sample_allocator,
+        [in, unique] IUnknown *state
+    );
+}
+
 typedef struct _MFT_REGISTRATION_INFO
 {
     CLSID clsid;
From fd72999bd68065a890a496b076a421841f92f778 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 22 Jun 2020 13:45:29 +0300
Subject: [PATCH] dxva2: Add device manager stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 configure                    |   1 +
 configure.ac                 |   1 +
 dlls/dxva2/Makefile.in       |   4 +-
 dlls/dxva2/main.c            | 147 +++++++++++++++++++++++++++-
 dlls/dxva2/tests/Makefile.in |   5 +
 dlls/dxva2/tests/dxva2.c     | 181 +++++++++++++++++++++++++++++++++++
 6 files changed, 334 insertions(+), 5 deletions(-)
 create mode 100644 dlls/dxva2/tests/Makefile.in
 create mode 100644 dlls/dxva2/tests/dxva2.c

diff --git a/configure b/configure
index dd23b5ab13b..106ce1625b1 100755
--- a/configure
+++ b/configure
@@ -20683,6 +20683,7 @@ wine_fn_config_makefile dlls/dxgi enable_dxgi
 wine_fn_config_makefile dlls/dxgi/tests enable_tests
 wine_fn_config_makefile dlls/dxguid enable_dxguid
 wine_fn_config_makefile dlls/dxva2 enable_dxva2
+wine_fn_config_makefile dlls/dxva2/tests enable_tests
 wine_fn_config_makefile dlls/esent enable_esent
 wine_fn_config_makefile dlls/evr enable_evr
 wine_fn_config_makefile dlls/evr/tests enable_tests
diff --git a/configure.ac b/configure.ac
index 9c5f76669df..a78610c6490 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3269,6 +3269,7 @@ WINE_CONFIG_MAKEFILE(dlls/dxgi)
 WINE_CONFIG_MAKEFILE(dlls/dxgi/tests)
 WINE_CONFIG_MAKEFILE(dlls/dxguid)
 WINE_CONFIG_MAKEFILE(dlls/dxva2)
+WINE_CONFIG_MAKEFILE(dlls/dxva2/tests)
 WINE_CONFIG_MAKEFILE(dlls/esent)
 WINE_CONFIG_MAKEFILE(dlls/evr)
 WINE_CONFIG_MAKEFILE(dlls/evr/tests)
diff --git a/dlls/dxva2/Makefile.in b/dlls/dxva2/Makefile.in
index 44e125e9b5f..e3fc2fd6c3a 100644
--- a/dlls/dxva2/Makefile.in
+++ b/dlls/dxva2/Makefile.in
@@ -1,4 +1,6 @@
-MODULE = dxva2.dll
+MODULE    = dxva2.dll
+IMPORTS   = uuid
+IMPORTLIB = dxva2
 
 EXTRADLLFLAGS = -mno-cygwin
 
diff --git a/dlls/dxva2/main.c b/dlls/dxva2/main.c
index 782f0dfa3d4..e1eb2128439 100644
--- a/dlls/dxva2/main.c
+++ b/dlls/dxva2/main.c
@@ -16,19 +16,144 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#define COBJMACROS
+
 #include <stdarg.h>
 #include "windef.h"
 #include "winbase.h"
 #include "d3d9.h"
-#include "dxva2api.h"
 #include "physicalmonitorenumerationapi.h"
 #include "lowlevelmonitorconfigurationapi.h"
 #include "highlevelmonitorconfigurationapi.h"
+#include "initguid.h"
+#include "dxva2api.h"
 
 #include "wine/debug.h"
+#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(dxva2);
 
+struct device_manager
+{
+    IDirect3DDeviceManager9 IDirect3DDeviceManager9_iface;
+    LONG refcount;
+
+    UINT token;
+};
+
+static struct device_manager *impl_from_IDirect3DDeviceManager9(IDirect3DDeviceManager9 *iface)
+{
+    return CONTAINING_RECORD(iface, struct device_manager, IDirect3DDeviceManager9_iface);
+}
+
+static HRESULT WINAPI device_manager_QueryInterface(IDirect3DDeviceManager9 *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(&IID_IDirect3DDeviceManager9, riid) ||
+            IsEqualIID(&IID_IUnknown, riid))
+    {
+        *obj = iface;
+        IDirect3DDeviceManager9_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI device_manager_AddRef(IDirect3DDeviceManager9 *iface)
+{
+    struct device_manager *manager = impl_from_IDirect3DDeviceManager9(iface);
+    ULONG refcount = InterlockedIncrement(&manager->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI device_manager_Release(IDirect3DDeviceManager9 *iface)
+{
+    struct device_manager *manager = impl_from_IDirect3DDeviceManager9(iface);
+    ULONG refcount = InterlockedDecrement(&manager->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        heap_free(manager);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI device_manager_ResetDevice(IDirect3DDeviceManager9 *iface, IDirect3DDevice9 *device,
+        UINT token)
+{
+    FIXME("%p, %p, %#x.\n", iface, device, token);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_OpenDeviceHandle(IDirect3DDeviceManager9 *iface, HANDLE *hdevice)
+{
+    FIXME("%p, %p.\n", iface, hdevice);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_CloseDeviceHandle(IDirect3DDeviceManager9 *iface, HANDLE hdevice)
+{
+    FIXME("%p, %p.\n", iface, hdevice);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_TestDevice(IDirect3DDeviceManager9 *iface, HANDLE hdevice)
+{
+    FIXME("%p, %p.\n", iface, hdevice);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_LockDevice(IDirect3DDeviceManager9 *iface, HANDLE hdevice,
+        IDirect3DDevice9 **device, BOOL block)
+{
+    FIXME("%p, %p, %p, %d.\n", iface, hdevice, device, block);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_UnlockDevice(IDirect3DDeviceManager9 *iface, HANDLE hdevice, BOOL savestate)
+{
+    FIXME("%p, %p, %d.\n", iface, hdevice, savestate);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_GetVideoService(IDirect3DDeviceManager9 *iface, HANDLE hdevice, REFIID riid,
+        void **obj)
+{
+    FIXME("%p, %p, %s, %p.\n", iface, hdevice, debugstr_guid(riid), obj);
+
+    return E_NOTIMPL;
+}
+
+static const IDirect3DDeviceManager9Vtbl device_manager_vtbl =
+{
+    device_manager_QueryInterface,
+    device_manager_AddRef,
+    device_manager_Release,
+    device_manager_ResetDevice,
+    device_manager_OpenDeviceHandle,
+    device_manager_CloseDeviceHandle,
+    device_manager_TestDevice,
+    device_manager_LockDevice,
+    device_manager_UnlockDevice,
+    device_manager_GetVideoService,
+};
+
 BOOL WINAPI CapabilitiesRequestAndCapabilitiesReply( HMONITOR monitor, LPSTR buffer, DWORD length )
 {
     FIXME("(%p, %p, %d): stub\n", monitor, buffer, length);
@@ -37,11 +162,25 @@ BOOL WINAPI CapabilitiesRequestAndCapabilitiesReply( HMONITOR monitor, LPSTR buf
     return FALSE;
 }
 
-HRESULT WINAPI DXVA2CreateDirect3DDeviceManager9( UINT *resetToken, IDirect3DDeviceManager9 **dxvManager )
+HRESULT WINAPI DXVA2CreateDirect3DDeviceManager9(UINT *token, IDirect3DDeviceManager9 **manager)
 {
-    FIXME("(%p, %p): stub\n", resetToken, dxvManager);
+    struct device_manager *object;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", token, manager);
+
+    *manager = NULL;
+
+    if (!(object = heap_alloc_zero(sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IDirect3DDeviceManager9_iface.lpVtbl = &device_manager_vtbl;
+    object->refcount = 1;
+    object->token = GetTickCount();
+
+    *token = object->token;
+    *manager = &object->IDirect3DDeviceManager9_iface;
+
+    return S_OK;
 }
 
 HRESULT WINAPI DXVA2CreateVideoService( IDirect3DDevice9 *device, REFIID riid, void **ppv )
diff --git a/dlls/dxva2/tests/Makefile.in b/dlls/dxva2/tests/Makefile.in
new file mode 100644
index 00000000000..c86c5ab42fc
--- /dev/null
+++ b/dlls/dxva2/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL   = dxva2.dll
+IMPORTS   = dxva2 user32 d3d9
+
+C_SRCS = \
+	dxva2.c
diff --git a/dlls/dxva2/tests/dxva2.c b/dlls/dxva2/tests/dxva2.c
new file mode 100644
index 00000000000..cbcad40ca59
--- /dev/null
+++ b/dlls/dxva2/tests/dxva2.c
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2020 Nikolay Sivov
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+#include "wine/test.h"
+#include "d3d9.h"
+
+#include "initguid.h"
+#include "dxva2api.h"
+
+static int get_refcount(IUnknown *object)
+{
+    IUnknown_AddRef(object);
+    return IUnknown_Release(object);
+}
+
+static HWND create_window(void)
+{
+    RECT r = {0, 0, 640, 480};
+
+    AdjustWindowRect(&r, WS_OVERLAPPEDWINDOW | WS_VISIBLE, FALSE);
+
+    return CreateWindowA("static", "d3d9_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+            0, 0, r.right - r.left, r.bottom - r.top, NULL, NULL, NULL, NULL);
+}
+
+static IDirect3DDevice9 *create_device(IDirect3D9 *d3d9, HWND focus_window)
+{
+    D3DPRESENT_PARAMETERS present_parameters = {0};
+    IDirect3DDevice9 *device = NULL;
+
+    present_parameters.BackBufferWidth = 640;
+    present_parameters.BackBufferHeight = 480;
+    present_parameters.BackBufferFormat = D3DFMT_A8R8G8B8;
+    present_parameters.SwapEffect = D3DSWAPEFFECT_DISCARD;
+    present_parameters.hDeviceWindow = focus_window;
+    present_parameters.Windowed = TRUE;
+    present_parameters.EnableAutoDepthStencil = TRUE;
+    present_parameters.AutoDepthStencilFormat = D3DFMT_D24S8;
+
+    IDirect3D9_CreateDevice(d3d9, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, focus_window,
+            D3DCREATE_HARDWARE_VERTEXPROCESSING, &present_parameters, &device);
+
+    return device;
+}
+
+static void test_device_manager(void)
+{
+    IDirectXVideoProcessorService *processor_service;
+    IDirect3DDevice9 *device, *device2;
+    IDirect3DDeviceManager9 *manager;
+    int refcount, refcount2;
+    HANDLE handle, handle1;
+    IDirect3D9 *d3d;
+    HWND window;
+    UINT token;
+    HRESULT hr;
+
+    window = create_window();
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+    ok(!!d3d, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d, window)))
+    {
+        skip("Failed to create a D3D device, skipping tests.\n");
+        goto done;
+    }
+
+    hr = DXVA2CreateDirect3DDeviceManager9(&token, &manager);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
+todo_wine
+    ok(hr == DXVA2_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
+
+    /* Invalid token. */
+    hr = IDirect3DDeviceManager9_ResetDevice(manager, device, token + 1);
+todo_wine
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_ResetDevice(manager, device, token);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    refcount = get_refcount((IUnknown *)device);
+
+    handle1 = NULL;
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle1);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    refcount2 = get_refcount((IUnknown *)device);
+    ok(refcount2 == refcount, "Unexpected refcount %d.\n", refcount);
+
+    handle = NULL;
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(handle != handle1, "Unexpected handle.\n");
+}
+    hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* Already closed. */
+    hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle);
+todo_wine
+    ok(hr == E_HANDLE, "Unexpected hr %#x.\n", hr);
+
+    handle = NULL;
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle1);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_TestDevice(manager, handle1);
+todo_wine
+    ok(hr == E_HANDLE, "Unexpected hr %#x.\n", hr);
+
+    handle = NULL;
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    handle1 = NULL;
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle1);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_GetVideoService(manager, handle, &IID_IDirectXVideoProcessorService,
+            (void **)&processor_service);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+        IDirectXVideoProcessorService_Release(processor_service);
+
+    device2 = create_device(d3d, window);
+    hr = IDirect3DDeviceManager9_ResetDevice(manager, device2, token);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_GetVideoService(manager, handle, &IID_IDirectXVideoProcessorService,
+            (void **)&processor_service);
+todo_wine
+    ok(hr == DXVA2_E_NEW_VIDEO_DEVICE, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_TestDevice(manager, handle);
+todo_wine
+    ok(hr == DXVA2_E_NEW_VIDEO_DEVICE, "Unexpected hr %#x.\n", hr);
+
+    IDirect3DDevice9_Release(device);
+    IDirect3DDevice9_Release(device2);
+
+    IDirect3DDeviceManager9_Release(manager);
+
+done:
+    IDirect3D9_Release(d3d);
+    DestroyWindow(window);
+}
+
+START_TEST(dxva2)
+{
+    test_device_manager();
+}
From 24aaf0d535b6c5c0d56b1e50deb2e47d3cce9ab8 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 22 Jun 2020 13:45:30 +0300
Subject: [PATCH] dxva2: Implement handle management for device manager.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dxva2/main.c        | 158 +++++++++++++++++++++++++++++++++++++--
 dlls/dxva2/tests/dxva2.c |  16 +---
 2 files changed, 151 insertions(+), 23 deletions(-)

diff --git a/dlls/dxva2/main.c b/dlls/dxva2/main.c
index e1eb2128439..7e983a43dd6 100644
--- a/dlls/dxva2/main.c
+++ b/dlls/dxva2/main.c
@@ -33,14 +33,59 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(dxva2);
 
+enum device_handle_flags
+{
+    HANDLE_FLAG_OPEN = 0x1,
+    HANDLE_FLAG_INVALID = 0x2,
+};
+
+struct device_handle
+{
+    unsigned int flags;
+};
+
 struct device_manager
 {
     IDirect3DDeviceManager9 IDirect3DDeviceManager9_iface;
     LONG refcount;
 
+    IDirect3DDevice9 *device;
     UINT token;
+
+    struct device_handle *handles;
+    size_t count;
+    size_t capacity;
+
+    CRITICAL_SECTION cs;
 };
 
+static BOOL dxva_array_reserve(void **elements, size_t *capacity, size_t count, size_t size)
+{
+    size_t new_capacity, max_capacity;
+    void *new_elements;
+
+    if (count <= *capacity)
+        return TRUE;
+
+    max_capacity = ~(SIZE_T)0 / size;
+    if (count > max_capacity)
+        return FALSE;
+
+    new_capacity = max(4, *capacity);
+    while (new_capacity < count && new_capacity <= max_capacity / 2)
+        new_capacity *= 2;
+    if (new_capacity < count)
+        new_capacity = max_capacity;
+
+    if (!(new_elements = heap_realloc(*elements, new_capacity * size)))
+        return FALSE;
+
+    *elements = new_elements;
+    *capacity = new_capacity;
+
+    return TRUE;
+}
+
 static struct device_manager *impl_from_IDirect3DDeviceManager9(IDirect3DDeviceManager9 *iface)
 {
     return CONTAINING_RECORD(iface, struct device_manager, IDirect3DDeviceManager9_iface);
@@ -82,6 +127,10 @@ static ULONG WINAPI device_manager_Release(IDirect3DDeviceManager9 *iface)
 
     if (!refcount)
     {
+        if (manager->device)
+            IDirect3DDevice9_Release(manager->device);
+        DeleteCriticalSection(&manager->cs);
+        heap_free(manager->handles);
         heap_free(manager);
     }
 
@@ -91,30 +140,122 @@ static ULONG WINAPI device_manager_Release(IDirect3DDeviceManager9 *iface)
 static HRESULT WINAPI device_manager_ResetDevice(IDirect3DDeviceManager9 *iface, IDirect3DDevice9 *device,
         UINT token)
 {
-    FIXME("%p, %p, %#x.\n", iface, device, token);
+    struct device_manager *manager = impl_from_IDirect3DDeviceManager9(iface);
+    size_t i;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %#x.\n", iface, device, token);
+
+    if (token != manager->token)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&manager->cs);
+    if (manager->device)
+    {
+        for (i = 0; i < manager->count; ++i)
+            manager->handles[i].flags |= HANDLE_FLAG_INVALID;
+        IDirect3DDevice9_Release(manager->device);
+    }
+    manager->device = device;
+    IDirect3DDevice9_AddRef(manager->device);
+    LeaveCriticalSection(&manager->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI device_manager_OpenDeviceHandle(IDirect3DDeviceManager9 *iface, HANDLE *hdevice)
 {
-    FIXME("%p, %p.\n", iface, hdevice);
+    struct device_manager *manager = impl_from_IDirect3DDeviceManager9(iface);
+    HRESULT hr = S_OK;
+    size_t i;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, hdevice);
+
+    *hdevice = NULL;
+
+    EnterCriticalSection(&manager->cs);
+    if (!manager->device)
+        hr = DXVA2_E_NOT_INITIALIZED;
+    else
+    {
+        for (i = 0; i < manager->count; ++i)
+        {
+            if (!(manager->handles[i].flags & HANDLE_FLAG_OPEN))
+            {
+                manager->handles[i].flags |= HANDLE_FLAG_OPEN;
+                *hdevice = ULongToHandle(i + 1);
+                break;
+            }
+        }
+
+        if (dxva_array_reserve((void **)&manager->handles, &manager->capacity, manager->count + 1,
+                sizeof(*manager->handles)))
+        {
+            *hdevice = ULongToHandle(manager->count + 1);
+            manager->handles[manager->count].flags |= HANDLE_FLAG_OPEN;
+            manager->count++;
+        }
+        else
+            hr = E_OUTOFMEMORY;
+    }
+    LeaveCriticalSection(&manager->cs);
+
+    return hr;
+}
+
+static HRESULT device_manager_get_handle_index(struct device_manager *manager, HANDLE hdevice, size_t *idx)
+{
+    if (hdevice > ULongToHandle(manager->count))
+        return E_HANDLE;
+    *idx = (ULONG_PTR)hdevice - 1;
+    return S_OK;
 }
 
 static HRESULT WINAPI device_manager_CloseDeviceHandle(IDirect3DDeviceManager9 *iface, HANDLE hdevice)
 {
-    FIXME("%p, %p.\n", iface, hdevice);
+    struct device_manager *manager = impl_from_IDirect3DDeviceManager9(iface);
+    HRESULT hr;
+    size_t idx;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, hdevice);
+
+    EnterCriticalSection(&manager->cs);
+    if (SUCCEEDED(hr = device_manager_get_handle_index(manager, hdevice, &idx)))
+    {
+        if (manager->handles[idx].flags & HANDLE_FLAG_OPEN)
+        {
+            manager->handles[idx].flags = 0;
+            if (idx == manager->count - 1)
+                manager->count--;
+        }
+        else
+            hr = E_HANDLE;
+    }
+    LeaveCriticalSection(&manager->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI device_manager_TestDevice(IDirect3DDeviceManager9 *iface, HANDLE hdevice)
 {
-    FIXME("%p, %p.\n", iface, hdevice);
+    struct device_manager *manager = impl_from_IDirect3DDeviceManager9(iface);
+    HRESULT hr;
+    size_t idx;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, hdevice);
+
+    EnterCriticalSection(&manager->cs);
+    if (SUCCEEDED(hr = device_manager_get_handle_index(manager, hdevice, &idx)))
+    {
+        unsigned int flags = manager->handles[idx].flags;
+
+        if (flags & HANDLE_FLAG_INVALID)
+            hr = DXVA2_E_NEW_VIDEO_DEVICE;
+        else if (!(flags & HANDLE_FLAG_OPEN))
+            hr = E_HANDLE;
+    }
+    LeaveCriticalSection(&manager->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI device_manager_LockDevice(IDirect3DDeviceManager9 *iface, HANDLE hdevice,
@@ -176,6 +317,7 @@ HRESULT WINAPI DXVA2CreateDirect3DDeviceManager9(UINT *token, IDirect3DDeviceMan
     object->IDirect3DDeviceManager9_iface.lpVtbl = &device_manager_vtbl;
     object->refcount = 1;
     object->token = GetTickCount();
+    InitializeCriticalSection(&object->cs);
 
     *token = object->token;
     *manager = &object->IDirect3DDeviceManager9_iface;
diff --git a/dlls/dxva2/tests/dxva2.c b/dlls/dxva2/tests/dxva2.c
index cbcad40ca59..605a69dd5a5 100644
--- a/dlls/dxva2/tests/dxva2.c
+++ b/dlls/dxva2/tests/dxva2.c
@@ -84,23 +84,19 @@ static void test_device_manager(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
-todo_wine
     ok(hr == DXVA2_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
 
     /* Invalid token. */
     hr = IDirect3DDeviceManager9_ResetDevice(manager, device, token + 1);
-todo_wine
     ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IDirect3DDeviceManager9_ResetDevice(manager, device, token);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     refcount = get_refcount((IUnknown *)device);
 
     handle1 = NULL;
     hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle1);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     refcount2 = get_refcount((IUnknown *)device);
@@ -108,40 +104,32 @@ todo_wine
 
     handle = NULL;
     hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(handle != handle1, "Unexpected handle.\n");
-}
+
     hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     /* Already closed. */
     hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle);
-todo_wine
     ok(hr == E_HANDLE, "Unexpected hr %#x.\n", hr);
 
     handle = NULL;
     hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle1);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IDirect3DDeviceManager9_TestDevice(manager, handle1);
-todo_wine
     ok(hr == E_HANDLE, "Unexpected hr %#x.\n", hr);
 
     handle = NULL;
     hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     handle1 = NULL;
     hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle1);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IDirect3DDeviceManager9_GetVideoService(manager, handle, &IID_IDirectXVideoProcessorService,
@@ -153,7 +141,6 @@ todo_wine
 
     device2 = create_device(d3d, window);
     hr = IDirect3DDeviceManager9_ResetDevice(manager, device2, token);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IDirect3DDeviceManager9_GetVideoService(manager, handle, &IID_IDirectXVideoProcessorService,
@@ -162,7 +149,6 @@ todo_wine
     ok(hr == DXVA2_E_NEW_VIDEO_DEVICE, "Unexpected hr %#x.\n", hr);
 
     hr = IDirect3DDeviceManager9_TestDevice(manager, handle);
-todo_wine
     ok(hr == DXVA2_E_NEW_VIDEO_DEVICE, "Unexpected hr %#x.\n", hr);
 
     IDirect3DDevice9_Release(device);
From 3b4738bb20db7bd0da178d6d28c8661db611af2f Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 22 Jun 2020 13:45:31 +0300
Subject: [PATCH] dxva2: Add IDirectXVideoProcessorService stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dxva2/main.c        | 141 ++++++++++++++++++++++++++++++++++++++-
 dlls/dxva2/tests/dxva2.c |   5 +-
 2 files changed, 140 insertions(+), 6 deletions(-)

diff --git a/dlls/dxva2/main.c b/dlls/dxva2/main.c
index 7e983a43dd6..7ba8d9806b1 100644
--- a/dlls/dxva2/main.c
+++ b/dlls/dxva2/main.c
@@ -47,6 +47,7 @@ struct device_handle
 struct device_manager
 {
     IDirect3DDeviceManager9 IDirect3DDeviceManager9_iface;
+    IDirectXVideoProcessorService IDirectXVideoProcessorService_iface;
     LONG refcount;
 
     IDirect3DDevice9 *device;
@@ -91,6 +92,115 @@ static struct device_manager *impl_from_IDirect3DDeviceManager9(IDirect3DDeviceM
     return CONTAINING_RECORD(iface, struct device_manager, IDirect3DDeviceManager9_iface);
 }
 
+static struct device_manager *impl_from_IDirectXVideoProcessorService(IDirectXVideoProcessorService *iface)
+{
+    return CONTAINING_RECORD(iface, struct device_manager, IDirectXVideoProcessorService_iface);
+}
+
+static HRESULT WINAPI device_manager_processor_service_QueryInterface(IDirectXVideoProcessorService *iface,
+        REFIID riid, void **obj)
+{
+    if (IsEqualIID(riid, &IID_IDirectXVideoProcessorService) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IDirectXVideoProcessorService_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI device_manager_processor_service_AddRef(IDirectXVideoProcessorService *iface)
+{
+    struct device_manager *manager = impl_from_IDirectXVideoProcessorService(iface);
+    return IDirect3DDeviceManager9_AddRef(&manager->IDirect3DDeviceManager9_iface);
+}
+
+static ULONG WINAPI device_manager_processor_service_Release(IDirectXVideoProcessorService *iface)
+{
+    struct device_manager *manager = impl_from_IDirectXVideoProcessorService(iface);
+    return IDirect3DDeviceManager9_Release(&manager->IDirect3DDeviceManager9_iface);
+}
+
+static HRESULT WINAPI device_manager_processor_service_CreateSurface(IDirectXVideoProcessorService *iface,
+        UINT width, UINT height, UINT backbuffers, D3DFORMAT format, D3DPOOL pool, DWORD usage, DWORD dxvaType,
+        IDirect3DSurface9 **surface, HANDLE *shared_handle)
+{
+    FIXME("%p, %u, %u, %u, %u, %u, %u, %u, %p, %p.\n", iface, width, height, backbuffers, format, pool, usage, dxvaType,
+            surface, shared_handle);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_processor_service_RegisterVideoProcessorSoftwareDevice(
+        IDirectXVideoProcessorService *iface, void *callbacks)
+{
+    FIXME("%p, %p.\n", iface, callbacks);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_processor_service_GetVideoProcessorDeviceGuids(
+        IDirectXVideoProcessorService *iface, const DXVA2_VideoDesc *video_desc, UINT *count, GUID **guids)
+{
+    FIXME("%p, %p, %p, %p.\n", iface, video_desc, count, guids);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_processor_service_GetVideoProcessorRenderTargets(
+        IDirectXVideoProcessorService *iface, REFGUID deviceguid, const DXVA2_VideoDesc *video_desc, UINT *count,
+        D3DFORMAT **formats)
+{
+    FIXME("%p, %s, %p, %p, %p.\n", iface, debugstr_guid(deviceguid), video_desc, count, formats);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_processor_service_GetVideoProcessorSubStreamFormats(
+        IDirectXVideoProcessorService *iface, REFGUID deviceguid, const DXVA2_VideoDesc *video_desc,
+        D3DFORMAT rt_format, UINT *count, D3DFORMAT **formats)
+{
+    FIXME("%p, %s, %p, %u, %p, %p.\n", iface, debugstr_guid(deviceguid), video_desc, rt_format, count, formats);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_processor_service_GetVideoProcessorCaps(
+        IDirectXVideoProcessorService *iface, REFGUID deviceguid, const DXVA2_VideoDesc *video_desc,
+        D3DFORMAT rt_format, DXVA2_VideoProcessorCaps *caps)
+{
+    FIXME("%p, %s, %p, %u, %p.\n", iface, debugstr_guid(deviceguid), video_desc, rt_format, caps);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_processor_service_GetProcAmpRange(
+        IDirectXVideoProcessorService *iface, REFGUID deviceguid, const DXVA2_VideoDesc *video_desc,
+        D3DFORMAT rt_format, UINT ProcAmpCap, DXVA2_ValueRange *range)
+{
+    FIXME("%p, %s, %p, %u, %u, %p.\n", iface, debugstr_guid(deviceguid), video_desc, rt_format, ProcAmpCap, range);
+
+    return E_NOTIMPL;
+}
+
+static const IDirectXVideoProcessorServiceVtbl device_manager_processor_service_vtbl =
+{
+    device_manager_processor_service_QueryInterface,
+    device_manager_processor_service_AddRef,
+    device_manager_processor_service_Release,
+    device_manager_processor_service_CreateSurface,
+    device_manager_processor_service_RegisterVideoProcessorSoftwareDevice,
+    device_manager_processor_service_GetVideoProcessorDeviceGuids,
+    device_manager_processor_service_GetVideoProcessorRenderTargets,
+    device_manager_processor_service_GetVideoProcessorSubStreamFormats,
+    device_manager_processor_service_GetVideoProcessorCaps,
+    device_manager_processor_service_GetProcAmpRange,
+};
+
 static HRESULT WINAPI device_manager_QueryInterface(IDirect3DDeviceManager9 *iface, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
@@ -276,9 +386,35 @@ static HRESULT WINAPI device_manager_UnlockDevice(IDirect3DDeviceManager9 *iface
 static HRESULT WINAPI device_manager_GetVideoService(IDirect3DDeviceManager9 *iface, HANDLE hdevice, REFIID riid,
         void **obj)
 {
-    FIXME("%p, %p, %s, %p.\n", iface, hdevice, debugstr_guid(riid), obj);
+    struct device_manager *manager = impl_from_IDirect3DDeviceManager9(iface);
+    HRESULT hr;
+    size_t idx;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %s, %p.\n", iface, hdevice, debugstr_guid(riid), obj);
+
+    EnterCriticalSection(&manager->cs);
+    if (SUCCEEDED(hr = device_manager_get_handle_index(manager, hdevice, &idx)))
+    {
+        unsigned int flags = manager->handles[idx].flags;
+
+        if (flags & HANDLE_FLAG_INVALID)
+            hr = DXVA2_E_NEW_VIDEO_DEVICE;
+        else if (!(flags & HANDLE_FLAG_OPEN))
+            hr = E_HANDLE;
+        else if (IsEqualIID(riid, &IID_IDirectXVideoProcessorService))
+        {
+            *obj = &manager->IDirectXVideoProcessorService_iface;
+            IUnknown_AddRef((IUnknown *)*obj);
+        }
+        else
+        {
+            WARN("Unsupported service %s.\n", debugstr_guid(riid));
+            hr = E_UNEXPECTED;
+        }
+    }
+    LeaveCriticalSection(&manager->cs);
+
+    return hr;
 }
 
 static const IDirect3DDeviceManager9Vtbl device_manager_vtbl =
@@ -315,6 +451,7 @@ HRESULT WINAPI DXVA2CreateDirect3DDeviceManager9(UINT *token, IDirect3DDeviceMan
         return E_OUTOFMEMORY;
 
     object->IDirect3DDeviceManager9_iface.lpVtbl = &device_manager_vtbl;
+    object->IDirectXVideoProcessorService_iface.lpVtbl = &device_manager_processor_service_vtbl;
     object->refcount = 1;
     object->token = GetTickCount();
     InitializeCriticalSection(&object->cs);
diff --git a/dlls/dxva2/tests/dxva2.c b/dlls/dxva2/tests/dxva2.c
index 605a69dd5a5..65771fb5874 100644
--- a/dlls/dxva2/tests/dxva2.c
+++ b/dlls/dxva2/tests/dxva2.c
@@ -134,10 +134,8 @@ static void test_device_manager(void)
 
     hr = IDirect3DDeviceManager9_GetVideoService(manager, handle, &IID_IDirectXVideoProcessorService,
             (void **)&processor_service);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    if (SUCCEEDED(hr))
-        IDirectXVideoProcessorService_Release(processor_service);
+    IDirectXVideoProcessorService_Release(processor_service);
 
     device2 = create_device(d3d, window);
     hr = IDirect3DDeviceManager9_ResetDevice(manager, device2, token);
@@ -145,7 +143,6 @@ todo_wine
 
     hr = IDirect3DDeviceManager9_GetVideoService(manager, handle, &IID_IDirectXVideoProcessorService,
             (void **)&processor_service);
-todo_wine
     ok(hr == DXVA2_E_NEW_VIDEO_DEVICE, "Unexpected hr %#x.\n", hr);
 
     hr = IDirect3DDeviceManager9_TestDevice(manager, handle);
From a7d18392e48ec3836af58927e733bb1901ab88cb Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 22 Jun 2020 17:20:35 +0300
Subject: [PATCH] mfplat: Add IMFVideoMediaType semi-stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/mediatype.c | 487 +++++++++++++++++++++++++++++++++++++++-
 dlls/mfplat/mfplat.spec |   2 +-
 include/mfapi.h         |   1 +
 3 files changed, 480 insertions(+), 10 deletions(-)

diff --git a/dlls/mfplat/mediatype.c b/dlls/mfplat/mediatype.c
index f92577a9cbc..ca806a899f5 100644
--- a/dlls/mfplat/mediatype.c
+++ b/dlls/mfplat/mediatype.c
@@ -37,6 +37,7 @@ struct media_type
 {
     struct attributes attributes;
     IMFMediaType IMFMediaType_iface;
+    IMFVideoMediaType IMFVideoMediaType_iface;
 };
 
 struct stream_desc
@@ -66,11 +67,16 @@ struct presentation_desc
 
 static HRESULT presentation_descriptor_init(struct presentation_desc *object, DWORD count);
 
-static inline struct media_type *impl_from_IMFMediaType(IMFMediaType *iface)
+static struct media_type *impl_from_IMFMediaType(IMFMediaType *iface)
 {
     return CONTAINING_RECORD(iface, struct media_type, IMFMediaType_iface);
 }
 
+static struct media_type *impl_from_IMFVideoMediaType(IMFVideoMediaType *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_type, IMFVideoMediaType_iface);
+}
+
 static inline struct stream_desc *impl_from_IMFStreamDescriptor(IMFStreamDescriptor *iface)
 {
     return CONTAINING_RECORD(iface, struct stream_desc, IMFStreamDescriptor_iface);
@@ -413,13 +419,10 @@ static HRESULT WINAPI mediatype_GetMajorType(IMFMediaType *iface, GUID *guid)
     return attributes_GetGUID(&media_type->attributes, &MF_MT_MAJOR_TYPE, guid);
 }
 
-static HRESULT WINAPI mediatype_IsCompressedFormat(IMFMediaType *iface, BOOL *compressed)
+static HRESULT mediatype_is_compressed(struct media_type *media_type, BOOL *compressed)
 {
-    struct media_type *media_type = impl_from_IMFMediaType(iface);
     UINT32 value;
 
-    TRACE("%p, %p.\n", iface, compressed);
-
     if (FAILED(attributes_GetUINT32(&media_type->attributes, &MF_MT_ALL_SAMPLES_INDEPENDENT, &value)))
     {
         value = 0;
@@ -430,11 +433,19 @@ static HRESULT WINAPI mediatype_IsCompressedFormat(IMFMediaType *iface, BOOL *co
     return S_OK;
 }
 
-static HRESULT WINAPI mediatype_IsEqual(IMFMediaType *iface, IMFMediaType *type, DWORD *flags)
+static HRESULT WINAPI mediatype_IsCompressedFormat(IMFMediaType *iface, BOOL *compressed)
+{
+    struct media_type *media_type = impl_from_IMFMediaType(iface);
+
+    TRACE("%p, %p.\n", iface, compressed);
+
+    return mediatype_is_compressed(media_type, compressed);
+}
+
+static HRESULT media_type_is_equal(struct media_type *media_type, IMFMediaType *type, DWORD *flags)
 {
     const DWORD full_equality_flags = MF_MEDIATYPE_EQUAL_MAJOR_TYPES | MF_MEDIATYPE_EQUAL_FORMAT_TYPES |
             MF_MEDIATYPE_EQUAL_FORMAT_DATA | MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA;
-    struct media_type *media_type = impl_from_IMFMediaType(iface);
     struct comparand
     {
         IMFAttributes *type;
@@ -446,8 +457,6 @@ static HRESULT WINAPI mediatype_IsEqual(IMFMediaType *iface, IMFMediaType *type,
     unsigned int i;
     BOOL result;
 
-    TRACE("%p, %p, %p.\n", iface, type, flags);
-
     *flags = 0;
 
     left.type = &media_type->attributes.IMFAttributes_iface;
@@ -535,6 +544,15 @@ static HRESULT WINAPI mediatype_IsEqual(IMFMediaType *iface, IMFMediaType *type,
     return *flags == full_equality_flags ? S_OK : S_FALSE;
 }
 
+static HRESULT WINAPI mediatype_IsEqual(IMFMediaType *iface, IMFMediaType *type, DWORD *flags)
+{
+    struct media_type *media_type = impl_from_IMFMediaType(iface);
+
+    TRACE("%p, %p, %p.\n", iface, type, flags);
+
+    return media_type_is_equal(media_type, type, flags);
+}
+
 static HRESULT WINAPI mediatype_GetRepresentation(IMFMediaType *iface, GUID guid, void **representation)
 {
     FIXME("%p, %s, %p.\n", iface, debugstr_guid(&guid), representation);
@@ -591,6 +609,425 @@ static const IMFMediaTypeVtbl mediatypevtbl =
     mediatype_FreeRepresentation
 };
 
+static HRESULT WINAPI video_mediatype_QueryInterface(IMFVideoMediaType *iface, REFIID riid, void **out)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), out);
+
+    if (IsEqualIID(riid, &IID_IMFVideoMediaType) ||
+            IsEqualIID(riid, &IID_IMFMediaType) ||
+            IsEqualIID(riid, &IID_IMFAttributes) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *out = iface;
+        IMFVideoMediaType_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI video_mediatype_AddRef(IMFVideoMediaType *iface)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+    ULONG refcount = InterlockedIncrement(&media_type->attributes.ref);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI video_mediatype_Release(IMFVideoMediaType *iface)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+    ULONG refcount = InterlockedDecrement(&media_type->attributes.ref);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        clear_attributes_object(&media_type->attributes);
+        heap_free(media_type);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI video_mediatype_GetItem(IMFVideoMediaType *iface, REFGUID key, PROPVARIANT *value)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_attr(key), value);
+
+    return attributes_GetItem(&media_type->attributes, key, value);
+}
+
+static HRESULT WINAPI video_mediatype_GetItemType(IMFVideoMediaType *iface, REFGUID key, MF_ATTRIBUTE_TYPE *type)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_attr(key), type);
+
+    return attributes_GetItemType(&media_type->attributes, key, type);
+}
+
+static HRESULT WINAPI video_mediatype_CompareItem(IMFVideoMediaType *iface, REFGUID key, REFPROPVARIANT value, BOOL *result)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %s, %p.\n", iface, debugstr_attr(key), debugstr_propvar(value), result);
+
+    return attributes_CompareItem(&media_type->attributes, key, value, result);
+}
+
+static HRESULT WINAPI video_mediatype_Compare(IMFVideoMediaType *iface, IMFAttributes *attrs,
+        MF_ATTRIBUTES_MATCH_TYPE type, BOOL *result)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %p, %d, %p.\n", iface, attrs, type, result);
+
+    return attributes_Compare(&media_type->attributes, attrs, type, result);
+}
+
+static HRESULT WINAPI video_mediatype_GetUINT32(IMFVideoMediaType *iface, REFGUID key, UINT32 *value)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_attr(key), value);
+
+    return attributes_GetUINT32(&media_type->attributes, key, value);
+}
+
+static HRESULT WINAPI video_mediatype_GetUINT64(IMFVideoMediaType *iface, REFGUID key, UINT64 *value)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_attr(key), value);
+
+    return attributes_GetUINT64(&media_type->attributes, key, value);
+}
+
+static HRESULT WINAPI video_mediatype_GetDouble(IMFVideoMediaType *iface, REFGUID key, double *value)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_attr(key), value);
+
+    return attributes_GetDouble(&media_type->attributes, key, value);
+}
+
+static HRESULT WINAPI video_mediatype_GetGUID(IMFVideoMediaType *iface, REFGUID key, GUID *value)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_attr(key), value);
+
+    return attributes_GetGUID(&media_type->attributes, key, value);
+}
+
+static HRESULT WINAPI video_mediatype_GetStringLength(IMFVideoMediaType *iface, REFGUID key, UINT32 *length)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_attr(key), length);
+
+    return attributes_GetStringLength(&media_type->attributes, key, length);
+}
+
+static HRESULT WINAPI video_mediatype_GetString(IMFVideoMediaType *iface, REFGUID key, WCHAR *value,
+        UINT32 size, UINT32 *length)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p, %u, %p.\n", iface, debugstr_attr(key), value, size, length);
+
+    return attributes_GetString(&media_type->attributes, key, value, size, length);
+}
+
+static HRESULT WINAPI video_mediatype_GetAllocatedString(IMFVideoMediaType *iface, REFGUID key,
+        WCHAR **value, UINT32 *length)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p, %p.\n", iface, debugstr_attr(key), value, length);
+
+    return attributes_GetAllocatedString(&media_type->attributes, key, value, length);
+}
+
+static HRESULT WINAPI video_mediatype_GetBlobSize(IMFVideoMediaType *iface, REFGUID key, UINT32 *size)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_attr(key), size);
+
+    return attributes_GetBlobSize(&media_type->attributes, key, size);
+}
+
+static HRESULT WINAPI video_mediatype_GetBlob(IMFVideoMediaType *iface, REFGUID key, UINT8 *buf,
+        UINT32 bufsize, UINT32 *blobsize)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p, %u, %p.\n", iface, debugstr_attr(key), buf, bufsize, blobsize);
+
+    return attributes_GetBlob(&media_type->attributes, key, buf, bufsize, blobsize);
+}
+
+static HRESULT WINAPI video_mediatype_GetAllocatedBlob(IMFVideoMediaType *iface, REFGUID key, UINT8 **buf, UINT32 *size)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p, %p.\n", iface, debugstr_attr(key), buf, size);
+
+    return attributes_GetAllocatedBlob(&media_type->attributes, key, buf, size);
+}
+
+static HRESULT WINAPI video_mediatype_GetUnknown(IMFVideoMediaType *iface, REFGUID key, REFIID riid, void **obj)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %s, %p.\n", iface, debugstr_attr(key), debugstr_guid(riid), obj);
+
+    return attributes_GetUnknown(&media_type->attributes, key, riid, obj);
+}
+
+static HRESULT WINAPI video_mediatype_SetItem(IMFVideoMediaType *iface, REFGUID key, REFPROPVARIANT value)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %s.\n", iface, debugstr_attr(key), debugstr_propvar(value));
+
+    return attributes_SetItem(&media_type->attributes, key, value);
+}
+
+static HRESULT WINAPI video_mediatype_DeleteItem(IMFVideoMediaType *iface, REFGUID key)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s.\n", iface, debugstr_attr(key));
+
+    return attributes_DeleteItem(&media_type->attributes, key);
+}
+
+static HRESULT WINAPI video_mediatype_DeleteAllItems(IMFVideoMediaType *iface)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p.\n", iface);
+
+    return attributes_DeleteAllItems(&media_type->attributes);
+}
+
+static HRESULT WINAPI video_mediatype_SetUINT32(IMFVideoMediaType *iface, REFGUID key, UINT32 value)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %u.\n", iface, debugstr_attr(key), value);
+
+    return attributes_SetUINT32(&media_type->attributes, key, value);
+}
+
+static HRESULT WINAPI video_mediatype_SetUINT64(IMFVideoMediaType *iface, REFGUID key, UINT64 value)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %s.\n", iface, debugstr_attr(key), wine_dbgstr_longlong(value));
+
+    return attributes_SetUINT64(&media_type->attributes, key, value);
+}
+
+static HRESULT WINAPI video_mediatype_SetDouble(IMFVideoMediaType *iface, REFGUID key, double value)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %f.\n", iface, debugstr_attr(key), value);
+
+    return attributes_SetDouble(&media_type->attributes, key, value);
+}
+
+static HRESULT WINAPI video_mediatype_SetGUID(IMFVideoMediaType *iface, REFGUID key, REFGUID value)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %s.\n", iface, debugstr_attr(key), debugstr_mf_guid(value));
+
+    return attributes_SetGUID(&media_type->attributes, key, value);
+}
+
+static HRESULT WINAPI video_mediatype_SetString(IMFVideoMediaType *iface, REFGUID key, const WCHAR *value)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %s.\n", iface, debugstr_attr(key), debugstr_w(value));
+
+    return attributes_SetString(&media_type->attributes, key, value);
+}
+
+static HRESULT WINAPI video_mediatype_SetBlob(IMFVideoMediaType *iface, REFGUID key, const UINT8 *buf, UINT32 size)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p, %u.\n", iface, debugstr_attr(key), buf, size);
+
+    return attributes_SetBlob(&media_type->attributes, key, buf, size);
+}
+
+static HRESULT WINAPI video_mediatype_SetUnknown(IMFVideoMediaType *iface, REFGUID key, IUnknown *unknown)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_attr(key), unknown);
+
+    return attributes_SetUnknown(&media_type->attributes, key, unknown);
+}
+
+static HRESULT WINAPI video_mediatype_LockStore(IMFVideoMediaType *iface)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p.\n", iface);
+
+    return attributes_LockStore(&media_type->attributes);
+}
+
+static HRESULT WINAPI video_mediatype_UnlockStore(IMFVideoMediaType *iface)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p.\n", iface);
+
+    return attributes_UnlockStore(&media_type->attributes);
+}
+
+static HRESULT WINAPI video_mediatype_GetCount(IMFVideoMediaType *iface, UINT32 *count)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %p.\n", iface, count);
+
+    return attributes_GetCount(&media_type->attributes, count);
+}
+
+static HRESULT WINAPI video_mediatype_GetItemByIndex(IMFVideoMediaType *iface, UINT32 index, GUID *key, PROPVARIANT *value)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %u, %p, %p.\n", iface, index, key, value);
+
+    return attributes_GetItemByIndex(&media_type->attributes, index, key, value);
+}
+
+static HRESULT WINAPI video_mediatype_CopyAllItems(IMFVideoMediaType *iface, IMFAttributes *dest)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %p.\n", iface, dest);
+
+    return attributes_CopyAllItems(&media_type->attributes, dest);
+}
+
+static HRESULT WINAPI video_mediatype_GetMajorType(IMFVideoMediaType *iface, GUID *guid)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %p.\n", iface, guid);
+
+    return attributes_GetGUID(&media_type->attributes, &MF_MT_MAJOR_TYPE, guid);
+}
+
+static HRESULT WINAPI video_mediatype_IsCompressedFormat(IMFVideoMediaType *iface, BOOL *compressed)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %p.\n", iface, compressed);
+
+    return mediatype_is_compressed(media_type, compressed);
+}
+
+static HRESULT WINAPI video_mediatype_IsEqual(IMFVideoMediaType *iface, IMFMediaType *type, DWORD *flags)
+{
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+
+    TRACE("%p, %p, %p.\n", iface, type, flags);
+
+    return media_type_is_equal(media_type, type, flags);
+}
+
+static HRESULT WINAPI video_mediatype_GetRepresentation(IMFVideoMediaType *iface, GUID guid, void **representation)
+{
+    FIXME("%p, %s, %p.\n", iface, debugstr_guid(&guid), representation);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mediatype_FreeRepresentation(IMFVideoMediaType *iface, GUID guid, void *representation)
+{
+    FIXME("%p, %s, %p.\n", iface, debugstr_guid(&guid), representation);
+
+    return E_NOTIMPL;
+}
+
+static const MFVIDEOFORMAT * WINAPI video_mediatype_GetVideoFormat(IMFVideoMediaType *iface)
+{
+    FIXME("%p.\n", iface);
+
+    return NULL;
+}
+
+static HRESULT WINAPI video_mediatype_GetVideoRepresentation(IMFVideoMediaType *iface, GUID representation,
+        void **data, LONG stride)
+{
+    FIXME("%p, %s, %p, %d.\n", iface, debugstr_guid(&representation), data, stride);
+
+    return E_NOTIMPL;
+}
+
+static const IMFVideoMediaTypeVtbl videomediatypevtbl =
+{
+    video_mediatype_QueryInterface,
+    video_mediatype_AddRef,
+    video_mediatype_Release,
+    video_mediatype_GetItem,
+    video_mediatype_GetItemType,
+    video_mediatype_CompareItem,
+    video_mediatype_Compare,
+    video_mediatype_GetUINT32,
+    video_mediatype_GetUINT64,
+    video_mediatype_GetDouble,
+    video_mediatype_GetGUID,
+    video_mediatype_GetStringLength,
+    video_mediatype_GetString,
+    video_mediatype_GetAllocatedString,
+    video_mediatype_GetBlobSize,
+    video_mediatype_GetBlob,
+    video_mediatype_GetAllocatedBlob,
+    video_mediatype_GetUnknown,
+    video_mediatype_SetItem,
+    video_mediatype_DeleteItem,
+    video_mediatype_DeleteAllItems,
+    video_mediatype_SetUINT32,
+    video_mediatype_SetUINT64,
+    video_mediatype_SetDouble,
+    video_mediatype_SetGUID,
+    video_mediatype_SetString,
+    video_mediatype_SetBlob,
+    video_mediatype_SetUnknown,
+    video_mediatype_LockStore,
+    video_mediatype_UnlockStore,
+    video_mediatype_GetCount,
+    video_mediatype_GetItemByIndex,
+    video_mediatype_CopyAllItems,
+    video_mediatype_GetMajorType,
+    video_mediatype_IsCompressedFormat,
+    video_mediatype_IsEqual,
+    video_mediatype_GetRepresentation,
+    video_mediatype_FreeRepresentation,
+    video_mediatype_GetVideoFormat,
+    video_mediatype_GetVideoRepresentation,
+};
+
 /***********************************************************************
  *      MFCreateMediaType (mfplat.@)
  */
@@ -2171,3 +2608,35 @@ HRESULT WINAPI MFInitMediaTypeFromWaveFormatEx(IMFMediaType *mediatype, const WA
 
     return hr;
 }
+
+/***********************************************************************
+ *      MFCreateVideoMediaTypeFromSubtype (mfplat.@)
+ */
+HRESULT WINAPI MFCreateVideoMediaTypeFromSubtype(const GUID *subtype, IMFVideoMediaType **media_type)
+{
+    struct media_type *object;
+    HRESULT hr;
+
+    TRACE("%s, %p.\n", debugstr_guid(subtype), media_type);
+
+    if (!media_type)
+        return E_INVALIDARG;
+
+    object = heap_alloc(sizeof(*object));
+    if (!object)
+        return E_OUTOFMEMORY;
+
+    if (FAILED(hr = init_attributes_object(&object->attributes, 0)))
+    {
+        heap_free(object);
+        return hr;
+    }
+    object->IMFVideoMediaType_iface.lpVtbl = &videomediatypevtbl;
+
+    IMFVideoMediaType_SetGUID(&object->IMFVideoMediaType_iface, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
+    IMFVideoMediaType_SetGUID(&object->IMFVideoMediaType_iface, &MF_MT_SUBTYPE, subtype);
+
+    *media_type = &object->IMFVideoMediaType_iface;
+
+    return S_OK;
+}
diff --git a/dlls/mfplat/mfplat.spec b/dlls/mfplat/mfplat.spec
index a1833312fc1..01f9efaecaa 100644
--- a/dlls/mfplat/mfplat.spec
+++ b/dlls/mfplat/mfplat.spec
@@ -76,7 +76,7 @@
 @ stub MFCreateVideoMediaType
 @ stub MFCreateVideoMediaTypeFromBitMapInfoHeader
 @ stub MFCreateVideoMediaTypeFromBitMapInfoHeaderEx
-@ stub MFCreateVideoMediaTypeFromSubtype
+@ stdcall MFCreateVideoMediaTypeFromSubtype(ptr ptr)
 @ stub MFCreateVideoMediaTypeFromVideoInfoHeader2
 @ stub MFCreateVideoMediaTypeFromVideoInfoHeader
 @ stdcall MFCreateWaveFormatExFromMFMediaType(ptr ptr ptr long)
diff --git a/include/mfapi.h b/include/mfapi.h
index 05ada65b9db..4da25341c68 100644
--- a/include/mfapi.h
+++ b/include/mfapi.h
@@ -510,6 +510,7 @@ HRESULT WINAPI MFCreateMediaEvent(MediaEventType type, REFGUID extended_type, HR
                                   const PROPVARIANT *value, IMFMediaEvent **event);
 HRESULT WINAPI MFCreateMediaType(IMFMediaType **type);
 HRESULT WINAPI MFCreateSample(IMFSample **sample);
+HRESULT WINAPI MFCreateVideoMediaTypeFromSubtype(const GUID *subtype, IMFVideoMediaType **media_type);
 HRESULT WINAPI MFCreateMemoryBuffer(DWORD max_length, IMFMediaBuffer **buffer);
 HRESULT WINAPI MFCreateWaveFormatExFromMFMediaType(IMFMediaType *type, WAVEFORMATEX **format, UINT32 *size, UINT32 flags);
 HRESULT WINAPI MFEndCreateFile(IMFAsyncResult *result, IMFByteStream **stream);
From 8140604763f679d8ea223c71ace077b9152d7d30 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 22 Jun 2020 17:20:36 +0300
Subject: [PATCH] mfplat: Implement MFCreateMFVideoFormatFromMFMediaType().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/mediatype.c    | 98 ++++++++++++++++++++++++++++++++++++++
 dlls/mfplat/mfplat.spec    |  2 +-
 dlls/mfplat/tests/mfplat.c | 20 ++++++++
 include/mfapi.h            |  1 +
 4 files changed, 120 insertions(+), 1 deletion(-)

diff --git a/dlls/mfplat/mediatype.c b/dlls/mfplat/mediatype.c
index ca806a899f5..66722a84b6f 100644
--- a/dlls/mfplat/mediatype.c
+++ b/dlls/mfplat/mediatype.c
@@ -2640,3 +2640,101 @@ HRESULT WINAPI MFCreateVideoMediaTypeFromSubtype(const GUID *subtype, IMFVideoMe
 
     return S_OK;
 }
+
+static void media_type_get_ratio(UINT64 value, UINT32 *numerator, UINT32 *denominator)
+{
+    *numerator = value >> 32;
+    *denominator = value;
+}
+
+/***********************************************************************
+ *      MFCreateMFVideoFormatFromMFMediaType (mfplat.@)
+ */
+HRESULT WINAPI MFCreateMFVideoFormatFromMFMediaType(IMFMediaType *media_type, MFVIDEOFORMAT **video_format, UINT32 *size)
+{
+    UINT32 flags, palette_size = 0, avgrate;
+    MFVIDEOFORMAT *format;
+    UINT64 value;
+    INT32 stride;
+    GUID guid;
+
+    TRACE("%p, %p, %p.\n", media_type, video_format, size);
+
+    *size = sizeof(*format);
+
+    if (SUCCEEDED(IMFMediaType_GetBlobSize(media_type, &MF_MT_PALETTE, &palette_size)))
+        *size += palette_size;
+
+    if (!(format = CoTaskMemAlloc(*size)))
+        return E_OUTOFMEMORY;
+
+    *video_format = format;
+
+    memset(format, 0, sizeof(*format));
+    format->dwSize = *size;
+
+    if (SUCCEEDED(IMFMediaType_GetGUID(media_type, &MF_MT_SUBTYPE, &guid)))
+    {
+        memcpy(&format->guidFormat, &guid, sizeof(guid));
+        format->surfaceInfo.Format = guid.Data1;
+    }
+
+    if (SUCCEEDED(IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &value)))
+        media_type_get_ratio(value, &format->videoInfo.dwWidth, &format->videoInfo.dwHeight);
+
+    if (SUCCEEDED(IMFMediaType_GetUINT64(media_type, &MF_MT_PIXEL_ASPECT_RATIO, &value)))
+    {
+        media_type_get_ratio(value, &format->videoInfo.PixelAspectRatio.Numerator,
+                &format->videoInfo.PixelAspectRatio.Denominator);
+    }
+
+    IMFMediaType_GetUINT32(media_type, &MF_MT_VIDEO_CHROMA_SITING, &format->videoInfo.SourceChromaSubsampling);
+    IMFMediaType_GetUINT32(media_type, &MF_MT_INTERLACE_MODE, &format->videoInfo.InterlaceMode);
+    IMFMediaType_GetUINT32(media_type, &MF_MT_TRANSFER_FUNCTION, &format->videoInfo.TransferFunction);
+    IMFMediaType_GetUINT32(media_type, &MF_MT_VIDEO_PRIMARIES, &format->videoInfo.ColorPrimaries);
+    IMFMediaType_GetUINT32(media_type, &MF_MT_YUV_MATRIX, &format->videoInfo.TransferMatrix);
+    IMFMediaType_GetUINT32(media_type, &MF_MT_VIDEO_LIGHTING, &format->videoInfo.SourceLighting);
+
+    if (SUCCEEDED(IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_RATE, &value)))
+    {
+        media_type_get_ratio(value, &format->videoInfo.FramesPerSecond.Numerator,
+                &format->videoInfo.FramesPerSecond.Denominator);
+    }
+
+    IMFMediaType_GetUINT32(media_type, &MF_MT_VIDEO_NOMINAL_RANGE, &format->videoInfo.NominalRange);
+    IMFMediaType_GetBlob(media_type, &MF_MT_GEOMETRIC_APERTURE, (UINT8 *)&format->videoInfo.GeometricAperture,
+           sizeof(format->videoInfo.GeometricAperture), NULL);
+    IMFMediaType_GetBlob(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE, (UINT8 *)&format->videoInfo.MinimumDisplayAperture,
+           sizeof(format->videoInfo.MinimumDisplayAperture), NULL);
+
+    /* Video flags. */
+    if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_PAD_CONTROL_FLAGS, &flags)))
+        format->videoInfo.VideoFlags |= flags;
+    if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_SOURCE_CONTENT_HINT, &flags)))
+        format->videoInfo.VideoFlags |= flags;
+    if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_DRM_FLAGS, &flags)))
+        format->videoInfo.VideoFlags |= flags;
+    if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_PAN_SCAN_ENABLED, &flags)) && !!flags)
+    {
+        format->videoInfo.VideoFlags |= MFVideoFlag_PanScanEnabled;
+        IMFMediaType_GetBlob(media_type, &MF_MT_PAN_SCAN_APERTURE, (UINT8 *)&format->videoInfo.PanScanAperture,
+               sizeof(format->videoInfo.PanScanAperture), NULL);
+    }
+    if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_DEFAULT_STRIDE, (UINT32 *)&stride)) && stride < 0)
+        format->videoInfo.VideoFlags |= MFVideoFlag_BottomUpLinearRep;
+
+    if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_AVG_BITRATE, &avgrate)))
+        format->compressedInfo.AvgBitrate = avgrate;
+    if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_AVG_BIT_ERROR_RATE, &avgrate)))
+        format->compressedInfo.AvgBitErrorRate = avgrate;
+    IMFMediaType_GetUINT32(media_type, &MF_MT_MAX_KEYFRAME_SPACING, &format->compressedInfo.MaxKeyFrameSpacing);
+
+    /* Palette. */
+    if (palette_size)
+    {
+        format->surfaceInfo.PaletteEntries = palette_size / sizeof(*format->surfaceInfo.Palette);
+        IMFMediaType_GetBlob(media_type, &MF_MT_PALETTE, (UINT8 *)format->surfaceInfo.Palette, palette_size, NULL);
+    }
+
+    return S_OK;
+}
diff --git a/dlls/mfplat/mfplat.spec b/dlls/mfplat/mfplat.spec
index 01f9efaecaa..e6069424fc9 100644
--- a/dlls/mfplat/mfplat.spec
+++ b/dlls/mfplat/mfplat.spec
@@ -52,7 +52,7 @@
 @ stdcall MFCreateMFByteStreamOnStream(ptr ptr)
 @ stdcall MFCreateMFByteStreamOnStreamEx(ptr ptr)
 @ stdcall MFCreateMFByteStreamWrapper(ptr ptr)
-@ stub MFCreateMFVideoFormatFromMFMediaType
+@ stdcall MFCreateMFVideoFormatFromMFMediaType(ptr ptr ptr)
 @ stdcall MFCreateMediaBufferFromMediaType(ptr int64 long long ptr)
 @ stub MFCreateMediaBufferWrapper
 @ stdcall MFCreateMediaEvent(long ptr long ptr ptr)
diff --git a/dlls/mfplat/tests/mfplat.c b/dlls/mfplat/tests/mfplat.c
index 8a52279a081..aac6f734583 100644
--- a/dlls/mfplat/tests/mfplat.c
+++ b/dlls/mfplat/tests/mfplat.c
@@ -5262,6 +5262,25 @@ static void test_MFInitMediaTypeFromWaveFormatEx(void)
     IMFMediaType_Release(mediatype);
 }
 
+static void test_MFCreateMFVideoFormatFromMFMediaType(void)
+{
+    MFVIDEOFORMAT *video_format;
+    IMFMediaType *media_type;
+    UINT32 size;
+    HRESULT hr;
+
+    hr = MFCreateMediaType(&media_type);
+    ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
+
+    hr = MFCreateMFVideoFormatFromMFMediaType(media_type, &video_format, &size);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!!video_format, "Unexpected format.\n");
+    ok(video_format->dwSize == size && size == sizeof(*video_format), "Unexpected size %u.\n", size);
+    CoTaskMemFree(video_format);
+
+    IMFMediaType_Release(media_type);
+}
+
 START_TEST(mfplat)
 {
     char **argv;
@@ -5317,6 +5336,7 @@ START_TEST(mfplat)
     test_MFCreate2DMediaBuffer();
     test_MFCreateMediaBufferFromMediaType();
     test_MFInitMediaTypeFromWaveFormatEx();
+    test_MFCreateMFVideoFormatFromMFMediaType();
 
     CoUninitialize();
 }
diff --git a/include/mfapi.h b/include/mfapi.h
index 4da25341c68..e86fb526f13 100644
--- a/include/mfapi.h
+++ b/include/mfapi.h
@@ -509,6 +509,7 @@ HRESULT WINAPI MFCreateMediaBufferFromMediaType(IMFMediaType *media_type, LONGLO
 HRESULT WINAPI MFCreateMediaEvent(MediaEventType type, REFGUID extended_type, HRESULT status,
                                   const PROPVARIANT *value, IMFMediaEvent **event);
 HRESULT WINAPI MFCreateMediaType(IMFMediaType **type);
+HRESULT WINAPI MFCreateMFVideoFormatFromMFMediaType(IMFMediaType *media_type, MFVIDEOFORMAT **video_format, UINT32 *size);
 HRESULT WINAPI MFCreateSample(IMFSample **sample);
 HRESULT WINAPI MFCreateVideoMediaTypeFromSubtype(const GUID *subtype, IMFVideoMediaType **media_type);
 HRESULT WINAPI MFCreateMemoryBuffer(DWORD max_length, IMFMediaBuffer **buffer);
From cb43efe901ab03bc90895b9559f501e8f035fce1 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 23 Jun 2020 14:29:05 +0300
Subject: [PATCH] mfplat: Implement GetVideoFormat().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/mediatype.c | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/dlls/mfplat/mediatype.c b/dlls/mfplat/mediatype.c
index 66722a84b6f..843c09c5e09 100644
--- a/dlls/mfplat/mediatype.c
+++ b/dlls/mfplat/mediatype.c
@@ -38,6 +38,7 @@ struct media_type
     struct attributes attributes;
     IMFMediaType IMFMediaType_iface;
     IMFVideoMediaType IMFVideoMediaType_iface;
+    MFVIDEOFORMAT *video_format;
 };
 
 struct stream_desc
@@ -648,6 +649,7 @@ static ULONG WINAPI video_mediatype_Release(IMFVideoMediaType *iface)
     if (!refcount)
     {
         clear_attributes_object(&media_type->attributes);
+        CoTaskMemFree(media_type->video_format);
         heap_free(media_type);
     }
 
@@ -971,9 +973,17 @@ static HRESULT WINAPI video_mediatype_FreeRepresentation(IMFVideoMediaType *ifac
 
 static const MFVIDEOFORMAT * WINAPI video_mediatype_GetVideoFormat(IMFVideoMediaType *iface)
 {
-    FIXME("%p.\n", iface);
+    struct media_type *media_type = impl_from_IMFVideoMediaType(iface);
+    unsigned int size;
+    HRESULT hr;
+
+    TRACE("%p.\n", iface);
+
+    CoTaskMemFree(media_type->video_format);
+    if (FAILED(hr = MFCreateMFVideoFormatFromMFMediaType((IMFMediaType *)iface, &media_type->video_format, &size)))
+        WARN("Failed to create format description, hr %#x.\n", hr);
 
-    return NULL;
+    return media_type->video_format;
 }
 
 static HRESULT WINAPI video_mediatype_GetVideoRepresentation(IMFVideoMediaType *iface, GUID representation,
From e0b5edf8964ed320fb628cd97bd1bf9b0aa90b0e Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 23 Jun 2020 14:31:17 +0300
Subject: [PATCH] dxva2: Implement DXVA2CreateVideoService().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dxva2/main.c        | 38 +++++++++++++++++++++++-----------
 dlls/dxva2/tests/dxva2.c | 44 +++++++++++++++++++++++++++++++++++++++-
 2 files changed, 69 insertions(+), 13 deletions(-)

diff --git a/dlls/dxva2/main.c b/dlls/dxva2/main.c
index 7ba8d9806b1..bbee697674f 100644
--- a/dlls/dxva2/main.c
+++ b/dlls/dxva2/main.c
@@ -101,6 +101,7 @@ static HRESULT WINAPI device_manager_processor_service_QueryInterface(IDirectXVi
         REFIID riid, void **obj)
 {
     if (IsEqualIID(riid, &IID_IDirectXVideoProcessorService) ||
+            IsEqualIID(riid, &IID_IDirectXVideoAccelerationService) ||
             IsEqualIID(riid, &IID_IUnknown))
     {
         *obj = iface;
@@ -401,16 +402,9 @@ static HRESULT WINAPI device_manager_GetVideoService(IDirect3DDeviceManager9 *if
             hr = DXVA2_E_NEW_VIDEO_DEVICE;
         else if (!(flags & HANDLE_FLAG_OPEN))
             hr = E_HANDLE;
-        else if (IsEqualIID(riid, &IID_IDirectXVideoProcessorService))
-        {
-            *obj = &manager->IDirectXVideoProcessorService_iface;
-            IUnknown_AddRef((IUnknown *)*obj);
-        }
         else
-        {
-            WARN("Unsupported service %s.\n", debugstr_guid(riid));
-            hr = E_UNEXPECTED;
-        }
+            hr = IDirectXVideoProcessorService_QueryInterface(&manager->IDirectXVideoProcessorService_iface,
+                    riid, obj);
     }
     LeaveCriticalSection(&manager->cs);
 
@@ -462,11 +456,31 @@ HRESULT WINAPI DXVA2CreateDirect3DDeviceManager9(UINT *token, IDirect3DDeviceMan
     return S_OK;
 }
 
-HRESULT WINAPI DXVA2CreateVideoService( IDirect3DDevice9 *device, REFIID riid, void **ppv )
+HRESULT WINAPI DXVA2CreateVideoService(IDirect3DDevice9 *device, REFIID riid, void **obj)
 {
-    FIXME("(%p, %s, %p): stub\n", device, debugstr_guid(riid), ppv);
+    IDirect3DDeviceManager9 *manager;
+    HANDLE handle;
+    HRESULT hr;
+    UINT token;
 
-    return E_NOTIMPL;
+    TRACE("%p, %s, %p.\n", device, debugstr_guid(riid), obj);
+
+    if (FAILED(hr = DXVA2CreateDirect3DDeviceManager9(&token, &manager)))
+        return hr;
+
+    if (FAILED(hr = IDirect3DDeviceManager9_ResetDevice(manager, device, token)))
+        goto done;
+
+    if (FAILED(hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle)))
+        goto done;
+
+    hr = IDirect3DDeviceManager9_GetVideoService(manager, handle, riid, obj);
+    IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle);
+
+done:
+    IDirect3DDeviceManager9_Release(manager);
+
+    return hr;
 }
 
 BOOL WINAPI DegaussMonitor( HMONITOR monitor )
diff --git a/dlls/dxva2/tests/dxva2.c b/dlls/dxva2/tests/dxva2.c
index 65771fb5874..e3e8dd2e66c 100644
--- a/dlls/dxva2/tests/dxva2.c
+++ b/dlls/dxva2/tests/dxva2.c
@@ -62,8 +62,10 @@ static IDirect3DDevice9 *create_device(IDirect3D9 *d3d9, HWND focus_window)
 static void test_device_manager(void)
 {
     IDirectXVideoProcessorService *processor_service;
-    IDirect3DDevice9 *device, *device2;
+    IDirectXVideoAccelerationService *accel_service;
+    IDirect3DDevice9 *device, *device2, *device3;
     IDirect3DDeviceManager9 *manager;
+    IDirect3DSurface9 *surface;
     int refcount, refcount2;
     HANDLE handle, handle1;
     IDirect3D9 *d3d;
@@ -148,6 +150,46 @@ static void test_device_manager(void)
     hr = IDirect3DDeviceManager9_TestDevice(manager, handle);
     ok(hr == DXVA2_E_NEW_VIDEO_DEVICE, "Unexpected hr %#x.\n", hr);
 
+    /* Acceleration service. */
+    hr = DXVA2CreateVideoService(device, &IID_IDirectXVideoAccelerationService, (void **)&accel_service);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirectXVideoAccelerationService_CreateSurface(accel_service, 64, 64, 1, D3DFMT_X8R8G8B8,
+            D3DPOOL_DEFAULT, 0, DXVA2_VideoProcessorRenderTarget, &surface, NULL);
+todo_wine
+    ok(hr == S_OK, "Failed to create a surface, hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+        IDirect3DSurface9_Release(surface);
+
+    IDirectXVideoAccelerationService_Release(accel_service);
+
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_GetVideoService(manager, handle, &IID_IDirectXVideoAccelerationService,
+            (void **)&accel_service);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirectXVideoAccelerationService_CreateSurface(accel_service, 64, 64, 1, D3DFMT_X8R8G8B8,
+            D3DPOOL_DEFAULT, 0, DXVA2_VideoProcessorRenderTarget, &surface, NULL);
+todo_wine
+    ok(hr == S_OK, "Failed to create a surface, hr %#x.\n", hr);
+
+    if (SUCCEEDED(hr))
+    {
+        hr = IDirect3DSurface9_GetDevice(surface, &device3);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+        ok(device2 == device3, "Unexpected device.\n");
+        IDirect3DDevice9_Release(device3);
+
+        IDirect3DSurface9_Release(surface);
+    }
+
+    IDirectXVideoAccelerationService_Release(accel_service);
+
     IDirect3DDevice9_Release(device);
     IDirect3DDevice9_Release(device2);
 
From 3ba3d228fb20d35ebd04dbf7f8e223228228a6c8 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 24 Jun 2020 16:25:35 +0300
Subject: [PATCH] evr: Implement MFT_MESSAGE_SET_D3D_MANAGER for default mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c | 33 +++++++++++++++++++++++++++++++--
 1 file changed, 31 insertions(+), 2 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index eaea037b693..931554b5479 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -21,6 +21,7 @@
 #include "wine/debug.h"
 #include "evr.h"
 #include "d3d9.h"
+#include "dxva2api.h"
 #include "mfapi.h"
 #include "mferror.h"
 
@@ -47,6 +48,9 @@ struct video_mixer
     struct input_stream inputs[MAX_MIXER_INPUT_STREAMS];
     unsigned int input_ids[MAX_MIXER_INPUT_STREAMS];
     unsigned int input_count;
+
+    IDirect3DDeviceManager9 *device_manager;
+
     CRITICAL_SECTION cs;
 };
 
@@ -151,6 +155,8 @@ static ULONG WINAPI video_mixer_transform_Release(IMFTransform *iface)
             if (mixer->inputs[i].attributes)
                 IMFAttributes_Release(mixer->inputs[i].attributes);
         }
+        if (mixer->device_manager)
+            IDirect3DDeviceManager9_Release(mixer->device_manager);
         DeleteCriticalSection(&mixer->cs);
         free(mixer);
     }
@@ -444,9 +450,32 @@ static HRESULT WINAPI video_mixer_transform_ProcessEvent(IMFTransform *iface, DW
 
 static HRESULT WINAPI video_mixer_transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
-    FIXME("%p, %u, %#lx.\n", iface, message, param);
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %#lx.\n", iface, message, param);
+
+    switch (message)
+    {
+        case MFT_MESSAGE_SET_D3D_MANAGER:
+
+            EnterCriticalSection(&mixer->cs);
+
+            if (mixer->device_manager)
+                IDirect3DDeviceManager9_Release(mixer->device_manager);
+            mixer->device_manager = NULL;
+            if (param)
+                hr = IUnknown_QueryInterface((IUnknown *)param, &IID_IDirect3DDeviceManager9, (void **)&mixer->device_manager);
+
+            LeaveCriticalSection(&mixer->cs);
+
+            break;
+        default:
+            WARN("Message not handled %d.\n", message);
+            hr = E_NOTIMPL;
+    }
+
+    return hr;
 }
 
 static HRESULT WINAPI video_mixer_transform_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
From 6ea77ccfebe56b2dd21b3e70bea86cc59b9495d5 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 24 Jun 2020 16:25:36 +0300
Subject: [PATCH] evr: Implement input type validation for the mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c           |  73 +++++++++++++++++++++--
 dlls/evr/tests/Makefile.in |   2 +-
 dlls/evr/tests/evr.c       | 116 ++++++++++++++++++++++++++++++++++++-
 3 files changed, 185 insertions(+), 6 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 931554b5479..a65e82d4ca8 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -379,7 +379,7 @@ static HRESULT WINAPI video_mixer_transform_AddInputStreams(IMFTransform *iface,
 static HRESULT WINAPI video_mixer_transform_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
 
     return E_NOTIMPL;
 }
@@ -392,11 +392,76 @@ static HRESULT WINAPI video_mixer_transform_GetOutputAvailableType(IMFTransform
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI video_mixer_transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+static HRESULT video_mixer_init_dxva_videodesc(IMFMediaType *media_type, DXVA2_VideoDesc *video_desc)
 {
-    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+    const MFVIDEOFORMAT *video_format;
+    IMFVideoMediaType *video_type;
+    BOOL is_compressed = TRUE;
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    if (FAILED(IMFMediaType_QueryInterface(media_type, &IID_IMFVideoMediaType, (void **)&video_type)))
+        return MF_E_INVALIDMEDIATYPE;
+
+    video_format = IMFVideoMediaType_GetVideoFormat(video_type);
+    IMFVideoMediaType_IsCompressedFormat(video_type, &is_compressed);
+
+    if (!video_format || !video_format->videoInfo.dwWidth || !video_format->videoInfo.dwHeight || is_compressed)
+    {
+        hr = MF_E_INVALIDMEDIATYPE;
+        goto done;
+    }
+
+    memset(video_desc, 0, sizeof(*video_desc));
+    video_desc->SampleWidth = video_format->videoInfo.dwWidth;
+    video_desc->SampleWidth = video_format->videoInfo.dwHeight;
+    video_desc->Format = video_format->surfaceInfo.Format;
+
+done:
+    IMFVideoMediaType_Release(video_type);
+
+    return hr;
+}
+
+static HRESULT WINAPI video_mixer_transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *media_type, DWORD flags)
+{
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    IDirectXVideoProcessorService *service;
+    DXVA2_VideoDesc video_desc;
+    HRESULT hr = E_NOTIMPL;
+    HANDLE handle;
+
+    TRACE("%p, %u, %p, %#x.\n", iface, id, media_type, flags);
+
+    if (id)
+    {
+        FIXME("Unimplemented for substreams.\n");
+        return E_NOTIMPL;
+    }
+
+    EnterCriticalSection(&mixer->cs);
+
+    if (!mixer->device_manager)
+        hr = MF_E_NOT_INITIALIZED;
+    else
+    {
+        if (SUCCEEDED(hr = IDirect3DDeviceManager9_OpenDeviceHandle(mixer->device_manager, &handle)))
+        {
+            if (SUCCEEDED(hr = IDirect3DDeviceManager9_GetVideoService(mixer->device_manager, handle,
+                    &IID_IDirectXVideoProcessorService, (void **)&service)))
+            {
+                if (SUCCEEDED(hr = video_mixer_init_dxva_videodesc(media_type, &video_desc)))
+                {
+                    FIXME("Probe for supported devices.\n");
+                    hr = E_NOTIMPL;
+                }
+            }
+            IDirect3DDeviceManager9_CloseDeviceHandle(mixer->device_manager, handle);
+        }
+    }
+
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_mixer_transform_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
diff --git a/dlls/evr/tests/Makefile.in b/dlls/evr/tests/Makefile.in
index 8253c4d7fb4..5bd82277d1b 100644
--- a/dlls/evr/tests/Makefile.in
+++ b/dlls/evr/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = evr.dll
-IMPORTS   = mfuuid strmiids uuid dxguid ole32 oleaut32 evr d3d9 user32
+IMPORTS   = dxva2 mfplat mfuuid strmiids uuid dxguid ole32 oleaut32 evr d3d9 user32
 
 C_SRCS = \
 	evr.c
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 9365856d1eb..44819c1b387 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -19,16 +19,20 @@
  */
 
 #define COBJMACROS
+
 #include "dshow.h"
 #include "wine/test.h"
 #include "d3d9.h"
 #include "evr.h"
+#include "mferror.h"
+#include "mfapi.h"
 #include "initguid.h"
 #include "dxva2api.h"
-#include "mferror.h"
 
 static const WCHAR sink_id[] = {'E','V','R',' ','I','n','p','u','t','0',0};
 
+static HRESULT (WINAPI *pMFCreateVideoMediaTypeFromSubtype)(const GUID *subtype, IMFVideoMediaType **video_type);
+
 static HWND create_window(void)
 {
     RECT r = {0, 0, 640, 480};
@@ -626,16 +630,126 @@ todo_wine
     DestroyWindow(window);
 }
 
+static void test_default_mixer_type_negotiation(void)
+{
+    IDirect3DDeviceManager9 *manager;
+    IMFVideoMediaType *video_type;
+    IMFMediaType *media_type;
+    IDirect3DDevice9 *device;
+    IMFTransform *transform;
+    IDirect3D9 *d3d;
+    HWND window;
+    HRESULT hr;
+    UINT token;
+
+    if (!pMFCreateVideoMediaTypeFromSubtype)
+    {
+        win_skip("Skipping mixer types tests.\n");
+        return;
+    }
+
+    hr = MFCreateVideoMixer(NULL, &IID_IDirect3DDevice9, &IID_IMFTransform, (void **)&transform);
+    ok(hr == S_OK, "Failed to create default mixer, hr %#x.\n", hr);
+
+    hr = IMFTransform_GetInputAvailableType(transform, 0, 0, &media_type);
+    ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type);
+todo_wine
+    ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
+
+    hr = MFCreateMediaType(&media_type);
+    ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
+
+    hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
+
+    hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, &MFVideoFormat_RGB32);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
+
+    hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
+    ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
+
+    /* Now try with device manager. */
+
+    window = create_window();
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+    ok(!!d3d, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d, window)))
+    {
+        skip("Failed to create a D3D device, skipping tests.\n");
+        goto done;
+    }
+
+    hr = DXVA2CreateDirect3DDeviceManager9(&token, &manager);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_ProcessMessage(transform, MFT_MESSAGE_SET_D3D_MANAGER, (ULONG_PTR)manager);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* Now manager is not initialized. */
+    hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
+    ok(hr == DXVA2_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_ResetDevice(manager, device, token);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* And now type description is incomplete. */
+    hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
+    IMFMediaType_Release(media_type);
+
+    hr = pMFCreateVideoMediaTypeFromSubtype(&MFVideoFormat_RGB32, &video_type);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* Partially initialized type. */
+    hr = IMFTransform_SetInputType(transform, 0, (IMFMediaType *)video_type, 0);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
+
+    /* Only required data - frame size and uncompressed marker. */
+    hr = IMFVideoMediaType_SetUINT64(video_type, &MF_MT_FRAME_SIZE, (UINT64)640 << 32 | 480);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    hr = IMFVideoMediaType_SetUINT32(video_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_SetInputType(transform, 0, (IMFMediaType *)video_type, 0);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+    {
+        ok(media_type != (IMFMediaType *)video_type, "Unexpected pointer.\n");
+        IMFMediaType_Release(media_type);
+    }
+
+    IMFVideoMediaType_Release(video_type);
+
+    IDirect3DDeviceManager9_Release(manager);
+
+    IDirect3DDevice9_Release(device);
+
+done:
+    IMFTransform_Release(transform);
+    IDirect3D9_Release(d3d);
+    DestroyWindow(window);
+}
+
 START_TEST(evr)
 {
     CoInitialize(NULL);
 
+    pMFCreateVideoMediaTypeFromSubtype = (void *)GetProcAddress(GetModuleHandleA("mfplat.dll"), "MFCreateVideoMediaTypeFromSubtype");
+
     test_aggregation();
     test_interfaces();
     test_enum_pins();
     test_find_pin();
     test_pin_info();
     test_default_mixer();
+    test_default_mixer_type_negotiation();
     test_surface_sample();
 
     CoUninitialize();
From 6aeb891d529d821fa62e26c177c186c3acb25f23 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 24 Jun 2020 16:25:37 +0300
Subject: [PATCH] include: Make inline helpers compatible with NONAMELESSUNION.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 include/dxva2api.idl | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/include/dxva2api.idl b/include/dxva2api.idl
index eb4a26509a1..04e620b7be8 100644
--- a/include/dxva2api.idl
+++ b/include/dxva2api.idl
@@ -805,23 +805,24 @@ cpp_quote("#endif")
 
 cpp_quote("static inline DXVA2_Fixed32 DXVA2_Fixed32OpaqueAlpha(void) {")
 cpp_quote("  DXVA2_Fixed32 f32;")
-cpp_quote("  f32.ll = 0 + (1 << 16);")
+cpp_quote("  *(LONG *)&f32 = 0 + (1 << 16);")
 cpp_quote("  return f32;")
 cpp_quote("}")
 cpp_quote("")
 cpp_quote("static inline DXVA2_Fixed32 DXVA2_Fixed32TransparentAlpha(void) {")
-cpp_quote("  DXVA2_Fixed32 f32;")
-cpp_quote("  f32.ll = 0;")
+cpp_quote("  DXVA2_Fixed32 f32 = {{{ 0 }}};")
 cpp_quote("  return f32;")
 cpp_quote("}")
 cpp_quote("")
 cpp_quote("static inline float DXVA2FixedToFloat(DXVA2_Fixed32 f32) {")
-cpp_quote("  return (float)f32.Value + (float)f32.Fraction / (1 << 16);")
+cpp_quote("  struct { USHORT Fraction; SHORT Value; } *_f32 = (void *)&f32;")
+cpp_quote("  return (float)_f32->Value + (float)_f32->Fraction / (1 << 16);")
 cpp_quote("}")
 cpp_quote("")
 cpp_quote("static inline DXVA2_Fixed32 DXVA2FloatToFixed(float f) {")
 cpp_quote("  DXVA2_Fixed32 f32;")
-cpp_quote("  f32.Value    = ((ULONG) (f * (1 << 16))) >> 16;")
-cpp_quote("  f32.Fraction = ((ULONG) (f * (1 << 16))) & 0xFFFF;")
+cpp_quote("  struct { USHORT Fraction; SHORT Value; } *_f32 = (void *)&f32;")
+cpp_quote("  _f32->Value    = ((ULONG) (f * (1 << 16))) >> 16;")
+cpp_quote("  _f32->Fraction = ((ULONG) (f * (1 << 16))) & 0xFFFF;")
 cpp_quote("  return f32;")
 cpp_quote("}")
From 1614769407e397956dd92de3c1bcd4f364f3dc08 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 24 Jun 2020 16:25:38 +0300
Subject: [PATCH] mfplat: Add MFConvertColorInfoToDXVA().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/mediatype.c | 34 ++++++++++++++++++++++++++++++++++
 dlls/mfplat/mfplat.spec |  2 +-
 include/mfapi.h         |  1 +
 3 files changed, 36 insertions(+), 1 deletion(-)

diff --git a/dlls/mfplat/mediatype.c b/dlls/mfplat/mediatype.c
index 843c09c5e09..5eaa4fdd08d 100644
--- a/dlls/mfplat/mediatype.c
+++ b/dlls/mfplat/mediatype.c
@@ -23,6 +23,7 @@
 #include "initguid.h"
 #include "ks.h"
 #include "ksmedia.h"
+#include "dxva2api.h"
 
 #include "wine/debug.h"
 
@@ -2748,3 +2749,36 @@ HRESULT WINAPI MFCreateMFVideoFormatFromMFMediaType(IMFMediaType *media_type, MF
 
     return S_OK;
 }
+
+/***********************************************************************
+ *      MFConvertColorInfoToDXVA (mfplat.@)
+ */
+HRESULT WINAPI MFConvertColorInfoToDXVA(DWORD *dxva_info, const MFVIDEOFORMAT *format)
+{
+    struct
+    {
+        UINT SampleFormat           : 8;
+        UINT VideoChromaSubsampling : 4;
+        UINT NominalRange           : 3;
+        UINT VideoTransferMatrix    : 3;
+        UINT VideoLighting          : 4;
+        UINT VideoPrimaries         : 5;
+        UINT VideoTransferFunction  : 5;
+    } *dxva_format = (void *)dxva_info;
+
+    TRACE("%p, %p.\n", dxva_info, format);
+
+    if (format->videoInfo.InterlaceMode == MFVideoInterlace_MixedInterlaceOrProgressive)
+        dxva_format->SampleFormat = DXVA2_SampleFieldInterleavedEvenFirst;
+    else
+        dxva_format->SampleFormat = format->videoInfo.InterlaceMode;
+
+    dxva_format->VideoChromaSubsampling = format->videoInfo.SourceChromaSubsampling;
+    dxva_format->NominalRange = format->videoInfo.NominalRange;
+    dxva_format->VideoTransferMatrix = format->videoInfo.TransferMatrix;
+    dxva_format->VideoLighting = format->videoInfo.SourceLighting;
+    dxva_format->VideoPrimaries = format->videoInfo.ColorPrimaries;
+    dxva_format->VideoTransferFunction = format->videoInfo.TransferFunction;
+
+    return S_OK;
+}
diff --git a/dlls/mfplat/mfplat.spec b/dlls/mfplat/mfplat.spec
index e6069424fc9..16be972e5bd 100644
--- a/dlls/mfplat/mfplat.spec
+++ b/dlls/mfplat/mfplat.spec
@@ -34,7 +34,7 @@
 @ stdcall MFCompareFullToPartialMediaType(ptr ptr)
 @ stub MFCompareSockaddrAddresses
 @ stub MFConvertColorInfoFromDXVA
-@ stub MFConvertColorInfoToDXVA
+@ stdcall MFConvertColorInfoToDXVA(ptr ptr)
 @ stub MFConvertFromFP16Array
 @ stub MFConvertToFP16Array
 @ stdcall MFCopyImage(ptr long ptr long long long)
diff --git a/include/mfapi.h b/include/mfapi.h
index e86fb526f13..06a5412cbc5 100644
--- a/include/mfapi.h
+++ b/include/mfapi.h
@@ -494,6 +494,7 @@ HRESULT WINAPI MFCalculateImageSize(REFGUID subtype, UINT32 width, UINT32 height
 HRESULT WINAPI MFCancelCreateFile(IUnknown *cancel_cookie);
 HRESULT WINAPI MFCancelWorkItem(MFWORKITEM_KEY key);
 BOOL    WINAPI MFCompareFullToPartialMediaType(IMFMediaType *full_type, IMFMediaType *partial_type);
+HRESULT WINAPI MFConvertColorInfoToDXVA(DWORD *dxva_info, const MFVIDEOFORMAT *format);
 HRESULT WINAPI MFCopyImage(BYTE *dest, LONG deststride, const BYTE *src, LONG srcstride, DWORD width, DWORD lines);
 HRESULT WINAPI MFCreate2DMediaBuffer(DWORD width, DWORD height, DWORD fourcc, BOOL bottom_up, IMFMediaBuffer **buffer);
 HRESULT WINAPI MFCreateAlignedMemoryBuffer(DWORD max_length, DWORD alignment, IMFMediaBuffer **buffer);
From 1f57af100f43c9ecd0d30b0f1200f5c605b18297 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 25 Jun 2020 17:57:57 +0300
Subject: [PATCH] include: Add some more EVR mixer interfaces.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 include/Makefile.in |   1 +
 include/evr9.idl    | 114 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 115 insertions(+)
 create mode 100644 include/evr9.idl

diff --git a/include/Makefile.in b/include/Makefile.in
index 9f70e72b4c7..90fb873f203 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -276,6 +276,7 @@ SOURCES = \
 	evntprov.h \
 	evntrace.h \
 	evr.idl \
+	evr9.idl \
 	excpt.h \
 	exdisp.idl \
 	exdispid.h \
diff --git a/include/evr9.idl b/include/evr9.idl
new file mode 100644
index 00000000000..1572d878387
--- /dev/null
+++ b/include/evr9.idl
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2020 Nikolay Sivov for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+import "unknwn.idl";
+import "evr.idl";
+import "dxva2api.idl";
+
+typedef struct MFVideoAlphaBitmapParams
+{
+    DWORD dwFlags;
+    COLORREF clrSrcKey;
+    RECT rcSrc;
+    MFVideoNormalizedRect nrcDest;
+    FLOAT fAlpha;
+    DWORD dwFilterMode;
+} MFVideoAlphaBitmapParams;
+
+typedef struct MFVideoAlphaBitmap
+{
+    BOOL GetBitmapFromDC;
+    union
+    {
+        HDC hdc;
+        IDirect3DSurface9 *pDDS;
+    } bitmap;
+    MFVideoAlphaBitmapParams params;
+} MFVideoAlphaBitmap;
+
+[
+    object,
+    uuid(814c7b20-0fdb-4eec-af8f-f957c8f69edc),
+    local
+]
+interface IMFVideoMixerBitmap : IUnknown
+{
+    HRESULT SetAlphaBitmap(
+        [in] const MFVideoAlphaBitmap *bitmap
+    );
+    HRESULT ClearAlphaBitmap(void);
+    HRESULT UpdateAlphaBitmapParameters(
+        [in] const MFVideoAlphaBitmapParams *params
+    );
+    HRESULT GetAlphaBitmapParameters(
+        [out] MFVideoAlphaBitmapParams *params
+    );
+}
+
+[
+    object,
+    uuid(6AB0000C-FECE-4d1f-A2AC-A9573530656E),
+    pointer_default(unique)
+]
+interface IMFVideoProcessor : IUnknown
+{
+    HRESULT GetAvailableVideoProcessorModes(
+        [out] UINT *count,
+        [out, size_is(*count)] GUID **modes
+    );
+    HRESULT GetVideoProcessorCaps(
+        [in] GUID *mode,
+        [out] DXVA2_VideoProcessorCaps *caps
+    );
+    HRESULT GetVideoProcessorMode(
+        [out] GUID *mode
+    );
+    HRESULT SetVideoProcessorMode(
+        [in] GUID *mode
+    );
+    HRESULT GetProcAmpRange(
+        [in] DWORD prop,
+        [out] DXVA2_ValueRange *range
+    );
+    HRESULT GetProcAmpValues(
+        [in] DWORD flags,
+        [out] DXVA2_ProcAmpValues *values
+    );
+    HRESULT SetProcAmpValues(
+        [in] DWORD flags,
+        [in] DXVA2_ProcAmpValues *values
+    );
+    HRESULT GetFilteringRange(
+        [in] DWORD prop,
+        [out] DXVA2_ValueRange *range
+    );
+    HRESULT GetFilteringValue(
+        [in] DWORD prop,
+        [out] DXVA2_Fixed32 *value
+    );
+    HRESULT SetFilteringValue(
+        [in] DWORD prop,
+        [in] DXVA2_Fixed32 *value
+    );
+    HRESULT GetBackgroundColor(
+        [out] COLORREF *color
+    );
+    HRESULT SetBackgroundColor(
+        [in] COLORREF color
+    );
+}
From c8b3ae700bda3c6588a536d58df2beda7e60b8ca Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 25 Jun 2020 17:57:58 +0300
Subject: [PATCH] evr/tests: Add some tests for supported mixer interfaces.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/tests/evr.c | 26 +++++++++++++++++++++++++-
 1 file changed, 25 insertions(+), 1 deletion(-)

diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 44819c1b387..6e51dba9929 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -27,7 +27,7 @@
 #include "mferror.h"
 #include "mfapi.h"
 #include "initguid.h"
-#include "dxva2api.h"
+#include "evr9.h"
 
 static const WCHAR sink_id[] = {'E','V','R',' ','I','n','p','u','t','0',0};
 
@@ -396,6 +396,30 @@ static void test_default_mixer(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
+    hr = IMFTransform_QueryInterface(transform, &IID_IMFGetService, (void **)&unk);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+        IUnknown_Release(unk);
+
+    hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoMixerBitmap, (void **)&unk);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+        IUnknown_Release(unk);
+
+    hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoPositionMapper, (void **)&unk);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+        IUnknown_Release(unk);
+
+    hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoProcessor, (void **)&unk);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+        IUnknown_Release(unk);
+
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoMixerControl, (void **)&unk);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
From e4791f6f9bc02341b9bc6953b05a5c1050443a33 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 25 Jun 2020 17:57:59 +0300
Subject: [PATCH] evr: Add IMFGetService stub for the mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 44 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c |  4 +---
 2 files changed, 45 insertions(+), 3 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index a65e82d4ca8..c835a62ad93 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -43,6 +43,7 @@ struct video_mixer
     IMFVideoDeviceID IMFVideoDeviceID_iface;
     IMFTopologyServiceLookupClient IMFTopologyServiceLookupClient_iface;
     IMFVideoMixerControl2 IMFVideoMixerControl2_iface;
+    IMFGetService IMFGetService_iface;
     LONG refcount;
 
     struct input_stream inputs[MAX_MIXER_INPUT_STREAMS];
@@ -74,6 +75,11 @@ static struct video_mixer *impl_from_IMFVideoMixerControl2(IMFVideoMixerControl2
     return CONTAINING_RECORD(iface, struct video_mixer, IMFVideoMixerControl2_iface);
 }
 
+static struct video_mixer *impl_from_IMFGetService(IMFGetService *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_mixer, IMFGetService_iface);
+}
+
 static int video_mixer_compare_input_id(const void *a, const void *b)
 {
     const unsigned int *key = a;
@@ -119,6 +125,10 @@ static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface,
     {
         *obj = &mixer->IMFVideoMixerControl2_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFGetService))
+    {
+        *obj = &mixer->IMFGetService_iface;
+    }
     else
     {
         WARN("Unsupported interface %s.\n", debugstr_guid(riid));
@@ -744,6 +754,39 @@ static const IMFVideoMixerControl2Vtbl video_mixer_control_vtbl =
     video_mixer_control_GetMixingPrefs,
 };
 
+static HRESULT WINAPI video_mixer_getservice_QueryInterface(IMFGetService *iface, REFIID riid, void **obj)
+{
+    struct video_mixer *mixer = impl_from_IMFGetService(iface);
+    return IMFTransform_QueryInterface(&mixer->IMFTransform_iface, riid, obj);
+}
+
+static ULONG WINAPI video_mixer_getservice_AddRef(IMFGetService *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFGetService(iface);
+    return IMFTransform_AddRef(&mixer->IMFTransform_iface);
+}
+
+static ULONG WINAPI video_mixer_getservice_Release(IMFGetService *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFGetService(iface);
+    return IMFTransform_Release(&mixer->IMFTransform_iface);
+}
+
+static HRESULT WINAPI video_mixer_getservice_GetService(IMFGetService *iface, REFGUID service, REFIID riid, void **obj)
+{
+    FIXME("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+
+    return E_NOTIMPL;
+}
+
+static const IMFGetServiceVtbl video_mixer_getservice_vtbl =
+{
+    video_mixer_getservice_QueryInterface,
+    video_mixer_getservice_AddRef,
+    video_mixer_getservice_Release,
+    video_mixer_getservice_GetService,
+};
+
 HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -770,6 +813,7 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
     object->IMFVideoDeviceID_iface.lpVtbl = &video_mixer_device_id_vtbl;
     object->IMFTopologyServiceLookupClient_iface.lpVtbl = &video_mixer_service_client_vtbl;
     object->IMFVideoMixerControl2_iface.lpVtbl = &video_mixer_control_vtbl;
+    object->IMFGetService_iface.lpVtbl = &video_mixer_getservice_vtbl;
     object->refcount = 1;
     object->input_count = 1;
     video_mixer_init_input(&object->inputs[0]);
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 6e51dba9929..5ea1f1a644d 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -397,10 +397,8 @@ static void test_default_mixer(void)
     IUnknown_Release(unk);
 
     hr = IMFTransform_QueryInterface(transform, &IID_IMFGetService, (void **)&unk);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    if (SUCCEEDED(hr))
-        IUnknown_Release(unk);
+    IUnknown_Release(unk);
 
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoMixerBitmap, (void **)&unk);
 todo_wine
From a9431eb0a2f787faa6a18a6a8f0f24136f1fc531 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 25 Jun 2020 17:58:00 +0300
Subject: [PATCH] evr: Add IMFVideoMixerBitmap stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 72 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c |  4 +--
 2 files changed, 73 insertions(+), 3 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index c835a62ad93..1bc4f470401 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -27,6 +27,9 @@
 
 #include "evr_classes.h"
 
+#include "initguid.h"
+#include "evr9.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(evr);
 
 #define MAX_MIXER_INPUT_STREAMS 16
@@ -44,6 +47,7 @@ struct video_mixer
     IMFTopologyServiceLookupClient IMFTopologyServiceLookupClient_iface;
     IMFVideoMixerControl2 IMFVideoMixerControl2_iface;
     IMFGetService IMFGetService_iface;
+    IMFVideoMixerBitmap IMFVideoMixerBitmap_iface;
     LONG refcount;
 
     struct input_stream inputs[MAX_MIXER_INPUT_STREAMS];
@@ -80,6 +84,11 @@ static struct video_mixer *impl_from_IMFGetService(IMFGetService *iface)
     return CONTAINING_RECORD(iface, struct video_mixer, IMFGetService_iface);
 }
 
+static struct video_mixer *impl_from_IMFVideoMixerBitmap(IMFVideoMixerBitmap *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_mixer, IMFVideoMixerBitmap_iface);
+}
+
 static int video_mixer_compare_input_id(const void *a, const void *b)
 {
     const unsigned int *key = a;
@@ -129,6 +138,10 @@ static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface,
     {
         *obj = &mixer->IMFGetService_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFVideoMixerBitmap))
+    {
+        *obj = &mixer->IMFVideoMixerBitmap_iface;
+    }
     else
     {
         WARN("Unsupported interface %s.\n", debugstr_guid(riid));
@@ -787,6 +800,64 @@ static const IMFGetServiceVtbl video_mixer_getservice_vtbl =
     video_mixer_getservice_GetService,
 };
 
+static HRESULT WINAPI video_mixer_bitmap_QueryInterface(IMFVideoMixerBitmap *iface, REFIID riid, void **obj)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoMixerBitmap(iface);
+    return IMFTransform_QueryInterface(&mixer->IMFTransform_iface, riid, obj);
+}
+
+static ULONG WINAPI video_mixer_bitmap_AddRef(IMFVideoMixerBitmap *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoMixerBitmap(iface);
+    return IMFTransform_AddRef(&mixer->IMFTransform_iface);
+}
+
+static ULONG WINAPI video_mixer_bitmap_Release(IMFVideoMixerBitmap *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoMixerBitmap(iface);
+    return IMFTransform_Release(&mixer->IMFTransform_iface);
+}
+
+static HRESULT WINAPI video_mixer_bitmap_SetAlphaBitmap(IMFVideoMixerBitmap *iface, const MFVideoAlphaBitmap *bitmap)
+{
+    FIXME("%p, %p.\n", iface, bitmap);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_bitmap_ClearAlphaBitmap(IMFVideoMixerBitmap *iface)
+{
+    FIXME("%p.\n", iface);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_bitmap_UpdateAlphaBitmapParameters(IMFVideoMixerBitmap *iface,
+        const MFVideoAlphaBitmapParams *params)
+{
+    FIXME("%p, %p.\n", iface, params);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_bitmap_GetAlphaBitmapParameters(IMFVideoMixerBitmap *iface, MFVideoAlphaBitmapParams *params)
+{
+    FIXME("%p, %p.\n", iface, params);
+
+    return E_NOTIMPL;
+}
+
+static const IMFVideoMixerBitmapVtbl video_mixer_bitmap_vtbl =
+{
+    video_mixer_bitmap_QueryInterface,
+    video_mixer_bitmap_AddRef,
+    video_mixer_bitmap_Release,
+    video_mixer_bitmap_SetAlphaBitmap,
+    video_mixer_bitmap_ClearAlphaBitmap,
+    video_mixer_bitmap_UpdateAlphaBitmapParameters,
+    video_mixer_bitmap_GetAlphaBitmapParameters,
+};
+
 HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -814,6 +885,7 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
     object->IMFTopologyServiceLookupClient_iface.lpVtbl = &video_mixer_service_client_vtbl;
     object->IMFVideoMixerControl2_iface.lpVtbl = &video_mixer_control_vtbl;
     object->IMFGetService_iface.lpVtbl = &video_mixer_getservice_vtbl;
+    object->IMFVideoMixerBitmap_iface.lpVtbl = &video_mixer_bitmap_vtbl;
     object->refcount = 1;
     object->input_count = 1;
     video_mixer_init_input(&object->inputs[0]);
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 5ea1f1a644d..4e97f65be09 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -401,10 +401,8 @@ static void test_default_mixer(void)
     IUnknown_Release(unk);
 
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoMixerBitmap, (void **)&unk);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    if (SUCCEEDED(hr))
-        IUnknown_Release(unk);
+    IUnknown_Release(unk);
 
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoPositionMapper, (void **)&unk);
 todo_wine
From cd1cf07c80dd896328f0545e78d66541cef058a1 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 25 Jun 2020 17:58:01 +0300
Subject: [PATCH] evr: Add IMFVideoPositionMapper stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 45 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c |  4 +---
 2 files changed, 46 insertions(+), 3 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 1bc4f470401..7663a28ab10 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -48,6 +48,7 @@ struct video_mixer
     IMFVideoMixerControl2 IMFVideoMixerControl2_iface;
     IMFGetService IMFGetService_iface;
     IMFVideoMixerBitmap IMFVideoMixerBitmap_iface;
+    IMFVideoPositionMapper IMFVideoPositionMapper_iface;
     LONG refcount;
 
     struct input_stream inputs[MAX_MIXER_INPUT_STREAMS];
@@ -89,6 +90,11 @@ static struct video_mixer *impl_from_IMFVideoMixerBitmap(IMFVideoMixerBitmap *if
     return CONTAINING_RECORD(iface, struct video_mixer, IMFVideoMixerBitmap_iface);
 }
 
+static struct video_mixer *impl_from_IMFVideoPositionMapper(IMFVideoPositionMapper *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_mixer, IMFVideoPositionMapper_iface);
+}
+
 static int video_mixer_compare_input_id(const void *a, const void *b)
 {
     const unsigned int *key = a;
@@ -142,6 +148,10 @@ static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface,
     {
         *obj = &mixer->IMFVideoMixerBitmap_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFVideoPositionMapper))
+    {
+        *obj = &mixer->IMFVideoPositionMapper_iface;
+    }
     else
     {
         WARN("Unsupported interface %s.\n", debugstr_guid(riid));
@@ -858,6 +868,40 @@ static const IMFVideoMixerBitmapVtbl video_mixer_bitmap_vtbl =
     video_mixer_bitmap_GetAlphaBitmapParameters,
 };
 
+static HRESULT WINAPI video_mixer_position_mapper_QueryInterface(IMFVideoPositionMapper *iface, REFIID riid, void **obj)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoPositionMapper(iface);
+    return IMFTransform_QueryInterface(&mixer->IMFTransform_iface, riid, obj);
+}
+
+static ULONG WINAPI video_mixer_position_mapper_AddRef(IMFVideoPositionMapper *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoPositionMapper(iface);
+    return IMFTransform_AddRef(&mixer->IMFTransform_iface);
+}
+
+static ULONG WINAPI video_mixer_position_mapper_Release(IMFVideoPositionMapper *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoPositionMapper(iface);
+    return IMFTransform_Release(&mixer->IMFTransform_iface);
+}
+
+static HRESULT WINAPI video_mixer_position_mapper_MapOutputCoordinateToInputStream(IMFVideoPositionMapper *iface,
+        float x_out, float y_out, DWORD output_stream, DWORD input_stream, float *x_in, float *y_in)
+{
+    FIXME("%p, %f, %f, %u, %u, %p, %p.\n", iface, x_out, y_out, output_stream, input_stream, x_in, y_in);
+
+    return E_NOTIMPL;
+}
+
+static const IMFVideoPositionMapperVtbl video_mixer_position_mapper_vtbl =
+{
+    video_mixer_position_mapper_QueryInterface,
+    video_mixer_position_mapper_AddRef,
+    video_mixer_position_mapper_Release,
+    video_mixer_position_mapper_MapOutputCoordinateToInputStream,
+};
+
 HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -886,6 +930,7 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
     object->IMFVideoMixerControl2_iface.lpVtbl = &video_mixer_control_vtbl;
     object->IMFGetService_iface.lpVtbl = &video_mixer_getservice_vtbl;
     object->IMFVideoMixerBitmap_iface.lpVtbl = &video_mixer_bitmap_vtbl;
+    object->IMFVideoPositionMapper_iface.lpVtbl = &video_mixer_position_mapper_vtbl;
     object->refcount = 1;
     object->input_count = 1;
     video_mixer_init_input(&object->inputs[0]);
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 4e97f65be09..4f954d868a6 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -405,10 +405,8 @@ static void test_default_mixer(void)
     IUnknown_Release(unk);
 
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoPositionMapper, (void **)&unk);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    if (SUCCEEDED(hr))
-        IUnknown_Release(unk);
+    IUnknown_Release(unk);
 
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoProcessor, (void **)&unk);
 todo_wine
From 93412525350b033db59cf1a582f977528f2a9585 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 26 Jun 2020 18:20:51 +0300
Subject: [PATCH] evr: Forward some known interface queries for
 MR_VIDEO_MIXER_SERVICE.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 14 +++++++++++++-
 dlls/evr/tests/evr.c | 18 +++++++++++++++++-
 include/evr.idl      |  6 ++++++
 3 files changed, 36 insertions(+), 2 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 7663a28ab10..006427b77af 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -797,7 +797,19 @@ static ULONG WINAPI video_mixer_getservice_Release(IMFGetService *iface)
 
 static HRESULT WINAPI video_mixer_getservice_GetService(IMFGetService *iface, REFGUID service, REFIID riid, void **obj)
 {
-    FIXME("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+    TRACE("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(service, &MR_VIDEO_MIXER_SERVICE))
+    {
+        if (IsEqualIID(riid, &IID_IMFVideoMixerBitmap) ||
+                IsEqualIID(riid, &IID_IMFVideoProcessor) ||
+                IsEqualIID(riid, &IID_IMFVideoPositionMapper))
+        {
+            return IMFGetService_QueryInterface(iface, riid, obj);
+        }
+    }
+
+    FIXME("Unsupported service %s, riid %s.\n", debugstr_guid(service), debugstr_guid(riid));
 
     return E_NOTIMPL;
 }
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 4f954d868a6..5bfa87014d8 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -383,6 +383,7 @@ static void test_default_mixer(void)
     DWORD input_id, output_id;
     IMFAttributes *attributes, *attributes2;
     IMFTransform *transform;
+    IMFGetService *gs;
     unsigned int i;
     DWORD ids[16];
     IUnknown *unk;
@@ -396,10 +397,25 @@ static void test_default_mixer(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
-    hr = IMFTransform_QueryInterface(transform, &IID_IMFGetService, (void **)&unk);
+    hr = IMFTransform_QueryInterface(transform, &IID_IMFGetService, (void **)&gs);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoMixerBitmap, (void **)&unk);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
+    hr = IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoProcessor, (void **)&unk);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+        IUnknown_Release(unk);
+
+    hr = IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoPositionMapper, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
+    IMFGetService_Release(gs);
+
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoMixerBitmap, (void **)&unk);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
diff --git a/include/evr.idl b/include/evr.idl
index 43afca1201a..4599e298790 100644
--- a/include/evr.idl
+++ b/include/evr.idl
@@ -218,5 +218,11 @@ interface IMFDesiredSample : IUnknown
     void Clear();
 }
 
+cpp_quote("DEFINE_GUID(MR_VIDEO_RENDER_SERVICE, 0x1092a86c, 0xab1a, 0x459a, 0xa3, 0x36, 0x83, 0x1f, 0xbc, 0x4d, 0x11, 0xff);")
+cpp_quote("DEFINE_GUID(MR_VIDEO_MIXER_SERVICE, 0x073cd2fc, 0x6cf4, 0x40b7, 0x88, 0x59, 0xe8, 0x95, 0x52, 0xc8, 0x41, 0xf8);")
+cpp_quote("DEFINE_GUID(MR_VIDEO_ACCELERATION_SERVICE, 0xefef5175, 0x5c7d, 0x4ce2, 0xbb, 0xbd, 0x34, 0xff, 0x8b, 0xca, 0x65, 0x54);")
+cpp_quote("DEFINE_GUID(MR_BUFFER_SERVICE, 0xa562248c, 0x9ac6, 0x4ffc, 0x9f, 0xba, 0x3a, 0xf8, 0xf8, 0xad, 0x1a, 0x4d);")
+cpp_quote("DEFINE_GUID(VIDEO_ZOOM_RECT, 0x7aaa1638, 0x1b7f, 0x4c93, 0xbd, 0x89, 0x5b, 0x9c, 0x9f, 0xb6, 0xfc, 0xf0);")
+
 cpp_quote("HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj);")
 cpp_quote("HRESULT WINAPI MFCreateVideoSampleFromSurface(IUnknown *surface, IMFSample **sample);")
From 84acd2f47ecef0a7def76c550a385850127fe105 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 26 Jun 2020 18:40:55 +0300
Subject: [PATCH] dxva2: Add missing processor service method stubs.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dxva2/main.c | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/dlls/dxva2/main.c b/dlls/dxva2/main.c
index bbee697674f..4a51410d4b6 100644
--- a/dlls/dxva2/main.c
+++ b/dlls/dxva2/main.c
@@ -188,6 +188,25 @@ static HRESULT WINAPI device_manager_processor_service_GetProcAmpRange(
     return E_NOTIMPL;
 }
 
+static HRESULT WINAPI device_manager_processor_service_GetFilterPropertyRange(
+        IDirectXVideoProcessorService *iface, REFGUID deviceguid, const DXVA2_VideoDesc *video_desc,
+        D3DFORMAT rt_format, UINT filter_setting, DXVA2_ValueRange *range)
+{
+    FIXME("%p, %s, %p, %d, %d, %p.\n", iface, debugstr_guid(deviceguid), video_desc, rt_format, filter_setting, range);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI device_manager_processor_service_CreateVideoProcessor(IDirectXVideoProcessorService *iface,
+        REFGUID deviceguid, const DXVA2_VideoDesc *video_desc, D3DFORMAT rt_format, UINT max_substreams,
+        IDirectXVideoProcessor **processor)
+{
+    FIXME("%p, %s, %p, %d, %u, %p.\n", iface, debugstr_guid(deviceguid), video_desc, rt_format, max_substreams,
+            processor);
+
+    return E_NOTIMPL;
+}
+
 static const IDirectXVideoProcessorServiceVtbl device_manager_processor_service_vtbl =
 {
     device_manager_processor_service_QueryInterface,
@@ -200,6 +219,8 @@ static const IDirectXVideoProcessorServiceVtbl device_manager_processor_service_
     device_manager_processor_service_GetVideoProcessorSubStreamFormats,
     device_manager_processor_service_GetVideoProcessorCaps,
     device_manager_processor_service_GetProcAmpRange,
+    device_manager_processor_service_GetFilterPropertyRange,
+    device_manager_processor_service_CreateVideoProcessor,
 };
 
 static HRESULT WINAPI device_manager_QueryInterface(IDirect3DDeviceManager9 *iface, REFIID riid, void **obj)
From 881336569c593057503f66f4f5857f1a43571c80 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 29 Jun 2020 15:43:37 +0300
Subject: [PATCH] evr: Add IMFVideoProcessor stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 134 +++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c |   8 +--
 include/evr9.idl     |   2 +-
 3 files changed, 137 insertions(+), 7 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 006427b77af..e8905f633ab 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -49,6 +49,7 @@ struct video_mixer
     IMFGetService IMFGetService_iface;
     IMFVideoMixerBitmap IMFVideoMixerBitmap_iface;
     IMFVideoPositionMapper IMFVideoPositionMapper_iface;
+    IMFVideoProcessor IMFVideoProcessor_iface;
     LONG refcount;
 
     struct input_stream inputs[MAX_MIXER_INPUT_STREAMS];
@@ -95,6 +96,11 @@ static struct video_mixer *impl_from_IMFVideoPositionMapper(IMFVideoPositionMapp
     return CONTAINING_RECORD(iface, struct video_mixer, IMFVideoPositionMapper_iface);
 }
 
+static struct video_mixer *impl_from_IMFVideoProcessor(IMFVideoProcessor *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_mixer, IMFVideoProcessor_iface);
+}
+
 static int video_mixer_compare_input_id(const void *a, const void *b)
 {
     const unsigned int *key = a;
@@ -152,6 +158,10 @@ static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface,
     {
         *obj = &mixer->IMFVideoPositionMapper_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFVideoProcessor))
+    {
+        *obj = &mixer->IMFVideoProcessor_iface;
+    }
     else
     {
         WARN("Unsupported interface %s.\n", debugstr_guid(riid));
@@ -914,6 +924,129 @@ static const IMFVideoPositionMapperVtbl video_mixer_position_mapper_vtbl =
     video_mixer_position_mapper_MapOutputCoordinateToInputStream,
 };
 
+static HRESULT WINAPI video_mixer_processor_QueryInterface(IMFVideoProcessor *iface, REFIID riid, void **obj)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoProcessor(iface);
+    return IMFTransform_QueryInterface(&mixer->IMFTransform_iface, riid, obj);
+}
+
+static ULONG WINAPI video_mixer_processor_AddRef(IMFVideoProcessor *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoProcessor(iface);
+    return IMFTransform_AddRef(&mixer->IMFTransform_iface);
+}
+
+static ULONG WINAPI video_mixer_processor_Release(IMFVideoProcessor *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFVideoProcessor(iface);
+    return IMFTransform_Release(&mixer->IMFTransform_iface);
+}
+
+static HRESULT WINAPI video_mixer_processor_GetAvailableVideoProcessorModes(IMFVideoProcessor *iface, UINT *count,
+        GUID **modes)
+{
+    FIXME("%p, %p, %p.\n", iface, count, modes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_processor_GetVideoProcessorCaps(IMFVideoProcessor *iface, GUID *mode,
+        DXVA2_VideoProcessorCaps *caps)
+{
+    FIXME("%p, %s, %p.\n", iface, debugstr_guid(mode), caps);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_processor_GetVideoProcessorMode(IMFVideoProcessor *iface, GUID *mode)
+{
+    FIXME("%p, %p.\n", iface, mode);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_processor_SetVideoProcessorMode(IMFVideoProcessor *iface, GUID *mode)
+{
+    FIXME("%p, %s.\n", iface, debugstr_guid(mode));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_processor_GetProcAmpRange(IMFVideoProcessor *iface, DWORD prop, DXVA2_ValueRange *range)
+{
+    FIXME("%p, %#x, %p.\n", iface, prop, range);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_processor_GetProcAmpValues(IMFVideoProcessor *iface, DWORD flags, DXVA2_ProcAmpValues *values)
+{
+    FIXME("%p, %#x, %p.\n", iface, flags, values);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_processor_SetProcAmpValues(IMFVideoProcessor *iface, DWORD flags, DXVA2_ProcAmpValues *values)
+{
+    FIXME("%p, %#x, %p.\n", iface, flags, values);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_processor_GetFilteringRange(IMFVideoProcessor *iface, DWORD prop, DXVA2_ValueRange *range)
+{
+    FIXME("%p, %#x, %p.\n", iface, prop, range);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_processor_GetFilteringValue(IMFVideoProcessor *iface, DWORD prop, DXVA2_Fixed32 *value)
+{
+    FIXME("%p, %#x, %p.\n", iface, prop, value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_processor_SetFilteringValue(IMFVideoProcessor *iface, DWORD prop, DXVA2_Fixed32 *value)
+{
+    FIXME("%p, %#x, %p.\n", iface, prop, value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_processor_GetBackgroundColor(IMFVideoProcessor *iface, COLORREF *color)
+{
+    FIXME("%p, %p.\n", iface, color);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_processor_SetBackgroundColor(IMFVideoProcessor *iface, COLORREF color)
+{
+    FIXME("%p, %#x.\n", iface, color);
+
+    return E_NOTIMPL;
+}
+
+static const IMFVideoProcessorVtbl video_mixer_processor_vtbl =
+{
+    video_mixer_processor_QueryInterface,
+    video_mixer_processor_AddRef,
+    video_mixer_processor_Release,
+    video_mixer_processor_GetAvailableVideoProcessorModes,
+    video_mixer_processor_GetVideoProcessorCaps,
+    video_mixer_processor_GetVideoProcessorMode,
+    video_mixer_processor_SetVideoProcessorMode,
+    video_mixer_processor_GetProcAmpRange,
+    video_mixer_processor_GetProcAmpValues,
+    video_mixer_processor_SetProcAmpValues,
+    video_mixer_processor_GetFilteringRange,
+    video_mixer_processor_GetFilteringValue,
+    video_mixer_processor_SetFilteringValue,
+    video_mixer_processor_GetBackgroundColor,
+    video_mixer_processor_SetBackgroundColor,
+};
+
 HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -943,6 +1076,7 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
     object->IMFGetService_iface.lpVtbl = &video_mixer_getservice_vtbl;
     object->IMFVideoMixerBitmap_iface.lpVtbl = &video_mixer_bitmap_vtbl;
     object->IMFVideoPositionMapper_iface.lpVtbl = &video_mixer_position_mapper_vtbl;
+    object->IMFVideoProcessor_iface.lpVtbl = &video_mixer_processor_vtbl;
     object->refcount = 1;
     object->input_count = 1;
     video_mixer_init_input(&object->inputs[0]);
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 5bfa87014d8..c37f921b09e 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -405,10 +405,8 @@ static void test_default_mixer(void)
     IUnknown_Release(unk);
 
     hr = IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoProcessor, (void **)&unk);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    if (SUCCEEDED(hr))
-        IUnknown_Release(unk);
+    IUnknown_Release(unk);
 
     hr = IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoPositionMapper, (void **)&unk);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
@@ -425,10 +423,8 @@ todo_wine
     IUnknown_Release(unk);
 
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoProcessor, (void **)&unk);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    if (SUCCEEDED(hr))
-        IUnknown_Release(unk);
+    IUnknown_Release(unk);
 
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoMixerControl, (void **)&unk);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
diff --git a/include/evr9.idl b/include/evr9.idl
index 1572d878387..b3d363cdee9 100644
--- a/include/evr9.idl
+++ b/include/evr9.idl
@@ -62,7 +62,7 @@ interface IMFVideoMixerBitmap : IUnknown
 
 [
     object,
-    uuid(6AB0000C-FECE-4d1f-A2AC-A9573530656E),
+    uuid(6ab0000c-fece-4d1f-a2ac-a9573530656e),
     pointer_default(unique)
 ]
 interface IMFVideoProcessor : IUnknown
From 43eebcd3e6f27b385715bc95f4b86dad665bd97c Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 29 Jun 2020 15:43:38 +0300
Subject: [PATCH] evr: Add input type validation through dxva.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 201 +++++++++++++++++++++++++++++++++++++++----
 dlls/evr/tests/evr.c |  87 ++++++++++++++++++-
 2 files changed, 269 insertions(+), 19 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index e8905f633ab..6fcad15ec64 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -18,7 +18,6 @@
 
 #define COBJMACROS
 
-#include "wine/debug.h"
 #include "evr.h"
 #include "d3d9.h"
 #include "dxva2api.h"
@@ -30,6 +29,9 @@
 #include "initguid.h"
 #include "evr9.h"
 
+#include "wine/debug.h"
+#include "wine/heap.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(evr);
 
 #define MAX_MIXER_INPUT_STREAMS 16
@@ -38,6 +40,14 @@ struct input_stream
 {
     unsigned int id;
     IMFAttributes *attributes;
+    IMFVideoMediaType *media_type;
+};
+
+struct output_stream
+{
+    IMFVideoMediaType *media_type;
+    IMFVideoMediaType **media_types;
+    unsigned int type_count;
 };
 
 struct video_mixer
@@ -55,6 +65,7 @@ struct video_mixer
     struct input_stream inputs[MAX_MIXER_INPUT_STREAMS];
     unsigned int input_ids[MAX_MIXER_INPUT_STREAMS];
     unsigned int input_count;
+    struct output_stream output;
 
     IDirect3DDeviceManager9 *device_manager;
 
@@ -122,6 +133,26 @@ static void video_mixer_init_input(struct input_stream *stream)
         IMFAttributes_SetUINT32(stream->attributes, &MF_SA_REQUIRED_SAMPLE_COUNT, 1);
 }
 
+static void video_mixer_clear_types(struct video_mixer *mixer)
+{
+    unsigned int i;
+
+    for (i = 0; i < mixer->input_count; ++i)
+    {
+        if (mixer->inputs[i].media_type)
+            IMFVideoMediaType_Release(mixer->inputs[i].media_type);
+        mixer->inputs[i].media_type = NULL;
+    }
+    for (i = 0; i < mixer->output.type_count; ++i)
+    {
+        IMFVideoMediaType_Release(mixer->output.media_types[i]);
+    }
+    heap_free(mixer->output.media_types);
+    if (mixer->output.media_type)
+        IMFVideoMediaType_Release(mixer->output.media_type);
+    mixer->output.media_type = NULL;
+}
+
 static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
 {
     struct video_mixer *mixer = impl_from_IMFTransform(iface);
@@ -198,6 +229,7 @@ static ULONG WINAPI video_mixer_transform_Release(IMFTransform *iface)
             if (mixer->inputs[i].attributes)
                 IMFAttributes_Release(mixer->inputs[i].attributes);
         }
+        video_mixer_clear_types(mixer);
         if (mixer->device_manager)
             IDirect3DDeviceManager9_Release(mixer->device_manager);
         DeleteCriticalSection(&mixer->cs);
@@ -430,9 +462,27 @@ static HRESULT WINAPI video_mixer_transform_GetInputAvailableType(IMFTransform *
 static HRESULT WINAPI video_mixer_transform_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    if (id)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&mixer->cs);
+
+    if (index >= mixer->output.type_count)
+        hr = MF_E_NO_MORE_TYPES;
+    else
+    {
+        *type = (IMFMediaType *)mixer->output.media_types[index];
+        IMFMediaType_AddRef(*type);
+    }
+
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
 static HRESULT video_mixer_init_dxva_videodesc(IMFMediaType *media_type, DXVA2_VideoDesc *video_desc)
@@ -465,24 +515,93 @@ static HRESULT video_mixer_init_dxva_videodesc(IMFMediaType *media_type, DXVA2_V
     return hr;
 }
 
+static int rt_formats_sort_compare(const void *left, const void *right)
+{
+    D3DFORMAT format1 = *(D3DFORMAT *)left, format2 = *(D3DFORMAT *)right;
+
+    if (format1 < format2) return -1;
+    if (format1 > format2) return 1;
+    return 0;
+}
+
+static HRESULT video_mixer_collect_output_types(struct video_mixer *mixer, const DXVA2_VideoDesc *video_desc,
+        IDirectXVideoProcessorService *service, unsigned int device_count, const GUID *devices)
+{
+    unsigned int i, j, format_count, count;
+    D3DFORMAT *rt_formats = NULL, *formats, *ptr;
+    GUID subtype;
+    HRESULT hr;
+
+    count = 0;
+    for (i = 0; i < device_count; ++i)
+    {
+        if (SUCCEEDED(IDirectXVideoProcessorService_GetVideoProcessorRenderTargets(service, &devices[i], video_desc,
+              &format_count, &formats)))
+        {
+            if (!(ptr = heap_realloc(rt_formats, (count + format_count) * sizeof(*rt_formats))))
+            {
+                hr = E_OUTOFMEMORY;
+                CoTaskMemFree(formats);
+                break;
+            }
+            rt_formats = ptr;
+
+            memcpy(&rt_formats[count], formats, format_count * sizeof(*formats));
+            count += format_count;
+
+            CoTaskMemFree(formats);
+        }
+    }
+
+    if (count)
+    {
+        qsort(rt_formats, count, sizeof(*rt_formats), rt_formats_sort_compare);
+
+        j = 0;
+        for (i = j + 1; i < count; ++i)
+        {
+            if (rt_formats[i] != rt_formats[j])
+            {
+                rt_formats[++j] = rt_formats[i];
+            }
+        }
+        count = j + 1;
+
+        memcpy(&subtype, &MFVideoFormat_Base, sizeof(subtype));
+        if ((mixer->output.media_types = heap_calloc(count, sizeof(*mixer->output.media_types))))
+        {
+            for (i = 0; i < count; ++i)
+            {
+                subtype.Data1 = rt_formats[i];
+                MFCreateVideoMediaTypeFromSubtype(&subtype, &mixer->output.media_types[i]);
+            }
+            mixer->output.type_count = count;
+        }
+        else
+            hr = E_OUTOFMEMORY;
+    }
+
+    heap_free(rt_formats);
+
+    return hr;
+}
+
 static HRESULT WINAPI video_mixer_transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *media_type, DWORD flags)
 {
     struct video_mixer *mixer = impl_from_IMFTransform(iface);
     IDirectXVideoProcessorService *service;
     DXVA2_VideoDesc video_desc;
     HRESULT hr = E_NOTIMPL;
+    unsigned int count;
     HANDLE handle;
+    GUID *guids;
 
     TRACE("%p, %u, %p, %#x.\n", iface, id, media_type, flags);
 
-    if (id)
-    {
-        FIXME("Unimplemented for substreams.\n");
-        return E_NOTIMPL;
-    }
-
     EnterCriticalSection(&mixer->cs);
 
+    video_mixer_clear_types(mixer);
+
     if (!mixer->device_manager)
         hr = MF_E_NOT_INITIALIZED;
     else
@@ -494,8 +613,21 @@ static HRESULT WINAPI video_mixer_transform_SetInputType(IMFTransform *iface, DW
             {
                 if (SUCCEEDED(hr = video_mixer_init_dxva_videodesc(media_type, &video_desc)))
                 {
-                    FIXME("Probe for supported devices.\n");
-                    hr = E_NOTIMPL;
+                    if (!id)
+                    {
+                        if (SUCCEEDED(hr = IDirectXVideoProcessorService_GetVideoProcessorDeviceGuids(service, &video_desc,
+                                &count, &guids)))
+                        {
+                            if (SUCCEEDED(hr = video_mixer_collect_output_types(mixer, &video_desc, service, count, guids)))
+                                FIXME("Set input type.\n");
+                            CoTaskMemFree(guids);
+                        }
+                    }
+                    else
+                    {
+                        FIXME("Unimplemented for substreams.\n");
+                        hr = E_NOTIMPL;
+                    }
                 }
             }
             IDirect3DDeviceManager9_CloseDeviceHandle(mixer->device_manager, handle);
@@ -516,16 +648,55 @@ static HRESULT WINAPI video_mixer_transform_SetOutputType(IMFTransform *iface, D
 
 static HRESULT WINAPI video_mixer_transform_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
 {
-    FIXME("%p, %u, %p.\n", iface, id, type);
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    struct input_stream *stream;
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p.\n", iface, id, type);
+
+    EnterCriticalSection(&mixer->cs);
+
+    if ((stream = video_mixer_get_input(mixer, id)))
+    {
+        if (!stream->media_type)
+            hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        else
+        {
+            *type = (IMFMediaType *)stream->media_type;
+            IMFMediaType_AddRef(*type);
+        }
+    }
+    else
+        hr = MF_E_INVALIDSTREAMNUMBER;
+
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_mixer_transform_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
 {
-    FIXME("%p, %u, %p.\n", iface, id, type);
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p.\n", iface, id, type);
+
+    if (id)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&mixer->cs);
+
+    if (!mixer->output.media_type)
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+    else
+    {
+        *type = (IMFMediaType *)mixer->output.media_type;
+        IMFMediaType_AddRef(*type);
+    }
+
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_mixer_transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index c37f921b09e..6259e636328 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -376,17 +376,23 @@ static void test_pin_info(void)
 static void test_default_mixer(void)
 {
     DWORD input_min, input_max, output_min, output_max;
+    IMFAttributes *attributes, *attributes2;
     MFT_OUTPUT_STREAM_INFO output_info;
     MFT_INPUT_STREAM_INFO input_info;
     DWORD input_count, output_count;
+    IMFVideoProcessor *processor;
     IMFVideoDeviceID *deviceid;
     DWORD input_id, output_id;
-    IMFAttributes *attributes, *attributes2;
     IMFTransform *transform;
+    DXVA2_ValueRange range;
+    DXVA2_Fixed32 value;
     IMFGetService *gs;
+    COLORREF color;
     unsigned int i;
     DWORD ids[16];
     IUnknown *unk;
+    DWORD count;
+    GUID *guids;
     HRESULT hr;
     IID iid;
 
@@ -404,9 +410,37 @@ static void test_default_mixer(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
-    hr = IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoProcessor, (void **)&unk);
+    hr = IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoProcessor, (void **)&processor);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    IUnknown_Release(unk);
+
+    color = 1;
+    hr = IMFVideoProcessor_GetBackgroundColor(processor, &color);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!color, "Unexpected color %#x.\n", color);
+}
+    hr = IMFVideoProcessor_SetBackgroundColor(processor, 0x00121212);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoProcessor_GetBackgroundColor(processor, &color);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(color == 0x121212, "Unexpected color %#x.\n", color);
+}
+    hr = IMFVideoProcessor_GetFilteringRange(processor, DXVA2_DetailFilterChromaLevel, &range);
+todo_wine
+    ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoProcessor_GetFilteringValue(processor, DXVA2_DetailFilterChromaLevel, &value);
+todo_wine
+    ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoProcessor_GetAvailableVideoProcessorModes(processor, &count, &guids);
+todo_wine
+    ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
+
+    IMFVideoProcessor_Release(processor);
 
     hr = IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoPositionMapper, (void **)&unk);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
@@ -663,12 +697,17 @@ todo_wine
 static void test_default_mixer_type_negotiation(void)
 {
     IDirect3DDeviceManager9 *manager;
+    DXVA2_VideoProcessorCaps caps;
     IMFVideoMediaType *video_type;
+    IMFVideoProcessor *processor;
     IMFMediaType *media_type;
     IDirect3DDevice9 *device;
     IMFTransform *transform;
+    GUID guid, *guids;
     IDirect3D9 *d3d;
+    IUnknown *unk;
     HWND window;
+    DWORD count;
     HRESULT hr;
     UINT token;
 
@@ -685,7 +724,6 @@ static void test_default_mixer_type_negotiation(void)
     ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
 
     hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type);
-todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateMediaType(&media_type);
@@ -746,15 +784,56 @@ todo_wine
 todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoProcessor, (void **)&processor);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoProcessor_GetVideoProcessorMode(processor, &guid);
+todo_wine
+    ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoProcessor_GetVideoProcessorCaps(processor, (GUID *)&DXVA2_VideoProcSoftwareDevice, &caps);
+todo_wine
+    ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
+
     hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type);
 todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     if (SUCCEEDED(hr))
     {
         ok(media_type != (IMFMediaType *)video_type, "Unexpected pointer.\n");
+        hr = IMFMediaType_QueryInterface(media_type, &IID_IMFVideoMediaType, (void **)&unk);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+        IUnknown_Release(unk);
+        IMFMediaType_Release(media_type);
+    }
+
+    hr = IMFVideoProcessor_GetAvailableVideoProcessorModes(processor, &count, &guids);
+todo_wine
+    ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_GetOutputAvailableType(transform, 0, 0, &media_type);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    if (SUCCEEDED(hr))
+    {
+        hr = IMFTransform_SetOutputType(transform, 0, media_type, 0);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
         IMFMediaType_Release(media_type);
     }
 
+    hr = IMFVideoProcessor_GetVideoProcessorMode(processor, &guid);
+todo_wine
+    ok(hr == S_FALSE, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoProcessor_GetAvailableVideoProcessorModes(processor, &count, &guids);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+        CoTaskMemFree(guids);
+
+    IMFVideoProcessor_Release(processor);
+
     IMFVideoMediaType_Release(video_type);
 
     IDirect3DDeviceManager9_Release(manager);
From 7a2dc025a3342821de2810ab6e6cfedff1408f55 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 29 Jun 2020 15:43:39 +0300
Subject: [PATCH] evr: Store background color property for the mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 25 +++++++++++++++++++++----
 dlls/evr/tests/evr.c | 10 +++++-----
 2 files changed, 26 insertions(+), 9 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 6fcad15ec64..23994375d45 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -67,6 +67,8 @@ struct video_mixer
     unsigned int input_count;
     struct output_stream output;
 
+    COLORREF bkgnd_color;
+
     IDirect3DDeviceManager9 *device_manager;
 
     CRITICAL_SECTION cs;
@@ -1187,16 +1189,31 @@ static HRESULT WINAPI video_mixer_processor_SetFilteringValue(IMFVideoProcessor
 
 static HRESULT WINAPI video_mixer_processor_GetBackgroundColor(IMFVideoProcessor *iface, COLORREF *color)
 {
-    FIXME("%p, %p.\n", iface, color);
+    struct video_mixer *mixer = impl_from_IMFVideoProcessor(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, color);
+
+    if (!color)
+        return E_POINTER;
+
+    EnterCriticalSection(&mixer->cs);
+    *color = mixer->bkgnd_color;
+    LeaveCriticalSection(&mixer->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_mixer_processor_SetBackgroundColor(IMFVideoProcessor *iface, COLORREF color)
 {
-    FIXME("%p, %#x.\n", iface, color);
+    struct video_mixer *mixer = impl_from_IMFVideoProcessor(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x.\n", iface, color);
+
+    EnterCriticalSection(&mixer->cs);
+    mixer->bkgnd_color = color;
+    LeaveCriticalSection(&mixer->cs);
+
+    return S_OK;
 }
 
 static const IMFVideoProcessorVtbl video_mixer_processor_vtbl =
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 6259e636328..70fc6b18e2f 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -413,21 +413,21 @@ static void test_default_mixer(void)
     hr = IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoProcessor, (void **)&processor);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFVideoProcessor_GetBackgroundColor(processor, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
     color = 1;
     hr = IMFVideoProcessor_GetBackgroundColor(processor, &color);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!color, "Unexpected color %#x.\n", color);
-}
+
     hr = IMFVideoProcessor_SetBackgroundColor(processor, 0x00121212);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoProcessor_GetBackgroundColor(processor, &color);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(color == 0x121212, "Unexpected color %#x.\n", color);
-}
+
     hr = IMFVideoProcessor_GetFilteringRange(processor, DXVA2_DetailFilterChromaLevel, &range);
 todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
From 7be64a8d3eec3c52dc58a20a178d33dd25de56d0 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 29 Jun 2020 20:14:06 -0500
Subject: [PATCH] winegstreamer: Don't store DirectShow caps.

Primarily so that we can connect using video caps that can't be translated into
DirectShow caps. They will later be converted into translatable caps once the
DirectShow source pin is connected.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47642
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 162 ++++++++++++++++++++--------------
 1 file changed, 94 insertions(+), 68 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 8f89935b82b..5697d2c0e0c 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -78,7 +78,6 @@ struct gstdemux_source
 
     GstPad *their_src, *post_sink, *post_src, *my_sink;
     GstElement *flip;
-    AM_MEDIA_TYPE mt;
     HANDLE caps_event, eos_event;
     GstSegment *segment;
     SourceSeeking seek;
@@ -99,15 +98,11 @@ static HRESULT WINAPI GST_ChangeCurrent(IMediaSeeking *iface);
 static HRESULT WINAPI GST_ChangeStop(IMediaSeeking *iface);
 static HRESULT WINAPI GST_ChangeRate(IMediaSeeking *iface);
 
-static gboolean amt_from_gst_caps_audio_raw(const GstCaps *caps, AM_MEDIA_TYPE *amt)
+static gboolean amt_from_gst_audio_info(const GstAudioInfo *info, AM_MEDIA_TYPE *amt)
 {
     WAVEFORMATEXTENSIBLE *wfe;
     WAVEFORMATEX *wfx;
     gint32 depth, bpp;
-    GstAudioInfo ainfo;
-
-    if (!gst_audio_info_from_caps (&ainfo, caps))
-        return FALSE;
 
     wfe = CoTaskMemAlloc(sizeof(*wfe));
     wfx = (WAVEFORMATEX*)wfe;
@@ -122,10 +117,10 @@ static gboolean amt_from_gst_caps_audio_raw(const GstCaps *caps, AM_MEDIA_TYPE *
 
     wfx->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
 
-    wfx->nChannels = ainfo.channels;
-    wfx->nSamplesPerSec = ainfo.rate;
-    depth = GST_AUDIO_INFO_WIDTH(&ainfo);
-    bpp = GST_AUDIO_INFO_DEPTH(&ainfo);
+    wfx->nChannels = info->channels;
+    wfx->nSamplesPerSec = info->rate;
+    depth = GST_AUDIO_INFO_WIDTH(info);
+    bpp = GST_AUDIO_INFO_DEPTH(info);
 
     if (!depth || depth > 32 || depth % 8)
         depth = bpp;
@@ -144,7 +139,8 @@ static gboolean amt_from_gst_caps_audio_raw(const GstCaps *caps, AM_MEDIA_TYPE *
         default:
         wfe->dwChannelMask = 0;
     }
-    if (GST_AUDIO_INFO_IS_FLOAT(&ainfo)) {
+    if (GST_AUDIO_INFO_IS_FLOAT(info))
+    {
         amt->subtype = MEDIASUBTYPE_IEEE_FLOAT;
         wfe->SubFormat = KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
     } else {
@@ -207,7 +203,7 @@ static gboolean amt_from_gst_video_info(const GstVideoInfo *info, AM_MEDIA_TYPE
             bih->biBitCount = 16;
             break;
         default:
-            FIXME("Unhandled type %s.\n", GST_VIDEO_INFO_NAME(info));
+            WARN("Cannot convert %s to a DirectShow type.\n", GST_VIDEO_INFO_NAME(info));
             CoTaskMemFree(vih);
             return FALSE;
         }
@@ -314,8 +310,16 @@ static gboolean amt_from_gst_caps(const GstCaps *caps, AM_MEDIA_TYPE *mt)
     const char *type = gst_structure_get_name(gst_caps_get_structure(caps, 0));
     GstStructure *structure = gst_caps_get_structure(caps, 0);
 
+    memset(mt, 0, sizeof(AM_MEDIA_TYPE));
+
     if (!strcmp(type, "audio/x-raw"))
-        return amt_from_gst_caps_audio_raw(caps, mt);
+    {
+        GstAudioInfo info;
+
+        if (!(gst_audio_info_from_caps(&info, caps)))
+            return FALSE;
+        return amt_from_gst_audio_info(&info, mt);
+    }
     else if (!strcmp(type, "video/x-raw"))
     {
         GstVideoInfo info;
@@ -331,7 +335,6 @@ static gboolean amt_from_gst_caps(const GstCaps *caps, AM_MEDIA_TYPE *mt)
         VIDEOINFOHEADER *vih;
         gint i;
 
-        memset(mt, 0, sizeof(AM_MEDIA_TYPE));
         mt->majortype = MEDIATYPE_Video;
         mt->subtype = MEDIASUBTYPE_CVID;
         mt->bTemporalCompression = TRUE;
@@ -466,24 +469,6 @@ static GstCaps *amt_to_gst_caps(const AM_MEDIA_TYPE *mt)
     return NULL;
 }
 
-static gboolean setcaps_sink(GstPad *pad, GstCaps *caps)
-{
-    struct gstdemux_source *pin = gst_pad_get_element_private(pad);
-    struct gstdemux *filter = impl_from_strmbase_filter(pin->pin.pin.filter);
-    gchar *caps_str = gst_caps_to_string(caps);
-
-    TRACE("filter %p, caps %s.\n", filter, debugstr_a(caps_str));
-    g_free(caps_str);
-
-    FreeMediaType(&pin->mt);
-
-    if (!amt_from_gst_caps(caps, &pin->mt))
-        return FALSE;
-
-    SetEvent(pin->caps_event);
-    return TRUE;
-}
-
 static gboolean query_sink(GstPad *pad, GstObject *parent, GstQuery *query)
 {
     struct gstdemux_source *pin = gst_pad_get_element_private(pad);
@@ -662,6 +647,7 @@ static gboolean event_src(GstPad *pad, GstObject *parent, GstEvent *event)
 static gboolean event_sink(GstPad *pad, GstObject *parent, GstEvent *event)
 {
     struct gstdemux_source *pin = gst_pad_get_element_private(pad);
+    gboolean ret;
 
     TRACE("pin %p, type \"%s\".\n", pin, GST_EVENT_TYPE_NAME(event));
 
@@ -722,11 +708,10 @@ static gboolean event_sink(GstPad *pad, GstObject *parent, GstEvent *event)
             if (pin->pin.pin.peer)
                 IPin_EndFlush(pin->pin.pin.peer);
             return TRUE;
-        case GST_EVENT_CAPS: {
-            GstCaps *caps;
-            gst_event_parse_caps(event, &caps);
-            return setcaps_sink(pad, caps);
-        }
+        case GST_EVENT_CAPS:
+            ret = gst_pad_event_default(pad, parent, event);
+            SetEvent(pin->caps_event);
+            return ret;
         default:
             WARN("Ignoring \"%s\" event.\n", GST_EVENT_TYPE_NAME(event));
             return gst_pad_event_default(pad, parent, event);
@@ -1678,6 +1663,10 @@ static HRESULT gstdecoder_source_query_accept(struct gstdemux_source *pin, const
 static HRESULT gstdecoder_source_get_media_type(struct gstdemux_source *pin,
         unsigned int index, AM_MEDIA_TYPE *mt)
 {
+    GstCaps *caps = gst_pad_get_current_caps(pin->my_sink);
+    const GstStructure *structure;
+    const char *type;
+
     static const GstVideoFormat video_formats[] =
     {
         /* Try to prefer YUV formats over RGB ones. Most decoders output in the
@@ -1695,42 +1684,48 @@ static HRESULT gstdecoder_source_get_media_type(struct gstdemux_source *pin,
         GST_VIDEO_FORMAT_BGR,
     };
 
-    if (!index)
+    assert(caps); /* We shouldn't be able to get here if caps haven't been set. */
+    structure = gst_caps_get_structure(caps, 0);
+    type = gst_structure_get_name(structure);
+
+    memset(mt, 0, sizeof(AM_MEDIA_TYPE));
+
+    if (amt_from_gst_caps(caps, mt))
     {
-        CopyMediaType(mt, &pin->mt);
-        return S_OK;
+        if (!index--)
+        {
+            gst_caps_unref(caps);
+            return S_OK;
+        }
     }
-    else if (IsEqualGUID(&pin->mt.majortype, &MEDIATYPE_Video)
-            && index - 1 < ARRAY_SIZE(video_formats))
+
+    if (!strcmp(type, "video/x-raw") && index < ARRAY_SIZE(video_formats))
     {
-        const VIDEOINFOHEADER *vih = (VIDEOINFOHEADER *)pin->mt.pbFormat;
+        gint width, height;
         GstVideoInfo info;
 
-        gst_video_info_set_format(&info, video_formats[index - 1],
-                vih->bmiHeader.biWidth, vih->bmiHeader.biHeight);
+        gst_caps_unref(caps);
+        gst_structure_get_int(structure, "width", &width);
+        gst_structure_get_int(structure, "height", &height);
+        gst_video_info_set_format(&info, video_formats[index], width, height);
         if (!amt_from_gst_video_info(&info, mt))
             return E_OUTOFMEMORY;
         return S_OK;
     }
-    else if (IsEqualGUID(&pin->mt.majortype, &MEDIATYPE_Audio) && index == 1)
-    {
-        const WAVEFORMATEX *our_format = (WAVEFORMATEX *)pin->mt.pbFormat;
-        WAVEFORMATEX *format;
-
-        *mt = pin->mt;
-        mt->subtype = MEDIASUBTYPE_PCM;
-        mt->pbFormat = CoTaskMemAlloc(sizeof(WAVEFORMATEX));
-        format = (WAVEFORMATEX *)mt->pbFormat;
-        format->wFormatTag = WAVE_FORMAT_PCM;
-        format->nChannels = 2;
-        format->nSamplesPerSec = our_format->nSamplesPerSec;
-        format->wBitsPerSample = 16;
-        format->nBlockAlign = 4;
-        format->nAvgBytesPerSec = format->nSamplesPerSec * 4;
-        format->cbSize = 0;
+    else if (!strcmp(type, "audio/x-raw") && !index)
+    {
+        GstAudioInfo info;
+        gint rate;
+
+        gst_caps_unref(caps);
+        gst_structure_get_int(structure, "rate", &rate);
+        gst_audio_info_set_format(&info, GST_AUDIO_FORMAT_S16LE, rate, 2, NULL);
+        if (!amt_from_gst_audio_info(&info, mt))
+            return E_OUTOFMEMORY;
         return S_OK;
     }
 
+    gst_caps_unref(caps);
     return VFW_S_NO_MORE_ITEMS;
 }
 
@@ -2137,7 +2132,6 @@ static void free_source_pin(struct gstdemux_source *pin)
     gst_object_unref(pin->my_sink);
     CloseHandle(pin->caps_event);
     CloseHandle(pin->eos_event);
-    FreeMediaType(&pin->mt);
     gst_segment_free(pin->segment);
 
     strmbase_seeking_cleanup(&pin->seek);
@@ -2394,9 +2388,24 @@ static BOOL wave_parser_init_gst(struct gstdemux *filter)
     return TRUE;
 }
 
+static gboolean get_source_amt(const struct gstdemux_source *pin, AM_MEDIA_TYPE *mt)
+{
+    GstCaps *caps = gst_pad_get_current_caps(pin->my_sink);
+    gboolean ret = amt_from_gst_caps(caps, mt);
+    gst_caps_unref(caps);
+    return ret;
+}
+
 static HRESULT wave_parser_source_query_accept(struct gstdemux_source *pin, const AM_MEDIA_TYPE *mt)
 {
-    return compare_media_types(mt, &pin->mt) ? S_OK : S_FALSE;
+    AM_MEDIA_TYPE pad_mt;
+    HRESULT hr;
+
+    if (!get_source_amt(pin, &pad_mt))
+        return E_OUTOFMEMORY;
+    hr = compare_media_types(mt, &pad_mt) ? S_OK : S_FALSE;
+    FreeMediaType(&pad_mt);
+    return hr;
 }
 
 static HRESULT wave_parser_source_get_media_type(struct gstdemux_source *pin,
@@ -2404,7 +2413,8 @@ static HRESULT wave_parser_source_get_media_type(struct gstdemux_source *pin,
 {
     if (index > 0)
         return VFW_S_NO_MORE_ITEMS;
-    CopyMediaType(mt, &pin->mt);
+    if (!get_source_amt(pin, mt))
+        return E_OUTOFMEMORY;
     return S_OK;
 }
 
@@ -2507,7 +2517,14 @@ static BOOL avi_splitter_init_gst(struct gstdemux *filter)
 
 static HRESULT avi_splitter_source_query_accept(struct gstdemux_source *pin, const AM_MEDIA_TYPE *mt)
 {
-    return compare_media_types(mt, &pin->mt) ? S_OK : S_FALSE;
+    AM_MEDIA_TYPE pad_mt;
+    HRESULT hr;
+
+    if (!get_source_amt(pin, &pad_mt))
+        return E_OUTOFMEMORY;
+    hr = compare_media_types(mt, &pad_mt) ? S_OK : S_FALSE;
+    FreeMediaType(&pad_mt);
+    return hr;
 }
 
 static HRESULT avi_splitter_source_get_media_type(struct gstdemux_source *pin,
@@ -2515,7 +2532,8 @@ static HRESULT avi_splitter_source_get_media_type(struct gstdemux_source *pin,
 {
     if (index > 0)
         return VFW_S_NO_MORE_ITEMS;
-    CopyMediaType(mt, &pin->mt);
+    if (!get_source_amt(pin, mt))
+        return E_OUTOFMEMORY;
     return S_OK;
 }
 
@@ -2632,7 +2650,14 @@ static BOOL mpeg_splitter_init_gst(struct gstdemux *filter)
 
 static HRESULT mpeg_splitter_source_query_accept(struct gstdemux_source *pin, const AM_MEDIA_TYPE *mt)
 {
-    return compare_media_types(mt, &pin->mt) ? S_OK : S_FALSE;
+    AM_MEDIA_TYPE pad_mt;
+    HRESULT hr;
+
+    if (!get_source_amt(pin, &pad_mt))
+        return E_OUTOFMEMORY;
+    hr = compare_media_types(mt, &pad_mt) ? S_OK : S_FALSE;
+    FreeMediaType(&pad_mt);
+    return hr;
 }
 
 static HRESULT mpeg_splitter_source_get_media_type(struct gstdemux_source *pin,
@@ -2640,7 +2665,8 @@ static HRESULT mpeg_splitter_source_get_media_type(struct gstdemux_source *pin,
 {
     if (index > 0)
         return VFW_S_NO_MORE_ITEMS;
-    CopyMediaType(mt, &pin->mt);
+    if (!get_source_amt(pin, mt))
+        return E_OUTOFMEMORY;
     return S_OK;
 }
 
From 431324ba63dc06cbb570d2c2f15913661e704c24 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 30 Jun 2020 12:35:59 +0300
Subject: [PATCH] dxva2: Implement locking functionality in device manager.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dxva2/main.c        |  94 +++++++++++++++++++++++++++++++--
 dlls/dxva2/tests/dxva2.c | 110 ++++++++++++++++++++++++++++++++++++++-
 2 files changed, 199 insertions(+), 5 deletions(-)

diff --git a/dlls/dxva2/main.c b/dlls/dxva2/main.c
index 4a51410d4b6..dd949b3d316 100644
--- a/dlls/dxva2/main.c
+++ b/dlls/dxva2/main.c
@@ -42,6 +42,7 @@ enum device_handle_flags
 struct device_handle
 {
     unsigned int flags;
+    IDirect3DStateBlock9 *state_block;
 };
 
 struct device_manager
@@ -57,7 +58,10 @@ struct device_manager
     size_t count;
     size_t capacity;
 
+    HANDLE locking_handle;
+
     CRITICAL_SECTION cs;
+    CONDITION_VARIABLE lock;
 };
 
 static BOOL dxva_array_reserve(void **elements, size_t *capacity, size_t count, size_t size)
@@ -254,6 +258,7 @@ static ULONG WINAPI device_manager_Release(IDirect3DDeviceManager9 *iface)
 {
     struct device_manager *manager = impl_from_IDirect3DDeviceManager9(iface);
     ULONG refcount = InterlockedDecrement(&manager->refcount);
+    size_t i;
 
     TRACE("%p, refcount %u.\n", iface, refcount);
 
@@ -262,6 +267,11 @@ static ULONG WINAPI device_manager_Release(IDirect3DDeviceManager9 *iface)
         if (manager->device)
             IDirect3DDevice9_Release(manager->device);
         DeleteCriticalSection(&manager->cs);
+        for (i = 0; i < manager->count; ++i)
+        {
+            if (manager->handles[i].state_block)
+                IDirect3DStateBlock9_Release(manager->handles[i].state_block);
+        }
         heap_free(manager->handles);
         heap_free(manager);
     }
@@ -284,13 +294,21 @@ static HRESULT WINAPI device_manager_ResetDevice(IDirect3DDeviceManager9 *iface,
     if (manager->device)
     {
         for (i = 0; i < manager->count; ++i)
+        {
+            if (manager->handles[i].state_block)
+                IDirect3DStateBlock9_Release(manager->handles[i].state_block);
+            manager->handles[i].state_block = NULL;
             manager->handles[i].flags |= HANDLE_FLAG_INVALID;
+        }
+        manager->locking_handle = NULL;
         IDirect3DDevice9_Release(manager->device);
     }
     manager->device = device;
     IDirect3DDevice9_AddRef(manager->device);
     LeaveCriticalSection(&manager->cs);
 
+    WakeAllConditionVariable(&manager->lock);
+
     return S_OK;
 }
 
@@ -324,6 +342,7 @@ static HRESULT WINAPI device_manager_OpenDeviceHandle(IDirect3DDeviceManager9 *i
         {
             *hdevice = ULongToHandle(manager->count + 1);
             manager->handles[manager->count].flags |= HANDLE_FLAG_OPEN;
+            manager->handles[manager->count].state_block = NULL;
             manager->count++;
         }
         else
@@ -355,15 +374,22 @@ static HRESULT WINAPI device_manager_CloseDeviceHandle(IDirect3DDeviceManager9 *
     {
         if (manager->handles[idx].flags & HANDLE_FLAG_OPEN)
         {
+            if (manager->locking_handle == hdevice)
+                manager->locking_handle = NULL;
             manager->handles[idx].flags = 0;
             if (idx == manager->count - 1)
                 manager->count--;
+            if (manager->handles[idx].state_block)
+                IDirect3DStateBlock9_Release(manager->handles[idx].state_block);
+            manager->handles[idx].state_block = NULL;
         }
         else
             hr = E_HANDLE;
     }
     LeaveCriticalSection(&manager->cs);
 
+    WakeAllConditionVariable(&manager->lock);
+
     return hr;
 }
 
@@ -393,16 +419,75 @@ static HRESULT WINAPI device_manager_TestDevice(IDirect3DDeviceManager9 *iface,
 static HRESULT WINAPI device_manager_LockDevice(IDirect3DDeviceManager9 *iface, HANDLE hdevice,
         IDirect3DDevice9 **device, BOOL block)
 {
-    FIXME("%p, %p, %p, %d.\n", iface, hdevice, device, block);
+    struct device_manager *manager = impl_from_IDirect3DDeviceManager9(iface);
+    HRESULT hr;
+    size_t idx;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %p, %d.\n", iface, hdevice, device, block);
+
+    EnterCriticalSection(&manager->cs);
+    if (!manager->device)
+        hr = DXVA2_E_NOT_INITIALIZED;
+    else if (SUCCEEDED(hr = device_manager_get_handle_index(manager, hdevice, &idx)))
+    {
+        if (manager->locking_handle && !block)
+            hr = DXVA2_E_VIDEO_DEVICE_LOCKED;
+        else
+        {
+            while (manager->locking_handle && block)
+            {
+                SleepConditionVariableCS(&manager->lock, &manager->cs, INFINITE);
+            }
+
+            if (SUCCEEDED(hr = device_manager_get_handle_index(manager, hdevice, &idx)))
+            {
+                if (manager->handles[idx].flags & HANDLE_FLAG_INVALID)
+                    hr = DXVA2_E_NEW_VIDEO_DEVICE;
+                else
+                {
+                    if (manager->handles[idx].state_block)
+                    {
+                        if (FAILED(IDirect3DStateBlock9_Apply(manager->handles[idx].state_block)))
+                            WARN("Failed to apply state.\n");
+                        IDirect3DStateBlock9_Release(manager->handles[idx].state_block);
+                        manager->handles[idx].state_block = NULL;
+                    }
+                    *device = manager->device;
+                    IDirect3DDevice9_AddRef(*device);
+                    manager->locking_handle = hdevice;
+                }
+            }
+        }
+    }
+    LeaveCriticalSection(&manager->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI device_manager_UnlockDevice(IDirect3DDeviceManager9 *iface, HANDLE hdevice, BOOL savestate)
 {
-    FIXME("%p, %p, %d.\n", iface, hdevice, savestate);
+    struct device_manager *manager = impl_from_IDirect3DDeviceManager9(iface);
+    HRESULT hr;
+    size_t idx;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %d.\n", iface, hdevice, savestate);
+
+    EnterCriticalSection(&manager->cs);
+
+    if (hdevice != manager->locking_handle)
+        hr = E_INVALIDARG;
+    else if (SUCCEEDED(hr = device_manager_get_handle_index(manager, hdevice, &idx)))
+    {
+        manager->locking_handle = NULL;
+        if (savestate)
+            IDirect3DDevice9_CreateStateBlock(manager->device, D3DSBT_ALL, &manager->handles[idx].state_block);
+    }
+
+    LeaveCriticalSection(&manager->cs);
+
+    WakeAllConditionVariable(&manager->lock);
+
+    return hr;
 }
 
 static HRESULT WINAPI device_manager_GetVideoService(IDirect3DDeviceManager9 *iface, HANDLE hdevice, REFIID riid,
@@ -470,6 +555,7 @@ HRESULT WINAPI DXVA2CreateDirect3DDeviceManager9(UINT *token, IDirect3DDeviceMan
     object->refcount = 1;
     object->token = GetTickCount();
     InitializeCriticalSection(&object->cs);
+    InitializeConditionVariable(&object->lock);
 
     *token = object->token;
     *manager = &object->IDirect3DDeviceManager9_iface;
diff --git a/dlls/dxva2/tests/dxva2.c b/dlls/dxva2/tests/dxva2.c
index e3e8dd2e66c..49b192a1fad 100644
--- a/dlls/dxva2/tests/dxva2.c
+++ b/dlls/dxva2/tests/dxva2.c
@@ -72,6 +72,7 @@ static void test_device_manager(void)
     HWND window;
     UINT token;
     HRESULT hr;
+    RECT rect;
 
     window = create_window();
     d3d = Direct3DCreate9(D3D_SDK_VERSION);
@@ -88,13 +89,15 @@ static void test_device_manager(void)
     hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
     ok(hr == DXVA2_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
 
+    hr = IDirect3DDeviceManager9_LockDevice(manager, 0, &device2, FALSE);
+    ok(hr == DXVA2_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
+
     /* Invalid token. */
     hr = IDirect3DDeviceManager9_ResetDevice(manager, device, token + 1);
     ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IDirect3DDeviceManager9_ResetDevice(manager, device, token);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-
     refcount = get_refcount((IUnknown *)device);
 
     handle1 = NULL;
@@ -140,6 +143,7 @@ static void test_device_manager(void)
     IDirectXVideoProcessorService_Release(processor_service);
 
     device2 = create_device(d3d, window);
+
     hr = IDirect3DDeviceManager9_ResetDevice(manager, device2, token);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
@@ -150,6 +154,110 @@ static void test_device_manager(void)
     hr = IDirect3DDeviceManager9_TestDevice(manager, handle);
     ok(hr == DXVA2_E_NEW_VIDEO_DEVICE, "Unexpected hr %#x.\n", hr);
 
+    hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* Lock/Unlock. */
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_LockDevice(manager, handle, &device3, FALSE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(device2 == device3, "Unexpected device pointer.\n");
+    IDirect3DDevice9_Release(device3);
+
+    hr = IDirect3DDeviceManager9_UnlockDevice(manager, handle, FALSE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_UnlockDevice(manager, handle, FALSE);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_UnlockDevice(manager, (HANDLE)((ULONG_PTR)handle + 100), FALSE);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    /* Locked with one handle, unlock with another. */
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle1);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_LockDevice(manager, handle, &device3, FALSE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(device2 == device3, "Unexpected device pointer.\n");
+    IDirect3DDevice9_Release(device3);
+
+    hr = IDirect3DDeviceManager9_UnlockDevice(manager, handle1, FALSE);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    /* Closing unlocks the device. */
+    hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_LockDevice(manager, handle1, &device3, FALSE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(device2 == device3, "Unexpected device pointer.\n");
+    IDirect3DDevice9_Release(device3);
+
+    hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle1);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* Open two handles. */
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle1);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_LockDevice(manager, handle, &device3, FALSE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(device2 == device3, "Unexpected device pointer.\n");
+    IDirect3DDevice9_Release(device3);
+
+    hr = IDirect3DDeviceManager9_LockDevice(manager, handle1, &device3, FALSE);
+    ok(hr == DXVA2_E_VIDEO_DEVICE_LOCKED, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle1);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* State saving function. */
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(manager, &handle);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_LockDevice(manager, handle, &device3, FALSE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(device2 == device3, "Unexpected device pointer.\n");
+
+    SetRect(&rect, 50, 60, 70, 80);
+    hr = IDirect3DDevice9_SetScissorRect(device3, &rect);
+    ok(SUCCEEDED(hr), "Failed to set scissor rect, hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_UnlockDevice(manager, handle, TRUE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    SetRect(&rect, 30, 60, 70, 80);
+    hr = IDirect3DDevice9_SetScissorRect(device3, &rect);
+    ok(SUCCEEDED(hr), "Failed to set scissor rect, hr %#x.\n", hr);
+
+    IDirect3DDevice9_Release(device3);
+
+    hr = IDirect3DDeviceManager9_LockDevice(manager, handle, &device3, FALSE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(device2 == device3, "Unexpected device pointer.\n");
+
+    hr = IDirect3DDevice9_GetScissorRect(device3, &rect);
+    ok(SUCCEEDED(hr), "Failed to get scissor rect, hr %#x.\n", hr);
+    ok(rect.left == 50 && rect.top == 60 && rect.right == 70 && rect.bottom == 80,
+            "Got unexpected scissor rect %s.\n", wine_dbgstr_rect(&rect));
+
+    IDirect3DDevice9_Release(device3);
+
+    hr = IDirect3DDeviceManager9_UnlockDevice(manager, handle, TRUE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_CloseDeviceHandle(manager, handle);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
     /* Acceleration service. */
     hr = DXVA2CreateVideoService(device, &IID_IDirectXVideoAccelerationService, (void **)&accel_service);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
From f0aefcfce54acd642cf13b4d44326424e13eeb27 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 30 Jun 2020 16:34:00 +0300
Subject: [PATCH] evr: Add a stub for default presenter.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/Makefile.in     |   3 +-
 dlls/evr/evr.spec        |   2 +-
 dlls/evr/evr_classes.idl |   7 ++
 dlls/evr/evr_private.h   |  23 +++++
 dlls/evr/main.c          |   1 +
 dlls/evr/presenter.c     | 218 +++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c     |  35 +++++++
 include/evr.idl          |   1 +
 8 files changed, 288 insertions(+), 2 deletions(-)
 create mode 100644 dlls/evr/presenter.c

diff --git a/dlls/evr/Makefile.in b/dlls/evr/Makefile.in
index 5671511f6ae..daaf9cc872a 100644
--- a/dlls/evr/Makefile.in
+++ b/dlls/evr/Makefile.in
@@ -8,6 +8,7 @@ EXTRADLLFLAGS = -mno-cygwin
 C_SRCS = \
 	evr.c \
 	main.c \
-	mixer.c
+	mixer.c \
+	presenter.c
 
 IDL_SRCS = evr_classes.idl
diff --git a/dlls/evr/evr.spec b/dlls/evr/evr.spec
index 214f2b81d85..e46cb04f644 100644
--- a/dlls/evr/evr.spec
+++ b/dlls/evr/evr.spec
@@ -17,7 +17,7 @@
 @ stub MFCreateVideoMixerAndPresenter
 @ stub MFCreateVideoOTA
 @ stub MFCreateVideoPresenter2
-@ stub MFCreateVideoPresenter
+@ stdcall MFCreateVideoPresenter(ptr ptr ptr ptr)
 @ stub MFCreateVideoSampleAllocator
 @ stdcall MFCreateVideoSampleFromSurface(ptr ptr)
 @ stub MFGetPlaneSize
diff --git a/dlls/evr/evr_classes.idl b/dlls/evr/evr_classes.idl
index 31f0d34fe75..1885a34d77f 100644
--- a/dlls/evr/evr_classes.idl
+++ b/dlls/evr/evr_classes.idl
@@ -31,3 +31,10 @@ coclass EnhancedVideoRenderer { interface IBaseFilter; }
     uuid(e474e05a-ab65-4f6a-827c-218b1baaf31f)
 ]
 coclass MFVideoMixer9 { interface IMFTransform; }
+
+[
+    helpstring("MF Video Presenter"),
+    threading(both),
+    uuid(98455561-5136-4d28-ab08-4cee40ea2781)
+]
+coclass MFVideoPresenter9 { interface IMFVideoPresenter; }
diff --git a/dlls/evr/evr_private.h b/dlls/evr/evr_private.h
index 5698eb0c21e..7ae83140579 100644
--- a/dlls/evr/evr_private.h
+++ b/dlls/evr/evr_private.h
@@ -22,8 +22,31 @@
 #include "dshow.h"
 #include "evr.h"
 #include "wine/strmbase.h"
+#include "wine/debug.h"
+
+static inline const char *debugstr_time(LONGLONG time)
+{
+    ULONGLONG abstime = time >= 0 ? time : -time;
+    unsigned int i = 0, j = 0;
+    char buffer[23], rev[23];
+
+    while (abstime || i <= 8)
+    {
+        buffer[i++] = '0' + (abstime % 10);
+        abstime /= 10;
+        if (i == 7) buffer[i++] = '.';
+    }
+    if (time < 0) buffer[i++] = '-';
+
+    while (i--) rev[j++] = buffer[i];
+    while (rev[j-1] == '0' && rev[j-2] != '.') --j;
+    rev[j] = 0;
+
+    return wine_dbg_sprintf("%s", rev);
+}
 
 HRESULT evr_filter_create(IUnknown *outer_unk, void **ppv) DECLSPEC_HIDDEN;
 HRESULT evr_mixer_create(IUnknown *outer_unk, void **ppv) DECLSPEC_HIDDEN;
+HRESULT evr_presenter_create(IUnknown *outer_unk, void **ppv) DECLSPEC_HIDDEN;
 
 #endif /* __EVR_PRIVATE_INCLUDED__ */
diff --git a/dlls/evr/main.c b/dlls/evr/main.c
index 85c81f13604..2c6db8430ba 100644
--- a/dlls/evr/main.c
+++ b/dlls/evr/main.c
@@ -72,6 +72,7 @@ static const struct object_creation_info object_creation[] =
 {
     { &CLSID_EnhancedVideoRenderer, evr_filter_create },
     { &CLSID_MFVideoMixer9, evr_mixer_create },
+    { &CLSID_MFVideoPresenter9, evr_presenter_create },
 };
 
 static HRESULT WINAPI classfactory_QueryInterface(IClassFactory *iface, REFIID riid, void **ppobj)
diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
new file mode 100644
index 00000000000..234c1f076ca
--- /dev/null
+++ b/dlls/evr/presenter.c
@@ -0,0 +1,218 @@
+/*
+ * Copyright 2020 Nikolay Sivov
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+
+#include "evr.h"
+#include "d3d9.h"
+#include "mfapi.h"
+#include "mferror.h"
+
+#include "evr_classes.h"
+#include "evr_private.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(evr);
+
+struct video_presenter
+{
+    IMFVideoPresenter IMFVideoPresenter_iface;
+    IUnknown IUnknown_inner;
+    IUnknown *outer_unk;
+    LONG refcount;
+};
+
+static struct video_presenter *impl_from_IUnknown(IUnknown *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_presenter, IUnknown_inner);
+}
+
+static struct video_presenter *impl_from_IMFVideoPresenter(IMFVideoPresenter *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_presenter, IMFVideoPresenter_iface);
+}
+
+static HRESULT WINAPI video_presenter_inner_QueryInterface(IUnknown *iface, REFIID riid, void **obj)
+{
+    struct video_presenter *presenter = impl_from_IUnknown(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+    }
+    else if (IsEqualIID(riid, &IID_IMFClockStateSink)
+            || IsEqualIID(riid, &IID_IMFVideoPresenter))
+    {
+        *obj = &presenter->IMFVideoPresenter_iface;
+    }
+    else
+    {
+        WARN("Unimplemented interface %s.\n", debugstr_guid(riid));
+        *obj = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*obj);
+    return S_OK;
+}
+
+static ULONG WINAPI video_presenter_inner_AddRef(IUnknown *iface)
+{
+    struct video_presenter *presenter = impl_from_IUnknown(iface);
+    ULONG refcount = InterlockedIncrement(&presenter->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI video_presenter_inner_Release(IUnknown *iface)
+{
+    struct video_presenter *presenter = impl_from_IUnknown(iface);
+    ULONG refcount = InterlockedDecrement(&presenter->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        heap_free(presenter);
+    }
+
+    return refcount;
+}
+
+static const IUnknownVtbl video_presenter_inner_vtbl =
+{
+    video_presenter_inner_QueryInterface,
+    video_presenter_inner_AddRef,
+    video_presenter_inner_Release,
+};
+
+static HRESULT WINAPI video_presenter_QueryInterface(IMFVideoPresenter *iface, REFIID riid, void **obj)
+{
+    struct video_presenter *presenter = impl_from_IMFVideoPresenter(iface);
+    return IUnknown_QueryInterface(presenter->outer_unk, riid, obj);
+}
+
+static ULONG WINAPI video_presenter_AddRef(IMFVideoPresenter *iface)
+{
+    struct video_presenter *presenter = impl_from_IMFVideoPresenter(iface);
+    return IUnknown_AddRef(presenter->outer_unk);
+}
+
+static ULONG WINAPI video_presenter_Release(IMFVideoPresenter *iface)
+{
+    struct video_presenter *presenter = impl_from_IMFVideoPresenter(iface);
+    return IUnknown_Release(presenter->outer_unk);
+}
+
+static HRESULT WINAPI video_presenter_OnClockStart(IMFVideoPresenter *iface, MFTIME systime, LONGLONG offset)
+{
+    FIXME("%p, %s, %s.\n", iface, debugstr_time(systime), wine_dbgstr_longlong(offset));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_OnClockStop(IMFVideoPresenter *iface, MFTIME systime)
+{
+    FIXME("%p, %s.\n", iface, debugstr_time(systime));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_OnClockPause(IMFVideoPresenter *iface, MFTIME systime)
+{
+    FIXME("%p, %s.\n", iface, debugstr_time(systime));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_OnClockRestart(IMFVideoPresenter *iface, MFTIME systime)
+{
+    FIXME("%p, %s.\n", iface, debugstr_time(systime));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_OnClockSetRate(IMFVideoPresenter *iface, MFTIME systime, float rate)
+{
+    FIXME("%p, %s, %f.\n", iface, debugstr_time(systime), rate);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_ProcessMessage(IMFVideoPresenter *iface, MFVP_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("%p, %d, %lu.\n", iface, message, param);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_GetCurrentMediaType(IMFVideoPresenter *iface, IMFVideoMediaType **media_type)
+{
+    FIXME("%p, %p.\n", iface, media_type);
+
+    return E_NOTIMPL;
+}
+
+static const IMFVideoPresenterVtbl video_presenter_vtbl =
+{
+    video_presenter_QueryInterface,
+    video_presenter_AddRef,
+    video_presenter_Release,
+    video_presenter_OnClockStart,
+    video_presenter_OnClockStop,
+    video_presenter_OnClockPause,
+    video_presenter_OnClockRestart,
+    video_presenter_OnClockSetRate,
+    video_presenter_ProcessMessage,
+    video_presenter_GetCurrentMediaType,
+};
+
+HRESULT WINAPI MFCreateVideoPresenter(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
+
+    *obj = NULL;
+
+    if (!IsEqualIID(riid_device, &IID_IDirect3DDevice9))
+        return E_INVALIDARG;
+
+    return CoCreateInstance(&CLSID_MFVideoPresenter9, owner, CLSCTX_INPROC_SERVER, riid, obj);
+}
+
+HRESULT evr_presenter_create(IUnknown *outer, void **out)
+{
+    struct video_presenter *object;
+
+    if (!(object = heap_alloc(sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFVideoPresenter_iface.lpVtbl = &video_presenter_vtbl;
+    object->IUnknown_inner.lpVtbl = &video_presenter_inner_vtbl;
+    object->outer_unk = outer ? outer : &object->IUnknown_inner;
+    object->refcount = 1;
+
+    *out = &object->IUnknown_inner;
+
+    return S_OK;
+}
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 70fc6b18e2f..6805a7ae2b7 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -117,6 +117,7 @@ static IUnknown test_outer = {&outer_vtbl};
 static void test_aggregation(void)
 {
     IBaseFilter *filter, *filter2;
+    IMFVideoPresenter *presenter;
     IUnknown *unk, *unk2;
     HRESULT hr;
     ULONG ref;
@@ -171,6 +172,25 @@ static void test_aggregation(void)
     ref = IUnknown_Release(unk);
     ok(!ref, "Got unexpected refcount %d.\n", ref);
     ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+
+    /* Default presenter. */
+    presenter = (void *)0xdeadbeef;
+    hr = CoCreateInstance(&CLSID_MFVideoPresenter9, &test_outer, CLSCTX_INPROC_SERVER, &IID_IMFVideoPresenter,
+            (void **)&presenter);
+    ok(hr == E_NOINTERFACE, "Unexpected hr %#x.\n", hr);
+    ok(!presenter, "Got interface %p.\n", presenter);
+
+    hr = CoCreateInstance(&CLSID_MFVideoPresenter9, &test_outer, CLSCTX_INPROC_SERVER, &IID_IUnknown, (void **)&unk);
+    ok(hr == S_OK || broken(hr == E_FAIL) /* WinXP */, "Unexpected hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+    {
+        ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+        ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
+        ref = get_refcount(unk);
+        ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+
+        IUnknown_Release(unk);
+    }
 }
 
 #define check_interface(a, b, c) check_interface_(__LINE__, a, b, c)
@@ -846,6 +866,20 @@ todo_wine
     DestroyWindow(window);
 }
 
+static void test_default_presenter(void)
+{
+    IMFVideoPresenter *presenter;
+    HRESULT hr;
+
+    hr = MFCreateVideoPresenter(NULL, &IID_IMFVideoPresenter, &IID_IMFVideoPresenter, (void **)&presenter);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    hr = MFCreateVideoPresenter(NULL, &IID_IDirect3DDevice9, &IID_IMFVideoPresenter, (void **)&presenter);
+    ok(hr == S_OK || broken(hr == E_FAIL) /* WinXP */, "Failed to create default presenter, hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+        IMFVideoPresenter_Release(presenter);
+}
+
 START_TEST(evr)
 {
     CoInitialize(NULL);
@@ -860,6 +894,7 @@ START_TEST(evr)
     test_default_mixer();
     test_default_mixer_type_negotiation();
     test_surface_sample();
+    test_default_presenter();
 
     CoUninitialize();
 }
diff --git a/include/evr.idl b/include/evr.idl
index 4599e298790..5a623c2c29c 100644
--- a/include/evr.idl
+++ b/include/evr.idl
@@ -225,4 +225,5 @@ cpp_quote("DEFINE_GUID(MR_BUFFER_SERVICE, 0xa562248c, 0x9ac6, 0x4ffc, 0x9f, 0xba
 cpp_quote("DEFINE_GUID(VIDEO_ZOOM_RECT, 0x7aaa1638, 0x1b7f, 0x4c93, 0xbd, 0x89, 0x5b, 0x9c, 0x9f, 0xb6, 0xfc, 0xf0);")
 
 cpp_quote("HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj);")
+cpp_quote("HRESULT WINAPI MFCreateVideoPresenter(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj);")
 cpp_quote("HRESULT WINAPI MFCreateVideoSampleFromSurface(IUnknown *surface, IMFSample **sample);")
From 50eb5eba6164b48d6e2b2436702070e69389939a Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 30 Jun 2020 16:34:01 +0300
Subject: [PATCH] evr: Add IMFVideoDeviceID for the presenter.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 49 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c | 20 ++++++++++++++++--
 2 files changed, 67 insertions(+), 2 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 234c1f076ca..34c9a06fcf3 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -34,6 +34,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(evr);
 struct video_presenter
 {
     IMFVideoPresenter IMFVideoPresenter_iface;
+    IMFVideoDeviceID IMFVideoDeviceID_iface;
     IUnknown IUnknown_inner;
     IUnknown *outer_unk;
     LONG refcount;
@@ -49,6 +50,11 @@ static struct video_presenter *impl_from_IMFVideoPresenter(IMFVideoPresenter *if
     return CONTAINING_RECORD(iface, struct video_presenter, IMFVideoPresenter_iface);
 }
 
+static struct video_presenter *impl_from_IMFVideoDeviceID(IMFVideoDeviceID *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_presenter, IMFVideoDeviceID_iface);
+}
+
 static HRESULT WINAPI video_presenter_inner_QueryInterface(IUnknown *iface, REFIID riid, void **obj)
 {
     struct video_presenter *presenter = impl_from_IUnknown(iface);
@@ -64,6 +70,10 @@ static HRESULT WINAPI video_presenter_inner_QueryInterface(IUnknown *iface, REFI
     {
         *obj = &presenter->IMFVideoPresenter_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFVideoDeviceID))
+    {
+        *obj = &presenter->IMFVideoDeviceID_iface;
+    }
     else
     {
         WARN("Unimplemented interface %s.\n", debugstr_guid(riid));
@@ -188,6 +198,44 @@ static const IMFVideoPresenterVtbl video_presenter_vtbl =
     video_presenter_GetCurrentMediaType,
 };
 
+static HRESULT WINAPI video_presenter_device_id_QueryInterface(IMFVideoDeviceID *iface, REFIID riid, void **obj)
+{
+    struct video_presenter *presenter = impl_from_IMFVideoDeviceID(iface);
+    return IMFVideoPresenter_QueryInterface(&presenter->IMFVideoPresenter_iface, riid, obj);
+}
+
+static ULONG WINAPI video_presenter_device_id_AddRef(IMFVideoDeviceID *iface)
+{
+    struct video_presenter *presenter = impl_from_IMFVideoDeviceID(iface);
+    return IMFVideoPresenter_AddRef(&presenter->IMFVideoPresenter_iface);
+}
+
+static ULONG WINAPI video_presenter_device_id_Release(IMFVideoDeviceID *iface)
+{
+    struct video_presenter *presenter = impl_from_IMFVideoDeviceID(iface);
+    return IMFVideoPresenter_Release(&presenter->IMFVideoPresenter_iface);
+}
+
+static HRESULT WINAPI video_presenter_device_id_GetDeviceID(IMFVideoDeviceID *iface, IID *device_id)
+{
+    TRACE("%p, %p.\n", iface, device_id);
+
+    if (!device_id)
+        return E_POINTER;
+
+    memcpy(device_id, &IID_IDirect3DDevice9, sizeof(*device_id));
+
+    return S_OK;
+}
+
+static const IMFVideoDeviceIDVtbl video_presenter_device_id_vtbl =
+{
+    video_presenter_device_id_QueryInterface,
+    video_presenter_device_id_AddRef,
+    video_presenter_device_id_Release,
+    video_presenter_device_id_GetDeviceID,
+};
+
 HRESULT WINAPI MFCreateVideoPresenter(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -208,6 +256,7 @@ HRESULT evr_presenter_create(IUnknown *outer, void **out)
         return E_OUTOFMEMORY;
 
     object->IMFVideoPresenter_iface.lpVtbl = &video_presenter_vtbl;
+    object->IMFVideoDeviceID_iface.lpVtbl = &video_presenter_device_id_vtbl;
     object->IUnknown_inner.lpVtbl = &video_presenter_inner_vtbl;
     object->outer_unk = outer ? outer : &object->IUnknown_inner;
     object->refcount = 1;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 6805a7ae2b7..965b921937c 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -869,15 +869,31 @@ todo_wine
 static void test_default_presenter(void)
 {
     IMFVideoPresenter *presenter;
+    IMFVideoDeviceID *deviceid;
     HRESULT hr;
+    GUID iid;
 
     hr = MFCreateVideoPresenter(NULL, &IID_IMFVideoPresenter, &IID_IMFVideoPresenter, (void **)&presenter);
     ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateVideoPresenter(NULL, &IID_IDirect3DDevice9, &IID_IMFVideoPresenter, (void **)&presenter);
     ok(hr == S_OK || broken(hr == E_FAIL) /* WinXP */, "Failed to create default presenter, hr %#x.\n", hr);
-    if (SUCCEEDED(hr))
-        IMFVideoPresenter_Release(presenter);
+    if (FAILED(hr))
+        return;
+
+    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFVideoDeviceID, (void **)&deviceid);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDeviceID_GetDeviceID(deviceid, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDeviceID_GetDeviceID(deviceid, &iid);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(IsEqualIID(&iid, &IID_IDirect3DDevice9), "Unexpected id %s.\n", wine_dbgstr_guid(&iid));
+
+    IMFVideoDeviceID_Release(deviceid);
+
+    IMFVideoPresenter_Release(presenter);
 }
 
 START_TEST(evr)
From 23f52cb733b1e4e02b5a164c7eeec9352e94decb Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 30 Jun 2020 16:34:02 +0300
Subject: [PATCH] evr: Add IMFTopologyServiceLookupClient stub for the
 presenter.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 54 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c |  5 ++++
 2 files changed, 59 insertions(+)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 34c9a06fcf3..db2f85b46fd 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -35,6 +35,7 @@ struct video_presenter
 {
     IMFVideoPresenter IMFVideoPresenter_iface;
     IMFVideoDeviceID IMFVideoDeviceID_iface;
+    IMFTopologyServiceLookupClient IMFTopologyServiceLookupClient_iface;
     IUnknown IUnknown_inner;
     IUnknown *outer_unk;
     LONG refcount;
@@ -55,6 +56,11 @@ static struct video_presenter *impl_from_IMFVideoDeviceID(IMFVideoDeviceID *ifac
     return CONTAINING_RECORD(iface, struct video_presenter, IMFVideoDeviceID_iface);
 }
 
+static struct video_presenter *impl_from_IMFTopologyServiceLookupClient(IMFTopologyServiceLookupClient *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_presenter, IMFTopologyServiceLookupClient_iface);
+}
+
 static HRESULT WINAPI video_presenter_inner_QueryInterface(IUnknown *iface, REFIID riid, void **obj)
 {
     struct video_presenter *presenter = impl_from_IUnknown(iface);
@@ -74,6 +80,10 @@ static HRESULT WINAPI video_presenter_inner_QueryInterface(IUnknown *iface, REFI
     {
         *obj = &presenter->IMFVideoDeviceID_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFTopologyServiceLookupClient))
+    {
+        *obj = &presenter->IMFTopologyServiceLookupClient_iface;
+    }
     else
     {
         WARN("Unimplemented interface %s.\n", debugstr_guid(riid));
@@ -236,6 +246,49 @@ static const IMFVideoDeviceIDVtbl video_presenter_device_id_vtbl =
     video_presenter_device_id_GetDeviceID,
 };
 
+static HRESULT WINAPI video_presenter_service_client_QueryInterface(IMFTopologyServiceLookupClient *iface,
+        REFIID riid, void **obj)
+{
+    struct video_presenter *presenter = impl_from_IMFTopologyServiceLookupClient(iface);
+    return IMFVideoPresenter_QueryInterface(&presenter->IMFVideoPresenter_iface, riid, obj);
+}
+
+static ULONG WINAPI video_presenter_service_client_AddRef(IMFTopologyServiceLookupClient *iface)
+{
+    struct video_presenter *presenter = impl_from_IMFTopologyServiceLookupClient(iface);
+    return IMFVideoPresenter_AddRef(&presenter->IMFVideoPresenter_iface);
+}
+
+static ULONG WINAPI video_presenter_service_client_Release(IMFTopologyServiceLookupClient *iface)
+{
+    struct video_presenter *presenter = impl_from_IMFTopologyServiceLookupClient(iface);
+    return IMFVideoPresenter_Release(&presenter->IMFVideoPresenter_iface);
+}
+
+static HRESULT WINAPI video_presenter_service_client_InitServicePointers(IMFTopologyServiceLookupClient *iface,
+        IMFTopologyServiceLookup *service_lookup)
+{
+    FIXME("%p, %p.\n", iface, service_lookup);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_service_client_ReleaseServicePointers(IMFTopologyServiceLookupClient *iface)
+{
+    FIXME("%p.\n", iface);
+
+    return E_NOTIMPL;
+}
+
+static const IMFTopologyServiceLookupClientVtbl video_presenter_service_client_vtbl =
+{
+    video_presenter_service_client_QueryInterface,
+    video_presenter_service_client_AddRef,
+    video_presenter_service_client_Release,
+    video_presenter_service_client_InitServicePointers,
+    video_presenter_service_client_ReleaseServicePointers,
+};
+
 HRESULT WINAPI MFCreateVideoPresenter(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -257,6 +310,7 @@ HRESULT evr_presenter_create(IUnknown *outer, void **out)
 
     object->IMFVideoPresenter_iface.lpVtbl = &video_presenter_vtbl;
     object->IMFVideoDeviceID_iface.lpVtbl = &video_presenter_device_id_vtbl;
+    object->IMFTopologyServiceLookupClient_iface.lpVtbl = &video_presenter_service_client_vtbl;
     object->IUnknown_inner.lpVtbl = &video_presenter_inner_vtbl;
     object->outer_unk = outer ? outer : &object->IUnknown_inner;
     object->refcount = 1;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 965b921937c..af9e6567101 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -870,6 +870,7 @@ static void test_default_presenter(void)
 {
     IMFVideoPresenter *presenter;
     IMFVideoDeviceID *deviceid;
+    IUnknown *unk;
     HRESULT hr;
     GUID iid;
 
@@ -893,6 +894,10 @@ static void test_default_presenter(void)
 
     IMFVideoDeviceID_Release(deviceid);
 
+    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFTopologyServiceLookupClient, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
     IMFVideoPresenter_Release(presenter);
 }
 
From dfbad372f5b2c03a8296542990127affd5e9b4ca Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 30 Jun 2020 16:34:03 +0300
Subject: [PATCH] include: Add IMFVideoDisplayControl definition.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 include/evr.idl | 76 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 76 insertions(+)

diff --git a/include/evr.idl b/include/evr.idl
index 5a623c2c29c..384a051944c 100644
--- a/include/evr.idl
+++ b/include/evr.idl
@@ -218,6 +218,82 @@ interface IMFDesiredSample : IUnknown
     void Clear();
 }
 
+[
+    object,
+    uuid(a490b1e4-ab84-4d31-a1b2-181e03b1077a),
+]
+interface IMFVideoDisplayControl : IUnknown
+{
+    HRESULT GetNativeVideoSize(
+        [in, out, unique] SIZE *video_size,
+        [in, out, unique] SIZE *aspect_ratio
+    );
+
+    HRESULT GetIdealVideoSize(
+        [in, out, unique] SIZE *min_size,
+        [in, out, unique] SIZE *max_size
+    );
+
+    HRESULT SetVideoPosition(
+        [in, unique] const MFVideoNormalizedRect *source,
+        [in, unique] const RECT *dest
+    );
+
+    HRESULT GetVideoPosition(
+        [out] MFVideoNormalizedRect *source,
+        [out] RECT *dest
+    );
+
+    HRESULT SetAspectRatioMode(
+        [in] DWORD mode
+    );
+
+    HRESULT GetAspectRatioMode(
+        [out] DWORD *mode
+    );
+
+    HRESULT SetVideoWindow(
+        [in] HWND window
+    );
+
+    HRESULT GetVideoWindow(
+        [out] HWND *window
+    );
+
+    HRESULT RepaintVideo();
+
+    HRESULT GetCurrentImage(
+        [in, out] LPBITMAPINFOHEADER header,
+        [out, size_is(, *dib_size)] BYTE **dib,
+        [out] DWORD *dib_size,
+        [in, out, unique] LONGLONG *timestamp
+    );
+
+    HRESULT SetBorderColor(
+        [in] COLORREF color
+    );
+
+    HRESULT GetBorderColor(
+        [out] COLORREF *color
+    );
+
+    HRESULT SetRenderingPrefs(
+        [in] DWORD flags
+    );
+
+    HRESULT GetRenderingPrefs(
+        [out] DWORD *flags
+    );
+
+    HRESULT SetFullscreen(
+        [in] BOOL fullscreen
+    );
+
+    HRESULT GetFullscreen(
+        [out] BOOL *fullscreen
+    );
+}
+
 cpp_quote("DEFINE_GUID(MR_VIDEO_RENDER_SERVICE, 0x1092a86c, 0xab1a, 0x459a, 0xa3, 0x36, 0x83, 0x1f, 0xbc, 0x4d, 0x11, 0xff);")
 cpp_quote("DEFINE_GUID(MR_VIDEO_MIXER_SERVICE, 0x073cd2fc, 0x6cf4, 0x40b7, 0x88, 0x59, 0xe8, 0x95, 0x52, 0xc8, 0x41, 0xf8);")
 cpp_quote("DEFINE_GUID(MR_VIDEO_ACCELERATION_SERVICE, 0xefef5175, 0x5c7d, 0x4ce2, 0xbb, 0xbd, 0x34, 0xff, 0x8b, 0xca, 0x65, 0x54);")
From 7ae5f06e4722ea8f55eb47c49bf17105bd0db080 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 30 Jun 2020 16:34:04 +0300
Subject: [PATCH] evr: Add IMFVideoDisplayControl stub for the presenter.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 121 +++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c |   4 ++
 2 files changed, 125 insertions(+)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index db2f85b46fd..cbe8b0d2ff4 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -36,6 +36,7 @@ struct video_presenter
     IMFVideoPresenter IMFVideoPresenter_iface;
     IMFVideoDeviceID IMFVideoDeviceID_iface;
     IMFTopologyServiceLookupClient IMFTopologyServiceLookupClient_iface;
+    IMFVideoDisplayControl IMFVideoDisplayControl_iface;
     IUnknown IUnknown_inner;
     IUnknown *outer_unk;
     LONG refcount;
@@ -61,6 +62,11 @@ static struct video_presenter *impl_from_IMFTopologyServiceLookupClient(IMFTopol
     return CONTAINING_RECORD(iface, struct video_presenter, IMFTopologyServiceLookupClient_iface);
 }
 
+static struct video_presenter *impl_from_IMFVideoDisplayControl(IMFVideoDisplayControl *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_presenter, IMFVideoDisplayControl_iface);
+}
+
 static HRESULT WINAPI video_presenter_inner_QueryInterface(IUnknown *iface, REFIID riid, void **obj)
 {
     struct video_presenter *presenter = impl_from_IUnknown(iface);
@@ -84,6 +90,10 @@ static HRESULT WINAPI video_presenter_inner_QueryInterface(IUnknown *iface, REFI
     {
         *obj = &presenter->IMFTopologyServiceLookupClient_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFVideoDisplayControl))
+    {
+        *obj = &presenter->IMFVideoDisplayControl_iface;
+    }
     else
     {
         WARN("Unimplemented interface %s.\n", debugstr_guid(riid));
@@ -289,6 +299,116 @@ static const IMFTopologyServiceLookupClientVtbl video_presenter_service_client_v
     video_presenter_service_client_ReleaseServicePointers,
 };
 
+static HRESULT WINAPI video_presenter_control_QueryInterface(IMFVideoDisplayControl *iface, REFIID riid, void **obj)
+{
+    struct video_presenter *presenter = impl_from_IMFVideoDisplayControl(iface);
+    return IMFVideoPresenter_QueryInterface(&presenter->IMFVideoPresenter_iface, riid, obj);
+}
+
+static ULONG WINAPI video_presenter_control_AddRef(IMFVideoDisplayControl *iface)
+{
+    struct video_presenter *presenter = impl_from_IMFVideoDisplayControl(iface);
+    return IMFVideoPresenter_AddRef(&presenter->IMFVideoPresenter_iface);
+}
+
+static ULONG WINAPI video_presenter_control_Release(IMFVideoDisplayControl *iface)
+{
+    struct video_presenter *presenter = impl_from_IMFVideoDisplayControl(iface);
+    return IMFVideoPresenter_Release(&presenter->IMFVideoPresenter_iface);
+}
+
+static HRESULT WINAPI video_presenter_control_GetNativeVideoSize(IMFVideoDisplayControl *iface, SIZE *video_size,
+        SIZE *aspect_ratio)
+{
+    FIXME("%p, %p, %p.\n", iface, video_size, aspect_ratio);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_GetIdealVideoSize(IMFVideoDisplayControl *iface, SIZE *min_size,
+        SIZE *max_size)
+{
+    FIXME("%p, %p, %p.\n", iface, min_size, max_size);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_SetVideoPosition(IMFVideoDisplayControl *iface,
+        const MFVideoNormalizedRect *source, const RECT *dest)
+{
+    FIXME("%p, %p, %p.\n", iface, source, dest);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_GetVideoPosition(IMFVideoDisplayControl *iface, MFVideoNormalizedRect *source,
+        RECT *dest)
+{
+    FIXME("%p, %p, %p.\n", iface, source, dest);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_SetAspectRatioMode(IMFVideoDisplayControl *iface, DWORD mode)
+{
+    FIXME("%p, %d.\n", iface, mode);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_GetAspectRatioMode(IMFVideoDisplayControl *iface, DWORD *mode)
+{
+    FIXME("%p, %p.\n", iface, mode);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_SetVideoWindow(IMFVideoDisplayControl *iface, HWND window)
+{
+    FIXME("%p, %p.\n", iface, window);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_GetVideoWindow(IMFVideoDisplayControl *iface, HWND *window)
+{
+    FIXME("%p, %p.\n", iface, window);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_RepaintVideo(IMFVideoDisplayControl *iface)
+{
+    FIXME("%p.\n", iface);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_GetCurrentImage(IMFVideoDisplayControl *iface, BITMAPINFOHEADER *header,
+        BYTE **dib, DWORD *dib_size, LONGLONG *timestamp)
+{
+    FIXME("%p, %p, %p, %p, %p.\n", iface, header, dib, dib_size, timestamp);
+
+    return E_NOTIMPL;
+}
+
+static const IMFVideoDisplayControlVtbl video_presenter_control_vtbl =
+{
+    video_presenter_control_QueryInterface,
+    video_presenter_control_AddRef,
+    video_presenter_control_Release,
+    video_presenter_control_GetNativeVideoSize,
+    video_presenter_control_GetIdealVideoSize,
+    video_presenter_control_SetVideoPosition,
+    video_presenter_control_GetVideoPosition,
+    video_presenter_control_SetAspectRatioMode,
+    video_presenter_control_GetAspectRatioMode,
+    video_presenter_control_SetVideoWindow,
+    video_presenter_control_GetVideoWindow,
+    video_presenter_control_RepaintVideo,
+    video_presenter_control_GetCurrentImage,
+};
+
 HRESULT WINAPI MFCreateVideoPresenter(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -311,6 +431,7 @@ HRESULT evr_presenter_create(IUnknown *outer, void **out)
     object->IMFVideoPresenter_iface.lpVtbl = &video_presenter_vtbl;
     object->IMFVideoDeviceID_iface.lpVtbl = &video_presenter_device_id_vtbl;
     object->IMFTopologyServiceLookupClient_iface.lpVtbl = &video_presenter_service_client_vtbl;
+    object->IMFVideoDisplayControl_iface.lpVtbl = &video_presenter_control_vtbl;
     object->IUnknown_inner.lpVtbl = &video_presenter_inner_vtbl;
     object->outer_unk = outer ? outer : &object->IUnknown_inner;
     object->refcount = 1;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index af9e6567101..037916fc4e1 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -898,6 +898,10 @@ static void test_default_presenter(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
+    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFVideoDisplayControl, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
     IMFVideoPresenter_Release(presenter);
 }
 
From 7e4e2b37960330045fe5db994869706d6a5311d6 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 1 Jul 2020 15:55:42 +0300
Subject: [PATCH] evr: Add IMFRateSupport stub for the presenter.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 61 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c | 28 ++++++++++++++++++++
 2 files changed, 89 insertions(+)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index cbe8b0d2ff4..29167d364df 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -37,6 +37,7 @@ struct video_presenter
     IMFVideoDeviceID IMFVideoDeviceID_iface;
     IMFTopologyServiceLookupClient IMFTopologyServiceLookupClient_iface;
     IMFVideoDisplayControl IMFVideoDisplayControl_iface;
+    IMFRateSupport IMFRateSupport_iface;
     IUnknown IUnknown_inner;
     IUnknown *outer_unk;
     LONG refcount;
@@ -67,6 +68,11 @@ static struct video_presenter *impl_from_IMFVideoDisplayControl(IMFVideoDisplayC
     return CONTAINING_RECORD(iface, struct video_presenter, IMFVideoDisplayControl_iface);
 }
 
+static struct video_presenter *impl_from_IMFRateSupport(IMFRateSupport *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_presenter, IMFRateSupport_iface);
+}
+
 static HRESULT WINAPI video_presenter_inner_QueryInterface(IUnknown *iface, REFIID riid, void **obj)
 {
     struct video_presenter *presenter = impl_from_IUnknown(iface);
@@ -94,6 +100,10 @@ static HRESULT WINAPI video_presenter_inner_QueryInterface(IUnknown *iface, REFI
     {
         *obj = &presenter->IMFVideoDisplayControl_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFRateSupport))
+    {
+        *obj = &presenter->IMFRateSupport_iface;
+    }
     else
     {
         WARN("Unimplemented interface %s.\n", debugstr_guid(riid));
@@ -409,6 +419,56 @@ static const IMFVideoDisplayControlVtbl video_presenter_control_vtbl =
     video_presenter_control_GetCurrentImage,
 };
 
+static HRESULT WINAPI video_presenter_rate_support_QueryInterface(IMFRateSupport *iface, REFIID riid, void **obj)
+{
+    struct video_presenter *presenter = impl_from_IMFRateSupport(iface);
+    return IMFVideoPresenter_QueryInterface(&presenter->IMFVideoPresenter_iface, riid, obj);
+}
+
+static ULONG WINAPI video_presenter_rate_support_AddRef(IMFRateSupport *iface)
+{
+    struct video_presenter *presenter = impl_from_IMFRateSupport(iface);
+    return IMFVideoPresenter_AddRef(&presenter->IMFVideoPresenter_iface);
+}
+
+static ULONG WINAPI video_presenter_rate_support_Release(IMFRateSupport *iface)
+{
+    struct video_presenter *presenter = impl_from_IMFRateSupport(iface);
+    return IMFVideoPresenter_Release(&presenter->IMFVideoPresenter_iface);
+}
+
+static HRESULT WINAPI video_presenter_rate_support_GetSlowestRate(IMFRateSupport *iface, MFRATE_DIRECTION direction,
+        BOOL thin, float *rate)
+{
+    TRACE("%p, %d, %d, %p.\n", iface, direction, thin, rate);
+
+    *rate = 0.0f;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI video_presenter_rate_support_GetFastestRate(IMFRateSupport *iface, MFRATE_DIRECTION direction,
+        BOOL thin, float *rate)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_rate_support_IsRateSupported(IMFRateSupport *iface, BOOL thin, float rate,
+        float *nearest_supported_rate)
+{
+    return E_NOTIMPL;
+}
+
+static const IMFRateSupportVtbl video_presenter_rate_support_vtbl =
+{
+    video_presenter_rate_support_QueryInterface,
+    video_presenter_rate_support_AddRef,
+    video_presenter_rate_support_Release,
+    video_presenter_rate_support_GetSlowestRate,
+    video_presenter_rate_support_GetFastestRate,
+    video_presenter_rate_support_IsRateSupported,
+};
+
 HRESULT WINAPI MFCreateVideoPresenter(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -432,6 +492,7 @@ HRESULT evr_presenter_create(IUnknown *outer, void **out)
     object->IMFVideoDeviceID_iface.lpVtbl = &video_presenter_device_id_vtbl;
     object->IMFTopologyServiceLookupClient_iface.lpVtbl = &video_presenter_service_client_vtbl;
     object->IMFVideoDisplayControl_iface.lpVtbl = &video_presenter_control_vtbl;
+    object->IMFRateSupport_iface.lpVtbl = &video_presenter_rate_support_vtbl;
     object->IUnknown_inner.lpVtbl = &video_presenter_inner_vtbl;
     object->outer_unk = outer ? outer : &object->IUnknown_inner;
     object->refcount = 1;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 037916fc4e1..dd3fbbe0289 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -869,8 +869,10 @@ todo_wine
 static void test_default_presenter(void)
 {
     IMFVideoPresenter *presenter;
+    IMFRateSupport *rate_support;
     IMFVideoDeviceID *deviceid;
     IUnknown *unk;
+    float rate;
     HRESULT hr;
     GUID iid;
 
@@ -902,6 +904,32 @@ static void test_default_presenter(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
+    /* Rate support. */
+    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFRateSupport, (void **)&rate_support);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    rate = 1.0f;
+    hr = IMFRateSupport_GetSlowestRate(rate_support, MFRATE_FORWARD, FALSE, &rate);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(rate == 0.0f, "Unexpected rate %f.\n", rate);
+
+    rate = 1.0f;
+    hr = IMFRateSupport_GetSlowestRate(rate_support, MFRATE_FORWARD, TRUE, &rate);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(rate == 0.0f, "Unexpected rate %f.\n", rate);
+
+    rate = 1.0f;
+    hr = IMFRateSupport_GetSlowestRate(rate_support, MFRATE_REVERSE, FALSE, &rate);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(rate == 0.0f, "Unexpected rate %f.\n", rate);
+
+    rate = 1.0f;
+    hr = IMFRateSupport_GetSlowestRate(rate_support, MFRATE_REVERSE, TRUE, &rate);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(rate == 0.0f, "Unexpected rate %f.\n", rate);
+
+    IMFRateSupport_Release(rate_support);
+
     IMFVideoPresenter_Release(presenter);
 }
 
From 7a4da22267c7907be7285719e366e7e29074cbd4 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 1 Jul 2020 15:55:43 +0300
Subject: [PATCH] evr: Implement presenter state tracking methods.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 63 +++++++++++++++++++++++++++++++++++++-------
 1 file changed, 53 insertions(+), 10 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 29167d364df..c70b83d0727 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -31,6 +31,14 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(evr);
 
+enum presenter_state
+{
+    PRESENTER_STATE_SHUT_DOWN = 0,
+    PRESENTER_STATE_STARTED,
+    PRESENTER_STATE_STOPPED,
+    PRESENTER_STATE_PAUSED,
+};
+
 struct video_presenter
 {
     IMFVideoPresenter IMFVideoPresenter_iface;
@@ -41,6 +49,9 @@ struct video_presenter
     IUnknown IUnknown_inner;
     IUnknown *outer_unk;
     LONG refcount;
+
+    unsigned int state;
+    CRITICAL_SECTION cs;
 };
 
 static struct video_presenter *impl_from_IUnknown(IUnknown *iface)
@@ -134,6 +145,7 @@ static ULONG WINAPI video_presenter_inner_Release(IUnknown *iface)
 
     if (!refcount)
     {
+        DeleteCriticalSection(&presenter->cs);
         heap_free(presenter);
     }
 
@@ -167,30 +179,54 @@ static ULONG WINAPI video_presenter_Release(IMFVideoPresenter *iface)
 
 static HRESULT WINAPI video_presenter_OnClockStart(IMFVideoPresenter *iface, MFTIME systime, LONGLONG offset)
 {
-    FIXME("%p, %s, %s.\n", iface, debugstr_time(systime), wine_dbgstr_longlong(offset));
+    struct video_presenter *presenter = impl_from_IMFVideoPresenter(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %s, %s.\n", iface, debugstr_time(systime), wine_dbgstr_longlong(offset));
+
+    EnterCriticalSection(&presenter->cs);
+    presenter->state = PRESENTER_STATE_STARTED;
+    LeaveCriticalSection(&presenter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_presenter_OnClockStop(IMFVideoPresenter *iface, MFTIME systime)
 {
-    FIXME("%p, %s.\n", iface, debugstr_time(systime));
+    struct video_presenter *presenter = impl_from_IMFVideoPresenter(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %s.\n", iface, debugstr_time(systime));
+
+    EnterCriticalSection(&presenter->cs);
+    presenter->state = PRESENTER_STATE_STOPPED;
+    LeaveCriticalSection(&presenter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_presenter_OnClockPause(IMFVideoPresenter *iface, MFTIME systime)
 {
-    FIXME("%p, %s.\n", iface, debugstr_time(systime));
+    struct video_presenter *presenter = impl_from_IMFVideoPresenter(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %s.\n", iface, debugstr_time(systime));
+
+    EnterCriticalSection(&presenter->cs);
+    presenter->state = PRESENTER_STATE_PAUSED;
+    LeaveCriticalSection(&presenter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_presenter_OnClockRestart(IMFVideoPresenter *iface, MFTIME systime)
 {
-    FIXME("%p, %s.\n", iface, debugstr_time(systime));
+    struct video_presenter *presenter = impl_from_IMFVideoPresenter(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %s.\n", iface, debugstr_time(systime));
+
+    EnterCriticalSection(&presenter->cs);
+    presenter->state = PRESENTER_STATE_STARTED;
+    LeaveCriticalSection(&presenter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_presenter_OnClockSetRate(IMFVideoPresenter *iface, MFTIME systime, float rate)
@@ -295,9 +331,15 @@ static HRESULT WINAPI video_presenter_service_client_InitServicePointers(IMFTopo
 
 static HRESULT WINAPI video_presenter_service_client_ReleaseServicePointers(IMFTopologyServiceLookupClient *iface)
 {
-    FIXME("%p.\n", iface);
+    struct video_presenter *presenter = impl_from_IMFTopologyServiceLookupClient(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&presenter->cs);
+    presenter->state = PRESENTER_STATE_SHUT_DOWN;
+    LeaveCriticalSection(&presenter->cs);
+
+    return S_OK;
 }
 
 static const IMFTopologyServiceLookupClientVtbl video_presenter_service_client_vtbl =
@@ -496,6 +538,7 @@ HRESULT evr_presenter_create(IUnknown *outer, void **out)
     object->IUnknown_inner.lpVtbl = &video_presenter_inner_vtbl;
     object->outer_unk = outer ? outer : &object->IUnknown_inner;
     object->refcount = 1;
+    InitializeCriticalSection(&object->cs);
 
     *out = &object->IUnknown_inner;
 
From 17e7de4bdfc5b5bb7aac42a2a7da109677167c35 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 1 Jul 2020 15:55:44 +0300
Subject: [PATCH] evr: Partially implement InitServicePointers() for the
 presenter.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 71 ++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 68 insertions(+), 3 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index c70b83d0727..a7da0704927 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -50,6 +50,10 @@ struct video_presenter
     IUnknown *outer_unk;
     LONG refcount;
 
+    IMFTransform *mixer;
+    IMFClock *clock;
+    IMediaEventSink *event_sink;
+
     unsigned int state;
     CRITICAL_SECTION cs;
 };
@@ -136,6 +140,19 @@ static ULONG WINAPI video_presenter_inner_AddRef(IUnknown *iface)
     return refcount;
 }
 
+static void video_presenter_clear_container(struct video_presenter *presenter)
+{
+    if (presenter->clock)
+        IMFClock_Release(presenter->clock);
+    if (presenter->mixer)
+        IMFTransform_Release(presenter->mixer);
+    if (presenter->event_sink)
+        IMediaEventSink_Release(presenter->event_sink);
+    presenter->clock = NULL;
+    presenter->mixer = NULL;
+    presenter->event_sink = NULL;
+}
+
 static ULONG WINAPI video_presenter_inner_Release(IUnknown *iface)
 {
     struct video_presenter *presenter = impl_from_IUnknown(iface);
@@ -145,6 +162,7 @@ static ULONG WINAPI video_presenter_inner_Release(IUnknown *iface)
 
     if (!refcount)
     {
+        video_presenter_clear_container(presenter);
         DeleteCriticalSection(&presenter->cs);
         heap_free(presenter);
     }
@@ -324,9 +342,53 @@ static ULONG WINAPI video_presenter_service_client_Release(IMFTopologyServiceLoo
 static HRESULT WINAPI video_presenter_service_client_InitServicePointers(IMFTopologyServiceLookupClient *iface,
         IMFTopologyServiceLookup *service_lookup)
 {
-    FIXME("%p, %p.\n", iface, service_lookup);
+    struct video_presenter *presenter = impl_from_IMFTopologyServiceLookupClient(iface);
+    unsigned int count;
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, service_lookup);
+
+    if (!service_lookup)
+        return E_POINTER;
+
+    EnterCriticalSection(&presenter->cs);
+
+    if (presenter->state == PRESENTER_STATE_STARTED ||
+            presenter->state == PRESENTER_STATE_PAUSED)
+    {
+        hr = MF_E_INVALIDREQUEST;
+    }
+    else
+    {
+        video_presenter_clear_container(presenter);
+
+        count = 1;
+        IMFTopologyServiceLookup_LookupService(service_lookup, MF_SERVICE_LOOKUP_GLOBAL, 0,
+                &MR_VIDEO_RENDER_SERVICE, &IID_IMFClock, (void **)&presenter->clock, &count);
+
+        count = 1;
+        if (SUCCEEDED(hr = IMFTopologyServiceLookup_LookupService(service_lookup, MF_SERVICE_LOOKUP_GLOBAL, 0,
+                &MR_VIDEO_MIXER_SERVICE, &IID_IMFTransform, (void **)&presenter->mixer, &count)))
+        {
+            /* FIXME: presumably should validate mixer's device id. */
+        }
+        else
+            WARN("Failed to get mixer interface, hr %#x.\n", hr);
+
+        count = 1;
+        if (FAILED(hr = IMFTopologyServiceLookup_LookupService(service_lookup, MF_SERVICE_LOOKUP_GLOBAL, 0,
+                &MR_VIDEO_RENDER_SERVICE, &IID_IMediaEventSink, (void **)&presenter->event_sink, &count)))
+        {
+            WARN("Failed to get renderer event sink, hr %#x.\n", hr);
+        }
+
+        if (SUCCEEDED(hr))
+            presenter->state = PRESENTER_STATE_STOPPED;
+    }
+
+    LeaveCriticalSection(&presenter->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_presenter_service_client_ReleaseServicePointers(IMFTopologyServiceLookupClient *iface)
@@ -336,7 +398,10 @@ static HRESULT WINAPI video_presenter_service_client_ReleaseServicePointers(IMFT
     TRACE("%p.\n", iface);
 
     EnterCriticalSection(&presenter->cs);
+
     presenter->state = PRESENTER_STATE_SHUT_DOWN;
+    video_presenter_clear_container(presenter);
+
     LeaveCriticalSection(&presenter->cs);
 
     return S_OK;
@@ -527,7 +592,7 @@ HRESULT evr_presenter_create(IUnknown *outer, void **out)
 {
     struct video_presenter *object;
 
-    if (!(object = heap_alloc(sizeof(*object))))
+    if (!(object = heap_alloc_zero(sizeof(*object))))
         return E_OUTOFMEMORY;
 
     object->IMFVideoPresenter_iface.lpVtbl = &video_presenter_vtbl;
From 1caf8ade07a95610f383de8205fa35b16a82253a Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 1 Jul 2020 15:55:45 +0300
Subject: [PATCH] evr: Add aggregation support for default mixer object.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 58 +++++++++++++++++++++++++++++++++++---------
 dlls/evr/tests/evr.c | 17 +++++++++++++
 2 files changed, 63 insertions(+), 12 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 23994375d45..c8bd300b0d3 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -60,6 +60,8 @@ struct video_mixer
     IMFVideoMixerBitmap IMFVideoMixerBitmap_iface;
     IMFVideoPositionMapper IMFVideoPositionMapper_iface;
     IMFVideoProcessor IMFVideoProcessor_iface;
+    IUnknown IUnknown_inner;
+    IUnknown *outer_unk;
     LONG refcount;
 
     struct input_stream inputs[MAX_MIXER_INPUT_STREAMS];
@@ -74,6 +76,11 @@ struct video_mixer
     CRITICAL_SECTION cs;
 };
 
+static struct video_mixer *impl_from_IUnknown(IUnknown *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_mixer, IUnknown_inner);
+}
+
 static struct video_mixer *impl_from_IMFTransform(IMFTransform *iface)
 {
     return CONTAINING_RECORD(iface, struct video_mixer, IMFTransform_iface);
@@ -155,17 +162,20 @@ static void video_mixer_clear_types(struct video_mixer *mixer)
     mixer->output.media_type = NULL;
 }
 
-static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
+static HRESULT WINAPI video_mixer_inner_QueryInterface(IUnknown *iface, REFIID riid, void **obj)
 {
-    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    struct video_mixer *mixer = impl_from_IUnknown(iface);
 
     TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
 
-    if (IsEqualIID(riid, &IID_IMFTransform) ||
-            IsEqualIID(riid, &IID_IUnknown))
+    if (IsEqualIID(riid, &IID_IUnknown))
     {
         *obj = iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFTransform))
+    {
+        *obj = &mixer->IMFTransform_iface;
+    }
     else if (IsEqualIID(riid, &IID_IMFVideoDeviceID))
     {
         *obj = &mixer->IMFVideoDeviceID_iface;
@@ -206,9 +216,9 @@ static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface,
     return S_OK;
 }
 
-static ULONG WINAPI video_mixer_transform_AddRef(IMFTransform *iface)
+static ULONG WINAPI video_mixer_inner_AddRef(IUnknown *iface)
 {
-    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    struct video_mixer *mixer = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedIncrement(&mixer->refcount);
 
     TRACE("%p, refcount %u.\n", iface, refcount);
@@ -216,9 +226,9 @@ static ULONG WINAPI video_mixer_transform_AddRef(IMFTransform *iface)
     return refcount;
 }
 
-static ULONG WINAPI video_mixer_transform_Release(IMFTransform *iface)
+static ULONG WINAPI video_mixer_inner_Release(IUnknown *iface)
 {
-    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    struct video_mixer *mixer = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedDecrement(&mixer->refcount);
     unsigned int i;
 
@@ -241,6 +251,31 @@ static ULONG WINAPI video_mixer_transform_Release(IMFTransform *iface)
     return refcount;
 }
 
+static const IUnknownVtbl video_mixer_inner_vtbl =
+{
+    video_mixer_inner_QueryInterface,
+    video_mixer_inner_AddRef,
+    video_mixer_inner_Release,
+};
+
+static HRESULT WINAPI video_mixer_transform_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
+{
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    return IUnknown_QueryInterface(mixer->outer_unk, riid, obj);
+}
+
+static ULONG WINAPI video_mixer_transform_AddRef(IMFTransform *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    return IUnknown_AddRef(mixer->outer_unk);
+}
+
+static ULONG WINAPI video_mixer_transform_Release(IMFTransform *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
+    return IUnknown_Release(mixer->outer_unk);
+}
+
 static HRESULT WINAPI video_mixer_transform_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum,
         DWORD *input_maximum, DWORD *output_minimum, DWORD *output_maximum)
 {
@@ -1251,9 +1286,6 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
 {
     struct video_mixer *object;
 
-    if (outer)
-        return E_NOINTERFACE;
-
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
 
@@ -1265,12 +1297,14 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
     object->IMFVideoMixerBitmap_iface.lpVtbl = &video_mixer_bitmap_vtbl;
     object->IMFVideoPositionMapper_iface.lpVtbl = &video_mixer_position_mapper_vtbl;
     object->IMFVideoProcessor_iface.lpVtbl = &video_mixer_processor_vtbl;
+    object->IUnknown_inner.lpVtbl = &video_mixer_inner_vtbl;
+    object->outer_unk = outer ? outer : &object->IUnknown_inner;
     object->refcount = 1;
     object->input_count = 1;
     video_mixer_init_input(&object->inputs[0]);
     InitializeCriticalSection(&object->cs);
 
-    *out = &object->IMFTransform_iface;
+    *out = &object->IUnknown_inner;
 
     return S_OK;
 }
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index dd3fbbe0289..1046e70312d 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -119,6 +119,7 @@ static void test_aggregation(void)
     IBaseFilter *filter, *filter2;
     IMFVideoPresenter *presenter;
     IUnknown *unk, *unk2;
+    IMFTransform *mixer;
     HRESULT hr;
     ULONG ref;
 
@@ -191,6 +192,22 @@ static void test_aggregation(void)
 
         IUnknown_Release(unk);
     }
+
+    /* Default mixer. */
+    presenter = (void *)0xdeadbeef;
+    hr = CoCreateInstance(&CLSID_MFVideoMixer9, &test_outer, CLSCTX_INPROC_SERVER, &IID_IMFTransform,
+            (void **)&mixer);
+    ok(hr == E_NOINTERFACE, "Unexpected hr %#x.\n", hr);
+    ok(!mixer, "Got interface %p.\n", mixer);
+
+    hr = CoCreateInstance(&CLSID_MFVideoMixer9, &test_outer, CLSCTX_INPROC_SERVER, &IID_IUnknown, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
+    ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
+    ref = get_refcount(unk);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+
+    IUnknown_Release(unk);
 }
 
 #define check_interface(a, b, c) check_interface_(__LINE__, a, b, c)
From 9630f9779887216eb3e079764a32240040580ff3 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 1 Jul 2020 15:55:46 +0300
Subject: [PATCH] evr: Added MFCreateVideoMixerAndPresenter().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/evr.spec    |  2 +-
 dlls/evr/main.c      | 28 ++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c | 13 +++++++++++++
 include/evr.idl      |  3 ++-
 4 files changed, 44 insertions(+), 2 deletions(-)

diff --git a/dlls/evr/evr.spec b/dlls/evr/evr.spec
index e46cb04f644..73cbf05b461 100644
--- a/dlls/evr/evr.spec
+++ b/dlls/evr/evr.spec
@@ -14,7 +14,7 @@
 @ stub MFCreateVideoMediaTypeFromVideoInfoHeader2
 @ stub MFCreateVideoMediaTypeFromVideoInfoHeader
 @ stdcall MFCreateVideoMixer(ptr ptr ptr ptr)
-@ stub MFCreateVideoMixerAndPresenter
+@ stdcall MFCreateVideoMixerAndPresenter(ptr ptr ptr ptr ptr ptr)
 @ stub MFCreateVideoOTA
 @ stub MFCreateVideoPresenter2
 @ stdcall MFCreateVideoPresenter(ptr ptr ptr ptr)
diff --git a/dlls/evr/main.c b/dlls/evr/main.c
index 2c6db8430ba..301330a51e2 100644
--- a/dlls/evr/main.c
+++ b/dlls/evr/main.c
@@ -196,3 +196,31 @@ HRESULT WINAPI DllUnregisterServer(void)
 {
     return __wine_unregister_resources(instance_evr);
 }
+
+HRESULT WINAPI MFCreateVideoMixerAndPresenter(IUnknown *mixer_outer, IUnknown *presenter_outer,
+        REFIID riid_mixer, void **mixer, REFIID riid_presenter, void **presenter)
+{
+    HRESULT hr;
+
+    TRACE("%p, %p, %s, %p, %s, %p.\n", mixer_outer, presenter_outer, debugstr_guid(riid_mixer), mixer,
+            debugstr_guid(riid_presenter), presenter);
+
+    if (!mixer || !presenter)
+        return E_POINTER;
+
+    *mixer = *presenter = NULL;
+
+    if (SUCCEEDED(hr = CoCreateInstance(&CLSID_MFVideoMixer9, mixer_outer, CLSCTX_INPROC_SERVER, riid_mixer, mixer)))
+        hr = CoCreateInstance(&CLSID_MFVideoPresenter9, presenter_outer, CLSCTX_INPROC_SERVER, riid_presenter, presenter);
+
+    if (FAILED(hr))
+    {
+        if (*mixer)
+            IUnknown_Release((IUnknown *)*mixer);
+        if (*presenter)
+            IUnknown_Release((IUnknown *)*presenter);
+        *mixer = *presenter = NULL;
+    }
+
+    return hr;
+}
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 1046e70312d..b9f86eb2529 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -950,6 +950,18 @@ static void test_default_presenter(void)
     IMFVideoPresenter_Release(presenter);
 }
 
+static void test_MFCreateVideoMixerAndPresenter(void)
+{
+    IUnknown *mixer, *presenter;
+    HRESULT hr;
+
+    hr = MFCreateVideoMixerAndPresenter(NULL, NULL, &IID_IUnknown, (void **)&mixer, &IID_IUnknown, (void **)&presenter);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    IUnknown_Release(mixer);
+    IUnknown_Release(presenter);
+}
+
 START_TEST(evr)
 {
     CoInitialize(NULL);
@@ -965,6 +977,7 @@ START_TEST(evr)
     test_default_mixer_type_negotiation();
     test_surface_sample();
     test_default_presenter();
+    test_MFCreateVideoMixerAndPresenter();
 
     CoUninitialize();
 }
diff --git a/include/evr.idl b/include/evr.idl
index 384a051944c..8628e111a31 100644
--- a/include/evr.idl
+++ b/include/evr.idl
@@ -299,7 +299,8 @@ cpp_quote("DEFINE_GUID(MR_VIDEO_MIXER_SERVICE, 0x073cd2fc, 0x6cf4, 0x40b7, 0x88,
 cpp_quote("DEFINE_GUID(MR_VIDEO_ACCELERATION_SERVICE, 0xefef5175, 0x5c7d, 0x4ce2, 0xbb, 0xbd, 0x34, 0xff, 0x8b, 0xca, 0x65, 0x54);")
 cpp_quote("DEFINE_GUID(MR_BUFFER_SERVICE, 0xa562248c, 0x9ac6, 0x4ffc, 0x9f, 0xba, 0x3a, 0xf8, 0xf8, 0xad, 0x1a, 0x4d);")
 cpp_quote("DEFINE_GUID(VIDEO_ZOOM_RECT, 0x7aaa1638, 0x1b7f, 0x4c93, 0xbd, 0x89, 0x5b, 0x9c, 0x9f, 0xb6, 0xfc, 0xf0);")
-
 cpp_quote("HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj);")
+cpp_quote("HRESULT WINAPI MFCreateVideoMixerAndPresenter(IUnknown *mixer_outer, IUnknown *presenter_outer, ")
+cpp_quote("        REFIID riid_mixer, void **mixer, REFIID riid_presenter, void **presenter);")
 cpp_quote("HRESULT WINAPI MFCreateVideoPresenter(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj);")
 cpp_quote("HRESULT WINAPI MFCreateVideoSampleFromSurface(IUnknown *surface, IMFSample **sample);")
From f0696f7e332090ff960bfadd97c09dfa9952a804 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 1 Jul 2020 15:57:14 +0300
Subject: [PATCH] mfplat/tests: Add some tests for d3d9 surface buffer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/tests/Makefile.in |   2 +-
 dlls/mfplat/tests/mfplat.c    | 185 ++++++++++++++++++++++++++++++++++
 include/mfapi.h               |   1 +
 3 files changed, 187 insertions(+), 1 deletion(-)

diff --git a/dlls/mfplat/tests/Makefile.in b/dlls/mfplat/tests/Makefile.in
index c58a0463e51..4e9413e8da0 100644
--- a/dlls/mfplat/tests/Makefile.in
+++ b/dlls/mfplat/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = mfplat.dll
-IMPORTS   = ole32 mfplat mfuuid propsys uuid
+IMPORTS   = ole32 mfplat user32 d3d9 mfuuid propsys uuid strmiids
 
 C_SRCS = \
 	mfplat.c
diff --git a/dlls/mfplat/tests/mfplat.c b/dlls/mfplat/tests/mfplat.c
index aac6f734583..8b4012f8087 100644
--- a/dlls/mfplat/tests/mfplat.c
+++ b/dlls/mfplat/tests/mfplat.c
@@ -34,6 +34,7 @@
 #include "mfreadwrite.h"
 #include "propvarutil.h"
 #include "strsafe.h"
+#include "evr.h"
 
 #include "wine/test.h"
 #include "wine/heap.h"
@@ -41,6 +42,7 @@
 #define D3D11_INIT_GUID
 #include "initguid.h"
 #include "d3d11_4.h"
+#include "d3d9.h"
 #include "d3d9types.h"
 #include "ks.h"
 #include "ksmedia.h"
@@ -104,6 +106,38 @@ static HRESULT (WINAPI *pMFCreate2DMediaBuffer)(DWORD width, DWORD height, DWORD
         IMFMediaBuffer **buffer);
 static HRESULT (WINAPI *pMFCreateMediaBufferFromMediaType)(IMFMediaType *media_type, LONGLONG duration, DWORD min_length,
         DWORD min_alignment, IMFMediaBuffer **buffer);
+static HRESULT (WINAPI *pMFCreateDXSurfaceBuffer)(REFIID riid, IUnknown *surface, BOOL bottom_up, IMFMediaBuffer **buffer);
+
+static HWND create_window(void)
+{
+    RECT r = {0, 0, 640, 480};
+
+    AdjustWindowRect(&r, WS_OVERLAPPEDWINDOW | WS_VISIBLE, FALSE);
+
+    return CreateWindowA("static", "d3d9_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+            0, 0, r.right - r.left, r.bottom - r.top, NULL, NULL, NULL, NULL);
+}
+
+static IDirect3DDevice9 *create_device(IDirect3D9 *d3d9, HWND focus_window)
+{
+    D3DPRESENT_PARAMETERS present_parameters = {0};
+    IDirect3DDevice9 *device = NULL;
+
+    present_parameters.BackBufferWidth = 640;
+    present_parameters.BackBufferHeight = 480;
+    present_parameters.BackBufferFormat = D3DFMT_A8R8G8B8;
+    present_parameters.SwapEffect = D3DSWAPEFFECT_DISCARD;
+    present_parameters.hDeviceWindow = focus_window;
+    present_parameters.Windowed = TRUE;
+    present_parameters.EnableAutoDepthStencil = TRUE;
+    present_parameters.AutoDepthStencilFormat = D3DFMT_D24S8;
+    present_parameters.Flags = D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;
+
+    IDirect3D9_CreateDevice(d3d9, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, focus_window,
+            D3DCREATE_HARDWARE_VERTEXPROCESSING, &present_parameters, &device);
+
+    return device;
+}
 
 static const WCHAR fileschemeW[] = L"file://";
 
@@ -677,6 +711,7 @@ static void init_functions(void)
     X(MFCopyImage);
     X(MFCreate2DMediaBuffer);
     X(MFCreateDXGIDeviceManager);
+    X(MFCreateDXSurfaceBuffer);
     X(MFCreateSourceResolver);
     X(MFCreateMediaBufferFromMediaType);
     X(MFCreateMFByteStreamOnStream);
@@ -5281,6 +5316,155 @@ static void test_MFCreateMFVideoFormatFromMFMediaType(void)
     IMFMediaType_Release(media_type);
 }
 
+static void test_MFCreateDXSurfaceBuffer(void)
+{
+    IDirect3DSurface9 *backbuffer = NULL, *surface;
+    IDirect3DSwapChain9 *swapchain;
+    IDirect3DDevice9 *device;
+    IMF2DBuffer2 *_2dbuffer2;
+    IMFMediaBuffer *buffer;
+    IMF2DBuffer *_2dbuffer;
+    BYTE *data, *data2;
+    IMFGetService *gs;
+    IDirect3D9 *d3d;
+    DWORD length;
+    HWND window;
+    HRESULT hr;
+    LONG pitch;
+    BOOL value;
+
+    if (!pMFCreateDXSurfaceBuffer)
+    {
+        skip("MFCreateDXSurfaceBuffer is not available.\n");
+        return;
+    }
+
+    window = create_window();
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+    ok(!!d3d, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d, window)))
+    {
+        skip("Failed to create a D3D device, skipping tests.\n");
+        goto done;
+    }
+
+    hr = IDirect3DDevice9_GetSwapChain(device, 0, &swapchain);
+    ok(SUCCEEDED(hr), "Failed to get the implicit swapchain (%08x)\n", hr);
+
+    hr = IDirect3DSwapChain9_GetBackBuffer(swapchain, 0, D3DBACKBUFFER_TYPE_MONO, &backbuffer);
+    ok(SUCCEEDED(hr), "Failed to get the back buffer (%08x)\n", hr);
+    ok(backbuffer != NULL, "The back buffer is NULL\n");
+
+    IDirect3DSwapChain9_Release(swapchain);
+
+    hr = pMFCreateDXSurfaceBuffer(&IID_IDirect3DSurface9, (IUnknown *)backbuffer, FALSE, &buffer);
+    ok(hr == S_OK, "Failed to create a buffer, hr %#x.\n", hr);
+
+    /* Surface is accessible. */
+    hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMFGetService, (void **)&gs);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    hr = IMFGetService_GetService(gs, &MR_BUFFER_SERVICE, &IID_IDirect3DSurface9, (void **)&surface);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(surface == backbuffer, "Unexpected surface pointer.\n");
+    IDirect3DSurface9_Release(surface);
+    IMFGetService_Release(gs);
+
+    length = 0;
+    hr = IMFMediaBuffer_GetMaxLength(buffer, &length);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!!length, "Unexpected length %u.\n", length);
+
+    hr = IMFMediaBuffer_GetCurrentLength(buffer, &length);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+    ok(!length, "Unexpected length %u.\n", length);
+
+    hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* Unlock twice. */
+    hr = IMFMediaBuffer_Unlock(buffer);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaBuffer_Unlock(buffer);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#x.\n", hr);
+
+    /* Lock twice. */
+    hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaBuffer_Lock(buffer, &data2, NULL, NULL);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(data == data2, "Unexpected pointer.\n");
+
+    hr = IMFMediaBuffer_Unlock(buffer);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaBuffer_Unlock(buffer);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer, (void **)&_2dbuffer);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* Unlocked. */
+    hr = IMF2DBuffer_GetScanline0AndPitch(_2dbuffer, &data, &pitch);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#x.\n", hr);
+
+    hr = IMF2DBuffer_Lock2D(_2dbuffer, &data, &pitch);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMF2DBuffer_GetScanline0AndPitch(_2dbuffer, &data, &pitch);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaBuffer_Lock(buffer, &data2, NULL, NULL);
+    ok(hr == MF_E_INVALIDREQUEST, "Unexpected hr %#x.\n", hr);
+
+    hr = IMF2DBuffer_Lock2D(_2dbuffer, &data, &pitch);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMF2DBuffer_Unlock2D(_2dbuffer);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMF2DBuffer_Unlock2D(_2dbuffer);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMF2DBuffer_Unlock2D(_2dbuffer);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#x.\n", hr);
+
+    hr = IMF2DBuffer_IsContiguousFormat(_2dbuffer, &value);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!value, "Unexpected return value %d.\n", value);
+
+    IMF2DBuffer_Release(_2dbuffer);
+
+    hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer2, (void **)&_2dbuffer2);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMF2DBuffer2_Lock2DSize(_2dbuffer2, MF2DBuffer_LockFlags_Read, &data, &pitch, &data2, &length);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(data == data2, "Unexpected scanline pointer.\n");
+    memset(data, 0xab, 4);
+    IMF2DBuffer2_Unlock2D(_2dbuffer2);
+
+    hr = IMF2DBuffer2_Lock2DSize(_2dbuffer2, MF2DBuffer_LockFlags_Write, &data, &pitch, &data2, &length);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(data[0] == 0xab, "Unexpected leading byte.\n");
+    IMF2DBuffer2_Unlock2D(_2dbuffer2);
+
+    hr = IMF2DBuffer2_Lock2DSize(_2dbuffer2, MF2DBuffer_LockFlags_ReadWrite, &data, &pitch, &data2, &length);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IMF2DBuffer2_Unlock2D(_2dbuffer2);
+
+    IMF2DBuffer2_Release(_2dbuffer2);
+
+    IMFMediaBuffer_Release(buffer);
+
+done:
+    if (backbuffer)
+        IDirect3DSurface9_Release(backbuffer);
+    IDirect3D9_Release(d3d);
+    DestroyWindow(window);
+}
+
 START_TEST(mfplat)
 {
     char **argv;
@@ -5337,6 +5521,7 @@ START_TEST(mfplat)
     test_MFCreateMediaBufferFromMediaType();
     test_MFInitMediaTypeFromWaveFormatEx();
     test_MFCreateMFVideoFormatFromMFMediaType();
+    test_MFCreateDXSurfaceBuffer();
 
     CoUninitialize();
 }
diff --git a/include/mfapi.h b/include/mfapi.h
index 06a5412cbc5..b1edeac02f6 100644
--- a/include/mfapi.h
+++ b/include/mfapi.h
@@ -502,6 +502,7 @@ HRESULT WINAPI MFCreateAttributes(IMFAttributes **attributes, UINT32 size);
 HRESULT WINAPI MFCreateAsyncResult(IUnknown *object, IMFAsyncCallback *callback, IUnknown *state, IMFAsyncResult **result);
 HRESULT WINAPI MFCreateCollection(IMFCollection **collection);
 HRESULT WINAPI MFCreateDXGIDeviceManager(UINT *token, IMFDXGIDeviceManager **manager);
+HRESULT WINAPI MFCreateDXSurfaceBuffer(REFIID riid, IUnknown *surface, BOOL bottom_up, IMFMediaBuffer **buffer);
 HRESULT WINAPI MFCreateEventQueue(IMFMediaEventQueue **queue);
 HRESULT WINAPI MFCreateFile(MF_FILE_ACCESSMODE accessmode, MF_FILE_OPENMODE openmode, MF_FILE_FLAGS flags,
                             LPCWSTR url, IMFByteStream **bytestream);
From eadcba79251f616b8028e2e39ee71985ee5d863b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 1 Jul 2020 12:10:01 -0500
Subject: [PATCH] winegstreamer: Append a deinterlace element to the video
 post-processing chain.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30366
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 21 +++++++++++++++++----
 1 file changed, 17 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 5697d2c0e0c..e6f00842df5 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -995,7 +995,16 @@ static void init_new_decoded_pad(GstElement *bin, GstPad *pad, struct gstdemux *
 
     if (!strcmp(typename, "video/x-raw"))
     {
-        GstElement *vconv, *flip;
+        GstElement *vconv, *flip, *deinterlace;
+
+        /* DirectShow can express interlaced video, but downstream filters can't
+         * necessarily consume it. In particular, the video renderer can't. */
+        if (!(deinterlace = gst_element_factory_make("deinterlace", NULL)))
+        {
+            ERR("Failed to create deinterlace, are %u-bit GStreamer \"base\" plugins installed?\n",
+                    8 * (int)sizeof(void *));
+            goto out;
+        }
 
         /* decodebin considers many YUV formats to be "raw", but some quartz
          * filters can't handle those. Also, videoflip can't handle all "raw"
@@ -1018,14 +1027,18 @@ static void init_new_decoded_pad(GstElement *bin, GstPad *pad, struct gstdemux *
             goto out;
         }
 
-        gst_bin_add(GST_BIN(This->container), vconv); /* bin takes ownership */
+        /* The bin takes ownership of these elements. */
+        gst_bin_add(GST_BIN(This->container), deinterlace);
+        gst_element_sync_state_with_parent(deinterlace);
+        gst_bin_add(GST_BIN(This->container), vconv);
         gst_element_sync_state_with_parent(vconv);
-        gst_bin_add(GST_BIN(This->container), flip); /* bin takes ownership */
+        gst_bin_add(GST_BIN(This->container), flip);
         gst_element_sync_state_with_parent(flip);
 
+        gst_element_link(deinterlace, vconv);
         gst_element_link(vconv, flip);
 
-        pin->post_sink = gst_element_get_static_pad(vconv, "sink");
+        pin->post_sink = gst_element_get_static_pad(deinterlace, "sink");
         pin->post_src = gst_element_get_static_pad(flip, "src");
         pin->flip = flip;
     }
From 2b8462a52075a25c260007900d51db602b337c8d Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 3 Jul 2020 19:22:15 +0300
Subject: [PATCH] evr: Add a stub for sample allocator.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/Makefile.in |   3 +-
 dlls/evr/evr.spec    |   2 +-
 dlls/evr/sample.c    | 199 +++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c |  19 +++++
 include/evr.idl      |   1 +
 include/mfidl.idl    |  57 +++++++++++++
 6 files changed, 279 insertions(+), 2 deletions(-)
 create mode 100644 dlls/evr/sample.c

diff --git a/dlls/evr/Makefile.in b/dlls/evr/Makefile.in
index daaf9cc872a..c8178297dab 100644
--- a/dlls/evr/Makefile.in
+++ b/dlls/evr/Makefile.in
@@ -9,6 +9,7 @@ C_SRCS = \
 	evr.c \
 	main.c \
 	mixer.c \
-	presenter.c
+	presenter.c \
+	sample.c
 
 IDL_SRCS = evr_classes.idl
diff --git a/dlls/evr/evr.spec b/dlls/evr/evr.spec
index 73cbf05b461..aa839295658 100644
--- a/dlls/evr/evr.spec
+++ b/dlls/evr/evr.spec
@@ -18,7 +18,7 @@
 @ stub MFCreateVideoOTA
 @ stub MFCreateVideoPresenter2
 @ stdcall MFCreateVideoPresenter(ptr ptr ptr ptr)
-@ stub MFCreateVideoSampleAllocator
+@ stdcall MFCreateVideoSampleAllocator(ptr ptr)
 @ stdcall MFCreateVideoSampleFromSurface(ptr ptr)
 @ stub MFGetPlaneSize
 @ stub MFGetStrideForBitmapInfoHeader
diff --git a/dlls/evr/sample.c b/dlls/evr/sample.c
new file mode 100644
index 00000000000..f371d920762
--- /dev/null
+++ b/dlls/evr/sample.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2020 Nikolay Sivov
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+
+#include "evr.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(evr);
+
+struct sample_allocator
+{
+    IMFVideoSampleAllocator IMFVideoSampleAllocator_iface;
+    IMFVideoSampleAllocatorCallback IMFVideoSampleAllocatorCallback_iface;
+    LONG refcount;
+};
+
+static struct sample_allocator *impl_from_IMFVideoSampleAllocator(IMFVideoSampleAllocator *iface)
+{
+    return CONTAINING_RECORD(iface, struct sample_allocator, IMFVideoSampleAllocator_iface);
+}
+
+static struct sample_allocator *impl_from_IMFVideoSampleAllocatorCallback(IMFVideoSampleAllocatorCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct sample_allocator, IMFVideoSampleAllocatorCallback_iface);
+}
+
+static HRESULT WINAPI sample_allocator_QueryInterface(IMFVideoSampleAllocator *iface, REFIID riid, void **obj)
+{
+    struct sample_allocator *allocator = impl_from_IMFVideoSampleAllocator(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IMFVideoSampleAllocator) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = &allocator->IMFVideoSampleAllocator_iface;
+    }
+    else if (IsEqualIID(riid, &IID_IMFVideoSampleAllocatorCallback))
+    {
+        *obj = &allocator->IMFVideoSampleAllocatorCallback_iface;
+    }
+    else
+    {
+        WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+        *obj = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*obj);
+    return S_OK;
+}
+
+static ULONG WINAPI sample_allocator_AddRef(IMFVideoSampleAllocator *iface)
+{
+    struct sample_allocator *allocator = impl_from_IMFVideoSampleAllocator(iface);
+    ULONG refcount = InterlockedIncrement(&allocator->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI sample_allocator_Release(IMFVideoSampleAllocator *iface)
+{
+    struct sample_allocator *allocator = impl_from_IMFVideoSampleAllocator(iface);
+    ULONG refcount = InterlockedDecrement(&allocator->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        heap_free(allocator);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI sample_allocator_SetDirectXManager(IMFVideoSampleAllocator *iface,
+        IUnknown *manager)
+{
+    FIXME("%p, %p.\n", iface, manager);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI sample_allocator_UninitializeSampleAllocator(IMFVideoSampleAllocator *iface)
+{
+    FIXME("%p.\n", iface);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI sample_allocator_InitializeSampleAllocator(IMFVideoSampleAllocator *iface,
+        DWORD sample_count, IMFMediaType *media_type)
+{
+    FIXME("%p, %u, %p.\n", iface, sample_count, media_type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI sample_allocator_AllocateSample(IMFVideoSampleAllocator *iface, IMFSample **sample)
+{
+    FIXME("%p, %p.\n", iface, sample);
+
+    return E_NOTIMPL;
+}
+
+static const IMFVideoSampleAllocatorVtbl sample_allocator_vtbl =
+{
+    sample_allocator_QueryInterface,
+    sample_allocator_AddRef,
+    sample_allocator_Release,
+    sample_allocator_SetDirectXManager,
+    sample_allocator_UninitializeSampleAllocator,
+    sample_allocator_InitializeSampleAllocator,
+    sample_allocator_AllocateSample,
+};
+
+static HRESULT WINAPI sample_allocator_callback_QueryInterface(IMFVideoSampleAllocatorCallback *iface,
+        REFIID riid, void **obj)
+{
+    struct sample_allocator *allocator = impl_from_IMFVideoSampleAllocatorCallback(iface);
+    return IMFVideoSampleAllocator_QueryInterface(&allocator->IMFVideoSampleAllocator_iface, riid, obj);
+}
+
+static ULONG WINAPI sample_allocator_callback_AddRef(IMFVideoSampleAllocatorCallback *iface)
+{
+    struct sample_allocator *allocator = impl_from_IMFVideoSampleAllocatorCallback(iface);
+    return IMFVideoSampleAllocator_AddRef(&allocator->IMFVideoSampleAllocator_iface);
+}
+
+static ULONG WINAPI sample_allocator_callback_Release(IMFVideoSampleAllocatorCallback *iface)
+{
+    struct sample_allocator *allocator = impl_from_IMFVideoSampleAllocatorCallback(iface);
+    return IMFVideoSampleAllocator_Release(&allocator->IMFVideoSampleAllocator_iface);
+}
+
+static HRESULT WINAPI sample_allocator_callback_SetCallback(IMFVideoSampleAllocatorCallback *iface,
+        IMFVideoSampleAllocatorNotify *callback)
+{
+    FIXME("%p, %p.\n", iface, callback);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI sample_allocator_callback_GetFreeSampleCount(IMFVideoSampleAllocatorCallback *iface,
+        LONG *count)
+{
+    FIXME("%p, %p.\n", iface, count);
+
+    return E_NOTIMPL;
+}
+
+static const IMFVideoSampleAllocatorCallbackVtbl sample_allocator_callback_vtbl =
+{
+    sample_allocator_callback_QueryInterface,
+    sample_allocator_callback_AddRef,
+    sample_allocator_callback_Release,
+    sample_allocator_callback_SetCallback,
+    sample_allocator_callback_GetFreeSampleCount,
+};
+
+HRESULT WINAPI MFCreateVideoSampleAllocator(REFIID riid, void **obj)
+{
+    struct sample_allocator *object;
+    HRESULT hr;
+
+    TRACE("%s, %p.\n", debugstr_guid(riid), obj);
+
+    if (!(object = heap_alloc_zero(sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFVideoSampleAllocator_iface.lpVtbl = &sample_allocator_vtbl;
+    object->IMFVideoSampleAllocatorCallback_iface.lpVtbl = &sample_allocator_callback_vtbl;
+    object->refcount = 1;
+
+    hr = IMFVideoSampleAllocator_QueryInterface(&object->IMFVideoSampleAllocator_iface, riid, obj);
+    IMFVideoSampleAllocator_Release(&object->IMFVideoSampleAllocator_iface);
+
+    return hr;
+}
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index b9f86eb2529..5773fedd226 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -962,6 +962,24 @@ static void test_MFCreateVideoMixerAndPresenter(void)
     IUnknown_Release(presenter);
 }
 
+static void test_MFCreateVideoSampleAllocator(void)
+{
+    IUnknown *unk;
+    HRESULT hr;
+
+    hr = MFCreateVideoSampleAllocator(&IID_IUnknown, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
+    hr = MFCreateVideoSampleAllocator(&IID_IMFVideoSampleAllocator, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
+    hr = MFCreateVideoSampleAllocator(&IID_IMFVideoSampleAllocatorCallback, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+}
+
 START_TEST(evr)
 {
     CoInitialize(NULL);
@@ -978,6 +996,7 @@ START_TEST(evr)
     test_surface_sample();
     test_default_presenter();
     test_MFCreateVideoMixerAndPresenter();
+    test_MFCreateVideoSampleAllocator();
 
     CoUninitialize();
 }
diff --git a/include/evr.idl b/include/evr.idl
index 8628e111a31..6369a39b2f3 100644
--- a/include/evr.idl
+++ b/include/evr.idl
@@ -303,4 +303,5 @@ cpp_quote("HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device
 cpp_quote("HRESULT WINAPI MFCreateVideoMixerAndPresenter(IUnknown *mixer_outer, IUnknown *presenter_outer, ")
 cpp_quote("        REFIID riid_mixer, void **mixer, REFIID riid_presenter, void **presenter);")
 cpp_quote("HRESULT WINAPI MFCreateVideoPresenter(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj);")
+cpp_quote("HRESULT WINAPI MFCreateVideoSampleAllocator(REFIID riid, void **allocator);")
 cpp_quote("HRESULT WINAPI MFCreateVideoSampleFromSurface(IUnknown *surface, IMFSample **sample);")
diff --git a/include/mfidl.idl b/include/mfidl.idl
index 35419756b5c..1f5fc06dd1e 100644
--- a/include/mfidl.idl
+++ b/include/mfidl.idl
@@ -1040,6 +1040,63 @@ interface IMFAudioPolicy : IUnknown
     HRESULT GetIconPath([out] LPWSTR *path);
 }
 
+[
+    object,
+    uuid(86cbc910-e533-4751-8e3b-f19b5b806a03),
+    local
+]
+interface IMFVideoSampleAllocator : IUnknown
+{
+    HRESULT SetDirectXManager(
+        [in, unique] IUnknown *manager
+    );
+    HRESULT UninitializeSampleAllocator();
+    HRESULT InitializeSampleAllocator(
+        [in] DWORD sample_count,
+        [in] IMFMediaType *media_type
+    );
+
+    HRESULT AllocateSample(
+        [out] IMFSample **sample
+    );
+}
+
+[
+    object,
+    uuid(a792cdbe-c374-4e89-8335-278e7b9956a4),
+    local
+]
+interface IMFVideoSampleAllocatorNotify : IUnknown
+{
+    HRESULT NotifyRelease();
+}
+
+[
+    object,
+    uuid(3978aa1a-6d5b-4b7f-a340-90899189ae34),
+    local
+]
+interface IMFVideoSampleAllocatorNotifyEx : IMFVideoSampleAllocatorNotify
+{
+    HRESULT NotifyPrune(IMFSample *sample);
+}
+
+[
+    object,
+    uuid(992388b4-3372-4f67-8b6f-c84c071f4751),
+    local
+]
+interface IMFVideoSampleAllocatorCallback : IUnknown
+{
+    HRESULT SetCallback(
+        [in, unique] IMFVideoSampleAllocatorNotify *callback
+    );
+
+    HRESULT GetFreeSampleCount(
+        [out] LONG *count
+    );
+}
+
 enum
 {
     MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL = 0x00000001,
From ba11eed83be5ab3fe77abfbd84311856ad87a461 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 3 Jul 2020 19:22:16 +0300
Subject: [PATCH] evr/tests: Add some tests for sample allocator.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/tests/evr.c | 127 +++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 123 insertions(+), 4 deletions(-)

diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 5773fedd226..db9b3a80e04 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -623,6 +623,7 @@ todo_wine
 static void test_surface_sample(void)
 {
     IDirect3DSurface9 *backbuffer = NULL;
+    IMFDesiredSample *desired_sample;
     IMFMediaBuffer *buffer, *buffer2;
     IDirect3DSwapChain9 *swapchain;
     IDirect3DDevice9 *device;
@@ -662,9 +663,20 @@ todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
-    hr = IMFSample_QueryInterface(sample, &IID_IMFDesiredSample, (void **)&unk);
+    hr = IMFSample_QueryInterface(sample, &IID_IMFDesiredSample, (void **)&desired_sample);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    IUnknown_Release(unk);
+
+    hr = IMFSample_GetCount(sample, &count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!count, "Unexpected attribute count %u.\n", count);
+
+    IMFDesiredSample_SetDesiredSampleTimeAndDuration(desired_sample, 123, 456);
+
+    hr = IMFSample_GetCount(sample, &count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!count, "Unexpected attribute count %u.\n", count);
+
+    IMFDesiredSample_Release(desired_sample);
 
     hr = IMFSample_GetCount(sample, &count);
     ok(hr == S_OK, "Failed to get attribute count, hr %#x.\n", hr);
@@ -964,16 +976,123 @@ static void test_MFCreateVideoMixerAndPresenter(void)
 
 static void test_MFCreateVideoSampleAllocator(void)
 {
+    IMFVideoSampleAllocatorCallback *allocator_cb;
+    IMFVideoSampleAllocator *allocator;
+    IMFVideoMediaType *video_type;
+    IMFSample *sample, *sample2;
+    IDirect3DSurface9 *surface;
+    IMFMediaType *media_type;
+    IMFMediaBuffer *buffer;
+    IMFGetService *gs;
     IUnknown *unk;
     HRESULT hr;
+    LONG count;
 
     hr = MFCreateVideoSampleAllocator(&IID_IUnknown, (void **)&unk);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
-    hr = MFCreateVideoSampleAllocator(&IID_IMFVideoSampleAllocator, (void **)&unk);
+    hr = MFCreateVideoSampleAllocator(&IID_IMFVideoSampleAllocator, (void **)&allocator);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    IUnknown_Release(unk);
+
+    hr = IMFVideoSampleAllocator_QueryInterface(allocator, &IID_IMFVideoSampleAllocatorCallback, (void **)&allocator_cb);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    count = 10;
+    hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!count, "Unexpected count %d.\n", count);
+}
+    hr = IMFVideoSampleAllocator_UninitializeSampleAllocator(allocator);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoSampleAllocator_AllocateSample(allocator, &sample);
+todo_wine
+    ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
+
+    hr = MFCreateMediaType(&media_type);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* It expects IMFVideoMediaType. */
+    hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 2, media_type);
+todo_wine
+    ok(hr == E_NOINTERFACE, "Unexpected hr %#x.\n", hr);
+
+    hr = MFCreateVideoMediaTypeFromSubtype(&MFVideoFormat_RGB32, &video_type);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 2, (IMFMediaType *)video_type);
+todo_wine
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
+
+    /* Frame size is required. */
+    hr = IMFVideoMediaType_SetUINT64(video_type, &MF_MT_FRAME_SIZE, (UINT64) 320 << 32 | 240);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 0, (IMFMediaType *)video_type);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(count == 1, "Unexpected count %d.\n", count);
+}
+    sample = NULL;
+    hr = IMFVideoSampleAllocator_AllocateSample(allocator, &sample);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+        ok(get_refcount(sample) == 3, "Unexpected refcount %u.\n", get_refcount(sample));
+
+    hr = IMFVideoSampleAllocator_AllocateSample(allocator, &sample2);
+todo_wine
+    ok(hr == MF_E_SAMPLEALLOCATOR_EMPTY, "Unexpected hr %#x.\n", hr);
+
+    /* Reinitialize with active sample. */
+    hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 4, (IMFMediaType *)video_type);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    if (sample)
+        ok(get_refcount(sample) == 3, "Unexpected refcount %u.\n", get_refcount(sample));
+
+    hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(count == 4, "Unexpected count %d.\n", count);
+}
+    if (sample)
+    {
+        hr = IMFSample_QueryInterface(sample, &IID_IMFDesiredSample, (void **)&unk);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+        IUnknown_Release(unk);
+
+        hr = IMFSample_QueryInterface(sample, &IID_IMFTrackedSample, (void **)&unk);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+        IUnknown_Release(unk);
+
+        hr = IMFSample_GetBufferByIndex(sample, 0, &buffer);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+        hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMFGetService, (void **)&gs);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+        /* Device manager wasn't set, sample get regular memory buffers. */
+        hr = IMFGetService_GetService(gs, &MR_BUFFER_SERVICE, &IID_IDirect3DSurface9, (void **)&surface);
+        ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
+
+        IMFMediaBuffer_Release(buffer);
+
+        IMFGetService_Release(gs);
+        IMFSample_Release(sample);
+    }
+
+    IMFVideoSampleAllocatorCallback_Release(allocator_cb);
+
+    IMFMediaType_Release(media_type);
+
+    IMFVideoSampleAllocator_Release(allocator);
 
     hr = MFCreateVideoSampleAllocator(&IID_IMFVideoSampleAllocatorCallback, (void **)&unk);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
From 3c02d5bed9d6d431db6689e84afa7a06c093a1b9 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 3 Jul 2020 19:25:09 +0300
Subject: [PATCH] mfplat: Add tracked sample stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/buffer.c       | 89 +++++++++++++++++++++++++++++++++++---
 dlls/mfplat/mfplat.spec    |  1 +
 dlls/mfplat/tests/mfplat.c | 37 ++++++++++++++++
 include/mfidl.idl          |  1 +
 4 files changed, 122 insertions(+), 6 deletions(-)

diff --git a/dlls/mfplat/buffer.c b/dlls/mfplat/buffer.c
index 1a31299d244..67c60663b33 100644
--- a/dlls/mfplat/buffer.c
+++ b/dlls/mfplat/buffer.c
@@ -62,6 +62,7 @@ struct sample
 {
     struct attributes attributes;
     IMFSample IMFSample_iface;
+    IMFTrackedSample IMFTrackedSample_iface;
 
     IMFMediaBuffer **buffers;
     size_t buffer_count;
@@ -87,6 +88,11 @@ static inline struct sample *impl_from_IMFSample(IMFSample *iface)
     return CONTAINING_RECORD(iface, struct sample, IMFSample_iface);
 }
 
+static struct sample *impl_from_IMFTrackedSample(IMFTrackedSample *iface)
+{
+    return CONTAINING_RECORD(iface, struct sample, IMFTrackedSample_iface);
+}
+
 static HRESULT WINAPI memory_buffer_QueryInterface(IMFMediaBuffer *iface, REFIID riid, void **out)
 {
     struct memory_buffer *buffer = impl_from_IMFMediaBuffer(iface);
@@ -711,20 +717,29 @@ HRESULT WINAPI MFCreateMediaBufferFromMediaType(IMFMediaType *media_type, LONGLO
 
 static HRESULT WINAPI sample_QueryInterface(IMFSample *iface, REFIID riid, void **out)
 {
+    struct sample *sample = impl_from_IMFSample(iface);
+
     TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), out);
 
     if (IsEqualIID(riid, &IID_IMFSample) ||
             IsEqualIID(riid, &IID_IMFAttributes) ||
             IsEqualIID(riid, &IID_IUnknown))
     {
-        *out = iface;
-        IMFSample_AddRef(iface);
-        return S_OK;
+        *out = &sample->IMFSample_iface;
+    }
+    else if (sample->IMFTrackedSample_iface.lpVtbl && IsEqualIID(riid, &IID_IMFTrackedSample))
+    {
+        *out = &sample->IMFTrackedSample_iface;
+    }
+    else
+    {
+        WARN("Unsupported %s.\n", debugstr_guid(riid));
+        *out = NULL;
+        return E_NOINTERFACE;
     }
 
-    WARN("Unsupported %s.\n", debugstr_guid(riid));
-    *out = NULL;
-    return E_NOINTERFACE;
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
 }
 
 static ULONG WINAPI sample_AddRef(IMFSample *iface)
@@ -1448,6 +1463,40 @@ static const IMFSampleVtbl samplevtbl =
     sample_CopyToBuffer,
 };
 
+static HRESULT WINAPI tracked_sample_QueryInterface(IMFTrackedSample *iface, REFIID riid, void **obj)
+{
+    struct sample *sample = impl_from_IMFTrackedSample(iface);
+    return IMFSample_QueryInterface(&sample->IMFSample_iface, riid, obj);
+}
+
+static ULONG WINAPI tracked_sample_AddRef(IMFTrackedSample *iface)
+{
+    struct sample *sample = impl_from_IMFTrackedSample(iface);
+    return IMFSample_AddRef(&sample->IMFSample_iface);
+}
+
+static ULONG WINAPI tracked_sample_Release(IMFTrackedSample *iface)
+{
+    struct sample *sample = impl_from_IMFTrackedSample(iface);
+    return IMFSample_Release(&sample->IMFSample_iface);
+}
+
+static HRESULT WINAPI tracked_sample_SetAllocator(IMFTrackedSample *iface,
+        IMFAsyncCallback *sample_allocator, IUnknown *state)
+{
+    FIXME("%p, %p, %p.\n", iface, sample_allocator, state);
+
+    return E_NOTIMPL;
+}
+
+static const IMFTrackedSampleVtbl tracked_sample_vtbl =
+{
+    tracked_sample_QueryInterface,
+    tracked_sample_AddRef,
+    tracked_sample_Release,
+    tracked_sample_SetAllocator,
+};
+
 /***********************************************************************
  *      MFCreateSample (mfplat.@)
  */
@@ -1476,3 +1525,31 @@ HRESULT WINAPI MFCreateSample(IMFSample **sample)
 
     return S_OK;
 }
+
+/***********************************************************************
+ *      MFCreateTrackedSample (mfplat.@)
+ */
+HRESULT WINAPI MFCreateTrackedSample(IMFTrackedSample **sample)
+{
+    struct sample *object;
+    HRESULT hr;
+
+    TRACE("%p.\n", sample);
+
+    object = heap_alloc_zero(sizeof(*object));
+    if (!object)
+        return E_OUTOFMEMORY;
+
+    if (FAILED(hr = init_attributes_object(&object->attributes, 0)))
+    {
+        heap_free(object);
+        return hr;
+    }
+
+    object->IMFSample_iface.lpVtbl = &samplevtbl;
+    object->IMFTrackedSample_iface.lpVtbl = &tracked_sample_vtbl;
+
+    *sample = &object->IMFTrackedSample_iface;
+
+    return S_OK;
+}
diff --git a/dlls/mfplat/mfplat.spec b/dlls/mfplat/mfplat.spec
index 16be972e5bd..f55a8237d35 100644
--- a/dlls/mfplat/mfplat.spec
+++ b/dlls/mfplat/mfplat.spec
@@ -70,6 +70,7 @@
 @ stdcall MFCreateSystemTimeSource(ptr)
 @ stub MFCreateSystemUnderlyingClock
 @ stub MFCreateTempFile
+@ stdcall MFCreateTrackedSample(ptr)
 @ stdcall MFCreateTransformActivate(ptr)
 @ stub MFCreateURLFromPath
 @ stub MFCreateUdpSockets
diff --git a/dlls/mfplat/tests/mfplat.c b/dlls/mfplat/tests/mfplat.c
index 8b4012f8087..01749dd9ef8 100644
--- a/dlls/mfplat/tests/mfplat.c
+++ b/dlls/mfplat/tests/mfplat.c
@@ -107,6 +107,7 @@ static HRESULT (WINAPI *pMFCreate2DMediaBuffer)(DWORD width, DWORD height, DWORD
 static HRESULT (WINAPI *pMFCreateMediaBufferFromMediaType)(IMFMediaType *media_type, LONGLONG duration, DWORD min_length,
         DWORD min_alignment, IMFMediaBuffer **buffer);
 static HRESULT (WINAPI *pMFCreateDXSurfaceBuffer)(REFIID riid, IUnknown *surface, BOOL bottom_up, IMFMediaBuffer **buffer);
+static HRESULT (WINAPI *pMFCreateTrackedSample)(IMFTrackedSample **sample);
 
 static HWND create_window(void)
 {
@@ -715,6 +716,7 @@ static void init_functions(void)
     X(MFCreateSourceResolver);
     X(MFCreateMediaBufferFromMediaType);
     X(MFCreateMFByteStreamOnStream);
+    X(MFCreateTrackedSample);
     X(MFCreateTransformActivate);
     X(MFGetPlaneSize);
     X(MFGetStrideForBitmapInfoHeader);
@@ -5465,6 +5467,40 @@ static void test_MFCreateDXSurfaceBuffer(void)
     DestroyWindow(window);
 }
 
+static void test_MFCreateTrackedSample(void)
+{
+    IMFTrackedSample *tracked_sample;
+    IMFDesiredSample *desired_sample;
+    IMFSample *sample;
+    IUnknown *unk;
+    HRESULT hr;
+
+    if (!pMFCreateTrackedSample)
+    {
+        win_skip("MFCreateTrackedSample() is not available.\n");
+        return;
+    }
+
+    hr = pMFCreateTrackedSample(&tracked_sample);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* It's actually a sample. */
+    hr = IMFTrackedSample_QueryInterface(tracked_sample, &IID_IMFSample, (void **)&sample);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTrackedSample_QueryInterface(tracked_sample, &IID_IUnknown, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(unk == (IUnknown *)sample, "Unexpected pointer.\n");
+    IUnknown_Release(unk);
+
+    IMFSample_Release(sample);
+
+    hr = IMFTrackedSample_QueryInterface(tracked_sample, &IID_IMFDesiredSample, (void **)&desired_sample);
+    ok(hr == E_NOINTERFACE, "Unexpected hr %#x.\n", hr);
+
+    IMFTrackedSample_Release(tracked_sample);
+}
+
 START_TEST(mfplat)
 {
     char **argv;
@@ -5522,6 +5558,7 @@ START_TEST(mfplat)
     test_MFInitMediaTypeFromWaveFormatEx();
     test_MFCreateMFVideoFormatFromMFMediaType();
     test_MFCreateDXSurfaceBuffer();
+    test_MFCreateTrackedSample();
 
     CoUninitialize();
 }
diff --git a/include/mfidl.idl b/include/mfidl.idl
index 1f5fc06dd1e..4ceeb707bd0 100644
--- a/include/mfidl.idl
+++ b/include/mfidl.idl
@@ -648,6 +648,7 @@ cpp_quote("HRESULT WINAPI MFGetService(IUnknown *object, REFGUID service, REFIID
 cpp_quote("MFTIME  WINAPI MFGetSystemTime(void);")
 cpp_quote("HRESULT WINAPI MFGetTopoNodeCurrentType(IMFTopologyNode *node, DWORD stream, BOOL output, IMFMediaType **type);")
 cpp_quote("HRESULT WINAPI MFShutdownObject(IUnknown *object);")
+cpp_quote("HRESULT WINAPI MFCreateTrackedSample(IMFTrackedSample **sample);")
 
 typedef enum _MFMEDIASOURCE_CHARACTERISTICS
 {
From 4cb8055298778ccfa03fc4f846a9339ca7a6bf6e Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 6 Jul 2020 18:08:25 +0300
Subject: [PATCH] mfplat: Implement sample tracking.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/buffer.c | 131 ++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 122 insertions(+), 9 deletions(-)

diff --git a/dlls/mfplat/buffer.c b/dlls/mfplat/buffer.c
index 67c60663b33..a3311bc10f1 100644
--- a/dlls/mfplat/buffer.c
+++ b/dlls/mfplat/buffer.c
@@ -19,6 +19,7 @@
 #define COBJMACROS
 
 #include "mfplat_private.h"
+#include "rtworkq.h"
 
 #include "wine/debug.h"
 
@@ -71,6 +72,10 @@ struct sample
     DWORD prop_flags;
     LONGLONG duration;
     LONGLONG timestamp;
+
+    /* Tracked sample functionality. */
+    IRtwqAsyncResult *tracked_result;
+    LONG tracked_refcount;
 };
 
 static inline struct memory_buffer *impl_from_IMFMediaBuffer(IMFMediaBuffer *iface)
@@ -752,22 +757,53 @@ static ULONG WINAPI sample_AddRef(IMFSample *iface)
     return refcount;
 }
 
+static void release_sample_object(struct sample *sample)
+{
+    size_t i;
+
+    for (i = 0; i < sample->buffer_count; ++i)
+        IMFMediaBuffer_Release(sample->buffers[i]);
+    clear_attributes_object(&sample->attributes);
+    heap_free(sample->buffers);
+    heap_free(sample);
+}
+
 static ULONG WINAPI sample_Release(IMFSample *iface)
 {
     struct sample *sample = impl_from_IMFSample(iface);
     ULONG refcount = InterlockedDecrement(&sample->attributes.ref);
-    size_t i;
 
     TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
+        release_sample_object(sample);
+
+    return refcount;
+}
+
+static ULONG WINAPI sample_tracked_Release(IMFSample *iface)
+{
+    struct sample *sample = impl_from_IMFSample(iface);
+    ULONG refcount;
+    HRESULT hr;
+
+    EnterCriticalSection(&sample->attributes.cs);
+    refcount = InterlockedDecrement(&sample->attributes.ref);
+    if (sample->tracked_result && sample->tracked_refcount == refcount)
     {
-        for (i = 0; i < sample->buffer_count; ++i)
-            IMFMediaBuffer_Release(sample->buffers[i]);
-        clear_attributes_object(&sample->attributes);
-        heap_free(sample->buffers);
-        heap_free(sample);
+        /* Call could fail if queue system is not initialized, it's not critical. */
+        if (FAILED(hr = RtwqInvokeCallback(sample->tracked_result)))
+            WARN("Failed to invoke tracking callback, hr %#x.\n", hr);
+        IRtwqAsyncResult_Release(sample->tracked_result);
+        sample->tracked_result = NULL;
+        sample->tracked_refcount = 0;
     }
+    LeaveCriticalSection(&sample->attributes.cs);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+        release_sample_object(sample);
 
     return refcount;
 }
@@ -1484,9 +1520,34 @@ static ULONG WINAPI tracked_sample_Release(IMFTrackedSample *iface)
 static HRESULT WINAPI tracked_sample_SetAllocator(IMFTrackedSample *iface,
         IMFAsyncCallback *sample_allocator, IUnknown *state)
 {
-    FIXME("%p, %p, %p.\n", iface, sample_allocator, state);
+    struct sample *sample = impl_from_IMFTrackedSample(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %p.\n", iface, sample_allocator, state);
+
+    EnterCriticalSection(&sample->attributes.cs);
+
+    if (sample->tracked_result)
+        hr = MF_E_NOTACCEPTING;
+    else
+    {
+        if (SUCCEEDED(hr = RtwqCreateAsyncResult((IUnknown *)iface, (IRtwqAsyncCallback *)sample_allocator,
+                state, &sample->tracked_result)))
+        {
+            /* Account for additional refcount brought by 'state' object. This threshold is used
+               on Release() to invoke tracker callback.  */
+            sample->tracked_refcount = 1;
+            if (state == (IUnknown *)&sample->IMFTrackedSample_iface ||
+                    state == (IUnknown *)&sample->IMFSample_iface)
+            {
+                ++sample->tracked_refcount;
+            }
+        }
+    }
+
+    LeaveCriticalSection(&sample->attributes.cs);
+
+    return hr;
 }
 
 static const IMFTrackedSampleVtbl tracked_sample_vtbl =
@@ -1497,6 +1558,58 @@ static const IMFTrackedSampleVtbl tracked_sample_vtbl =
     tracked_sample_SetAllocator,
 };
 
+static const IMFSampleVtbl sample_tracked_vtbl =
+{
+    sample_QueryInterface,
+    sample_AddRef,
+    sample_tracked_Release,
+    sample_GetItem,
+    sample_GetItemType,
+    sample_CompareItem,
+    sample_Compare,
+    sample_GetUINT32,
+    sample_GetUINT64,
+    sample_GetDouble,
+    sample_GetGUID,
+    sample_GetStringLength,
+    sample_GetString,
+    sample_GetAllocatedString,
+    sample_GetBlobSize,
+    sample_GetBlob,
+    sample_GetAllocatedBlob,
+    sample_GetUnknown,
+    sample_SetItem,
+    sample_DeleteItem,
+    sample_DeleteAllItems,
+    sample_SetUINT32,
+    sample_SetUINT64,
+    sample_SetDouble,
+    sample_SetGUID,
+    sample_SetString,
+    sample_SetBlob,
+    sample_SetUnknown,
+    sample_LockStore,
+    sample_UnlockStore,
+    sample_GetCount,
+    sample_GetItemByIndex,
+    sample_CopyAllItems,
+    sample_GetSampleFlags,
+    sample_SetSampleFlags,
+    sample_GetSampleTime,
+    sample_SetSampleTime,
+    sample_GetSampleDuration,
+    sample_SetSampleDuration,
+    sample_GetBufferCount,
+    sample_GetBufferByIndex,
+    sample_ConvertToContiguousBuffer,
+    sample_AddBuffer,
+    sample_RemoveBufferByIndex,
+    sample_RemoveAllBuffers,
+    sample_GetTotalLength,
+    sample_CopyToBuffer,
+};
+
+
 /***********************************************************************
  *      MFCreateSample (mfplat.@)
  */
@@ -1546,7 +1659,7 @@ HRESULT WINAPI MFCreateTrackedSample(IMFTrackedSample **sample)
         return hr;
     }
 
-    object->IMFSample_iface.lpVtbl = &samplevtbl;
+    object->IMFSample_iface.lpVtbl = &sample_tracked_vtbl;
     object->IMFTrackedSample_iface.lpVtbl = &tracked_sample_vtbl;
 
     *sample = &object->IMFTrackedSample_iface;
From 045a2ff4308d8fcf81dd2a239943a493c0d1fcf4 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 6 Jul 2020 18:08:26 +0300
Subject: [PATCH] mf: Add a sink stub for EVR.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/Makefile.in |   1 +
 dlls/mf/evr.c       | 218 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/mf/main.c      |  38 --------
 dlls/mf/tests/mf.c  |   9 +-
 4 files changed, 224 insertions(+), 42 deletions(-)
 create mode 100644 dlls/mf/evr.c

diff --git a/dlls/mf/Makefile.in b/dlls/mf/Makefile.in
index fe156e43abf..1d2bfc8a782 100644
--- a/dlls/mf/Makefile.in
+++ b/dlls/mf/Makefile.in
@@ -5,6 +5,7 @@ IMPORTS   = advapi32 mfplat ole32 uuid mfuuid
 EXTRADLLFLAGS = -mno-cygwin
 
 C_SRCS = \
+	evr.c \
 	main.c \
 	samplegrabber.c \
 	sar.c \
diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
new file mode 100644
index 00000000000..27238339031
--- /dev/null
+++ b/dlls/mf/evr.c
@@ -0,0 +1,218 @@
+/*
+ * Copyright 2020 Nikolay Sivov for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+
+#include "mf_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+struct video_renderer
+{
+    IMFMediaSink IMFMediaSink_iface;
+    LONG refcount;
+};
+
+static struct video_renderer *impl_from_IMFMediaSink(IMFMediaSink *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_renderer, IMFMediaSink_iface);
+}
+
+static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IMFMediaSink) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+    }
+    else
+    {
+        WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+        *obj = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*obj);
+
+    return S_OK;
+}
+
+static ULONG WINAPI video_renderer_sink_AddRef(IMFMediaSink *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
+    ULONG refcount = InterlockedIncrement(&renderer->refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
+    return refcount;
+}
+
+static ULONG WINAPI video_renderer_sink_Release(IMFMediaSink *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
+    ULONG refcount = InterlockedDecrement(&renderer->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        heap_free(renderer);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI video_renderer_sink_GetCharacteristics(IMFMediaSink *iface, DWORD *flags)
+{
+    FIXME("%p, %p.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_renderer_sink_AddStreamSink(IMFMediaSink *iface, DWORD stream_sink_id,
+    IMFMediaType *media_type, IMFStreamSink **stream_sink)
+{
+    FIXME("%p, %#x, %p, %p.\n", iface, stream_sink_id, media_type, stream_sink);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_renderer_sink_RemoveStreamSink(IMFMediaSink *iface, DWORD stream_sink_id)
+{
+    FIXME("%p, %#x.\n", iface, stream_sink_id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_renderer_sink_GetStreamSinkCount(IMFMediaSink *iface, DWORD *count)
+{
+    FIXME("%p, %p.\n", iface, count);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_renderer_sink_GetStreamSinkByIndex(IMFMediaSink *iface, DWORD index,
+        IMFStreamSink **stream)
+{
+    FIXME("%p, %u, %p.\n", iface, index, stream);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_renderer_sink_GetStreamSinkById(IMFMediaSink *iface, DWORD stream_sink_id,
+        IMFStreamSink **stream)
+{
+    FIXME("%p, %#x, %p.\n", iface, stream_sink_id, stream);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_renderer_sink_SetPresentationClock(IMFMediaSink *iface, IMFPresentationClock *clock)
+{
+    FIXME("%p, %p.\n", iface, clock);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_renderer_sink_GetPresentationClock(IMFMediaSink *iface, IMFPresentationClock **clock)
+{
+    FIXME("%p, %p.\n", iface, clock);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_renderer_sink_Shutdown(IMFMediaSink *iface)
+{
+    FIXME("%p.\n", iface);
+
+    return E_NOTIMPL;
+}
+
+static const IMFMediaSinkVtbl video_renderer_sink_vtbl =
+{
+    video_renderer_sink_QueryInterface,
+    video_renderer_sink_AddRef,
+    video_renderer_sink_Release,
+    video_renderer_sink_GetCharacteristics,
+    video_renderer_sink_AddStreamSink,
+    video_renderer_sink_RemoveStreamSink,
+    video_renderer_sink_GetStreamSinkCount,
+    video_renderer_sink_GetStreamSinkByIndex,
+    video_renderer_sink_GetStreamSinkById,
+    video_renderer_sink_SetPresentationClock,
+    video_renderer_sink_GetPresentationClock,
+    video_renderer_sink_Shutdown,
+};
+
+static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context, IUnknown **obj)
+{
+    struct video_renderer *object;
+
+    TRACE("%p, %p, %p.\n", attributes, user_context, obj);
+
+    if (!(object = heap_alloc_zero(sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFMediaSink_iface.lpVtbl = &video_renderer_sink_vtbl;
+    object->refcount = 1;
+
+    *obj = (IUnknown *)&object->IMFMediaSink_iface;
+
+    return S_OK;
+}
+
+static void evr_shutdown_object(void *user_context, IUnknown *obj)
+{
+    IMFMediaSink *sink;
+
+    if (SUCCEEDED(IUnknown_QueryInterface(obj, &IID_IMFMediaSink, (void **)&sink)))
+    {
+        IMFMediaSink_Shutdown(sink);
+        IMFMediaSink_Release(sink);
+    }
+}
+
+static void evr_free_private(void *user_context)
+{
+}
+
+static const struct activate_funcs evr_activate_funcs =
+{
+    evr_create_object,
+    evr_shutdown_object,
+    evr_free_private,
+};
+
+/***********************************************************************
+ *      MFCreateVideoRendererActivate (mf.@)
+ */
+HRESULT WINAPI MFCreateVideoRendererActivate(HWND hwnd, IMFActivate **activate)
+{
+    HRESULT hr;
+
+    TRACE("%p, %p.\n", hwnd, activate);
+
+    if (!activate)
+        return E_POINTER;
+
+    hr = create_activation_object(hwnd, &evr_activate_funcs, activate);
+    if (SUCCEEDED(hr))
+        IMFActivate_SetUINT64(*activate, &MF_ACTIVATE_VIDEO_WINDOW, (ULONG_PTR)hwnd);
+
+    return hr;
+}
diff --git a/dlls/mf/main.c b/dlls/mf/main.c
index 3546caa6912..4d9f5a7ea39 100644
--- a/dlls/mf/main.c
+++ b/dlls/mf/main.c
@@ -1267,44 +1267,6 @@ HRESULT WINAPI MFEnumDeviceSources(IMFAttributes *attributes, IMFActivate ***sou
     return S_OK;
 }
 
-static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context, IUnknown **obj)
-{
-    FIXME("%p, %p, %p.\n", attributes, user_context, obj);
-
-    return E_NOTIMPL;
-}
-
-static void evr_shutdown_object(void *user_context, IUnknown *obj)
-{
-}
-
-static void evr_free_private(void *user_context)
-{
-}
-
-static const struct activate_funcs evr_activate_funcs =
-{
-    evr_create_object,
-    evr_shutdown_object,
-    evr_free_private,
-};
-
-HRESULT WINAPI MFCreateVideoRendererActivate(HWND hwnd, IMFActivate **activate)
-{
-    HRESULT hr;
-
-    TRACE("%p, %p.\n", hwnd, activate);
-
-    if (!activate)
-        return E_POINTER;
-
-    hr = create_activation_object(hwnd, &evr_activate_funcs, activate);
-    if (SUCCEEDED(hr))
-        IMFActivate_SetUINT64(*activate, &MF_ACTIVATE_VIDEO_WINDOW, (ULONG_PTR)hwnd);
-
-    return hr;
-}
-
 struct simple_type_handler
 {
     IMFMediaTypeHandler IMFMediaTypeHandler_iface;
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index d252bab9b3b..72444dd2482 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3250,23 +3250,23 @@ static void test_evr(void)
     ok(!value, "Unexpected value.\n");
 
     hr = IMFActivate_ActivateObject(activate, &IID_IMFMediaSink, (void **)&sink);
-todo_wine
     ok(hr == S_OK, "Failed to activate, hr %#x.\n", hr);
 
-if (hr == S_OK)
-{
     hr = IMFMediaSink_GetCharacteristics(sink, &flags);
+todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFActivate_ShutdownObject(activate);
     ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     hr = IMFMediaSink_GetCharacteristics(sink, &flags);
+todo_wine
     ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     /* Activate again. */
     hr = IMFActivate_ActivateObject(activate, &IID_IMFMediaSink, (void **)&sink2);
     ok(hr == S_OK, "Failed to activate, hr %#x.\n", hr);
+todo_wine
     ok(sink == sink2, "Unexpected instance.\n");
     IMFMediaSink_Release(sink2);
 
@@ -3274,6 +3274,7 @@ if (hr == S_OK)
     ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaSink_GetCharacteristics(sink, &flags);
+todo_wine
     ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = IMFActivate_ActivateObject(activate, &IID_IMFMediaSink, (void **)&sink2);
@@ -3284,7 +3285,7 @@ if (hr == S_OK)
 
     IMFMediaSink_Release(sink2);
     IMFMediaSink_Release(sink);
-}
+
     IMFActivate_Release(activate);
 
     CoUninitialize();
From 1cdcfaf6883916d9e6ea04feb1b2c18b89970cbe Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 6 Jul 2020 18:08:27 +0300
Subject: [PATCH] mf/evr: Add IMFMediaSinkPreroll stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c      | 48 +++++++++++++++++++++++++++++++++++++++++++++-
 dlls/mf/tests/mf.c |  9 ++++++++-
 2 files changed, 55 insertions(+), 2 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 27238339031..2ac85fab795 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -25,6 +25,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 struct video_renderer
 {
     IMFMediaSink IMFMediaSink_iface;
+    IMFMediaSinkPreroll IMFMediaSinkPreroll_iface;
     LONG refcount;
 };
 
@@ -33,14 +34,25 @@ static struct video_renderer *impl_from_IMFMediaSink(IMFMediaSink *iface)
     return CONTAINING_RECORD(iface, struct video_renderer, IMFMediaSink_iface);
 }
 
+static struct video_renderer *impl_from_IMFMediaSinkPreroll(IMFMediaSinkPreroll *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_renderer, IMFMediaSinkPreroll_iface);
+}
+
 static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, REFIID riid, void **obj)
 {
+    struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
+
     TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
 
     if (IsEqualIID(riid, &IID_IMFMediaSink) ||
             IsEqualIID(riid, &IID_IUnknown))
     {
-        *obj = iface;
+        *obj = &renderer->IMFMediaSink_iface;
+    }
+    else if (IsEqualIID(riid, &IID_IMFMediaSinkPreroll))
+    {
+        *obj = &renderer->IMFMediaSinkPreroll_iface;
     }
     else
     {
@@ -159,6 +171,39 @@ static const IMFMediaSinkVtbl video_renderer_sink_vtbl =
     video_renderer_sink_Shutdown,
 };
 
+static HRESULT WINAPI video_renderer_preroll_QueryInterface(IMFMediaSinkPreroll *iface, REFIID riid, void **obj)
+{
+    struct video_renderer *renderer = impl_from_IMFMediaSinkPreroll(iface);
+    return IMFMediaSink_QueryInterface(&renderer->IMFMediaSink_iface, riid, obj);
+}
+
+static ULONG WINAPI video_renderer_preroll_AddRef(IMFMediaSinkPreroll *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFMediaSinkPreroll(iface);
+    return IMFMediaSink_AddRef(&renderer->IMFMediaSink_iface);
+}
+
+static ULONG WINAPI video_renderer_preroll_Release(IMFMediaSinkPreroll *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFMediaSinkPreroll(iface);
+    return IMFMediaSink_Release(&renderer->IMFMediaSink_iface);
+}
+
+static HRESULT WINAPI video_renderer_preroll_NotifyPreroll(IMFMediaSinkPreroll *iface, MFTIME start_time)
+{
+    FIXME("%p, %s.\n", iface, debugstr_time(start_time));
+
+    return E_NOTIMPL;
+}
+
+static const IMFMediaSinkPrerollVtbl video_renderer_preroll_vtbl =
+{
+    video_renderer_preroll_QueryInterface,
+    video_renderer_preroll_AddRef,
+    video_renderer_preroll_Release,
+    video_renderer_preroll_NotifyPreroll,
+};
+
 static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context, IUnknown **obj)
 {
     struct video_renderer *object;
@@ -169,6 +214,7 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
         return E_OUTOFMEMORY;
 
     object->IMFMediaSink_iface.lpVtbl = &video_renderer_sink_vtbl;
+    object->IMFMediaSinkPreroll_iface.lpVtbl = &video_renderer_preroll_vtbl;
     object->refcount = 1;
 
     *obj = (IUnknown *)&object->IMFMediaSink_iface;
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 72444dd2482..44d69a7a8cc 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3226,6 +3226,7 @@ todo_wine
 
 static void test_evr(void)
 {
+    IMFMediaSinkPreroll *preroll;
     IMFMediaSink *sink, *sink2;
     IMFActivate *activate;
     DWORD flags, count;
@@ -3252,9 +3253,15 @@ static void test_evr(void)
     hr = IMFActivate_ActivateObject(activate, &IID_IMFMediaSink, (void **)&sink);
     ok(hr == S_OK, "Failed to activate, hr %#x.\n", hr);
 
+    flags = 0;
     hr = IMFMediaSink_GetCharacteristics(sink, &flags);
-todo_wine
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(flags == (MEDIASINK_CAN_PREROLL | MEDIASINK_CLOCK_REQUIRED), "Unexpected flags %#x.\n", flags);
+}
+    hr = IMFMediaSink_QueryInterface(sink, &IID_IMFMediaSinkPreroll, (void **)&preroll);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IMFMediaSinkPreroll_Release(preroll);
 
     hr = IMFActivate_ShutdownObject(activate);
     ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
From 1f2cf87def23b2298df2531f9842c5fba3723596 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 6 Jul 2020 18:08:28 +0300
Subject: [PATCH] mf/evr: Return sink flags.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c      | 6 ++++--
 dlls/mf/tests/mf.c | 4 +---
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 2ac85fab795..a5a39fe7786 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -91,9 +91,11 @@ static ULONG WINAPI video_renderer_sink_Release(IMFMediaSink *iface)
 
 static HRESULT WINAPI video_renderer_sink_GetCharacteristics(IMFMediaSink *iface, DWORD *flags)
 {
-    FIXME("%p, %p.\n", iface, flags);
+    TRACE("%p, %p.\n", iface, flags);
 
-    return E_NOTIMPL;
+    *flags = MEDIASINK_CLOCK_REQUIRED | MEDIASINK_CAN_PREROLL;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_renderer_sink_AddStreamSink(IMFMediaSink *iface, DWORD stream_sink_id,
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 44d69a7a8cc..c274c3263d3 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3253,12 +3253,10 @@ static void test_evr(void)
     hr = IMFActivate_ActivateObject(activate, &IID_IMFMediaSink, (void **)&sink);
     ok(hr == S_OK, "Failed to activate, hr %#x.\n", hr);
 
-    flags = 0;
     hr = IMFMediaSink_GetCharacteristics(sink, &flags);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(flags == (MEDIASINK_CAN_PREROLL | MEDIASINK_CLOCK_REQUIRED), "Unexpected flags %#x.\n", flags);
-}
+
     hr = IMFMediaSink_QueryInterface(sink, &IID_IMFMediaSinkPreroll, (void **)&preroll);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IMFMediaSinkPreroll_Release(preroll);
From ca27d5b4ec99a00103f110ebe85774f569f3a468 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 6 Jul 2020 18:08:29 +0300
Subject: [PATCH] mf/evr: Track shutdown state.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c           | 27 +++++++++++++++++++++++++--
 dlls/mf/main.c          |  1 -
 dlls/mf/mf_private.h    |  1 +
 dlls/mf/samplegrabber.c |  1 -
 dlls/mf/sar.c           |  1 -
 dlls/mf/session.c       |  1 -
 dlls/mf/tests/mf.c      |  2 --
 dlls/mf/topology.c      |  1 -
 8 files changed, 26 insertions(+), 9 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index a5a39fe7786..64944673d5a 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -22,11 +22,18 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+enum video_renderer_flags
+{
+    EVR_SHUT_DOWN = 0x1,
+};
+
 struct video_renderer
 {
     IMFMediaSink IMFMediaSink_iface;
     IMFMediaSinkPreroll IMFMediaSinkPreroll_iface;
     LONG refcount;
+    unsigned int flags;
+    CRITICAL_SECTION cs;
 };
 
 static struct video_renderer *impl_from_IMFMediaSink(IMFMediaSink *iface)
@@ -83,6 +90,7 @@ static ULONG WINAPI video_renderer_sink_Release(IMFMediaSink *iface)
 
     if (!refcount)
     {
+        DeleteCriticalSection(&renderer->cs);
         heap_free(renderer);
     }
 
@@ -91,8 +99,13 @@ static ULONG WINAPI video_renderer_sink_Release(IMFMediaSink *iface)
 
 static HRESULT WINAPI video_renderer_sink_GetCharacteristics(IMFMediaSink *iface, DWORD *flags)
 {
+    struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
+
     TRACE("%p, %p.\n", iface, flags);
 
+    if (renderer->flags & EVR_SHUT_DOWN)
+        return MF_E_SHUTDOWN;
+
     *flags = MEDIASINK_CLOCK_REQUIRED | MEDIASINK_CAN_PREROLL;
 
     return S_OK;
@@ -152,9 +165,18 @@ static HRESULT WINAPI video_renderer_sink_GetPresentationClock(IMFMediaSink *ifa
 
 static HRESULT WINAPI video_renderer_sink_Shutdown(IMFMediaSink *iface)
 {
-    FIXME("%p.\n", iface);
+    struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p.\n", iface);
+
+    if (renderer->flags & EVR_SHUT_DOWN)
+        return MF_E_SHUTDOWN;
+
+    EnterCriticalSection(&renderer->cs);
+    renderer->flags |= EVR_SHUT_DOWN;
+    LeaveCriticalSection(&renderer->cs);
+
+    return S_OK;
 }
 
 static const IMFMediaSinkVtbl video_renderer_sink_vtbl =
@@ -218,6 +240,7 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
     object->IMFMediaSink_iface.lpVtbl = &video_renderer_sink_vtbl;
     object->IMFMediaSinkPreroll_iface.lpVtbl = &video_renderer_preroll_vtbl;
     object->refcount = 1;
+    InitializeCriticalSection(&object->cs);
 
     *obj = (IUnknown *)&object->IMFMediaSink_iface;
 
diff --git a/dlls/mf/main.c b/dlls/mf/main.c
index 4d9f5a7ea39..8656c6cddf2 100644
--- a/dlls/mf/main.c
+++ b/dlls/mf/main.c
@@ -27,7 +27,6 @@
 #include "rpcproxy.h"
 
 #include "mfapi.h"
-#include "mferror.h"
 
 #include "mf_private.h"
 
diff --git a/dlls/mf/mf_private.h b/dlls/mf/mf_private.h
index 14f7288c9bb..f4356219731 100644
--- a/dlls/mf/mf_private.h
+++ b/dlls/mf/mf_private.h
@@ -16,6 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "mferror.h"
 #include "mfidl.h"
 
 #include "wine/heap.h"
diff --git a/dlls/mf/samplegrabber.c b/dlls/mf/samplegrabber.c
index 92330abc9fe..cbf7453d04d 100644
--- a/dlls/mf/samplegrabber.c
+++ b/dlls/mf/samplegrabber.c
@@ -20,7 +20,6 @@
 
 #include "mfapi.h"
 #include "mfidl.h"
-#include "mferror.h"
 #include "mf_private.h"
 
 #include "wine/debug.h"
diff --git a/dlls/mf/sar.c b/dlls/mf/sar.c
index 89a517b1358..8a27c0658c3 100644
--- a/dlls/mf/sar.c
+++ b/dlls/mf/sar.c
@@ -20,7 +20,6 @@
 
 #include "mfapi.h"
 #include "mfidl.h"
-#include "mferror.h"
 #include "mf_private.h"
 #include "initguid.h"
 #include "mmdeviceapi.h"
diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 39b5e1a5377..d0365ea8564 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -25,7 +25,6 @@
 #include "winbase.h"
 #include "mfidl.h"
 #include "mfapi.h"
-#include "mferror.h"
 
 #include "wine/debug.h"
 #include "wine/heap.h"
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index c274c3263d3..691734aa9a9 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3265,7 +3265,6 @@ static void test_evr(void)
     ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     hr = IMFMediaSink_GetCharacteristics(sink, &flags);
-todo_wine
     ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     /* Activate again. */
@@ -3279,7 +3278,6 @@ todo_wine
     ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaSink_GetCharacteristics(sink, &flags);
-todo_wine
     ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = IMFActivate_ActivateObject(activate, &IID_IMFMediaSink, (void **)&sink2);
diff --git a/dlls/mf/topology.c b/dlls/mf/topology.c
index 432979206ba..f4cc30a9fc6 100644
--- a/dlls/mf/topology.c
+++ b/dlls/mf/topology.c
@@ -27,7 +27,6 @@
 #undef INITGUID
 #include <guiddef.h>
 #include "mfapi.h"
-#include "mferror.h"
 #include "mfidl.h"
 
 #include "wine/debug.h"
From 1a72836c372459b2928c4b8c27b90879fa2606ec Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 6 Jul 2020 15:41:01 -0500
Subject: [PATCH] winegstreamer: deinterlace belongs to the "good" set, not the
 "base" set.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index e6f00842df5..a32b0b0e415 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1001,7 +1001,7 @@ static void init_new_decoded_pad(GstElement *bin, GstPad *pad, struct gstdemux *
          * necessarily consume it. In particular, the video renderer can't. */
         if (!(deinterlace = gst_element_factory_make("deinterlace", NULL)))
         {
-            ERR("Failed to create deinterlace, are %u-bit GStreamer \"base\" plugins installed?\n",
+            ERR("Failed to create deinterlace, are %u-bit GStreamer \"good\" plugins installed?\n",
                     8 * (int)sizeof(void *));
             goto out;
         }
From 3a973ca8275ac398d7df9fd27a1b777cbed1fad4 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 7 Jul 2020 14:40:11 +0300
Subject: [PATCH] mf: Make freeing function optional for object activator.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c  | 9 ++-------
 dlls/mf/main.c | 3 ++-
 dlls/mf/sar.c  | 9 ++-------
 3 files changed, 6 insertions(+), 15 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 64944673d5a..e0ab44f8b05 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -258,15 +258,10 @@ static void evr_shutdown_object(void *user_context, IUnknown *obj)
     }
 }
 
-static void evr_free_private(void *user_context)
-{
-}
-
 static const struct activate_funcs evr_activate_funcs =
 {
-    evr_create_object,
-    evr_shutdown_object,
-    evr_free_private,
+    .create_object = evr_create_object,
+    .shutdown_object = evr_shutdown_object,
 };
 
 /***********************************************************************
diff --git a/dlls/mf/main.c b/dlls/mf/main.c
index 8656c6cddf2..62dc1813c7b 100644
--- a/dlls/mf/main.c
+++ b/dlls/mf/main.c
@@ -91,7 +91,8 @@ static ULONG WINAPI activate_object_Release(IMFActivate *iface)
 
     if (!refcount)
     {
-        activate->funcs->free_private(activate->context);
+        if (activate->funcs->free_private)
+            activate->funcs->free_private(activate->context);
         if (activate->object)
             IUnknown_Release(activate->object);
         IMFAttributes_Release(activate->attributes);
diff --git a/dlls/mf/sar.c b/dlls/mf/sar.c
index 8a27c0658c3..6f1f1bd834e 100644
--- a/dlls/mf/sar.c
+++ b/dlls/mf/sar.c
@@ -1891,15 +1891,10 @@ static void sar_shutdown_object(void *user_context, IUnknown *obj)
     }
 }
 
-static void sar_free_private(void *user_context)
-{
-}
-
 static const struct activate_funcs sar_activate_funcs =
 {
-    sar_create_object,
-    sar_shutdown_object,
-    sar_free_private,
+    .create_object = sar_create_object,
+    .shutdown_object = sar_shutdown_object,
 };
 
 /***********************************************************************
From 502341aa76e2e593e5a151afe5451176971a4832 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 7 Jul 2020 14:40:12 +0300
Subject: [PATCH] mf/evr: Create mixer object on activation.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/Makefile.in |  2 +-
 dlls/mf/evr.c       | 39 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 40 insertions(+), 1 deletion(-)

diff --git a/dlls/mf/Makefile.in b/dlls/mf/Makefile.in
index 1d2bfc8a782..b64cdb4a64d 100644
--- a/dlls/mf/Makefile.in
+++ b/dlls/mf/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = mf.dll
 IMPORTLIB = mf
-IMPORTS   = advapi32 mfplat ole32 uuid mfuuid
+IMPORTS   = advapi32 mfplat ole32 uuid mfuuid strmiids
 
 EXTRADLLFLAGS = -mno-cygwin
 
diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index e0ab44f8b05..4166c1dd3e4 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -19,6 +19,7 @@
 #define COBJMACROS
 
 #include "mf_private.h"
+#include "uuids.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
@@ -32,6 +33,8 @@ struct video_renderer
     IMFMediaSink IMFMediaSink_iface;
     IMFMediaSinkPreroll IMFMediaSinkPreroll_iface;
     LONG refcount;
+
+    IMFTransform *mixer;
     unsigned int flags;
     CRITICAL_SECTION cs;
 };
@@ -90,6 +93,8 @@ static ULONG WINAPI video_renderer_sink_Release(IMFMediaSink *iface)
 
     if (!refcount)
     {
+        if (renderer->mixer)
+            IMFTransform_Release(renderer->mixer);
         DeleteCriticalSection(&renderer->cs);
         heap_free(renderer);
     }
@@ -228,9 +233,33 @@ static const IMFMediaSinkPrerollVtbl video_renderer_preroll_vtbl =
     video_renderer_preroll_NotifyPreroll,
 };
 
+static HRESULT video_renderer_create_mixer(IMFAttributes *attributes, IMFTransform **out)
+{
+    unsigned int flags = 0;
+    IMFActivate *activate;
+    CLSID clsid;
+    HRESULT hr;
+
+    if (SUCCEEDED(IMFAttributes_GetUnknown(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE,
+            &IID_IMFActivate, (void **)&activate)))
+    {
+        IMFAttributes_GetUINT32(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_FLAGS, &flags);
+        hr = IMFActivate_ActivateObject(activate, &IID_IMFTransform, (void **)out);
+        IMFActivate_Release(activate);
+        if (FAILED(hr) && !(flags & MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL))
+            return hr;
+    }
+
+    if (FAILED(IMFAttributes_GetGUID(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID, &clsid)))
+        memcpy(&clsid, &CLSID_MFVideoMixer9, sizeof(clsid));
+
+    return CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFTransform, (void **)out);
+}
+
 static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context, IUnknown **obj)
 {
     struct video_renderer *object;
+    HRESULT hr;
 
     TRACE("%p, %p, %p.\n", attributes, user_context, obj);
 
@@ -242,9 +271,19 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
     object->refcount = 1;
     InitializeCriticalSection(&object->cs);
 
+    /* Create mixer. */
+    if (FAILED(hr = video_renderer_create_mixer(attributes, &object->mixer)))
+        goto done;
+
     *obj = (IUnknown *)&object->IMFMediaSink_iface;
 
     return S_OK;
+
+done:
+
+    IMFMediaSink_Release(&object->IMFMediaSink_iface);
+
+    return hr;
 }
 
 static void evr_shutdown_object(void *user_context, IUnknown *obj)
From 835611ef3e685009e37bb30c576207ad0df96798 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 7 Jul 2020 14:40:13 +0300
Subject: [PATCH] mf/evr: Create presenter object on activation.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 32 +++++++++++++++++++++++++++++++-
 1 file changed, 31 insertions(+), 1 deletion(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 4166c1dd3e4..c3ee38c8292 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -20,6 +20,7 @@
 
 #include "mf_private.h"
 #include "uuids.h"
+#include "evr.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
@@ -35,6 +36,7 @@ struct video_renderer
     LONG refcount;
 
     IMFTransform *mixer;
+    IMFVideoPresenter *presenter;
     unsigned int flags;
     CRITICAL_SECTION cs;
 };
@@ -95,6 +97,8 @@ static ULONG WINAPI video_renderer_sink_Release(IMFMediaSink *iface)
     {
         if (renderer->mixer)
             IMFTransform_Release(renderer->mixer);
+        if (renderer->presenter)
+            IMFVideoPresenter_Release(renderer->presenter);
         DeleteCriticalSection(&renderer->cs);
         heap_free(renderer);
     }
@@ -256,6 +260,29 @@ static HRESULT video_renderer_create_mixer(IMFAttributes *attributes, IMFTransfo
     return CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFTransform, (void **)out);
 }
 
+static HRESULT video_renderer_create_presenter(IMFAttributes *attributes, IMFVideoPresenter **out)
+{
+    unsigned int flags = 0;
+    IMFActivate *activate;
+    CLSID clsid;
+    HRESULT hr;
+
+    if (SUCCEEDED(IMFAttributes_GetUnknown(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_ACTIVATE,
+            &IID_IMFActivate, (void **)&activate)))
+    {
+        IMFAttributes_GetUINT32(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS, &flags);
+        hr = IMFActivate_ActivateObject(activate, &IID_IMFVideoPresenter, (void **)out);
+        IMFActivate_Release(activate);
+        if (FAILED(hr) && !(flags & MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL))
+            return hr;
+    }
+
+    if (FAILED(IMFAttributes_GetGUID(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_CLSID, &clsid)))
+        memcpy(&clsid, &CLSID_MFVideoPresenter9, sizeof(clsid));
+
+    return CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFVideoPresenter, (void **)out);
+}
+
 static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context, IUnknown **obj)
 {
     struct video_renderer *object;
@@ -271,10 +298,13 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
     object->refcount = 1;
     InitializeCriticalSection(&object->cs);
 
-    /* Create mixer. */
+    /* Create mixer and presenter. */
     if (FAILED(hr = video_renderer_create_mixer(attributes, &object->mixer)))
         goto done;
 
+    if (FAILED(hr = video_renderer_create_presenter(attributes, &object->presenter)))
+        goto done;
+
     *obj = (IUnknown *)&object->IMFMediaSink_iface;
 
     return S_OK;
From 8ce49878bcf596c782ee2be3499ecc42699665bf Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 7 Jul 2020 14:40:14 +0300
Subject: [PATCH] mf/evr: Add IMFVideoRenderer stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c      | 45 +++++++++++++++++++++++++++++++++++++++++++++
 dlls/mf/tests/mf.c |  6 ++++++
 2 files changed, 51 insertions(+)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index c3ee38c8292..92f0ff04fab 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -33,6 +33,7 @@ struct video_renderer
 {
     IMFMediaSink IMFMediaSink_iface;
     IMFMediaSinkPreroll IMFMediaSinkPreroll_iface;
+    IMFVideoRenderer IMFVideoRenderer_iface;
     LONG refcount;
 
     IMFTransform *mixer;
@@ -51,6 +52,11 @@ static struct video_renderer *impl_from_IMFMediaSinkPreroll(IMFMediaSinkPreroll
     return CONTAINING_RECORD(iface, struct video_renderer, IMFMediaSinkPreroll_iface);
 }
 
+static struct video_renderer *impl_from_IMFVideoRenderer(IMFVideoRenderer *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_renderer, IMFVideoRenderer_iface);
+}
+
 static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, REFIID riid, void **obj)
 {
     struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
@@ -66,6 +72,10 @@ static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, RE
     {
         *obj = &renderer->IMFMediaSinkPreroll_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFVideoRenderer))
+    {
+        *obj = &renderer->IMFVideoRenderer_iface;
+    }
     else
     {
         WARN("Unsupported interface %s.\n", debugstr_guid(riid));
@@ -237,6 +247,40 @@ static const IMFMediaSinkPrerollVtbl video_renderer_preroll_vtbl =
     video_renderer_preroll_NotifyPreroll,
 };
 
+static HRESULT WINAPI video_renderer_QueryInterface(IMFVideoRenderer *iface, REFIID riid, void **obj)
+{
+    struct video_renderer *renderer = impl_from_IMFVideoRenderer(iface);
+    return IMFMediaSink_QueryInterface(&renderer->IMFMediaSink_iface, riid, obj);
+}
+
+static ULONG WINAPI video_renderer_AddRef(IMFVideoRenderer *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFVideoRenderer(iface);
+    return IMFMediaSink_AddRef(&renderer->IMFMediaSink_iface);
+}
+
+static ULONG WINAPI video_renderer_Release(IMFVideoRenderer *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFVideoRenderer(iface);
+    return IMFMediaSink_Release(&renderer->IMFMediaSink_iface);
+}
+
+static HRESULT WINAPI video_renderer_InitializeRenderer(IMFVideoRenderer *iface, IMFTransform *mixer,
+        IMFVideoPresenter *presenter)
+{
+    FIXME("%p, %p, %p.\n", iface, mixer, presenter);
+
+    return E_NOTIMPL;
+}
+
+static const IMFVideoRendererVtbl video_renderer_vtbl =
+{
+    video_renderer_QueryInterface,
+    video_renderer_AddRef,
+    video_renderer_Release,
+    video_renderer_InitializeRenderer,
+};
+
 static HRESULT video_renderer_create_mixer(IMFAttributes *attributes, IMFTransform **out)
 {
     unsigned int flags = 0;
@@ -295,6 +339,7 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
 
     object->IMFMediaSink_iface.lpVtbl = &video_renderer_sink_vtbl;
     object->IMFMediaSinkPreroll_iface.lpVtbl = &video_renderer_preroll_vtbl;
+    object->IMFVideoRenderer_iface.lpVtbl = &video_renderer_vtbl;
     object->refcount = 1;
     InitializeCriticalSection(&object->cs);
 
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 691734aa9a9..a66bdcf1ee7 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -41,6 +41,7 @@ DEFINE_GUID(MFVideoFormat_ABGR32, 0x00000020, 0x0000, 0x0010, 0x80, 0x00, 0x00,
 #include "initguid.h"
 #include "mmdeviceapi.h"
 #include "audioclient.h"
+#include "evr.h"
 
 #include "wine/test.h"
 
@@ -3226,6 +3227,7 @@ todo_wine
 
 static void test_evr(void)
 {
+    IMFVideoRenderer *video_renderer;
     IMFMediaSinkPreroll *preroll;
     IMFMediaSink *sink, *sink2;
     IMFActivate *activate;
@@ -3261,6 +3263,10 @@ static void test_evr(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IMFMediaSinkPreroll_Release(preroll);
 
+    hr = IMFMediaSink_QueryInterface(sink, &IID_IMFVideoRenderer, (void **)&video_renderer);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IMFVideoRenderer_Release(video_renderer);
+
     hr = IMFActivate_ShutdownObject(activate);
     ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
From 68204a86a228b65b63b21be6ef07e9ae8baba542 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 7 Jul 2020 14:40:15 +0300
Subject: [PATCH] mf/evr: Add events queue support for the sink.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c           | 92 +++++++++++++++++++++++++++++++++++++++--
 dlls/mf/main.c          |  2 -
 dlls/mf/mf_private.h    |  1 +
 dlls/mf/samplegrabber.c |  1 -
 dlls/mf/session.c       |  1 -
 dlls/mf/tests/mf.c      |  5 +++
 dlls/mf/topology.c      |  1 -
 7 files changed, 95 insertions(+), 8 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 92f0ff04fab..bb21ccdd25a 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -34,8 +34,10 @@ struct video_renderer
     IMFMediaSink IMFMediaSink_iface;
     IMFMediaSinkPreroll IMFMediaSinkPreroll_iface;
     IMFVideoRenderer IMFVideoRenderer_iface;
+    IMFMediaEventGenerator IMFMediaEventGenerator_iface;
     LONG refcount;
 
+    IMFMediaEventQueue *event_queue;
     IMFTransform *mixer;
     IMFVideoPresenter *presenter;
     unsigned int flags;
@@ -57,6 +59,11 @@ static struct video_renderer *impl_from_IMFVideoRenderer(IMFVideoRenderer *iface
     return CONTAINING_RECORD(iface, struct video_renderer, IMFVideoRenderer_iface);
 }
 
+static struct video_renderer *impl_from_IMFMediaEventGenerator(IMFMediaEventGenerator *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_renderer, IMFMediaEventGenerator_iface);
+}
+
 static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, REFIID riid, void **obj)
 {
     struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
@@ -76,6 +83,10 @@ static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, RE
     {
         *obj = &renderer->IMFVideoRenderer_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFMediaEventGenerator))
+    {
+        *obj = &renderer->IMFMediaEventGenerator_iface;
+    }
     else
     {
         WARN("Unsupported interface %s.\n", debugstr_guid(riid));
@@ -105,6 +116,8 @@ static ULONG WINAPI video_renderer_sink_Release(IMFMediaSink *iface)
 
     if (!refcount)
     {
+        if (renderer->event_queue)
+            IMFMediaEventQueue_Release(renderer->event_queue);
         if (renderer->mixer)
             IMFTransform_Release(renderer->mixer);
         if (renderer->presenter)
@@ -193,6 +206,7 @@ static HRESULT WINAPI video_renderer_sink_Shutdown(IMFMediaSink *iface)
 
     EnterCriticalSection(&renderer->cs);
     renderer->flags |= EVR_SHUT_DOWN;
+    IMFMediaEventQueue_Shutdown(renderer->event_queue);
     LeaveCriticalSection(&renderer->cs);
 
     return S_OK;
@@ -281,6 +295,74 @@ static const IMFVideoRendererVtbl video_renderer_vtbl =
     video_renderer_InitializeRenderer,
 };
 
+static HRESULT WINAPI video_renderer_events_QueryInterface(IMFMediaEventGenerator *iface, REFIID riid, void **obj)
+{
+    struct video_renderer *renderer = impl_from_IMFMediaEventGenerator(iface);
+    return IMFMediaSink_QueryInterface(&renderer->IMFMediaSink_iface, riid, obj);
+}
+
+static ULONG WINAPI video_renderer_events_AddRef(IMFMediaEventGenerator *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFMediaEventGenerator(iface);
+    return IMFMediaSink_AddRef(&renderer->IMFMediaSink_iface);
+}
+
+static ULONG WINAPI video_renderer_events_Release(IMFMediaEventGenerator *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFMediaEventGenerator(iface);
+    return IMFMediaSink_Release(&renderer->IMFMediaSink_iface);
+}
+
+static HRESULT WINAPI video_renderer_events_GetEvent(IMFMediaEventGenerator *iface, DWORD flags, IMFMediaEvent **event)
+{
+    struct video_renderer *renderer = impl_from_IMFMediaEventGenerator(iface);
+
+    TRACE("%p, %#x, %p.\n", iface, flags, event);
+
+    return IMFMediaEventQueue_GetEvent(renderer->event_queue, flags, event);
+}
+
+static HRESULT WINAPI video_renderer_events_BeginGetEvent(IMFMediaEventGenerator *iface, IMFAsyncCallback *callback,
+        IUnknown *state)
+{
+    struct video_renderer *renderer = impl_from_IMFMediaEventGenerator(iface);
+
+    TRACE("%p, %p, %p.\n", iface, callback, state);
+
+    return IMFMediaEventQueue_BeginGetEvent(renderer->event_queue, callback, state);
+}
+
+static HRESULT WINAPI video_renderer_events_EndGetEvent(IMFMediaEventGenerator *iface, IMFAsyncResult *result,
+        IMFMediaEvent **event)
+{
+    struct video_renderer *renderer = impl_from_IMFMediaEventGenerator(iface);
+
+    TRACE("%p, %p, %p.\n", iface, result, event);
+
+    return IMFMediaEventQueue_EndGetEvent(renderer->event_queue, result, event);
+}
+
+static HRESULT WINAPI video_renderer_events_QueueEvent(IMFMediaEventGenerator *iface, MediaEventType event_type,
+        REFGUID ext_type, HRESULT hr, const PROPVARIANT *value)
+{
+    struct video_renderer *renderer = impl_from_IMFMediaEventGenerator(iface);
+
+    TRACE("%p, %u, %s, %#x, %p.\n", iface, event_type, debugstr_guid(ext_type), hr, value);
+
+    return IMFMediaEventQueue_QueueEventParamVar(renderer->event_queue, event_type, ext_type, hr, value);
+}
+
+static const IMFMediaEventGeneratorVtbl video_renderer_events_vtbl =
+{
+    video_renderer_events_QueryInterface,
+    video_renderer_events_AddRef,
+    video_renderer_events_Release,
+    video_renderer_events_GetEvent,
+    video_renderer_events_BeginGetEvent,
+    video_renderer_events_EndGetEvent,
+    video_renderer_events_QueueEvent,
+};
+
 static HRESULT video_renderer_create_mixer(IMFAttributes *attributes, IMFTransform **out)
 {
     unsigned int flags = 0;
@@ -340,21 +422,25 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
     object->IMFMediaSink_iface.lpVtbl = &video_renderer_sink_vtbl;
     object->IMFMediaSinkPreroll_iface.lpVtbl = &video_renderer_preroll_vtbl;
     object->IMFVideoRenderer_iface.lpVtbl = &video_renderer_vtbl;
+    object->IMFMediaEventGenerator_iface.lpVtbl = &video_renderer_events_vtbl;
     object->refcount = 1;
     InitializeCriticalSection(&object->cs);
 
+    if (FAILED(hr = MFCreateEventQueue(&object->event_queue)))
+        goto failed;
+
     /* Create mixer and presenter. */
     if (FAILED(hr = video_renderer_create_mixer(attributes, &object->mixer)))
-        goto done;
+        goto failed;
 
     if (FAILED(hr = video_renderer_create_presenter(attributes, &object->presenter)))
-        goto done;
+        goto failed;
 
     *obj = (IUnknown *)&object->IMFMediaSink_iface;
 
     return S_OK;
 
-done:
+failed:
 
     IMFMediaSink_Release(&object->IMFMediaSink_iface);
 
diff --git a/dlls/mf/main.c b/dlls/mf/main.c
index 62dc1813c7b..53264258137 100644
--- a/dlls/mf/main.c
+++ b/dlls/mf/main.c
@@ -26,8 +26,6 @@
 #include "mfidl.h"
 #include "rpcproxy.h"
 
-#include "mfapi.h"
-
 #include "mf_private.h"
 
 #include "wine/debug.h"
diff --git a/dlls/mf/mf_private.h b/dlls/mf/mf_private.h
index f4356219731..66d970dfce5 100644
--- a/dlls/mf/mf_private.h
+++ b/dlls/mf/mf_private.h
@@ -18,6 +18,7 @@
 
 #include "mferror.h"
 #include "mfidl.h"
+#include "mfapi.h"
 
 #include "wine/heap.h"
 #include "wine/debug.h"
diff --git a/dlls/mf/samplegrabber.c b/dlls/mf/samplegrabber.c
index cbf7453d04d..566ee2f2930 100644
--- a/dlls/mf/samplegrabber.c
+++ b/dlls/mf/samplegrabber.c
@@ -18,7 +18,6 @@
 
 #define COBJMACROS
 
-#include "mfapi.h"
 #include "mfidl.h"
 #include "mf_private.h"
 
diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index d0365ea8564..e2a6b868caf 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -24,7 +24,6 @@
 #include "windef.h"
 #include "winbase.h"
 #include "mfidl.h"
-#include "mfapi.h"
 
 #include "wine/debug.h"
 #include "wine/heap.h"
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index a66bdcf1ee7..5d9ccc5408d 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3227,6 +3227,7 @@ todo_wine
 
 static void test_evr(void)
 {
+    IMFMediaEventGenerator *ev_generator;
     IMFVideoRenderer *video_renderer;
     IMFMediaSinkPreroll *preroll;
     IMFMediaSink *sink, *sink2;
@@ -3267,6 +3268,10 @@ static void test_evr(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IMFVideoRenderer_Release(video_renderer);
 
+    hr = IMFMediaSink_QueryInterface(sink, &IID_IMFMediaEventGenerator, (void **)&ev_generator);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IMFMediaEventGenerator_Release(ev_generator);
+
     hr = IMFActivate_ShutdownObject(activate);
     ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
diff --git a/dlls/mf/topology.c b/dlls/mf/topology.c
index f4cc30a9fc6..abe66c45fd4 100644
--- a/dlls/mf/topology.c
+++ b/dlls/mf/topology.c
@@ -26,7 +26,6 @@
 
 #undef INITGUID
 #include <guiddef.h>
-#include "mfapi.h"
 #include "mfidl.h"
 
 #include "wine/debug.h"
From 115ac283993013116af06f9d14e650e027d7f06d Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 8 Jul 2020 18:10:34 +0300
Subject: [PATCH] mf/evr: Add a stub for clock state sink.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c      | 76 ++++++++++++++++++++++++++++++++++++++++++++++
 dlls/mf/tests/mf.c |  5 +++
 2 files changed, 81 insertions(+)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index bb21ccdd25a..aa4d3850c6f 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -34,6 +34,7 @@ struct video_renderer
     IMFMediaSink IMFMediaSink_iface;
     IMFMediaSinkPreroll IMFMediaSinkPreroll_iface;
     IMFVideoRenderer IMFVideoRenderer_iface;
+    IMFClockStateSink IMFClockStateSink_iface;
     IMFMediaEventGenerator IMFMediaEventGenerator_iface;
     LONG refcount;
 
@@ -64,6 +65,11 @@ static struct video_renderer *impl_from_IMFMediaEventGenerator(IMFMediaEventGene
     return CONTAINING_RECORD(iface, struct video_renderer, IMFMediaEventGenerator_iface);
 }
 
+static struct video_renderer *impl_from_IMFClockStateSink(IMFClockStateSink *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_renderer, IMFClockStateSink_iface);
+}
+
 static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, REFIID riid, void **obj)
 {
     struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
@@ -87,6 +93,10 @@ static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, RE
     {
         *obj = &renderer->IMFMediaEventGenerator_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFClockStateSink))
+    {
+        *obj = &renderer->IMFClockStateSink_iface;
+    }
     else
     {
         WARN("Unsupported interface %s.\n", debugstr_guid(riid));
@@ -363,6 +373,71 @@ static const IMFMediaEventGeneratorVtbl video_renderer_events_vtbl =
     video_renderer_events_QueueEvent,
 };
 
+static HRESULT WINAPI video_renderer_clock_sink_QueryInterface(IMFClockStateSink *iface, REFIID riid, void **obj)
+{
+    struct video_renderer *renderer = impl_from_IMFClockStateSink(iface);
+    return IMFMediaSink_QueryInterface(&renderer->IMFMediaSink_iface, riid, obj);
+}
+
+static ULONG WINAPI video_renderer_clock_sink_AddRef(IMFClockStateSink *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFClockStateSink(iface);
+    return IMFMediaSink_AddRef(&renderer->IMFMediaSink_iface);
+}
+
+static ULONG WINAPI video_renderer_clock_sink_Release(IMFClockStateSink *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFClockStateSink(iface);
+    return IMFMediaSink_Release(&renderer->IMFMediaSink_iface);
+}
+
+static HRESULT WINAPI video_renderer_clock_sink_OnClockStart(IMFClockStateSink *iface, MFTIME systime, LONGLONG offset)
+{
+    FIXME("%p, %s, %s.\n", iface, debugstr_time(systime), debugstr_time(offset));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_renderer_clock_sink_OnClockStop(IMFClockStateSink *iface, MFTIME systime)
+{
+    FIXME("%p, %s.\n", iface, debugstr_time(systime));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_renderer_clock_sink_OnClockPause(IMFClockStateSink *iface, MFTIME systime)
+{
+    FIXME("%p, %s.\n", iface, debugstr_time(systime));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_renderer_clock_sink_OnClockRestart(IMFClockStateSink *iface, MFTIME systime)
+{
+    FIXME("%p, %s.\n", iface, debugstr_time(systime));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_renderer_clock_sink_OnClockSetRate(IMFClockStateSink *iface, MFTIME systime, float rate)
+{
+    FIXME("%p, %s, %f.\n", iface, debugstr_time(systime), rate);
+
+    return E_NOTIMPL;
+}
+
+static const IMFClockStateSinkVtbl video_renderer_clock_sink_vtbl =
+{
+    video_renderer_clock_sink_QueryInterface,
+    video_renderer_clock_sink_AddRef,
+    video_renderer_clock_sink_Release,
+    video_renderer_clock_sink_OnClockStart,
+    video_renderer_clock_sink_OnClockStop,
+    video_renderer_clock_sink_OnClockPause,
+    video_renderer_clock_sink_OnClockRestart,
+    video_renderer_clock_sink_OnClockSetRate,
+};
+
 static HRESULT video_renderer_create_mixer(IMFAttributes *attributes, IMFTransform **out)
 {
     unsigned int flags = 0;
@@ -423,6 +498,7 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
     object->IMFMediaSinkPreroll_iface.lpVtbl = &video_renderer_preroll_vtbl;
     object->IMFVideoRenderer_iface.lpVtbl = &video_renderer_vtbl;
     object->IMFMediaEventGenerator_iface.lpVtbl = &video_renderer_events_vtbl;
+    object->IMFClockStateSink_iface.lpVtbl = &video_renderer_clock_sink_vtbl;
     object->refcount = 1;
     InitializeCriticalSection(&object->cs);
 
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 5d9ccc5408d..077466b7e8e 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3229,6 +3229,7 @@ static void test_evr(void)
 {
     IMFMediaEventGenerator *ev_generator;
     IMFVideoRenderer *video_renderer;
+    IMFClockStateSink *clock_sink;
     IMFMediaSinkPreroll *preroll;
     IMFMediaSink *sink, *sink2;
     IMFActivate *activate;
@@ -3272,6 +3273,10 @@ static void test_evr(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IMFMediaEventGenerator_Release(ev_generator);
 
+    hr = IMFMediaSink_QueryInterface(sink, &IID_IMFClockStateSink, (void **)&clock_sink);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IMFClockStateSink_Release(clock_sink);
+
     hr = IMFActivate_ShutdownObject(activate);
     ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
From f557a5ee561faa215f2700b492daab789c82bee8 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 8 Jul 2020 18:10:35 +0300
Subject: [PATCH] mf/evr: Add IMFGetService stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c      | 44 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/mf/tests/mf.c |  5 +++++
 2 files changed, 49 insertions(+)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index aa4d3850c6f..ebb3fd4c2c8 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -36,6 +36,7 @@ struct video_renderer
     IMFVideoRenderer IMFVideoRenderer_iface;
     IMFClockStateSink IMFClockStateSink_iface;
     IMFMediaEventGenerator IMFMediaEventGenerator_iface;
+    IMFGetService IMFGetService_iface;
     LONG refcount;
 
     IMFMediaEventQueue *event_queue;
@@ -70,6 +71,11 @@ static struct video_renderer *impl_from_IMFClockStateSink(IMFClockStateSink *ifa
     return CONTAINING_RECORD(iface, struct video_renderer, IMFClockStateSink_iface);
 }
 
+static struct video_renderer *impl_from_IMFGetService(IMFGetService *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_renderer, IMFGetService_iface);
+}
+
 static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, REFIID riid, void **obj)
 {
     struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
@@ -97,6 +103,10 @@ static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, RE
     {
         *obj = &renderer->IMFClockStateSink_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFGetService))
+    {
+        *obj = &renderer->IMFGetService_iface;
+    }
     else
     {
         WARN("Unsupported interface %s.\n", debugstr_guid(riid));
@@ -438,6 +448,39 @@ static const IMFClockStateSinkVtbl video_renderer_clock_sink_vtbl =
     video_renderer_clock_sink_OnClockSetRate,
 };
 
+static HRESULT WINAPI video_renderer_get_service_QueryInterface(IMFGetService *iface, REFIID riid, void **obj)
+{
+    struct video_renderer *renderer = impl_from_IMFGetService(iface);
+    return IMFMediaSink_QueryInterface(&renderer->IMFMediaSink_iface, riid, obj);
+}
+
+static ULONG WINAPI video_renderer_get_service_AddRef(IMFGetService *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFGetService(iface);
+    return IMFMediaSink_AddRef(&renderer->IMFMediaSink_iface);
+}
+
+static ULONG WINAPI video_renderer_get_service_Release(IMFGetService *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFGetService(iface);
+    return IMFMediaSink_Release(&renderer->IMFMediaSink_iface);
+}
+
+static HRESULT WINAPI video_renderer_get_service_GetService(IMFGetService *iface, REFGUID service, REFIID riid, void **obj)
+{
+    FIXME("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+
+    return E_NOTIMPL;
+}
+
+static const IMFGetServiceVtbl video_renderer_get_service_vtbl =
+{
+    video_renderer_get_service_QueryInterface,
+    video_renderer_get_service_AddRef,
+    video_renderer_get_service_Release,
+    video_renderer_get_service_GetService,
+};
+
 static HRESULT video_renderer_create_mixer(IMFAttributes *attributes, IMFTransform **out)
 {
     unsigned int flags = 0;
@@ -499,6 +542,7 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
     object->IMFVideoRenderer_iface.lpVtbl = &video_renderer_vtbl;
     object->IMFMediaEventGenerator_iface.lpVtbl = &video_renderer_events_vtbl;
     object->IMFClockStateSink_iface.lpVtbl = &video_renderer_clock_sink_vtbl;
+    object->IMFGetService_iface.lpVtbl = &video_renderer_get_service_vtbl;
     object->refcount = 1;
     InitializeCriticalSection(&object->cs);
 
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 077466b7e8e..3fad309bcf6 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3234,6 +3234,7 @@ static void test_evr(void)
     IMFMediaSink *sink, *sink2;
     IMFActivate *activate;
     DWORD flags, count;
+    IMFGetService *gs;
     UINT64 value;
     HRESULT hr;
 
@@ -3277,6 +3278,10 @@ static void test_evr(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IMFClockStateSink_Release(clock_sink);
 
+    hr = IMFMediaSink_QueryInterface(sink, &IID_IMFGetService, (void **)&gs);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IMFGetService_Release(gs);
+
     hr = IMFActivate_ShutdownObject(activate);
     ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
From 52f8191b9348f0e5b183b81cb6f7a8e9787a64c2 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 8 Jul 2020 18:10:36 +0300
Subject: [PATCH] evr: Respond to IMFVideoMixerControl in mixer's GetService().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 4 +++-
 dlls/evr/tests/evr.c | 4 ++++
 2 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index c8bd300b0d3..f274a2a447f 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -1021,7 +1021,9 @@ static HRESULT WINAPI video_mixer_getservice_GetService(IMFGetService *iface, RE
     {
         if (IsEqualIID(riid, &IID_IMFVideoMixerBitmap) ||
                 IsEqualIID(riid, &IID_IMFVideoProcessor) ||
-                IsEqualIID(riid, &IID_IMFVideoPositionMapper))
+                IsEqualIID(riid, &IID_IMFVideoPositionMapper) ||
+                IsEqualIID(riid, &IID_IMFVideoMixerControl) ||
+                IsEqualIID(riid, &IID_IMFVideoMixerControl2))
         {
             return IMFGetService_QueryInterface(iface, riid, obj);
         }
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index db9b3a80e04..5e184947188 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -450,6 +450,10 @@ static void test_default_mixer(void)
     hr = IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoProcessor, (void **)&processor);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoMixerControl, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
     hr = IMFVideoProcessor_GetBackgroundColor(processor, NULL);
     ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
From 58f7c7823be66e81b1a212ab8be458185472d2bc Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 8 Jul 2020 18:10:37 +0300
Subject: [PATCH] mf/evr: Forward mixer service requests to the mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c      | 23 +++++++++++++++++++++--
 dlls/mf/tests/mf.c |  6 ++++++
 2 files changed, 27 insertions(+), 2 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index ebb3fd4c2c8..8b7de5c76bb 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -468,9 +468,28 @@ static ULONG WINAPI video_renderer_get_service_Release(IMFGetService *iface)
 
 static HRESULT WINAPI video_renderer_get_service_GetService(IMFGetService *iface, REFGUID service, REFIID riid, void **obj)
 {
-    FIXME("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+    struct video_renderer *renderer = impl_from_IMFGetService(iface);
+    HRESULT hr = E_NOINTERFACE;
+    IMFGetService *gs = NULL;
 
-    return E_NOTIMPL;
+    TRACE("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(service, &MR_VIDEO_MIXER_SERVICE))
+    {
+        hr = IMFTransform_QueryInterface(renderer->mixer, &IID_IMFGetService, (void **)&gs);
+    }
+    else
+    {
+        FIXME("Unsupported service %s.\n", debugstr_guid(service));
+    }
+
+    if (gs)
+    {
+        hr = IMFGetService_GetService(gs, service, riid, obj);
+        IMFGetService_Release(gs);
+    }
+
+    return hr;
 }
 
 static const IMFGetServiceVtbl video_renderer_get_service_vtbl =
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 3fad309bcf6..aa2c5199b95 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3235,6 +3235,7 @@ static void test_evr(void)
     IMFActivate *activate;
     DWORD flags, count;
     IMFGetService *gs;
+    IUnknown *unk;
     UINT64 value;
     HRESULT hr;
 
@@ -3280,6 +3281,11 @@ static void test_evr(void)
 
     hr = IMFMediaSink_QueryInterface(sink, &IID_IMFGetService, (void **)&gs);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoMixerControl, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
     IMFGetService_Release(gs);
 
     hr = IMFActivate_ShutdownObject(activate);
From 612f96ae27a7a117e5d5260ab7c01f15b030c6f1 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 8 Jul 2020 18:10:38 +0300
Subject: [PATCH] mf/evr: Forward presenter service requests to the presenter.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 8b7de5c76bb..d20fb1a395d 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -478,6 +478,10 @@ static HRESULT WINAPI video_renderer_get_service_GetService(IMFGetService *iface
     {
         hr = IMFTransform_QueryInterface(renderer->mixer, &IID_IMFGetService, (void **)&gs);
     }
+    else if (IsEqualGUID(service, &MR_VIDEO_RENDER_SERVICE))
+    {
+        hr = IMFVideoPresenter_QueryInterface(renderer->presenter, &IID_IMFGetService, (void **)&gs);
+    }
     else
     {
         FIXME("Unsupported service %s.\n", debugstr_guid(service));
From 65d3383be9cd6c6ba182bd27bb61dab961e90f01 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 9 Jul 2020 15:08:46 +0300
Subject: [PATCH] mf/evr: Do not set user context for activator object.

Window handle is passed as an attribute.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index d20fb1a395d..b35af55353d 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -619,7 +619,7 @@ HRESULT WINAPI MFCreateVideoRendererActivate(HWND hwnd, IMFActivate **activate)
     if (!activate)
         return E_POINTER;
 
-    hr = create_activation_object(hwnd, &evr_activate_funcs, activate);
+    hr = create_activation_object(NULL, &evr_activate_funcs, activate);
     if (SUCCEEDED(hr))
         IMFActivate_SetUINT64(*activate, &MF_ACTIVATE_VIDEO_WINDOW, (ULONG_PTR)hwnd);
 
From 747c8a38c4aa2a372316a7e5c876b5cbd90ec56d Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 9 Jul 2020 15:08:47 +0300
Subject: [PATCH] mf/evr: Implement setting/getting sink clock.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 60 +++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 56 insertions(+), 4 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index b35af55353d..ebd4b232fc7 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -40,6 +40,8 @@ struct video_renderer
     LONG refcount;
 
     IMFMediaEventQueue *event_queue;
+    IMFPresentationClock *clock;
+
     IMFTransform *mixer;
     IMFVideoPresenter *presenter;
     unsigned int flags;
@@ -142,6 +144,8 @@ static ULONG WINAPI video_renderer_sink_Release(IMFMediaSink *iface)
             IMFTransform_Release(renderer->mixer);
         if (renderer->presenter)
             IMFVideoPresenter_Release(renderer->presenter);
+        if (renderer->clock)
+            IMFPresentationClock_Release(renderer->clock);
         DeleteCriticalSection(&renderer->cs);
         heap_free(renderer);
     }
@@ -201,18 +205,65 @@ static HRESULT WINAPI video_renderer_sink_GetStreamSinkById(IMFMediaSink *iface,
     return E_NOTIMPL;
 }
 
+static void video_renderer_set_presentation_clock(struct video_renderer *renderer, IMFPresentationClock *clock)
+{
+    if (renderer->clock)
+    {
+        IMFPresentationClock_RemoveClockStateSink(renderer->clock, &renderer->IMFClockStateSink_iface);
+        IMFPresentationClock_Release(renderer->clock);
+    }
+    renderer->clock = clock;
+    if (renderer->clock)
+    {
+        IMFPresentationClock_AddRef(renderer->clock);
+        IMFPresentationClock_AddClockStateSink(renderer->clock, &renderer->IMFClockStateSink_iface);
+    }
+}
+
 static HRESULT WINAPI video_renderer_sink_SetPresentationClock(IMFMediaSink *iface, IMFPresentationClock *clock)
 {
-    FIXME("%p, %p.\n", iface, clock);
+    struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, clock);
+
+    EnterCriticalSection(&renderer->cs);
+
+    if (renderer->flags & EVR_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else
+        video_renderer_set_presentation_clock(renderer, clock);
+
+    LeaveCriticalSection(&renderer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_renderer_sink_GetPresentationClock(IMFMediaSink *iface, IMFPresentationClock **clock)
 {
-    FIXME("%p, %p.\n", iface, clock);
+    struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, clock);
+
+    if (!clock)
+        return E_POINTER;
+
+    EnterCriticalSection(&renderer->cs);
+
+    if (renderer->flags & EVR_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (renderer->clock)
+    {
+        *clock = renderer->clock;
+        IMFPresentationClock_AddRef(*clock);
+    }
+    else
+        hr = MF_E_NO_CLOCK;
+
+    LeaveCriticalSection(&renderer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_renderer_sink_Shutdown(IMFMediaSink *iface)
@@ -227,6 +278,7 @@ static HRESULT WINAPI video_renderer_sink_Shutdown(IMFMediaSink *iface)
     EnterCriticalSection(&renderer->cs);
     renderer->flags |= EVR_SHUT_DOWN;
     IMFMediaEventQueue_Shutdown(renderer->event_queue);
+    video_renderer_set_presentation_clock(renderer, NULL);
     LeaveCriticalSection(&renderer->cs);
 
     return S_OK;
From 1fc9827602361148300b647a984166b6578ff743 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 9 Jul 2020 15:08:48 +0300
Subject: [PATCH] mf/evr: Add IMFTopologyServiceLookup stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 54 +++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index ebd4b232fc7..4a70f798723 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -37,6 +37,7 @@ struct video_renderer
     IMFClockStateSink IMFClockStateSink_iface;
     IMFMediaEventGenerator IMFMediaEventGenerator_iface;
     IMFGetService IMFGetService_iface;
+    IMFTopologyServiceLookup IMFTopologyServiceLookup_iface;
     LONG refcount;
 
     IMFMediaEventQueue *event_queue;
@@ -78,6 +79,11 @@ static struct video_renderer *impl_from_IMFGetService(IMFGetService *iface)
     return CONTAINING_RECORD(iface, struct video_renderer, IMFGetService_iface);
 }
 
+static struct video_renderer *impl_from_IMFTopologyServiceLookup(IMFTopologyServiceLookup *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_renderer, IMFTopologyServiceLookup_iface);
+}
+
 static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, REFIID riid, void **obj)
 {
     struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
@@ -556,6 +562,53 @@ static const IMFGetServiceVtbl video_renderer_get_service_vtbl =
     video_renderer_get_service_GetService,
 };
 
+static HRESULT WINAPI video_renderer_service_lookup_QueryInterface(IMFTopologyServiceLookup *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IMFTopologyServiceLookup) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFTopologyServiceLookup_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI video_renderer_service_lookup_AddRef(IMFTopologyServiceLookup *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFTopologyServiceLookup(iface);
+    return IMFMediaSink_AddRef(&renderer->IMFMediaSink_iface);
+}
+
+static ULONG WINAPI video_renderer_service_lookup_Release(IMFTopologyServiceLookup *iface)
+{
+    struct video_renderer *renderer = impl_from_IMFTopologyServiceLookup(iface);
+    return IMFMediaSink_Release(&renderer->IMFMediaSink_iface);
+}
+
+static HRESULT WINAPI video_renderer_service_lookup_LookupService(IMFTopologyServiceLookup *iface,
+        MF_SERVICE_LOOKUP_TYPE lookup_type, DWORD index, REFGUID service, REFIID riid,
+        void **objects, DWORD *num_objects)
+{
+    TRACE("%p, %u, %u, %s, %s, %p, %p.\n", iface, lookup_type, index, debugstr_guid(service), debugstr_guid(riid),
+            objects, num_objects);
+
+    return E_NOTIMPL;
+}
+
+static const IMFTopologyServiceLookupVtbl video_renderer_service_lookup_vtbl =
+{
+    video_renderer_service_lookup_QueryInterface,
+    video_renderer_service_lookup_AddRef,
+    video_renderer_service_lookup_Release,
+    video_renderer_service_lookup_LookupService,
+};
+
 static HRESULT video_renderer_create_mixer(IMFAttributes *attributes, IMFTransform **out)
 {
     unsigned int flags = 0;
@@ -618,6 +671,7 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
     object->IMFMediaEventGenerator_iface.lpVtbl = &video_renderer_events_vtbl;
     object->IMFClockStateSink_iface.lpVtbl = &video_renderer_clock_sink_vtbl;
     object->IMFGetService_iface.lpVtbl = &video_renderer_get_service_vtbl;
+    object->IMFTopologyServiceLookup_iface.lpVtbl = &video_renderer_service_lookup_vtbl;
     object->refcount = 1;
     InitializeCriticalSection(&object->cs);
 
From 03401edef8a4a460f455af39f34b7367909cce4c Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 9 Jul 2020 15:08:49 +0300
Subject: [PATCH] mf/evr: Add support for LookupService() for
 MR_VIDEO_RENDER_SERVICE/IMediaEventSink.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 127 ++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 123 insertions(+), 4 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 4a70f798723..b702ed2e22a 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -27,6 +27,8 @@ WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 enum video_renderer_flags
 {
     EVR_SHUT_DOWN = 0x1,
+    EVR_INIT_SERVICES = 0x2, /* Currently in InitServices() call. */
+    EVR_PRESENTER_INITED_SERVICES = 0x4,
 };
 
 struct video_renderer
@@ -38,6 +40,7 @@ struct video_renderer
     IMFMediaEventGenerator IMFMediaEventGenerator_iface;
     IMFGetService IMFGetService_iface;
     IMFTopologyServiceLookup IMFTopologyServiceLookup_iface;
+    IMediaEventSink IMediaEventSink_iface;
     LONG refcount;
 
     IMFMediaEventQueue *event_queue;
@@ -84,6 +87,24 @@ static struct video_renderer *impl_from_IMFTopologyServiceLookup(IMFTopologyServ
     return CONTAINING_RECORD(iface, struct video_renderer, IMFTopologyServiceLookup_iface);
 }
 
+static struct video_renderer *impl_from_IMediaEventSink(IMediaEventSink *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_renderer, IMediaEventSink_iface);
+}
+
+static void video_renderer_release_services(struct video_renderer *renderer)
+{
+    IMFTopologyServiceLookupClient *lookup_client;
+
+    if (renderer->flags & EVR_PRESENTER_INITED_SERVICES && SUCCEEDED(IMFVideoPresenter_QueryInterface(renderer->presenter,
+            &IID_IMFTopologyServiceLookupClient, (void **)&lookup_client)))
+    {
+        IMFTopologyServiceLookupClient_ReleaseServicePointers(lookup_client);
+        IMFTopologyServiceLookupClient_Release(lookup_client);
+        renderer->flags &= ~EVR_PRESENTER_INITED_SERVICES;
+    }
+}
+
 static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, REFIID riid, void **obj)
 {
     struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
@@ -285,6 +306,7 @@ static HRESULT WINAPI video_renderer_sink_Shutdown(IMFMediaSink *iface)
     renderer->flags |= EVR_SHUT_DOWN;
     IMFMediaEventQueue_Shutdown(renderer->event_queue);
     video_renderer_set_presentation_clock(renderer, NULL);
+    video_renderer_release_services(renderer);
     LeaveCriticalSection(&renderer->cs);
 
     return S_OK;
@@ -595,10 +617,43 @@ static HRESULT WINAPI video_renderer_service_lookup_LookupService(IMFTopologySer
         MF_SERVICE_LOOKUP_TYPE lookup_type, DWORD index, REFGUID service, REFIID riid,
         void **objects, DWORD *num_objects)
 {
+    struct video_renderer *renderer = impl_from_IMFTopologyServiceLookup(iface);
+    HRESULT hr = S_OK;
+
     TRACE("%p, %u, %u, %s, %s, %p, %p.\n", iface, lookup_type, index, debugstr_guid(service), debugstr_guid(riid),
             objects, num_objects);
 
-    return E_NOTIMPL;
+    EnterCriticalSection(&renderer->cs);
+
+    if (!(renderer->flags & EVR_INIT_SERVICES))
+        hr = MF_E_NOTACCEPTING;
+    else if (IsEqualGUID(service, &MR_VIDEO_RENDER_SERVICE))
+    {
+        if (IsEqualIID(riid, &IID_IMediaEventSink))
+        {
+            *objects = &renderer->IMediaEventSink_iface;
+            IUnknown_AddRef((IUnknown *)*objects);
+        }
+        else
+        {
+            FIXME("Unsupported interface %s for render service.\n", debugstr_guid(riid));
+            hr = E_NOINTERFACE;
+        }
+    }
+    else if (IsEqualGUID(service, &MR_VIDEO_MIXER_SERVICE))
+    {
+        FIXME("Unimplemented lookup for mixer service.\n");
+        hr = MF_E_UNSUPPORTED_SERVICE;
+    }
+    else
+    {
+        WARN("Unsupported service %s.\n", debugstr_guid(service));
+        hr = MF_E_UNSUPPORTED_SERVICE;
+    }
+
+    LeaveCriticalSection(&renderer->cs);
+
+    return hr;
 }
 
 static const IMFTopologyServiceLookupVtbl video_renderer_service_lookup_vtbl =
@@ -609,6 +664,50 @@ static const IMFTopologyServiceLookupVtbl video_renderer_service_lookup_vtbl =
     video_renderer_service_lookup_LookupService,
 };
 
+static HRESULT WINAPI video_renderer_event_sink_QueryInterface(IMediaEventSink *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IMediaEventSink) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMediaEventSink_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI video_renderer_event_sink_AddRef(IMediaEventSink *iface)
+{
+    struct video_renderer *renderer = impl_from_IMediaEventSink(iface);
+    return IMFMediaSink_AddRef(&renderer->IMFMediaSink_iface);
+}
+
+static ULONG WINAPI video_renderer_event_sink_Release(IMediaEventSink *iface)
+{
+    struct video_renderer *renderer = impl_from_IMediaEventSink(iface);
+    return IMFMediaSink_Release(&renderer->IMFMediaSink_iface);
+}
+
+static HRESULT WINAPI video_renderer_event_sink_Notify(IMediaEventSink *iface, LONG event, LONG_PTR param1, LONG_PTR param2)
+{
+    FIXME("%p, %d, %ld, %ld.\n", iface, event, param1, param2);
+
+    return E_NOTIMPL;
+}
+
+static const IMediaEventSinkVtbl media_event_sink_vtbl =
+{
+    video_renderer_event_sink_QueryInterface,
+    video_renderer_event_sink_AddRef,
+    video_renderer_event_sink_Release,
+    video_renderer_event_sink_Notify,
+};
+
 static HRESULT video_renderer_create_mixer(IMFAttributes *attributes, IMFTransform **out)
 {
     unsigned int flags = 0;
@@ -632,8 +731,10 @@ static HRESULT video_renderer_create_mixer(IMFAttributes *attributes, IMFTransfo
     return CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFTransform, (void **)out);
 }
 
-static HRESULT video_renderer_create_presenter(IMFAttributes *attributes, IMFVideoPresenter **out)
+static HRESULT video_renderer_create_presenter(struct video_renderer *renderer, IMFAttributes *attributes,
+        IMFVideoPresenter **out)
 {
+    IMFTopologyServiceLookupClient *lookup_client;
     unsigned int flags = 0;
     IMFActivate *activate;
     CLSID clsid;
@@ -652,7 +753,23 @@ static HRESULT video_renderer_create_presenter(IMFAttributes *attributes, IMFVid
     if (FAILED(IMFAttributes_GetGUID(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_CLSID, &clsid)))
         memcpy(&clsid, &CLSID_MFVideoPresenter9, sizeof(clsid));
 
-    return CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFVideoPresenter, (void **)out);
+    if (SUCCEEDED(hr = CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFVideoPresenter, (void **)out)))
+    {
+        if (SUCCEEDED(hr = IMFVideoPresenter_QueryInterface(*out, &IID_IMFTopologyServiceLookupClient,
+                (void **)&lookup_client)))
+        {
+            renderer->flags |= EVR_INIT_SERVICES;
+            if (SUCCEEDED(hr = IMFTopologyServiceLookupClient_InitServicePointers(lookup_client,
+                    &renderer->IMFTopologyServiceLookup_iface)))
+            {
+                renderer->flags |= EVR_PRESENTER_INITED_SERVICES;
+            }
+            renderer->flags &= ~EVR_INIT_SERVICES;
+            IMFTopologyServiceLookupClient_Release(lookup_client);
+        }
+    }
+
+    return hr;
 }
 
 static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context, IUnknown **obj)
@@ -672,6 +789,7 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
     object->IMFClockStateSink_iface.lpVtbl = &video_renderer_clock_sink_vtbl;
     object->IMFGetService_iface.lpVtbl = &video_renderer_get_service_vtbl;
     object->IMFTopologyServiceLookup_iface.lpVtbl = &video_renderer_service_lookup_vtbl;
+    object->IMediaEventSink_iface.lpVtbl = &media_event_sink_vtbl;
     object->refcount = 1;
     InitializeCriticalSection(&object->cs);
 
@@ -682,7 +800,7 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
     if (FAILED(hr = video_renderer_create_mixer(attributes, &object->mixer)))
         goto failed;
 
-    if (FAILED(hr = video_renderer_create_presenter(attributes, &object->presenter)))
+    if (FAILED(hr = video_renderer_create_presenter(object, attributes, &object->presenter)))
         goto failed;
 
     *obj = (IUnknown *)&object->IMFMediaSink_iface;
@@ -691,6 +809,7 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
 
 failed:
 
+    video_renderer_release_services(object);
     IMFMediaSink_Release(&object->IMFMediaSink_iface);
 
     return hr;
From 34d453529216114e59115ed1e6853a7ef13c8057 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 9 Jul 2020 15:08:50 +0300
Subject: [PATCH] mf/evr: Return mixer's transform for MR_VIDEO_MIXER_SERVICE
 requests.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index b702ed2e22a..42a6c98cf6a 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -642,8 +642,16 @@ static HRESULT WINAPI video_renderer_service_lookup_LookupService(IMFTopologySer
     }
     else if (IsEqualGUID(service, &MR_VIDEO_MIXER_SERVICE))
     {
-        FIXME("Unimplemented lookup for mixer service.\n");
-        hr = MF_E_UNSUPPORTED_SERVICE;
+        if (IsEqualIID(riid, &IID_IMFTransform))
+        {
+            *objects = renderer->mixer;
+            IUnknown_AddRef((IUnknown *)*objects);
+        }
+        else
+        {
+            FIXME("Unsupported interface %s for mixer service.\n", debugstr_guid(riid));
+            hr = E_NOINTERFACE;
+        }
     }
     else
     {
From cdf8118ab37b27ffaa7a039d410b859ce100da90 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 9 Jul 2020 15:08:51 +0300
Subject: [PATCH] evr/mixer: Request EVR event sink.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c | 38 ++++++++++++++++++++++++++++++++++----
 1 file changed, 34 insertions(+), 4 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index f274a2a447f..7b9949b01d2 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -73,6 +73,8 @@ struct video_mixer
 
     IDirect3DDeviceManager9 *device_manager;
 
+    IMediaEventSink *event_sink;
+
     CRITICAL_SECTION cs;
 };
 
@@ -899,16 +901,44 @@ static ULONG WINAPI video_mixer_service_client_Release(IMFTopologyServiceLookupC
 static HRESULT WINAPI video_mixer_service_client_InitServicePointers(IMFTopologyServiceLookupClient *iface,
         IMFTopologyServiceLookup *service_lookup)
 {
-    FIXME("%p, %p.\n", iface, service_lookup);
+    struct video_mixer *mixer = impl_from_IMFTopologyServiceLookupClient(iface);
+    unsigned int count;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, service_lookup);
+
+    if (!service_lookup)
+        return E_POINTER;
+
+    EnterCriticalSection(&mixer->cs);
+
+    count = 1;
+    if (FAILED(hr = IMFTopologyServiceLookup_LookupService(service_lookup, MF_SERVICE_LOOKUP_GLOBAL, 0,
+            &MR_VIDEO_RENDER_SERVICE, &IID_IMediaEventSink, (void **)&mixer->event_sink, &count)))
+    {
+        WARN("Failed to get renderer event sink, hr %#x.\n", hr);
+    }
+
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_mixer_service_client_ReleaseServicePointers(IMFTopologyServiceLookupClient *iface)
 {
-    FIXME("%p.\n", iface);
+    struct video_mixer *mixer = impl_from_IMFTopologyServiceLookupClient(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p.\n", iface);
+
+    EnterCriticalSection(&mixer->cs);
+
+    if (mixer->event_sink)
+        IMediaEventSink_Release(mixer->event_sink);
+    mixer->event_sink = NULL;
+
+    LeaveCriticalSection(&mixer->cs);
+
+    return S_OK;
 }
 
 static const IMFTopologyServiceLookupClientVtbl video_mixer_service_client_vtbl =
From 67a840dc5cbb7f07e2c482047a896b1c90ebb7ca Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 9 Jul 2020 15:08:52 +0300
Subject: [PATCH] mf/evr: Let mixer request necessary services.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 35 +++++++++++++++++++++++++++++++----
 1 file changed, 31 insertions(+), 4 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 42a6c98cf6a..8a4aa3c350d 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -28,7 +28,8 @@ enum video_renderer_flags
 {
     EVR_SHUT_DOWN = 0x1,
     EVR_INIT_SERVICES = 0x2, /* Currently in InitServices() call. */
-    EVR_PRESENTER_INITED_SERVICES = 0x4,
+    EVR_MIXER_INITED_SERVICES = 0x4,
+    EVR_PRESENTER_INITED_SERVICES = 0x8,
 };
 
 struct video_renderer
@@ -96,6 +97,14 @@ static void video_renderer_release_services(struct video_renderer *renderer)
 {
     IMFTopologyServiceLookupClient *lookup_client;
 
+    if (renderer->flags & EVR_MIXER_INITED_SERVICES && SUCCEEDED(IMFTransform_QueryInterface(renderer->mixer,
+            &IID_IMFTopologyServiceLookupClient, (void **)&lookup_client)))
+    {
+        IMFTopologyServiceLookupClient_ReleaseServicePointers(lookup_client);
+        IMFTopologyServiceLookupClient_Release(lookup_client);
+        renderer->flags &= ~EVR_MIXER_INITED_SERVICES;
+    }
+
     if (renderer->flags & EVR_PRESENTER_INITED_SERVICES && SUCCEEDED(IMFVideoPresenter_QueryInterface(renderer->presenter,
             &IID_IMFTopologyServiceLookupClient, (void **)&lookup_client)))
     {
@@ -716,8 +725,10 @@ static const IMediaEventSinkVtbl media_event_sink_vtbl =
     video_renderer_event_sink_Notify,
 };
 
-static HRESULT video_renderer_create_mixer(IMFAttributes *attributes, IMFTransform **out)
+static HRESULT video_renderer_create_mixer(struct video_renderer *renderer, IMFAttributes *attributes,
+        IMFTransform **out)
 {
+    IMFTopologyServiceLookupClient *lookup_client;
     unsigned int flags = 0;
     IMFActivate *activate;
     CLSID clsid;
@@ -736,7 +747,23 @@ static HRESULT video_renderer_create_mixer(IMFAttributes *attributes, IMFTransfo
     if (FAILED(IMFAttributes_GetGUID(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID, &clsid)))
         memcpy(&clsid, &CLSID_MFVideoMixer9, sizeof(clsid));
 
-    return CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFTransform, (void **)out);
+    if (SUCCEEDED(hr = CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFTransform, (void **)out)))
+    {
+        if (SUCCEEDED(hr = IMFTransform_QueryInterface(*out, &IID_IMFTopologyServiceLookupClient,
+                (void **)&lookup_client)))
+        {
+            renderer->flags |= EVR_INIT_SERVICES;
+            if (SUCCEEDED(hr = IMFTopologyServiceLookupClient_InitServicePointers(lookup_client,
+                    &renderer->IMFTopologyServiceLookup_iface)))
+            {
+                renderer->flags |= EVR_MIXER_INITED_SERVICES;
+            }
+            renderer->flags &= ~EVR_INIT_SERVICES;
+            IMFTopologyServiceLookupClient_Release(lookup_client);
+        }
+    }
+
+    return hr;
 }
 
 static HRESULT video_renderer_create_presenter(struct video_renderer *renderer, IMFAttributes *attributes,
@@ -805,7 +832,7 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
         goto failed;
 
     /* Create mixer and presenter. */
-    if (FAILED(hr = video_renderer_create_mixer(attributes, &object->mixer)))
+    if (FAILED(hr = video_renderer_create_mixer(object, attributes, &object->mixer)))
         goto failed;
 
     if (FAILED(hr = video_renderer_create_presenter(object, attributes, &object->presenter)))
From 5ea1287e08a78e182bfca19d0d1069ca0408bb95 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 23 Jul 2020 19:29:21 -0500
Subject: [PATCH] winegstreamer: Preserve the frame rate when converting video
 formats.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 1aa564f2123..9de1b16411a 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1718,13 +1718,18 @@ static HRESULT gstdecoder_source_get_media_type(struct gstdemux_source *pin,
 
     if (!strcmp(type, "video/x-raw") && index < ARRAY_SIZE(video_formats))
     {
-        gint width, height;
+        gint width, height, fps_n, fps_d;
         GstVideoInfo info;
 
         gst_caps_unref(caps);
         gst_structure_get_int(structure, "width", &width);
         gst_structure_get_int(structure, "height", &height);
         gst_video_info_set_format(&info, video_formats[index], width, height);
+        if (gst_structure_get_fraction(structure, "framerate", &fps_n, &fps_d) && fps_n)
+        {
+            info.fps_n = fps_n;
+            info.fps_d = fps_d;
+        }
         if (!amt_from_gst_video_info(&info, mt))
             return E_OUTOFMEMORY;
         return S_OK;
From e7075780077cbbcb9d994f4a4cdbba6cc88b2d01 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 23 Jul 2020 19:29:22 -0500
Subject: [PATCH] winegstreamer: Release the IAsyncReader on disconnection.

This allows "Zero Escape: Nine Hours, Nine Persons, Nine Doors" to start.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/qedit/tests/mediadet.c   | 4 ++--
 dlls/winegstreamer/gstdemux.c | 3 +++
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/qedit/tests/mediadet.c b/dlls/qedit/tests/mediadet.c
index 9bf6c43a2af..dc83bb9a0a6 100644
--- a/dlls/qedit/tests/mediadet.c
+++ b/dlls/qedit/tests/mediadet.c
@@ -1147,9 +1147,9 @@ START_TEST(mediadet)
     test_COM_sg_enumpins();
 
     ret = DeleteFileW(test_avi_filename);
-    todo_wine ok(ret, "Failed to delete file, error %u.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
     ret = DeleteFileW(test_sound_avi_filename);
-    todo_wine ok(ret, "Failed to delete file, error %u.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 
     CoUninitialize();
 }
diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 9de1b16411a..fe5fe0e60df 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1598,6 +1598,9 @@ static void gstdemux_sink_disconnect(struct strmbase_sink *iface)
     mark_wine_thread();
 
     GST_RemoveOutputPins(filter);
+
+    IAsyncReader_Release(filter->reader);
+    filter->reader = NULL;
 }
 
 static const struct strmbase_sink_ops sink_ops =
From 7c229f647bef384441edc8e730b9436c6ffacb9a Mon Sep 17 00:00:00 2001
From: Gijs Vermeulen <gijsvrm@gmail.com>
Date: Tue, 18 Aug 2020 14:34:38 +0200
Subject: [PATCH] evr: Fix typo in video_mixer_init_dxva_videodesc()
 (Coverity).

Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 7b9949b01d2..d92bb6c1704 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -545,7 +545,7 @@ static HRESULT video_mixer_init_dxva_videodesc(IMFMediaType *media_type, DXVA2_V
 
     memset(video_desc, 0, sizeof(*video_desc));
     video_desc->SampleWidth = video_format->videoInfo.dwWidth;
-    video_desc->SampleWidth = video_format->videoInfo.dwHeight;
+    video_desc->SampleHeight = video_format->videoInfo.dwHeight;
     video_desc->Format = video_format->surfaceInfo.Format;
 
 done:
From 12f1ebdfeca06d7dbc8e7b99bf3c21a09a565162 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 28 Aug 2020 18:25:27 +1000
Subject: [PATCH] include: Add more eAVEncH264VProfile enums.

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 include/codecapi.h | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/include/codecapi.h b/include/codecapi.h
index 1d9fd7e255c..9719389b081 100644
--- a/include/codecapi.h
+++ b/include/codecapi.h
@@ -30,6 +30,14 @@ enum eAVEncH264VProfile
     eAVEncH264VProfile_High10 = 110,
     eAVEncH264VProfile_444 = 244,
     eAVEncH264VProfile_Extended = 88,
+    eAVEncH264VProfile_ScalableBase =  83,
+    eAVEncH264VProfile_ScalableHigh =  86,
+    eAVEncH264VProfile_MultiviewHigh = 118,
+    eAVEncH264VProfile_StereoHigh = 128,
+    eAVEncH264VProfile_ConstrainedBase = 256,
+    eAVEncH264VProfile_UCConstrainedHigh = 257,
+    eAVEncH264VProfile_UCScalableConstrainedBase = 258,
+    eAVEncH264VProfile_UCScalableConstrainedHigh = 259
 };
 
 enum eAVEncH264VLevel
From 0c34a2c97a9e21847eb965ef869e345be7503266 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 29 Aug 2020 12:37:36 -0500
Subject: [PATCH] winegstreamer: Fix a leak in
 gstdecoder_source_get_media_type().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index e8f65a0e6ed..2c9aafd7a6b 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1713,6 +1713,7 @@ static HRESULT gstdecoder_source_get_media_type(struct gstdemux_source *pin,
             gst_caps_unref(caps);
             return S_OK;
         }
+        FreeMediaType(mt);
     }
 
     if (!strcmp(type, "video/x-raw") && index < ARRAY_SIZE(video_formats))
From f949087624c970d3b32969d10a49640b1d4bbea5 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 4 Sep 2020 18:52:51 +0300
Subject: [PATCH] evr: Create and initialize mixer transform attributes.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 28 +++++++++++++++++++++++-----
 dlls/evr/tests/evr.c | 24 ++++++++++++++++++++++++
 2 files changed, 47 insertions(+), 5 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index d92bb6c1704..d9f86a7fc91 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -70,11 +70,9 @@ struct video_mixer
     struct output_stream output;
 
     COLORREF bkgnd_color;
-
     IDirect3DDeviceManager9 *device_manager;
-
     IMediaEventSink *event_sink;
-
+    IMFAttributes *attributes;
     CRITICAL_SECTION cs;
 };
 
@@ -246,6 +244,8 @@ static ULONG WINAPI video_mixer_inner_Release(IUnknown *iface)
         video_mixer_clear_types(mixer);
         if (mixer->device_manager)
             IDirect3DDeviceManager9_Release(mixer->device_manager);
+        if (mixer->attributes)
+            IMFAttributes_Release(mixer->attributes);
         DeleteCriticalSection(&mixer->cs);
         free(mixer);
     }
@@ -360,9 +360,17 @@ static HRESULT WINAPI video_mixer_transform_GetOutputStreamInfo(IMFTransform *if
 
 static HRESULT WINAPI video_mixer_transform_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
 {
-    FIXME("%p, %p.\n", iface, attributes);
+    struct video_mixer *mixer = impl_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, attributes);
+
+    if (!attributes)
+        return E_POINTER;
+
+    *attributes = mixer->attributes;
+    IMFAttributes_AddRef(*attributes);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_mixer_transform_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
@@ -1317,6 +1325,8 @@ HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID ri
 HRESULT evr_mixer_create(IUnknown *outer, void **out)
 {
     struct video_mixer *object;
+    MFVideoNormalizedRect rect;
+    HRESULT hr;
 
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
@@ -1335,6 +1345,14 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
     object->input_count = 1;
     video_mixer_init_input(&object->inputs[0]);
     InitializeCriticalSection(&object->cs);
+    if (FAILED(hr = MFCreateAttributes(&object->attributes, 0)))
+    {
+        IUnknown_Release(&object->IUnknown_inner);
+        return hr;
+    }
+    rect.left = rect.top = 0.0f;
+    rect.right = rect.bottom = 1.0f;
+    IMFAttributes_SetBlob(object->attributes, &VIDEO_ZOOM_RECT, (const UINT8 *)&rect, sizeof(rect));
 
     *out = &object->IUnknown_inner;
 
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 6a5d80df416..ba97eba53d1 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -419,6 +419,7 @@ static void test_default_mixer(void)
     DWORD input_count, output_count;
     IMFVideoProcessor *processor;
     IMFVideoDeviceID *deviceid;
+    MFVideoNormalizedRect rect;
     DWORD input_id, output_id;
     IMFTransform *transform;
     DXVA2_ValueRange range;
@@ -508,6 +509,29 @@ todo_wine
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoDeviceID, (void **)&deviceid);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFTransform_GetAttributes(transform, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_GetAttributes(transform, &attributes);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_GetAttributes(transform, &attributes2);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(attributes == attributes2, "Unexpected attributes instance.\n");
+    IMFAttributes_Release(attributes2);
+
+    hr = IMFAttributes_GetCount(attributes, &count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(count == 1, "Unexpected attribute count %u.\n", count);
+
+    memset(&rect, 0, sizeof(rect));
+    hr = IMFAttributes_GetBlob(attributes, &VIDEO_ZOOM_RECT, (UINT8 *)&rect, sizeof(rect), NULL);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(rect.left == 0.0f && rect.top == 0.0f && rect.right == 1.0f && rect.bottom == 1.0f,
+            "Unexpected zoom rect (%f, %f) - (%f, %f).\n", rect.left, rect.top, rect.right, rect.bottom);
+
+    IMFAttributes_Release(attributes);
+
     hr = IMFVideoDeviceID_GetDeviceID(deviceid, NULL);
     ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
From c58bb881a08a7abd175466f648ac9c9f4e09e4cd Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 2 Sep 2020 14:25:58 -0500
Subject: [PATCH] mfplat: Remove fallback media source.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/main.c         | 207 +------------------------------------
 dlls/mfplat/tests/mfplat.c | 106 +++++++++++--------
 2 files changed, 64 insertions(+), 249 deletions(-)

diff --git a/dlls/mfplat/main.c b/dlls/mfplat/main.c
index 6cd409d63b7..ea1b1770e15 100644
--- a/dlls/mfplat/main.c
+++ b/dlls/mfplat/main.c
@@ -5679,188 +5679,6 @@ HRESULT WINAPI MFGetPluginControl(IMFPluginControl **ret)
     return S_OK;
 }
 
-typedef struct _mfsource
-{
-    IMFMediaSource IMFMediaSource_iface;
-    LONG ref;
-} mfsource;
-
-static inline mfsource *impl_from_IMFMediaSource(IMFMediaSource *iface)
-{
-    return CONTAINING_RECORD(iface, mfsource, IMFMediaSource_iface);
-}
-
-static HRESULT WINAPI mfsource_QueryInterface(IMFMediaSource *iface, REFIID riid, void **out)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-
-    TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), out);
-
-    if (IsEqualIID(riid, &IID_IMFMediaSource) ||
-        IsEqualIID(riid, &IID_IMFMediaEventGenerator) ||
-        IsEqualIID(riid, &IID_IUnknown))
-    {
-        *out = &This->IMFMediaSource_iface;
-    }
-    else
-    {
-        FIXME("(%s, %p)\n", debugstr_guid(riid), out);
-        *out = NULL;
-        return E_NOINTERFACE;
-    }
-
-    IUnknown_AddRef((IUnknown*)*out);
-    return S_OK;
-}
-
-static ULONG WINAPI mfsource_AddRef(IMFMediaSource *iface)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-    ULONG ref = InterlockedIncrement(&This->ref);
-
-    TRACE("(%p) ref=%u\n", This, ref);
-
-    return ref;
-}
-
-static ULONG WINAPI mfsource_Release(IMFMediaSource *iface)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-    ULONG ref = InterlockedDecrement(&This->ref);
-
-    TRACE("(%p) ref=%u\n", This, ref);
-
-    if (!ref)
-    {
-        HeapFree(GetProcessHeap(), 0, This);
-    }
-
-    return ref;
-}
-
-static HRESULT WINAPI mfsource_GetEvent(IMFMediaSource *iface, DWORD flags, IMFMediaEvent **event)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-
-    FIXME("(%p)->(%#x, %p)\n", This, flags, event);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI mfsource_BeginGetEvent(IMFMediaSource *iface, IMFAsyncCallback *callback, IUnknown *state)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-
-    FIXME("(%p)->(%p, %p)\n", This, callback, state);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI mfsource_EndGetEvent(IMFMediaSource *iface, IMFAsyncResult *result, IMFMediaEvent **event)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-
-    FIXME("(%p)->(%p, %p)\n", This, result, event);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI mfsource_QueueEvent(IMFMediaSource *iface, MediaEventType event_type, REFGUID ext_type,
-        HRESULT hr, const PROPVARIANT *value)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-
-    FIXME("(%p)->(%d, %s, %#x, %p)\n", This, event_type, debugstr_guid(ext_type), hr, value);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI mfsource_GetCharacteristics(IMFMediaSource *iface, DWORD *characteristics)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-
-    FIXME("(%p)->(%p): stub\n", This, characteristics);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI mfsource_CreatePresentationDescriptor(IMFMediaSource *iface, IMFPresentationDescriptor **descriptor)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-    IMFStreamDescriptor *sd;
-    IMFMediaType *mediatype;
-    HRESULT hr;
-
-    FIXME("(%p)->(%p): stub\n", This, descriptor);
-
-    if (FAILED(hr = MFCreateMediaType(&mediatype)))
-        return hr;
-
-    hr = MFCreateStreamDescriptor(0, 1, &mediatype, &sd);
-    IMFMediaType_Release(mediatype);
-    if (FAILED(hr))
-        return hr;
-
-    hr = MFCreatePresentationDescriptor(1, &sd, descriptor);
-    IMFStreamDescriptor_Release(sd);
-
-    return hr;
-}
-
-static HRESULT WINAPI mfsource_Start(IMFMediaSource *iface, IMFPresentationDescriptor *descriptor,
-                                     const GUID *time_format, const PROPVARIANT *start_position)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-
-    FIXME("(%p)->(%p, %p, %p): stub\n", This, descriptor, time_format, start_position);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI mfsource_Stop(IMFMediaSource *iface)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-
-    FIXME("(%p): stub\n", This);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI mfsource_Pause(IMFMediaSource *iface)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-
-    FIXME("(%p): stub\n", This);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI mfsource_Shutdown(IMFMediaSource *iface)
-{
-    mfsource *This = impl_from_IMFMediaSource(iface);
-
-    FIXME("(%p): stub\n", This);
-
-    return S_OK;
-}
-
-static const IMFMediaSourceVtbl mfsourcevtbl =
-{
-    mfsource_QueryInterface,
-    mfsource_AddRef,
-    mfsource_Release,
-    mfsource_GetEvent,
-    mfsource_BeginGetEvent,
-    mfsource_EndGetEvent,
-    mfsource_QueueEvent,
-    mfsource_GetCharacteristics,
-    mfsource_CreatePresentationDescriptor,
-    mfsource_Start,
-    mfsource_Stop,
-    mfsource_Pause,
-    mfsource_Shutdown,
-};
-
 enum resolved_object_origin
 {
     OBJECT_FROM_BYTESTREAM,
@@ -6505,7 +6323,7 @@ static HRESULT WINAPI source_resolver_CreateObjectFromByteStream(IMFSourceResolv
         return E_POINTER;
 
     if (FAILED(hr = resolver_get_bytestream_handler(stream, url, flags, &handler)))
-        goto fallback;
+        return MF_E_UNSUPPORTED_BYTESTREAM_TYPE;
 
     hr = RtwqCreateAsyncResult((IUnknown *)handler, NULL, NULL, &result);
     IMFByteStreamHandler_Release(handler);
@@ -6528,28 +6346,7 @@ static HRESULT WINAPI source_resolver_CreateObjectFromByteStream(IMFSourceResolv
     hr = resolver_end_create_object(resolver, OBJECT_FROM_BYTESTREAM, result, obj_type, object);
     IRtwqAsyncResult_Release(result);
 
-    /* TODO: following stub is left intentionally until real source plugins are implemented.  */
-    if (SUCCEEDED(hr))
-        return hr;
-
-fallback:
-    if (flags & MF_RESOLUTION_MEDIASOURCE)
-    {
-        mfsource *new_object;
-
-        new_object = HeapAlloc( GetProcessHeap(), 0, sizeof(*new_object) );
-        if (!new_object)
-            return E_OUTOFMEMORY;
-
-        new_object->IMFMediaSource_iface.lpVtbl = &mfsourcevtbl;
-        new_object->ref = 1;
-
-        *object = (IUnknown *)&new_object->IMFMediaSource_iface;
-        *obj_type = MF_OBJECT_MEDIASOURCE;
-        return S_OK;
-    }
-
-    return E_NOTIMPL;
+    return hr;
 }
 
 static HRESULT WINAPI source_resolver_BeginCreateObjectFromURL(IMFSourceResolver *iface, const WCHAR *url,
diff --git a/dlls/mfplat/tests/mfplat.c b/dlls/mfplat/tests/mfplat.c
index 01749dd9ef8..fa90f1e4bac 100644
--- a/dlls/mfplat/tests/mfplat.c
+++ b/dlls/mfplat/tests/mfplat.c
@@ -382,12 +382,16 @@ static HRESULT WINAPI test_create_from_file_handler_callback_Invoke(IMFAsyncCall
     handler = (IMFSchemeHandler *)IMFAsyncResult_GetStateNoAddRef(result);
 
     hr = IMFSchemeHandler_EndCreateObject(handler, result, &obj_type, &object);
+todo_wine
     ok(hr == S_OK, "Failed to create an object, hr %#x.\n", hr);
 
-    hr = IMFAsyncResult_GetObject(result, &object2);
-    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+    {
+        hr = IMFAsyncResult_GetObject(result, &object2);
+        ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
-    IUnknown_Release(object);
+        IUnknown_Release(object);
+    }
 
     SetEvent(callback->event);
 
@@ -502,13 +506,43 @@ static void test_source_resolver(void)
 
     hr = IMFSourceResolver_CreateObjectFromByteStream(resolver, stream, NULL, MF_RESOLUTION_MEDIASOURCE, NULL,
             &obj_type, (IUnknown **)&mediasource);
-    todo_wine ok(hr == MF_E_UNSUPPORTED_BYTESTREAM_TYPE, "got 0x%08x\n", hr);
+    ok(hr == MF_E_UNSUPPORTED_BYTESTREAM_TYPE, "got 0x%08x\n", hr);
     if (hr == S_OK) IMFMediaSource_Release(mediasource);
 
     hr = IMFSourceResolver_CreateObjectFromByteStream(resolver, stream, NULL, MF_RESOLUTION_BYTESTREAM, NULL,
             &obj_type, (IUnknown **)&mediasource);
-    todo_wine ok(hr == MF_E_UNSUPPORTED_BYTESTREAM_TYPE, "got 0x%08x\n", hr);
+    ok(hr == MF_E_UNSUPPORTED_BYTESTREAM_TYPE, "got 0x%08x\n", hr);
+
+    IMFByteStream_Release(stream);
+
+    /* Create from URL. */
+    callback.event = CreateEventA(NULL, FALSE, FALSE, NULL);
+
+    hr = IMFSourceResolver_CreateObjectFromURL(resolver, L"nonexisting.mp4", MF_RESOLUTION_BYTESTREAM, NULL, &obj_type,
+            (IUnknown **)&stream);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), "Unexpected hr %#x.\n", hr);
+
+    hr = IMFSourceResolver_CreateObjectFromURL(resolver, filename, MF_RESOLUTION_BYTESTREAM, NULL, &obj_type,
+            (IUnknown **)&stream);
+    ok(hr == S_OK, "Failed to resolve url, hr %#x.\n", hr);
+    IMFByteStream_Release(stream);
+
+    hr = IMFSourceResolver_BeginCreateObjectFromURL(resolver, filename, MF_RESOLUTION_BYTESTREAM, NULL,
+            &cancel_cookie, &callback.IMFAsyncCallback_iface, (IUnknown *)resolver);
+    ok(hr == S_OK, "Create request failed, hr %#x.\n", hr);
+    ok(cancel_cookie != NULL, "Unexpected cancel object.\n");
+    IUnknown_Release(cancel_cookie);
+
+    if (SUCCEEDED(hr))
+        WaitForSingleObject(callback.event, INFINITE);
+
+    /* With explicit scheme. */
+    lstrcpyW(pathW, fileschemeW);
+    lstrcatW(pathW, filename);
 
+    hr = IMFSourceResolver_CreateObjectFromURL(resolver, pathW, MF_RESOLUTION_BYTESTREAM, NULL, &obj_type,
+            (IUnknown **)&stream);
+    ok(hr == S_OK, "Failed to resolve url, hr %#x.\n", hr);
     IMFByteStream_Release(stream);
 
     /* We have to create a new bytestream here, because all following
@@ -522,14 +556,31 @@ static void test_source_resolver(void)
     ok(hr == S_OK, "Failed to set string value, hr %#x.\n", hr);
     IMFAttributes_Release(attributes);
 
+    /* Start of gstreamer dependent tests */
+
     hr = IMFSourceResolver_CreateObjectFromByteStream(resolver, stream, NULL, MF_RESOLUTION_MEDIASOURCE, NULL,
             &obj_type, (IUnknown **)&mediasource);
-    ok(hr == S_OK, "got 0x%08x\n", hr);
+    if (strcmp(winetest_platform, "wine"))
+        ok(hr == S_OK, "got 0x%08x\n", hr);
+    if (FAILED(hr))
+    {
+        IMFByteStream_Release(stream);
+        IMFSourceResolver_Release(resolver);
+
+        hr = MFShutdown();
+        ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
+
+        DeleteFileW(filename);
+        return;
+    }
     ok(mediasource != NULL, "got %p\n", mediasource);
     ok(obj_type == MF_OBJECT_MEDIASOURCE, "got %d\n", obj_type);
 
     hr = IMFMediaSource_CreatePresentationDescriptor(mediasource, &descriptor);
+todo_wine
     ok(hr == S_OK, "Failed to get presentation descriptor, hr %#x.\n", hr);
+    if (FAILED(hr))
+        goto skip_source_tests;
     ok(descriptor != NULL, "got %p\n", descriptor);
 
     hr = IMFPresentationDescriptor_GetStreamDescriptorByIndex(descriptor, 0, &selected, &sd);
@@ -540,10 +591,7 @@ static void test_source_resolver(void)
     IMFStreamDescriptor_Release(sd);
 
     hr = IMFMediaTypeHandler_GetMajorType(handler, &guid);
-todo_wine
     ok(hr == S_OK, "Failed to get stream major type, hr %#x.\n", hr);
-    if (FAILED(hr))
-        goto skip_source_tests;
 
     /* Check major/minor type for the test media. */
     ok(IsEqualGUID(&guid, &MFMediaType_Video), "Unexpected major type %s.\n", debugstr_guid(&guid));
@@ -624,6 +672,7 @@ todo_wine
     get_event((IMFMediaEventGenerator *)mediasource, MEEndOfPresentation, NULL);
 
     IMFMediaTypeHandler_Release(handler);
+    IMFPresentationDescriptor_Release(descriptor);
 
     hr = IMFMediaSource_Shutdown(mediasource);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
@@ -633,42 +682,9 @@ todo_wine
 
 skip_source_tests:
 
-    IMFPresentationDescriptor_Release(descriptor);
     IMFMediaSource_Release(mediasource);
     IMFByteStream_Release(stream);
 
-    /* Create from URL. */
-    callback.event = CreateEventA(NULL, FALSE, FALSE, NULL);
-
-    hr = IMFSourceResolver_CreateObjectFromURL(resolver, L"nonexisting.mp4", MF_RESOLUTION_BYTESTREAM, NULL, &obj_type,
-            (IUnknown **)&stream);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), "Unexpected hr %#x.\n", hr);
-
-    hr = IMFSourceResolver_CreateObjectFromURL(resolver, filename, MF_RESOLUTION_BYTESTREAM, NULL, &obj_type,
-            (IUnknown **)&stream);
-    ok(hr == S_OK, "Failed to resolve url, hr %#x.\n", hr);
-    IMFByteStream_Release(stream);
-
-    hr = IMFSourceResolver_BeginCreateObjectFromURL(resolver, filename, MF_RESOLUTION_BYTESTREAM, NULL,
-            &cancel_cookie, &callback.IMFAsyncCallback_iface, (IUnknown *)resolver);
-    ok(hr == S_OK, "Create request failed, hr %#x.\n", hr);
-    ok(cancel_cookie != NULL, "Unexpected cancel object.\n");
-    IUnknown_Release(cancel_cookie);
-
-    if (SUCCEEDED(hr))
-        WaitForSingleObject(callback.event, INFINITE);
-
-    /* With explicit scheme. */
-    lstrcpyW(pathW, fileschemeW);
-    lstrcatW(pathW, filename);
-
-    hr = IMFSourceResolver_CreateObjectFromURL(resolver, pathW, MF_RESOLUTION_BYTESTREAM, NULL, &obj_type,
-            (IUnknown **)&stream);
-    ok(hr == S_OK, "Failed to resolve url, hr %#x.\n", hr);
-    IMFByteStream_Release(stream);
-
-    IMFSourceResolver_Release(resolver);
-
     /* Create directly through scheme handler. */
     hr = CoInitialize(NULL);
     ok(SUCCEEDED(hr), "Failed to initialize, hr %#x.\n", hr);
@@ -693,12 +709,14 @@ todo_wine
     if (do_uninit)
         CoUninitialize();
 
+    CloseHandle(callback.event);
+
+    IMFSourceResolver_Release(resolver);
+
     hr = MFShutdown();
     ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     DeleteFileW(filename);
-
-    CloseHandle(callback.event);
 }
 
 static void init_functions(void)
From a6be76bb9cd00614c565c2f1b69d6733e38414db Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 2 Sep 2020 15:05:02 -0500
Subject: [PATCH] winegstreamer: Add stub bytestream handler.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/main.c                           |   6 +
 dlls/winegstreamer/Makefile.in               |   1 +
 dlls/winegstreamer/gst_private.h             |   2 +
 dlls/winegstreamer/media_source.c            | 474 +++++++++++++++++++
 dlls/winegstreamer/mfplat.c                  |   3 +
 dlls/winegstreamer/winegstreamer_classes.idl |   7 +
 6 files changed, 493 insertions(+)
 create mode 100644 dlls/winegstreamer/media_source.c

diff --git a/dlls/mfplat/main.c b/dlls/mfplat/main.c
index ea1b1770e15..a6ff97ae04a 100644
--- a/dlls/mfplat/main.c
+++ b/dlls/mfplat/main.c
@@ -6057,6 +6057,12 @@ static HRESULT resolver_get_bytestream_handler(IMFByteStream *stream, const WCHA
             break;
     }
 
+    if (FAILED(hr))
+    {
+        static const GUID CLSID_GStreamerByteStreamHandler = {0x317df618, 0x5e5a, 0x468a, {0x9f, 0x15, 0xd8, 0x27, 0xa9, 0xa0, 0x81, 0x62}};
+        hr = CoCreateInstance(&CLSID_GStreamerByteStreamHandler, NULL, CLSCTX_INPROC_SERVER, &IID_IMFByteStreamHandler, (void **)handler);
+    }
+
     CoTaskMemFree(mimeW);
     return hr;
 }
diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index 337c1086e6b..e578d194f7f 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -10,6 +10,7 @@ C_SRCS = \
 	gst_cbs.c \
 	gstdemux.c \
 	main.c \
+	media_source.c \
 	mediatype.c \
 	mfplat.c \
 	pin.c \
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index e6fb841fc87..ef07d3591e7 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -54,4 +54,6 @@ void start_dispatch_thread(void) DECLSPEC_HIDDEN;
 
 extern HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj) DECLSPEC_HIDDEN;
 
+HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj) DECLSPEC_HIDDEN;
+
 #endif /* __GST_PRIVATE_INCLUDED__ */
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
new file mode 100644
index 00000000000..2bde4efea22
--- /dev/null
+++ b/dlls/winegstreamer/media_source.c
@@ -0,0 +1,474 @@
+/* GStreamer Media Source
+ *
+ * Copyright 2020 Derek Lesho
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include <stdarg.h>
+
+#define COBJMACROS
+#define NONAMELESSUNION
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfidl.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+#include "wine/list.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+struct winegstreamer_stream_handler_result
+{
+    struct list entry;
+    IMFAsyncResult *result;
+    MF_OBJECT_TYPE obj_type;
+    IUnknown *object;
+};
+
+struct winegstreamer_stream_handler
+{
+    IMFByteStreamHandler IMFByteStreamHandler_iface;
+    IMFAsyncCallback IMFAsyncCallback_iface;
+    LONG refcount;
+    struct list results;
+    CRITICAL_SECTION cs;
+};
+
+static struct winegstreamer_stream_handler *impl_from_IMFByteStreamHandler(IMFByteStreamHandler *iface)
+{
+    return CONTAINING_RECORD(iface, struct winegstreamer_stream_handler, IMFByteStreamHandler_iface);
+}
+
+static struct winegstreamer_stream_handler *impl_from_IMFAsyncCallback(IMFAsyncCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct winegstreamer_stream_handler, IMFAsyncCallback_iface);
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_QueryInterface(IMFByteStreamHandler *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IMFByteStreamHandler) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFByteStreamHandler_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI winegstreamer_stream_handler_AddRef(IMFByteStreamHandler *iface)
+{
+    struct winegstreamer_stream_handler *handler = impl_from_IMFByteStreamHandler(iface);
+    ULONG refcount = InterlockedIncrement(&handler->refcount);
+
+    TRACE("%p, refcount %u.\n", handler, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI winegstreamer_stream_handler_Release(IMFByteStreamHandler *iface)
+{
+    struct winegstreamer_stream_handler *handler = impl_from_IMFByteStreamHandler(iface);
+    ULONG refcount = InterlockedDecrement(&handler->refcount);
+    struct winegstreamer_stream_handler_result *result, *next;
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        LIST_FOR_EACH_ENTRY_SAFE(result, next, &handler->results, struct winegstreamer_stream_handler_result, entry)
+        {
+            list_remove(&result->entry);
+            IMFAsyncResult_Release(result->result);
+            if (result->object)
+                IUnknown_Release(result->object);
+            heap_free(result);
+        }
+        DeleteCriticalSection(&handler->cs);
+        heap_free(handler);
+    }
+
+    return refcount;
+}
+
+struct create_object_context
+{
+    IUnknown IUnknown_iface;
+    LONG refcount;
+
+    IPropertyStore *props;
+    IMFByteStream *stream;
+    WCHAR *url;
+    DWORD flags;
+};
+
+static struct create_object_context *impl_from_IUnknown(IUnknown *iface)
+{
+    return CONTAINING_RECORD(iface, struct create_object_context, IUnknown_iface);
+}
+
+static HRESULT WINAPI create_object_context_QueryInterface(IUnknown *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IUnknown_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI create_object_context_AddRef(IUnknown *iface)
+{
+    struct create_object_context *context = impl_from_IUnknown(iface);
+    ULONG refcount = InterlockedIncrement(&context->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI create_object_context_Release(IUnknown *iface)
+{
+    struct create_object_context *context = impl_from_IUnknown(iface);
+    ULONG refcount = InterlockedDecrement(&context->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        if (context->props)
+            IPropertyStore_Release(context->props);
+        if (context->stream)
+            IMFByteStream_Release(context->stream);
+        if (context->url)
+            heap_free(context->url);
+        heap_free(context);
+    }
+
+    return refcount;
+}
+
+static const IUnknownVtbl create_object_context_vtbl =
+{
+    create_object_context_QueryInterface,
+    create_object_context_AddRef,
+    create_object_context_Release,
+};
+
+static WCHAR *heap_strdupW(const WCHAR *str)
+{
+    WCHAR *ret = NULL;
+
+    if (str)
+    {
+        unsigned int size;
+
+        size = (lstrlenW(str) + 1) * sizeof(WCHAR);
+        ret = heap_alloc(size);
+        if (ret)
+            memcpy(ret, str, size);
+    }
+
+    return ret;
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_BeginCreateObject(IMFByteStreamHandler *iface, IMFByteStream *stream, const WCHAR *url, DWORD flags,
+        IPropertyStore *props, IUnknown **cancel_cookie, IMFAsyncCallback *callback, IUnknown *state)
+{
+    struct winegstreamer_stream_handler *this = impl_from_IMFByteStreamHandler(iface);
+    struct create_object_context *context;
+    IMFAsyncResult *caller, *item;
+    HRESULT hr;
+
+    TRACE("%p, %s, %#x, %p, %p, %p, %p.\n", iface, debugstr_w(url), flags, props, cancel_cookie, callback, state);
+
+    if (cancel_cookie)
+        *cancel_cookie = NULL;
+
+    if (FAILED(hr = MFCreateAsyncResult(NULL, callback, state, &caller)))
+        return hr;
+
+    context = heap_alloc(sizeof(*context));
+    if (!context)
+    {
+        IMFAsyncResult_Release(caller);
+        return E_OUTOFMEMORY;
+    }
+
+    context->IUnknown_iface.lpVtbl = &create_object_context_vtbl;
+    context->refcount = 1;
+    context->props = props;
+    if (context->props)
+        IPropertyStore_AddRef(context->props);
+    context->flags = flags;
+    context->stream = stream;
+    if (context->stream)
+        IMFByteStream_AddRef(context->stream);
+    if (url)
+        context->url = heap_strdupW(url);
+    if (!context->stream)
+    {
+        IMFAsyncResult_Release(caller);
+        IUnknown_Release(&context->IUnknown_iface);
+        return E_OUTOFMEMORY;
+    }
+
+    hr = MFCreateAsyncResult(&context->IUnknown_iface, &this->IMFAsyncCallback_iface, (IUnknown *)caller, &item);
+    IUnknown_Release(&context->IUnknown_iface);
+    if (SUCCEEDED(hr))
+    {
+        if (SUCCEEDED(hr = MFPutWorkItemEx(MFASYNC_CALLBACK_QUEUE_IO, item)))
+        {
+            if (cancel_cookie)
+            {
+                *cancel_cookie = (IUnknown *)caller;
+                IUnknown_AddRef(*cancel_cookie);
+            }
+        }
+
+        IMFAsyncResult_Release(item);
+    }
+    IMFAsyncResult_Release(caller);
+
+    return hr;
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_EndCreateObject(IMFByteStreamHandler *iface, IMFAsyncResult *result,
+        MF_OBJECT_TYPE *obj_type, IUnknown **object)
+{
+    struct winegstreamer_stream_handler *this = impl_from_IMFByteStreamHandler(iface);
+    struct winegstreamer_stream_handler_result *found = NULL, *cur;
+    HRESULT hr;
+
+    TRACE("%p, %p, %p, %p.\n", iface, result, obj_type, object);
+
+    EnterCriticalSection(&this->cs);
+
+    LIST_FOR_EACH_ENTRY(cur, &this->results, struct winegstreamer_stream_handler_result, entry)
+    {
+        if (result == cur->result)
+        {
+            list_remove(&cur->entry);
+            found = cur;
+            break;
+        }
+    }
+
+    LeaveCriticalSection(&this->cs);
+
+    if (found)
+    {
+        *obj_type = found->obj_type;
+        *object = found->object;
+        hr = IMFAsyncResult_GetStatus(found->result);
+        IMFAsyncResult_Release(found->result);
+        heap_free(found);
+    }
+    else
+    {
+        *obj_type = MF_OBJECT_INVALID;
+        *object = NULL;
+        hr = MF_E_UNEXPECTED;
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_CancelObjectCreation(IMFByteStreamHandler *iface, IUnknown *cancel_cookie)
+{
+    struct winegstreamer_stream_handler *this = impl_from_IMFByteStreamHandler(iface);
+    struct winegstreamer_stream_handler_result *found = NULL, *cur;
+
+    TRACE("%p, %p.\n", iface, cancel_cookie);
+
+    EnterCriticalSection(&this->cs);
+
+    LIST_FOR_EACH_ENTRY(cur, &this->results, struct winegstreamer_stream_handler_result, entry)
+    {
+        if (cancel_cookie == (IUnknown *)cur->result)
+        {
+            list_remove(&cur->entry);
+            found = cur;
+            break;
+        }
+    }
+
+    LeaveCriticalSection(&this->cs);
+
+    if (found)
+    {
+        IMFAsyncResult_Release(found->result);
+        if (found->object)
+            IUnknown_Release(found->object);
+        heap_free(found);
+    }
+
+    return found ? S_OK : MF_E_UNEXPECTED;
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_GetMaxNumberOfBytesRequiredForResolution(IMFByteStreamHandler *iface, QWORD *bytes)
+{
+    FIXME("stub (%p %p)\n", iface, bytes);
+    return E_NOTIMPL;
+}
+
+static const IMFByteStreamHandlerVtbl winegstreamer_stream_handler_vtbl =
+{
+    winegstreamer_stream_handler_QueryInterface,
+    winegstreamer_stream_handler_AddRef,
+    winegstreamer_stream_handler_Release,
+    winegstreamer_stream_handler_BeginCreateObject,
+    winegstreamer_stream_handler_EndCreateObject,
+    winegstreamer_stream_handler_CancelObjectCreation,
+    winegstreamer_stream_handler_GetMaxNumberOfBytesRequiredForResolution,
+};
+
+static HRESULT WINAPI winegstreamer_stream_handler_callback_QueryInterface(IMFAsyncCallback *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(riid, &IID_IMFAsyncCallback) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFAsyncCallback_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI winegstreamer_stream_handler_callback_AddRef(IMFAsyncCallback *iface)
+{
+    struct winegstreamer_stream_handler *handler = impl_from_IMFAsyncCallback(iface);
+    return IMFByteStreamHandler_AddRef(&handler->IMFByteStreamHandler_iface);
+}
+
+static ULONG WINAPI winegstreamer_stream_handler_callback_Release(IMFAsyncCallback *iface)
+{
+    struct winegstreamer_stream_handler *handler = impl_from_IMFAsyncCallback(iface);
+    return IMFByteStreamHandler_Release(&handler->IMFByteStreamHandler_iface);
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_callback_GetParameters(IMFAsyncCallback *iface, DWORD *flags, DWORD *queue)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT winegstreamer_stream_handler_create_object(struct winegstreamer_stream_handler *This, WCHAR *url, IMFByteStream *stream, DWORD flags,
+                                            IPropertyStore *props, IUnknown **out_object, MF_OBJECT_TYPE *out_obj_type)
+{
+    FIXME("(%p %s %p %u %p %p %p)\n", This, debugstr_w(url), stream, flags, props, out_object, out_obj_type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_callback_Invoke(IMFAsyncCallback *iface, IMFAsyncResult *result)
+{
+    struct winegstreamer_stream_handler *handler = impl_from_IMFAsyncCallback(iface);
+    struct winegstreamer_stream_handler_result *handler_result;
+    MF_OBJECT_TYPE obj_type = MF_OBJECT_INVALID;
+    IUnknown *object = NULL, *context_object;
+    struct create_object_context *context;
+    IMFAsyncResult *caller;
+    HRESULT hr;
+
+    caller = (IMFAsyncResult *)IMFAsyncResult_GetStateNoAddRef(result);
+
+    if (FAILED(hr = IMFAsyncResult_GetObject(result, &context_object)))
+    {
+        WARN("Expected context set for callee result.\n");
+        return hr;
+    }
+
+    context = impl_from_IUnknown(context_object);
+
+    hr = winegstreamer_stream_handler_create_object(handler, context->url, context->stream, context->flags, context->props, &object, &obj_type);
+
+    handler_result = heap_alloc(sizeof(*handler_result));
+    if (handler_result)
+    {
+        handler_result->result = caller;
+        IMFAsyncResult_AddRef(handler_result->result);
+        handler_result->obj_type = obj_type;
+        handler_result->object = object;
+
+        EnterCriticalSection(&handler->cs);
+        list_add_tail(&handler->results, &handler_result->entry);
+        LeaveCriticalSection(&handler->cs);
+    }
+    else
+    {
+        if (object)
+            IUnknown_Release(object);
+        hr = E_OUTOFMEMORY;
+    }
+
+    IUnknown_Release(&context->IUnknown_iface);
+
+    IMFAsyncResult_SetStatus(caller, hr);
+    MFInvokeCallback(caller);
+
+    return S_OK;
+}
+
+static const IMFAsyncCallbackVtbl winegstreamer_stream_handler_callback_vtbl =
+{
+    winegstreamer_stream_handler_callback_QueryInterface,
+    winegstreamer_stream_handler_callback_AddRef,
+    winegstreamer_stream_handler_callback_Release,
+    winegstreamer_stream_handler_callback_GetParameters,
+    winegstreamer_stream_handler_callback_Invoke,
+};
+
+HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj)
+{
+    struct winegstreamer_stream_handler *this;
+    HRESULT hr;
+
+    TRACE("%s, %p.\n", debugstr_guid(riid), obj);
+
+    this = heap_alloc_zero(sizeof(*this));
+    if (!this)
+        return E_OUTOFMEMORY;
+
+    list_init(&this->results);
+    InitializeCriticalSection(&this->cs);
+
+    this->IMFByteStreamHandler_iface.lpVtbl = &winegstreamer_stream_handler_vtbl;
+    this->IMFAsyncCallback_iface.lpVtbl = &winegstreamer_stream_handler_callback_vtbl;
+    this->refcount = 1;
+
+    hr = IMFByteStreamHandler_QueryInterface(&this->IMFByteStreamHandler_iface, riid, obj);
+    IMFByteStreamHandler_Release(&this->IMFByteStreamHandler_iface);
+
+    return hr;
+}
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 55b9b088765..c996f06211e 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -398,6 +398,8 @@ static HRESULT video_processor_create(REFIID riid, void **ret)
     return hr;
 }
 
+static const GUID CLSID_GStreamerByteStreamHandler = {0x317df618, 0x5e5a, 0x468a, {0x9f, 0x15, 0xd8, 0x27, 0xa9, 0xa0, 0x81, 0x62}};
+
 static const struct class_object
 {
     const GUID *clsid;
@@ -406,6 +408,7 @@ static const struct class_object
 class_objects[] =
 {
     { &CLSID_VideoProcessorMFT, &video_processor_create },
+    { &CLSID_GStreamerByteStreamHandler, &winegstreamer_stream_handler_create },
 };
 
 HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj)
diff --git a/dlls/winegstreamer/winegstreamer_classes.idl b/dlls/winegstreamer/winegstreamer_classes.idl
index fa0e1784057..1dc4ba9a10b 100644
--- a/dlls/winegstreamer/winegstreamer_classes.idl
+++ b/dlls/winegstreamer/winegstreamer_classes.idl
@@ -54,3 +54,10 @@ coclass Gstreamer_Splitter {}
     uuid(88753b26-5b24-49bd-b2e7-0c445c78c982)
 ]
 coclass VideoProcessorMFT {}
+
+[
+    helpstring("Generic Decodebin Byte Stream Handler"),
+    threading(both),
+    uuid(317df618-5e5a-468a-9f15-d827a9a08162)
+]
+coclass GStreamerByteStreamHandler {}
From 784ae1e9bd4129a4f0967c656c51e6c9cc3855f5 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 2 Sep 2020 14:26:00 -0500
Subject: [PATCH] winegstreamer: Add stub media source.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/tests/mfplat.c        |   1 -
 dlls/winegstreamer/media_source.c | 197 +++++++++++++++++++++++++++++-
 2 files changed, 195 insertions(+), 3 deletions(-)

diff --git a/dlls/mfplat/tests/mfplat.c b/dlls/mfplat/tests/mfplat.c
index fa90f1e4bac..94fdf9e6f39 100644
--- a/dlls/mfplat/tests/mfplat.c
+++ b/dlls/mfplat/tests/mfplat.c
@@ -382,7 +382,6 @@ static HRESULT WINAPI test_create_from_file_handler_callback_Invoke(IMFAsyncCall
     handler = (IMFSchemeHandler *)IMFAsyncResult_GetStateNoAddRef(result);
 
     hr = IMFSchemeHandler_EndCreateObject(handler, result, &obj_type, &object);
-todo_wine
     ok(hr == S_OK, "Failed to create an object, hr %#x.\n", hr);
 
     if (SUCCEEDED(hr))
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 2bde4efea22..21245c718b9 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -34,6 +34,180 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+struct media_source
+{
+    IMFMediaSource IMFMediaSource_iface;
+    LONG ref;
+};
+
+static inline struct media_source *impl_from_IMFMediaSource(IMFMediaSource *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_source, IMFMediaSource_iface);
+}
+
+static HRESULT WINAPI media_source_QueryInterface(IMFMediaSource *iface, REFIID riid, void **out)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    TRACE("(%p)->(%s %p)\n", source, debugstr_guid(riid), out);
+
+    if (IsEqualIID(riid, &IID_IMFMediaSource) ||
+        IsEqualIID(riid, &IID_IMFMediaEventGenerator) ||
+        IsEqualIID(riid, &IID_IUnknown))
+    {
+        *out = &source->IMFMediaSource_iface;
+    }
+    else
+    {
+        FIXME("(%s, %p)\n", debugstr_guid(riid), out);
+        *out = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI media_source_AddRef(IMFMediaSource *iface)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+    ULONG ref = InterlockedIncrement(&source->ref);
+
+    TRACE("(%p) ref=%u\n", source, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI media_source_Release(IMFMediaSource *iface)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+    ULONG ref = InterlockedDecrement(&source->ref);
+
+    TRACE("(%p) ref=%u\n", source, ref);
+
+    if (!ref)
+    {
+        heap_free(source);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI media_source_GetEvent(IMFMediaSource *iface, DWORD flags, IMFMediaEvent **event)
+{
+    FIXME("(%p)->(%#x, %p)\n", iface, flags, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_source_BeginGetEvent(IMFMediaSource *iface, IMFAsyncCallback *callback, IUnknown *state)
+{
+    FIXME("(%p)->(%p, %p)\n", iface, callback, state);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_source_EndGetEvent(IMFMediaSource *iface, IMFAsyncResult *result, IMFMediaEvent **event)
+{
+    FIXME("(%p)->(%p, %p)\n", iface, result, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_source_QueueEvent(IMFMediaSource *iface, MediaEventType event_type, REFGUID ext_type,
+        HRESULT hr, const PROPVARIANT *value)
+{
+    FIXME("(%p)->(%d, %s, %#x, %p)\n", iface, event_type, debugstr_guid(ext_type), hr, value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_source_GetCharacteristics(IMFMediaSource *iface, DWORD *characteristics)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    FIXME("(%p)->(%p): stub\n", source, characteristics);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_source_CreatePresentationDescriptor(IMFMediaSource *iface, IMFPresentationDescriptor **descriptor)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    FIXME("(%p)->(%p): stub\n", source, descriptor);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_source_Start(IMFMediaSource *iface, IMFPresentationDescriptor *descriptor,
+                                     const GUID *time_format, const PROPVARIANT *start_position)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    FIXME("(%p)->(%p, %p, %p): stub\n", source, descriptor, time_format, start_position);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_source_Stop(IMFMediaSource *iface)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    FIXME("(%p): stub\n", source);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_source_Pause(IMFMediaSource *iface)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    FIXME("(%p): stub\n", source);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_source_Shutdown(IMFMediaSource *iface)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    FIXME("(%p): stub\n", source);
+
+    return E_NOTIMPL;
+}
+
+static const IMFMediaSourceVtbl IMFMediaSource_vtbl =
+{
+    media_source_QueryInterface,
+    media_source_AddRef,
+    media_source_Release,
+    media_source_GetEvent,
+    media_source_BeginGetEvent,
+    media_source_EndGetEvent,
+    media_source_QueueEvent,
+    media_source_GetCharacteristics,
+    media_source_CreatePresentationDescriptor,
+    media_source_Start,
+    media_source_Stop,
+    media_source_Pause,
+    media_source_Shutdown,
+};
+
+static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_source **out_media_source)
+{
+    struct media_source *object = heap_alloc_zero(sizeof(*object));
+
+    if (!object)
+        return E_OUTOFMEMORY;
+
+    object->IMFMediaSource_iface.lpVtbl = &IMFMediaSource_vtbl;
+    object->ref = 1;
+
+    *out_media_source = object;
+    return S_OK;
+}
+
 struct winegstreamer_stream_handler_result
 {
     struct list entry;
@@ -386,9 +560,28 @@ static HRESULT WINAPI winegstreamer_stream_handler_callback_GetParameters(IMFAsy
 static HRESULT winegstreamer_stream_handler_create_object(struct winegstreamer_stream_handler *This, WCHAR *url, IMFByteStream *stream, DWORD flags,
                                             IPropertyStore *props, IUnknown **out_object, MF_OBJECT_TYPE *out_obj_type)
 {
-    FIXME("(%p %s %p %u %p %p %p)\n", This, debugstr_w(url), stream, flags, props, out_object, out_obj_type);
+    TRACE("(%p %s %p %u %p %p %p)\n", This, debugstr_w(url), stream, flags, props, out_object, out_obj_type);
 
-    return E_NOTIMPL;
+    if (flags & MF_RESOLUTION_MEDIASOURCE)
+    {
+        HRESULT hr;
+        struct media_source *new_source;
+
+        if (FAILED(hr = media_source_constructor(stream, &new_source)))
+            return hr;
+
+        TRACE("->(%p)\n", new_source);
+
+        *out_object = (IUnknown*)&new_source->IMFMediaSource_iface;
+        *out_obj_type = MF_OBJECT_MEDIASOURCE;
+
+        return S_OK;
+    }
+    else
+    {
+        FIXME("flags = %08x\n", flags);
+        return E_NOTIMPL;
+    }
 }
 
 static HRESULT WINAPI winegstreamer_stream_handler_callback_Invoke(IMFAsyncCallback *iface, IMFAsyncResult *result)
From d832ebf1b0a082a41f5c8e1169d934fefb41d0f2 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 2 Sep 2020 14:26:01 -0500
Subject: [PATCH] winegstreamer: Implement source event methods.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/media_source.c | 36 ++++++++++++++++++++++++-------
 1 file changed, 28 insertions(+), 8 deletions(-)

diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 21245c718b9..cbe51fa9570 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -38,6 +38,7 @@ struct media_source
 {
     IMFMediaSource IMFMediaSource_iface;
     LONG ref;
+    IMFMediaEventQueue *event_queue;
 };
 
 static inline struct media_source *impl_from_IMFMediaSource(IMFMediaSource *iface)
@@ -87,6 +88,7 @@ static ULONG WINAPI media_source_Release(IMFMediaSource *iface)
 
     if (!ref)
     {
+        IMFMediaEventQueue_Release(source->event_queue);
         heap_free(source);
     }
 
@@ -95,31 +97,39 @@ static ULONG WINAPI media_source_Release(IMFMediaSource *iface)
 
 static HRESULT WINAPI media_source_GetEvent(IMFMediaSource *iface, DWORD flags, IMFMediaEvent **event)
 {
-    FIXME("(%p)->(%#x, %p)\n", iface, flags, event);
+    struct media_source *source = impl_from_IMFMediaSource(iface);
 
-    return E_NOTIMPL;
+    TRACE("(%p)->(%#x, %p)\n", source, flags, event);
+
+    return IMFMediaEventQueue_GetEvent(source->event_queue, flags, event);
 }
 
 static HRESULT WINAPI media_source_BeginGetEvent(IMFMediaSource *iface, IMFAsyncCallback *callback, IUnknown *state)
 {
-    FIXME("(%p)->(%p, %p)\n", iface, callback, state);
+    struct media_source *source = impl_from_IMFMediaSource(iface);
 
-    return E_NOTIMPL;
+    TRACE("(%p)->(%p, %p)\n", source, callback, state);
+
+    return IMFMediaEventQueue_BeginGetEvent(source->event_queue, callback, state);
 }
 
 static HRESULT WINAPI media_source_EndGetEvent(IMFMediaSource *iface, IMFAsyncResult *result, IMFMediaEvent **event)
 {
-    FIXME("(%p)->(%p, %p)\n", iface, result, event);
+    struct media_source *source = impl_from_IMFMediaSource(iface);
 
-    return E_NOTIMPL;
+    TRACE("(%p)->(%p, %p)\n", source, result, event);
+
+    return IMFMediaEventQueue_EndGetEvent(source->event_queue, result, event);
 }
 
 static HRESULT WINAPI media_source_QueueEvent(IMFMediaSource *iface, MediaEventType event_type, REFGUID ext_type,
         HRESULT hr, const PROPVARIANT *value)
 {
-    FIXME("(%p)->(%d, %s, %#x, %p)\n", iface, event_type, debugstr_guid(ext_type), hr, value);
+    struct media_source *source = impl_from_IMFMediaSource(iface);
 
-    return E_NOTIMPL;
+    TRACE("(%p)->(%d, %s, %#x, %p)\n", source, event_type, debugstr_guid(ext_type), hr, value);
+
+    return IMFMediaEventQueue_QueueEventParamVar(source->event_queue, event_type, ext_type, hr, value);
 }
 
 static HRESULT WINAPI media_source_GetCharacteristics(IMFMediaSource *iface, DWORD *characteristics)
@@ -197,15 +207,25 @@ static const IMFMediaSourceVtbl IMFMediaSource_vtbl =
 static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_source **out_media_source)
 {
     struct media_source *object = heap_alloc_zero(sizeof(*object));
+    HRESULT hr;
 
     if (!object)
         return E_OUTOFMEMORY;
 
+    if (FAILED(hr = MFCreateEventQueue(&object->event_queue)))
+        goto fail;
+
     object->IMFMediaSource_iface.lpVtbl = &IMFMediaSource_vtbl;
     object->ref = 1;
 
     *out_media_source = object;
     return S_OK;
+
+    fail:
+    WARN("Failed to construct MFMediaSource, hr %#x.\n", hr);
+
+    IMFMediaSource_Release(&object->IMFMediaSource_iface);
+    return hr;
 }
 
 struct winegstreamer_stream_handler_result
From e7b8911695d42ddb826c941dcd9c26da5c3312b9 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 2 Sep 2020 14:26:02 -0500
Subject: [PATCH] winegstreamer: Implement IMFMediaSource::Shutdown.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/tests/mfplat.c        |  4 ++--
 dlls/winegstreamer/media_source.c | 36 +++++++++++++++++++++++++++++--
 2 files changed, 36 insertions(+), 4 deletions(-)

diff --git a/dlls/mfplat/tests/mfplat.c b/dlls/mfplat/tests/mfplat.c
index 94fdf9e6f39..309f7b669a4 100644
--- a/dlls/mfplat/tests/mfplat.c
+++ b/dlls/mfplat/tests/mfplat.c
@@ -673,14 +673,14 @@ todo_wine
     IMFMediaTypeHandler_Release(handler);
     IMFPresentationDescriptor_Release(descriptor);
 
+skip_source_tests:
+
     hr = IMFMediaSource_Shutdown(mediasource);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaSource_CreatePresentationDescriptor(mediasource, NULL);
     ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
-skip_source_tests:
-
     IMFMediaSource_Release(mediasource);
     IMFByteStream_Release(stream);
 
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index cbe51fa9570..84ecf305d4c 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -39,6 +39,12 @@ struct media_source
     IMFMediaSource IMFMediaSource_iface;
     LONG ref;
     IMFMediaEventQueue *event_queue;
+    enum
+    {
+        SOURCE_OPENING,
+        SOURCE_STOPPED,
+        SOURCE_SHUTDOWN,
+    } state;
 };
 
 static inline struct media_source *impl_from_IMFMediaSource(IMFMediaSource *iface)
@@ -88,6 +94,7 @@ static ULONG WINAPI media_source_Release(IMFMediaSource *iface)
 
     if (!ref)
     {
+        IMFMediaSource_Shutdown(&source->IMFMediaSource_iface);
         IMFMediaEventQueue_Release(source->event_queue);
         heap_free(source);
     }
@@ -138,6 +145,9 @@ static HRESULT WINAPI media_source_GetCharacteristics(IMFMediaSource *iface, DWO
 
     FIXME("(%p)->(%p): stub\n", source, characteristics);
 
+    if (source->state == SOURCE_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
     return E_NOTIMPL;
 }
 
@@ -147,6 +157,9 @@ static HRESULT WINAPI media_source_CreatePresentationDescriptor(IMFMediaSource *
 
     FIXME("(%p)->(%p): stub\n", source, descriptor);
 
+    if (source->state == SOURCE_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
     return E_NOTIMPL;
 }
 
@@ -157,6 +170,9 @@ static HRESULT WINAPI media_source_Start(IMFMediaSource *iface, IMFPresentationD
 
     FIXME("(%p)->(%p, %p, %p): stub\n", source, descriptor, time_format, start_position);
 
+    if (source->state == SOURCE_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
     return E_NOTIMPL;
 }
 
@@ -166,6 +182,9 @@ static HRESULT WINAPI media_source_Stop(IMFMediaSource *iface)
 
     FIXME("(%p): stub\n", source);
 
+    if (source->state == SOURCE_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
     return E_NOTIMPL;
 }
 
@@ -175,6 +194,9 @@ static HRESULT WINAPI media_source_Pause(IMFMediaSource *iface)
 
     FIXME("(%p): stub\n", source);
 
+    if (source->state == SOURCE_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
     return E_NOTIMPL;
 }
 
@@ -182,9 +204,17 @@ static HRESULT WINAPI media_source_Shutdown(IMFMediaSource *iface)
 {
     struct media_source *source = impl_from_IMFMediaSource(iface);
 
-    FIXME("(%p): stub\n", source);
+    TRACE("(%p)\n", source);
 
-    return E_NOTIMPL;
+    if (source->state == SOURCE_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    source->state = SOURCE_SHUTDOWN;
+
+    if (source->event_queue)
+        IMFMediaEventQueue_Shutdown(source->event_queue);
+
+    return S_OK;
 }
 
 static const IMFMediaSourceVtbl IMFMediaSource_vtbl =
@@ -215,6 +245,8 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
     if (FAILED(hr = MFCreateEventQueue(&object->event_queue)))
         goto fail;
 
+    object->state = SOURCE_STOPPED;
+
     object->IMFMediaSource_iface.lpVtbl = &IMFMediaSource_vtbl;
     object->ref = 1;
 
From cc66d5de6ad78fff756dd254c0482773f5f005bc Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 7 Sep 2020 12:43:33 +0300
Subject: [PATCH] evr/mixer: Use same max input count symbol for
 GetStreamLimits().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index d9f86a7fc91..7e08beae353 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -284,7 +284,7 @@ static HRESULT WINAPI video_mixer_transform_GetStreamLimits(IMFTransform *iface,
     TRACE("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
 
     *input_minimum = 1;
-    *input_maximum = 16;
+    *input_maximum = MAX_MIXER_INPUT_STREAMS;
     *output_minimum = 1;
     *output_maximum = 1;
 
From c1c4856205c78a9c8c153cbec2907e8b392b9838 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 7 Sep 2020 12:43:34 +0300
Subject: [PATCH] mf/evr: Actually use custom mixer when available.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 36 ++++++++++++++++++++++--------------
 1 file changed, 22 insertions(+), 14 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 8a4aa3c350d..fe73f6a4a0c 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -734,7 +734,7 @@ static HRESULT video_renderer_create_mixer(struct video_renderer *renderer, IMFA
     CLSID clsid;
     HRESULT hr;
 
-    if (SUCCEEDED(IMFAttributes_GetUnknown(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE,
+    if (SUCCEEDED(hr = IMFAttributes_GetUnknown(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE,
             &IID_IMFActivate, (void **)&activate)))
     {
         IMFAttributes_GetUINT32(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_FLAGS, &flags);
@@ -744,23 +744,31 @@ static HRESULT video_renderer_create_mixer(struct video_renderer *renderer, IMFA
             return hr;
     }
 
-    if (FAILED(IMFAttributes_GetGUID(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID, &clsid)))
-        memcpy(&clsid, &CLSID_MFVideoMixer9, sizeof(clsid));
+    /* Activation object failed, use class activation. */
+    if (FAILED(hr))
+    {
+        if (FAILED(IMFAttributes_GetGUID(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID, &clsid)))
+            memcpy(&clsid, &CLSID_MFVideoMixer9, sizeof(clsid));
+        hr = CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFTransform, (void **)out);
+    }
 
-    if (SUCCEEDED(hr = CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFTransform, (void **)out)))
+    if (FAILED(hr))
     {
-        if (SUCCEEDED(hr = IMFTransform_QueryInterface(*out, &IID_IMFTopologyServiceLookupClient,
-                (void **)&lookup_client)))
+        WARN("Failed to create a mixer object, hr %#x.\n", hr);
+        return hr;
+    }
+
+    if (SUCCEEDED(hr = IMFTransform_QueryInterface(*out, &IID_IMFTopologyServiceLookupClient,
+            (void **)&lookup_client)))
+    {
+        renderer->flags |= EVR_INIT_SERVICES;
+        if (SUCCEEDED(hr = IMFTopologyServiceLookupClient_InitServicePointers(lookup_client,
+                &renderer->IMFTopologyServiceLookup_iface)))
         {
-            renderer->flags |= EVR_INIT_SERVICES;
-            if (SUCCEEDED(hr = IMFTopologyServiceLookupClient_InitServicePointers(lookup_client,
-                    &renderer->IMFTopologyServiceLookup_iface)))
-            {
-                renderer->flags |= EVR_MIXER_INITED_SERVICES;
-            }
-            renderer->flags &= ~EVR_INIT_SERVICES;
-            IMFTopologyServiceLookupClient_Release(lookup_client);
+            renderer->flags |= EVR_MIXER_INITED_SERVICES;
         }
+        renderer->flags &= ~EVR_INIT_SERVICES;
+        IMFTopologyServiceLookupClient_Release(lookup_client);
     }
 
     return hr;
From 629882e161846b8a8fa59a7f76b18186ac44e56d Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 7 Sep 2020 12:43:35 +0300
Subject: [PATCH] mf/evr: Implement stream sinks management functionality.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 347 ++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 334 insertions(+), 13 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index fe73f6a4a0c..86242611a47 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -32,6 +32,16 @@ enum video_renderer_flags
     EVR_PRESENTER_INITED_SERVICES = 0x8,
 };
 
+struct video_renderer;
+
+struct video_stream
+{
+    IMFStreamSink IMFStreamSink_iface;
+    LONG refcount;
+    unsigned int id;
+    struct video_renderer *parent;
+};
+
 struct video_renderer
 {
     IMFMediaSink IMFMediaSink_iface;
@@ -50,6 +60,11 @@ struct video_renderer
     IMFTransform *mixer;
     IMFVideoPresenter *presenter;
     unsigned int flags;
+
+    struct video_stream **streams;
+    size_t stream_size;
+    size_t stream_count;
+
     CRITICAL_SECTION cs;
 };
 
@@ -93,6 +108,11 @@ static struct video_renderer *impl_from_IMediaEventSink(IMediaEventSink *iface)
     return CONTAINING_RECORD(iface, struct video_renderer, IMediaEventSink_iface);
 }
 
+static struct video_stream *impl_from_IMFStreamSink(IMFStreamSink *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_stream, IMFStreamSink_iface);
+}
+
 static void video_renderer_release_services(struct video_renderer *renderer)
 {
     IMFTopologyServiceLookupClient *lookup_client;
@@ -114,6 +134,176 @@ static void video_renderer_release_services(struct video_renderer *renderer)
     }
 }
 
+static HRESULT WINAPI video_stream_sink_QueryInterface(IMFStreamSink *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(riid, &IID_IMFStreamSink) ||
+            IsEqualIID(riid, &IID_IMFMediaEventGenerator) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFStreamSink_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI video_stream_sink_AddRef(IMFStreamSink *iface)
+{
+    struct video_stream *stream = impl_from_IMFStreamSink(iface);
+    ULONG refcount = InterlockedIncrement(&stream->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI video_stream_sink_Release(IMFStreamSink *iface)
+{
+    struct video_stream *stream = impl_from_IMFStreamSink(iface);
+    ULONG refcount = InterlockedDecrement(&stream->refcount);
+
+    if (!refcount)
+    {
+        heap_free(stream);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI video_stream_sink_GetEvent(IMFStreamSink *iface, DWORD flags, IMFMediaEvent **event)
+{
+    FIXME("%p, %#x, %p.\n", iface, flags, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_stream_sink_BeginGetEvent(IMFStreamSink *iface, IMFAsyncCallback *callback, IUnknown *state)
+{
+    FIXME("%p, %p, %p.\n", iface, callback, state);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_stream_sink_EndGetEvent(IMFStreamSink *iface, IMFAsyncResult *result,
+        IMFMediaEvent **event)
+{
+    FIXME("%p, %p, %p.\n", iface, result, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_stream_sink_QueueEvent(IMFStreamSink *iface, MediaEventType event_type,
+        REFGUID exttype, HRESULT hr_status, const PROPVARIANT *value)
+{
+    FIXME("%p, %d, %s, %#x, %p.\n", iface, event_type, debugstr_guid(exttype), hr_status, value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_stream_sink_GetMediaSink(IMFStreamSink *iface, IMFMediaSink **sink)
+{
+    struct video_stream *stream = impl_from_IMFStreamSink(iface);
+
+    TRACE("%p, %p.\n", iface, sink);
+
+    if (!stream->parent)
+        return MF_E_STREAMSINK_REMOVED;
+
+    if (!sink)
+        return E_POINTER;
+
+    /* FIXME: not entirely safe if sink is being shut down. */
+    *sink = &stream->parent->IMFMediaSink_iface;
+    IMFMediaSink_AddRef(*sink);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI video_stream_sink_GetIdentifier(IMFStreamSink *iface, DWORD *id)
+{
+    struct video_stream *stream = impl_from_IMFStreamSink(iface);
+
+    TRACE("%p, %p.\n", iface, id);
+
+    if (!stream->parent)
+        return MF_E_STREAMSINK_REMOVED;
+
+    if (!id)
+        return E_INVALIDARG;
+
+    *id = stream->id;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI video_stream_sink_GetMediaTypeHandler(IMFStreamSink *iface, IMFMediaTypeHandler **handler)
+{
+    FIXME("%p, %p.\n", iface, handler);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_stream_sink_ProcessSample(IMFStreamSink *iface, IMFSample *sample)
+{
+    FIXME("%p, %p.\n", iface, sample);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_stream_sink_PlaceMarker(IMFStreamSink *iface, MFSTREAMSINK_MARKER_TYPE marker_type,
+        const PROPVARIANT *marker_value, const PROPVARIANT *context_value)
+{
+    FIXME("%p, %d, %p, %p.\n", iface, marker_type, marker_value, context_value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_stream_sink_Flush(IMFStreamSink *iface)
+{
+    FIXME("%p.\n", iface);
+
+    return E_NOTIMPL;
+}
+
+static const IMFStreamSinkVtbl video_stream_sink_vtbl =
+{
+    video_stream_sink_QueryInterface,
+    video_stream_sink_AddRef,
+    video_stream_sink_Release,
+    video_stream_sink_GetEvent,
+    video_stream_sink_BeginGetEvent,
+    video_stream_sink_EndGetEvent,
+    video_stream_sink_QueueEvent,
+    video_stream_sink_GetMediaSink,
+    video_stream_sink_GetIdentifier,
+    video_stream_sink_GetMediaTypeHandler,
+    video_stream_sink_ProcessSample,
+    video_stream_sink_PlaceMarker,
+    video_stream_sink_Flush,
+};
+
+static HRESULT video_renderer_stream_create(struct video_renderer *renderer, unsigned int id,
+        struct video_stream **ret)
+{
+    struct video_stream *stream;
+
+    if (!(stream = heap_alloc_zero(sizeof(*stream))))
+        return E_OUTOFMEMORY;
+
+    stream->IMFStreamSink_iface.lpVtbl = &video_stream_sink_vtbl;
+    stream->refcount = 1;
+    stream->parent = renderer;
+    IMFMediaSink_AddRef(&stream->parent->IMFMediaSink_iface);
+    stream->id = id;
+
+    *ret = stream;
+
+    return S_OK;
+}
+
 static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, REFIID riid, void **obj)
 {
     struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
@@ -203,42 +393,161 @@ static HRESULT WINAPI video_renderer_sink_GetCharacteristics(IMFMediaSink *iface
     return S_OK;
 }
 
-static HRESULT WINAPI video_renderer_sink_AddStreamSink(IMFMediaSink *iface, DWORD stream_sink_id,
+static HRESULT WINAPI video_renderer_sink_AddStreamSink(IMFMediaSink *iface, DWORD id,
     IMFMediaType *media_type, IMFStreamSink **stream_sink)
 {
-    FIXME("%p, %#x, %p, %p.\n", iface, stream_sink_id, media_type, stream_sink);
+    struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
+    struct video_stream *stream;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x, %p, %p.\n", iface, id, media_type, stream_sink);
+
+    /* Rely on mixer for stream id validation. */
+
+    EnterCriticalSection(&renderer->cs);
+    if (renderer->flags & EVR_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (SUCCEEDED(hr = IMFTransform_AddInputStreams(renderer->mixer, 1, &id)))
+    {
+        if (mf_array_reserve((void **)&renderer->streams, &renderer->stream_size, renderer->stream_count + 1,
+                sizeof(*renderer->streams)))
+        {
+            if (SUCCEEDED(hr = video_renderer_stream_create(renderer, id, &stream)))
+            {
+                *stream_sink = &stream->IMFStreamSink_iface;
+                IMFStreamSink_AddRef(*stream_sink);
+                renderer->streams[renderer->stream_count++] = stream;
+            }
+        }
+        else
+            hr = E_OUTOFMEMORY;
+
+        if (FAILED(hr))
+            IMFTransform_DeleteInputStream(renderer->mixer, id);
+
+    }
+    LeaveCriticalSection(&renderer->cs);
+
+    return hr;
 }
 
-static HRESULT WINAPI video_renderer_sink_RemoveStreamSink(IMFMediaSink *iface, DWORD stream_sink_id)
+static HRESULT WINAPI video_renderer_sink_RemoveStreamSink(IMFMediaSink *iface, DWORD id)
 {
-    FIXME("%p, %#x.\n", iface, stream_sink_id);
+    struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
+    HRESULT hr;
+    size_t i;
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x.\n", iface, id);
+
+    /* Rely on mixer for stream id validation. */
+
+    EnterCriticalSection(&renderer->cs);
+    if (renderer->flags & EVR_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (SUCCEEDED(hr = IMFTransform_DeleteInputStream(renderer->mixer, id)))
+    {
+        for (i = 0; i < renderer->stream_count; ++i)
+        {
+            if (renderer->streams[i]->id == id)
+            {
+                IMFStreamSink_Release(&renderer->streams[i]->IMFStreamSink_iface);
+                renderer->streams[i] = NULL;
+                if (i < renderer->stream_count - 1)
+                {
+                    memmove(&renderer->streams[i], &renderer->streams[i+1],
+                            (renderer->stream_count - i - 1) * sizeof(*renderer->streams));
+                }
+                renderer->stream_count--;
+                break;
+            }
+        }
+    }
+    LeaveCriticalSection(&renderer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_renderer_sink_GetStreamSinkCount(IMFMediaSink *iface, DWORD *count)
 {
-    FIXME("%p, %p.\n", iface, count);
+    struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, count);
+
+    if (!count)
+        return E_POINTER;
+
+    EnterCriticalSection(&renderer->cs);
+    if (renderer->flags & EVR_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (!count)
+        hr = E_POINTER;
+    else
+        *count = renderer->stream_count;
+    LeaveCriticalSection(&renderer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_renderer_sink_GetStreamSinkByIndex(IMFMediaSink *iface, DWORD index,
         IMFStreamSink **stream)
 {
-    FIXME("%p, %u, %p.\n", iface, index, stream);
+    struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p.\n", iface, index, stream);
+
+    EnterCriticalSection(&renderer->cs);
+    if (renderer->flags & EVR_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (!stream)
+        hr = E_POINTER;
+    else if (index >= renderer->stream_count)
+        hr = E_INVALIDARG;
+    else
+    {
+        *stream = &renderer->streams[index]->IMFStreamSink_iface;
+        IMFStreamSink_AddRef(*stream);
+    }
+    LeaveCriticalSection(&renderer->cs);
+
+    return hr;
 }
 
-static HRESULT WINAPI video_renderer_sink_GetStreamSinkById(IMFMediaSink *iface, DWORD stream_sink_id,
+static HRESULT WINAPI video_renderer_sink_GetStreamSinkById(IMFMediaSink *iface, DWORD id,
         IMFStreamSink **stream)
 {
-    FIXME("%p, %#x, %p.\n", iface, stream_sink_id, stream);
+    struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
+    HRESULT hr = S_OK;
+    size_t i;
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x, %p.\n", iface, id, stream);
+
+    EnterCriticalSection(&renderer->cs);
+    if (renderer->flags & EVR_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (!stream)
+        hr = E_POINTER;
+    else
+    {
+        for (i = 0; i < renderer->stream_count; ++i)
+        {
+            if (renderer->streams[i]->id == id)
+                break;
+        }
+
+        if (i == renderer->stream_count)
+            hr = MF_E_INVALIDSTREAMNUMBER;
+        else
+        {
+            *stream = &renderer->streams[i]->IMFStreamSink_iface;
+            IMFStreamSink_AddRef(*stream);
+        }
+
+    }
+    LeaveCriticalSection(&renderer->cs);
+
+    return hr;
 }
 
 static void video_renderer_set_presentation_clock(struct video_renderer *renderer, IMFPresentationClock *clock)
@@ -305,6 +614,7 @@ static HRESULT WINAPI video_renderer_sink_GetPresentationClock(IMFMediaSink *ifa
 static HRESULT WINAPI video_renderer_sink_Shutdown(IMFMediaSink *iface)
 {
     struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
+    size_t i;
 
     TRACE("%p.\n", iface);
 
@@ -313,6 +623,17 @@ static HRESULT WINAPI video_renderer_sink_Shutdown(IMFMediaSink *iface)
 
     EnterCriticalSection(&renderer->cs);
     renderer->flags |= EVR_SHUT_DOWN;
+    /* Detach streams from the sink. */
+    for (i = 0; i < renderer->stream_count; ++i)
+    {
+        IMFMediaSink_Release(&renderer->streams[i]->parent->IMFMediaSink_iface);
+        renderer->streams[i]->parent = NULL;
+        IMFStreamSink_Release(&renderer->streams[i]->IMFStreamSink_iface);
+        renderer->streams[i] = NULL;
+    }
+    heap_free(renderer->streams);
+    renderer->stream_count = 0;
+    renderer->stream_size = 0;
     IMFMediaEventQueue_Shutdown(renderer->event_queue);
     video_renderer_set_presentation_clock(renderer, NULL);
     video_renderer_release_services(renderer);
From 951240cb138af421610fc96a349ed89713368677 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 7 Sep 2020 12:43:36 +0300
Subject: [PATCH] mf/evr: Add events support for video stream sinks.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 35 ++++++++++++++++++++++++++---------
 1 file changed, 26 insertions(+), 9 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 86242611a47..93ad06b9493 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -40,6 +40,7 @@ struct video_stream
     LONG refcount;
     unsigned int id;
     struct video_renderer *parent;
+    IMFMediaEventQueue *event_queue;
 };
 
 struct video_renderer
@@ -167,6 +168,8 @@ static ULONG WINAPI video_stream_sink_Release(IMFStreamSink *iface)
 
     if (!refcount)
     {
+        if (stream->event_queue)
+            IMFMediaEventQueue_Release(stream->event_queue);
         heap_free(stream);
     }
 
@@ -175,32 +178,40 @@ static ULONG WINAPI video_stream_sink_Release(IMFStreamSink *iface)
 
 static HRESULT WINAPI video_stream_sink_GetEvent(IMFStreamSink *iface, DWORD flags, IMFMediaEvent **event)
 {
-    FIXME("%p, %#x, %p.\n", iface, flags, event);
+    struct video_stream *stream = impl_from_IMFStreamSink(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x, %p.\n", iface, flags, event);
+
+    return IMFMediaEventQueue_GetEvent(stream->event_queue, flags, event);
 }
 
 static HRESULT WINAPI video_stream_sink_BeginGetEvent(IMFStreamSink *iface, IMFAsyncCallback *callback, IUnknown *state)
 {
-    FIXME("%p, %p, %p.\n", iface, callback, state);
+    struct video_stream *stream = impl_from_IMFStreamSink(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %p.\n", iface, callback, state);
+
+    return IMFMediaEventQueue_BeginGetEvent(stream->event_queue, callback, state);
 }
 
 static HRESULT WINAPI video_stream_sink_EndGetEvent(IMFStreamSink *iface, IMFAsyncResult *result,
         IMFMediaEvent **event)
 {
-    FIXME("%p, %p, %p.\n", iface, result, event);
+    struct video_stream *stream = impl_from_IMFStreamSink(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %p.\n", iface, result, event);
+
+    return IMFMediaEventQueue_EndGetEvent(stream->event_queue, result, event);
 }
 
 static HRESULT WINAPI video_stream_sink_QueueEvent(IMFStreamSink *iface, MediaEventType event_type,
-        REFGUID exttype, HRESULT hr_status, const PROPVARIANT *value)
+        REFGUID ext_type, HRESULT hr, const PROPVARIANT *value)
 {
-    FIXME("%p, %d, %s, %#x, %p.\n", iface, event_type, debugstr_guid(exttype), hr_status, value);
+    struct video_stream *stream = impl_from_IMFStreamSink(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %d, %s, %#x, %p.\n", iface, event_type, debugstr_guid(ext_type), hr, value);
+
+    return IMFMediaEventQueue_QueueEventParamVar(stream->event_queue, event_type, ext_type, hr, value);
 }
 
 static HRESULT WINAPI video_stream_sink_GetMediaSink(IMFStreamSink *iface, IMFMediaSink **sink)
@@ -289,12 +300,17 @@ static HRESULT video_renderer_stream_create(struct video_renderer *renderer, uns
         struct video_stream **ret)
 {
     struct video_stream *stream;
+    HRESULT hr;
 
     if (!(stream = heap_alloc_zero(sizeof(*stream))))
         return E_OUTOFMEMORY;
 
     stream->IMFStreamSink_iface.lpVtbl = &video_stream_sink_vtbl;
     stream->refcount = 1;
+
+    if (FAILED(hr = MFCreateEventQueue(&stream->event_queue)))
+        return hr;
+
     stream->parent = renderer;
     IMFMediaSink_AddRef(&stream->parent->IMFMediaSink_iface);
     stream->id = id;
@@ -628,6 +644,7 @@ static HRESULT WINAPI video_renderer_sink_Shutdown(IMFMediaSink *iface)
     {
         IMFMediaSink_Release(&renderer->streams[i]->parent->IMFMediaSink_iface);
         renderer->streams[i]->parent = NULL;
+        IMFMediaEventQueue_Shutdown(renderer->streams[i]->event_queue);
         IMFStreamSink_Release(&renderer->streams[i]->IMFStreamSink_iface);
         renderer->streams[i] = NULL;
     }
From 2ff7160cb7fc2f566237e0cb755d4b76a6882d46 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 7 Sep 2020 12:43:37 +0300
Subject: [PATCH] mf/session: Add support for MR_VIDEO_RENDER_SERVICE service.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/session.c | 52 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 52 insertions(+)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index e2a6b868caf..a1b54b7080e 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -24,6 +24,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "mfidl.h"
+#include "evr.h"
 
 #include "wine/debug.h"
 #include "wine/heap.h"
@@ -1794,6 +1795,57 @@ static HRESULT WINAPI session_get_service_GetService(IMFGetService *iface, REFGU
     {
         return IMFLocalMFTRegistration_QueryInterface(&local_mft_registration, riid, obj);
     }
+    else if (IsEqualGUID(service, &MR_VIDEO_RENDER_SERVICE))
+    {
+        IMFStreamSink *stream_sink;
+        IMFTopologyNode *node;
+        IUnknown *vr, *object;
+        IMFCollection *nodes;
+        IMFMediaSink *sink;
+        unsigned int i = 0;
+        HRESULT hr;
+
+        EnterCriticalSection(&session->cs);
+
+        /* Use first sink to support IMFVideoRenderer. */
+        if (session->presentation.current_topology)
+        {
+            if (SUCCEEDED(IMFTopology_GetOutputNodeCollection(session->presentation.current_topology,
+                    &nodes)))
+            {
+                while (IMFCollection_GetElement(nodes, i++, (IUnknown **)&node) == S_OK)
+                {
+                    if (SUCCEEDED(IMFTopologyNode_GetObject(node, &object)))
+                    {
+                        if (SUCCEEDED(IUnknown_QueryInterface(object, &IID_IMFStreamSink, (void **)&stream_sink)))
+                        {
+                            if (SUCCEEDED(IMFStreamSink_GetMediaSink(stream_sink, &sink)))
+                            {
+                                if (SUCCEEDED(IMFMediaSink_QueryInterface(sink, &IID_IMFVideoRenderer, (void **)&vr)))
+                                {
+                                    if (FAILED(hr = MFGetService(vr, service, riid, obj)))
+                                        WARN("Failed to get service from video renderer %#x.\n", hr);
+                                    IUnknown_Release(vr);
+                                }
+                            }
+                            IMFStreamSink_Release(stream_sink);
+                        }
+
+                        IUnknown_Release(object);
+                    }
+
+                    IMFTopologyNode_Release(node);
+
+                    if (*obj)
+                        break;
+                }
+
+                IMFCollection_Release(nodes);
+            }
+        }
+
+        LeaveCriticalSection(&session->cs);
+    }
     else
         FIXME("Unsupported service %s.\n", debugstr_guid(service));
 
From 9c898dcc1944105abbaeaeb3d53ce6f7f6113956 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 8 Sep 2020 11:05:57 +0300
Subject: [PATCH] mf/tests: Fix tests crashes.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/tests/mf.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index f01385cc46c..7013939ab0b 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -1451,7 +1451,10 @@ todo_wine
         return;
 
     hr = IMFMediaSource_CreatePresentationDescriptor(source, &pd);
+todo_wine
     ok(hr == S_OK, "Failed to create descriptor, hr %#x.\n", hr);
+    if (FAILED(hr))
+        return;
 
     hr = IMFPresentationDescriptor_GetStreamDescriptorByIndex(pd, 0, &selected, &sd);
     ok(hr == S_OK, "Failed to get stream descriptor, hr %#x.\n", hr);
From 98fab7e0acd85e51c21d6549e5da34de49eae54e Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 8 Sep 2020 11:05:58 +0300
Subject: [PATCH] mf/evr: Create stream sinks for default mixer inputs.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 70 ++++++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 55 insertions(+), 15 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 93ad06b9493..161c0d9b730 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -409,11 +409,35 @@ static HRESULT WINAPI video_renderer_sink_GetCharacteristics(IMFMediaSink *iface
     return S_OK;
 }
 
+static HRESULT video_renderer_add_stream(struct video_renderer *renderer, unsigned int id,
+        IMFStreamSink **stream_sink)
+{
+    struct video_stream *stream;
+    HRESULT hr;
+
+    if (!mf_array_reserve((void **)&renderer->streams, &renderer->stream_size, renderer->stream_count + 1,
+            sizeof(*renderer->streams)))
+    {
+        return E_OUTOFMEMORY;
+    }
+
+    if (SUCCEEDED(hr = video_renderer_stream_create(renderer, id, &stream)))
+    {
+        if (stream_sink)
+        {
+            *stream_sink = &stream->IMFStreamSink_iface;
+            IMFStreamSink_AddRef(*stream_sink);
+        }
+        renderer->streams[renderer->stream_count++] = stream;
+    }
+
+    return hr;
+}
+
 static HRESULT WINAPI video_renderer_sink_AddStreamSink(IMFMediaSink *iface, DWORD id,
     IMFMediaType *media_type, IMFStreamSink **stream_sink)
 {
     struct video_renderer *renderer = impl_from_IMFMediaSink(iface);
-    struct video_stream *stream;
     HRESULT hr;
 
     TRACE("%p, %#x, %p, %p.\n", iface, id, media_type, stream_sink);
@@ -425,20 +449,7 @@ static HRESULT WINAPI video_renderer_sink_AddStreamSink(IMFMediaSink *iface, DWO
         hr = MF_E_SHUTDOWN;
     else if (SUCCEEDED(hr = IMFTransform_AddInputStreams(renderer->mixer, 1, &id)))
     {
-        if (mf_array_reserve((void **)&renderer->streams, &renderer->stream_size, renderer->stream_count + 1,
-                sizeof(*renderer->streams)))
-        {
-            if (SUCCEEDED(hr = video_renderer_stream_create(renderer, id, &stream)))
-            {
-                *stream_sink = &stream->IMFStreamSink_iface;
-                IMFStreamSink_AddRef(*stream_sink);
-                renderer->streams[renderer->stream_count++] = stream;
-            }
-        }
-        else
-            hr = E_OUTOFMEMORY;
-
-        if (FAILED(hr))
+        if (FAILED(hr = video_renderer_add_stream(renderer, id, stream_sink)))
             IMFTransform_DeleteInputStream(renderer->mixer, id);
 
     }
@@ -1109,6 +1120,35 @@ static HRESULT video_renderer_create_mixer(struct video_renderer *renderer, IMFA
         IMFTopologyServiceLookupClient_Release(lookup_client);
     }
 
+    if (SUCCEEDED(hr))
+    {
+        unsigned int input_count, output_count;
+        unsigned int *ids, *oids;
+        size_t i;
+
+        /* Create stream sinks for inputs that mixer already has by default. */
+        if (SUCCEEDED(IMFTransform_GetStreamCount(*out, &input_count, &output_count)))
+        {
+            ids = heap_calloc(input_count, sizeof(*ids));
+            oids = heap_calloc(output_count, sizeof(*oids));
+
+            if (ids && oids)
+            {
+                if (SUCCEEDED(IMFTransform_GetStreamIDs(*out, input_count, ids, output_count, oids)))
+                {
+                    for (i = 0; i < input_count; ++i)
+                    {
+                        video_renderer_add_stream(renderer, ids[i], NULL);
+                    }
+                }
+
+            }
+
+            heap_free(ids);
+            heap_free(oids);
+        }
+    }
+
     return hr;
 }
 
From 3625f762500970d1ae3d4b21a6fd23cf4a0f0c09 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 8 Sep 2020 11:05:59 +0300
Subject: [PATCH] mf/evr: Add a IMFMediaTypeHandler stub for input video
 streams.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 114 ++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 111 insertions(+), 3 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 161c0d9b730..b27610e073a 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -37,6 +37,7 @@ struct video_renderer;
 struct video_stream
 {
     IMFStreamSink IMFStreamSink_iface;
+    IMFMediaTypeHandler IMFMediaTypeHandler_iface;
     LONG refcount;
     unsigned int id;
     struct video_renderer *parent;
@@ -114,6 +115,11 @@ static struct video_stream *impl_from_IMFStreamSink(IMFStreamSink *iface)
     return CONTAINING_RECORD(iface, struct video_stream, IMFStreamSink_iface);
 }
 
+static struct video_stream *impl_from_IMFMediaTypeHandler(IMFMediaTypeHandler *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_stream, IMFMediaTypeHandler_iface);
+}
+
 static void video_renderer_release_services(struct video_renderer *renderer)
 {
     IMFTopologyServiceLookupClient *lookup_client;
@@ -137,12 +143,26 @@ static void video_renderer_release_services(struct video_renderer *renderer)
 
 static HRESULT WINAPI video_stream_sink_QueryInterface(IMFStreamSink *iface, REFIID riid, void **obj)
 {
+    struct video_stream *stream = impl_from_IMFStreamSink(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    *obj = NULL;
+
     if (IsEqualIID(riid, &IID_IMFStreamSink) ||
             IsEqualIID(riid, &IID_IMFMediaEventGenerator) ||
             IsEqualIID(riid, &IID_IUnknown))
     {
         *obj = iface;
-        IMFStreamSink_AddRef(iface);
+    }
+    else if (IsEqualIID(riid, &IID_IMFMediaTypeHandler))
+    {
+        *obj = &stream->IMFMediaTypeHandler_iface;
+    }
+
+    if (*obj)
+    {
+        IUnknown_AddRef((IUnknown *)*obj);
         return S_OK;
     }
 
@@ -252,9 +272,20 @@ static HRESULT WINAPI video_stream_sink_GetIdentifier(IMFStreamSink *iface, DWOR
 
 static HRESULT WINAPI video_stream_sink_GetMediaTypeHandler(IMFStreamSink *iface, IMFMediaTypeHandler **handler)
 {
-    FIXME("%p, %p.\n", iface, handler);
+    struct video_stream *stream = impl_from_IMFStreamSink(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, handler);
+
+    if (!handler)
+        return E_POINTER;
+
+    if (!stream->parent)
+        return MF_E_STREAMSINK_REMOVED;
+
+    *handler = &stream->IMFMediaTypeHandler_iface;
+    IMFMediaTypeHandler_AddRef(*handler);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_stream_sink_ProcessSample(IMFStreamSink *iface, IMFSample *sample)
@@ -296,6 +327,82 @@ static const IMFStreamSinkVtbl video_stream_sink_vtbl =
     video_stream_sink_Flush,
 };
 
+static HRESULT WINAPI video_stream_typehandler_QueryInterface(IMFMediaTypeHandler *iface, REFIID riid,
+        void **obj)
+{
+    struct video_stream *stream = impl_from_IMFMediaTypeHandler(iface);
+    return IMFStreamSink_QueryInterface(&stream->IMFStreamSink_iface, riid, obj);
+}
+
+static ULONG WINAPI video_stream_typehandler_AddRef(IMFMediaTypeHandler *iface)
+{
+    struct video_stream *stream = impl_from_IMFMediaTypeHandler(iface);
+    return IMFStreamSink_AddRef(&stream->IMFStreamSink_iface);
+}
+
+static ULONG WINAPI video_stream_typehandler_Release(IMFMediaTypeHandler *iface)
+{
+    struct video_stream *stream = impl_from_IMFMediaTypeHandler(iface);
+    return IMFStreamSink_Release(&stream->IMFStreamSink_iface);
+}
+
+static HRESULT WINAPI video_stream_typehandler_IsMediaTypeSupported(IMFMediaTypeHandler *iface,
+        IMFMediaType *in_type, IMFMediaType **out_type)
+{
+    FIXME("%p, %p, %p.\n", iface, in_type, out_type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_stream_typehandler_GetMediaTypeCount(IMFMediaTypeHandler *iface, DWORD *count)
+{
+    FIXME("%p, %p.\n", iface, count);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_stream_typehandler_GetMediaTypeByIndex(IMFMediaTypeHandler *iface, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, index, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_stream_typehandler_SetCurrentMediaType(IMFMediaTypeHandler *iface, IMFMediaType *type)
+{
+    FIXME("%p, %p.\n", iface, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_stream_typehandler_GetCurrentMediaType(IMFMediaTypeHandler *iface, IMFMediaType **type)
+{
+    FIXME("%p, %p.\n", iface, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_stream_typehandler_GetMajorType(IMFMediaTypeHandler *iface, GUID *type)
+{
+    FIXME("%p, %p.\n", iface, type);
+
+    return E_NOTIMPL;
+}
+
+static const IMFMediaTypeHandlerVtbl video_stream_type_handler_vtbl =
+{
+    video_stream_typehandler_QueryInterface,
+    video_stream_typehandler_AddRef,
+    video_stream_typehandler_Release,
+    video_stream_typehandler_IsMediaTypeSupported,
+    video_stream_typehandler_GetMediaTypeCount,
+    video_stream_typehandler_GetMediaTypeByIndex,
+    video_stream_typehandler_SetCurrentMediaType,
+    video_stream_typehandler_GetCurrentMediaType,
+    video_stream_typehandler_GetMajorType,
+};
+
 static HRESULT video_renderer_stream_create(struct video_renderer *renderer, unsigned int id,
         struct video_stream **ret)
 {
@@ -306,6 +413,7 @@ static HRESULT video_renderer_stream_create(struct video_renderer *renderer, uns
         return E_OUTOFMEMORY;
 
     stream->IMFStreamSink_iface.lpVtbl = &video_stream_sink_vtbl;
+    stream->IMFMediaTypeHandler_iface.lpVtbl = &video_stream_type_handler_vtbl;
     stream->refcount = 1;
 
     if (FAILED(hr = MFCreateEventQueue(&stream->event_queue)))
From 3d8d05dbeb373bc2189d74bb48a433618c62e90f Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 8 Sep 2020 11:06:00 +0300
Subject: [PATCH] mf/evr: Add GetMajorType() for the stream sink.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c      | 13 +++++++++++--
 dlls/mf/tests/mf.c | 20 ++++++++++++++++++++
 2 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index b27610e073a..31bc110ea48 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -385,9 +385,18 @@ static HRESULT WINAPI video_stream_typehandler_GetCurrentMediaType(IMFMediaTypeH
 
 static HRESULT WINAPI video_stream_typehandler_GetMajorType(IMFMediaTypeHandler *iface, GUID *type)
 {
-    FIXME("%p, %p.\n", iface, type);
+    struct video_stream *stream = impl_from_IMFMediaTypeHandler(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, type);
+
+    if (!stream->parent)
+        return MF_E_STREAMSINK_REMOVED;
+
+    if (!type)
+        return E_POINTER;
+
+    memcpy(type, &MFMediaType_Video, sizeof(*type));
+    return S_OK;
 }
 
 static const IMFMediaTypeHandlerVtbl video_stream_type_handler_vtbl =
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 7013939ab0b..2c02b1d8e54 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3236,16 +3236,19 @@ todo_wine
 static void test_evr(void)
 {
     IMFMediaEventGenerator *ev_generator;
+    IMFMediaTypeHandler *type_handler;
     IMFVideoRenderer *video_renderer;
     IMFClockStateSink *clock_sink;
     IMFMediaSinkPreroll *preroll;
     IMFMediaSink *sink, *sink2;
+    IMFStreamSink *stream_sink;
     IMFActivate *activate;
     DWORD flags, count;
     IMFGetService *gs;
     IUnknown *unk;
     UINT64 value;
     HRESULT hr;
+    GUID guid;
 
     hr = CoInitialize(NULL);
     ok(hr == S_OK, "Failed to initialize, hr %#x.\n", hr);
@@ -3267,6 +3270,23 @@ static void test_evr(void)
     hr = IMFActivate_ActivateObject(activate, &IID_IMFMediaSink, (void **)&sink);
     ok(hr == S_OK, "Failed to activate, hr %#x.\n", hr);
 
+    /* Primary stream type handler. */
+    hr = IMFMediaSink_GetStreamSinkById(sink, 0, &stream_sink);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFStreamSink_GetMediaTypeHandler(stream_sink, &type_handler);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaTypeHandler_GetMajorType(type_handler, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaTypeHandler_GetMajorType(type_handler, &guid);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(IsEqualGUID(&guid, &MFMediaType_Video), "Unexpected type %s.\n", wine_dbgstr_guid(&guid));
+
+    IMFStreamSink_Release(stream_sink);
+    IMFMediaTypeHandler_Release(type_handler);
+
     hr = IMFMediaSink_GetCharacteristics(sink, &flags);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(flags == (MEDIASINK_CAN_PREROLL | MEDIASINK_CLOCK_REQUIRED), "Unexpected flags %#x.\n", flags);
From 8827eb6a83348057293f89be535ccb74607db608 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 8 Sep 2020 11:06:01 +0300
Subject: [PATCH] evr/mixer: Return initial mixing preferences.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 24 ++++++++++++++++++++----
 dlls/evr/tests/evr.c | 15 ++++++++++++++-
 include/evr.idl      | 10 ++++++++++
 3 files changed, 44 insertions(+), 5 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 7e08beae353..c7dbf8ff975 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -73,6 +73,7 @@ struct video_mixer
     IDirect3DDeviceManager9 *device_manager;
     IMediaEventSink *event_sink;
     IMFAttributes *attributes;
+    unsigned int mixing_flags;
     CRITICAL_SECTION cs;
 };
 
@@ -1008,16 +1009,31 @@ static HRESULT WINAPI video_mixer_control_GetStreamOutputRect(IMFVideoMixerContr
 
 static HRESULT WINAPI video_mixer_control_SetMixingPrefs(IMFVideoMixerControl2 *iface, DWORD flags)
 {
-    FIXME("%p, %#x.\n", iface, flags);
+    struct video_mixer *mixer = impl_from_IMFVideoMixerControl2(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x.\n", iface, flags);
+
+    EnterCriticalSection(&mixer->cs);
+    mixer->mixing_flags = flags;
+    LeaveCriticalSection(&mixer->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_mixer_control_GetMixingPrefs(IMFVideoMixerControl2 *iface, DWORD *flags)
 {
-    FIXME("%p, %p.\n", iface, flags);
+    struct video_mixer *mixer = impl_from_IMFVideoMixerControl2(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, flags);
+
+    if (!flags)
+        return E_POINTER;
+
+    EnterCriticalSection(&mixer->cs);
+    *flags = mixer->mixing_flags;
+    LeaveCriticalSection(&mixer->cs);
+
+    return S_OK;
 }
 
 static const IMFVideoMixerControl2Vtbl video_mixer_control_vtbl =
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index ba97eba53d1..92810b516a7 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -414,6 +414,7 @@ static void test_default_mixer(void)
 {
     DWORD input_min, input_max, output_min, output_max;
     IMFAttributes *attributes, *attributes2;
+    IMFVideoMixerControl2 *mixer_control2;
     MFT_OUTPUT_STREAM_INFO output_info;
     MFT_INPUT_STREAM_INFO input_info;
     DWORD input_count, output_count;
@@ -424,12 +425,12 @@ static void test_default_mixer(void)
     IMFTransform *transform;
     DXVA2_ValueRange range;
     DXVA2_Fixed32 value;
+    DWORD flags, count;
     IMFGetService *gs;
     COLORREF color;
     unsigned int i;
     DWORD ids[16];
     IUnknown *unk;
-    DWORD count;
     GUID *guids;
     HRESULT hr;
     IID iid;
@@ -455,6 +456,18 @@ static void test_default_mixer(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
+    if (SUCCEEDED(IMFGetService_GetService(gs, &MR_VIDEO_MIXER_SERVICE, &IID_IMFVideoMixerControl2, (void **)&mixer_control2)))
+    {
+        hr = IMFVideoMixerControl2_GetMixingPrefs(mixer_control2, NULL);
+        ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+        hr = IMFVideoMixerControl2_GetMixingPrefs(mixer_control2, &flags);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+        ok(!flags, "Unexpected flags %#x.\n", flags);
+
+        IMFVideoMixerControl2_Release(mixer_control2);
+    }
+
     hr = IMFVideoProcessor_GetBackgroundColor(processor, NULL);
     ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
diff --git a/include/evr.idl b/include/evr.idl
index 6369a39b2f3..77c46a075f1 100644
--- a/include/evr.idl
+++ b/include/evr.idl
@@ -184,6 +184,16 @@ interface IMFVideoMixerControl : IUnknown
     );
 }
 
+typedef enum _MFVideoMixPrefs
+{
+    MFVideoMixPrefs_ForceHalfInterlace       = 0x00000001,
+    MFVideoMixPrefs_AllowDropToHalfInterlace = 0x00000002,
+    MFVideoMixPrefs_AllowDropToBob           = 0x00000004,
+    MFVideoMixPrefs_ForceBob                 = 0x00000008,
+    MFVideoMixPrefs_EnableRotation           = 0x00000010,
+    MFVideoMixPrefs_Mask                     = 0x0000001f,
+} MFVideoMixPrefs;
+
 [
     object,
     uuid(8459616d-966e-4930-b658-54fa7e5a16d3)
From bce18ee78ad60b55a23642de45a76669211ea642 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 9 Sep 2020 13:41:00 +0300
Subject: [PATCH] maintainers: Get rid of removed paths.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 MAINTAINERS | 2 --
 1 file changed, 2 deletions(-)

diff --git a/MAINTAINERS b/MAINTAINERS
index 46b3d40ec33..b57eb5a5363 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -198,8 +198,6 @@ M:	Huw Davies <huw@codeweavers.com>
 F:	dlls/combase/
 F:	dlls/ole32/compobj.c
 F:	dlls/ole32/marshal.c
-F:	dlls/ole32/rpc.c
-F:	dlls/ole32/stubmanager.c
 F:	dlls/ole32/usrmarshal.c
 
 OLE Storage
From 23a879ec0ed12454f26e597247c73739ad1f8bbd Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 9 Sep 2020 12:48:27 +0300
Subject: [PATCH] evr/mixer: Add another set of attributes.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 355 +++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c |  25 ++-
 2 files changed, 377 insertions(+), 3 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index c7dbf8ff975..70199f37a1c 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -60,6 +60,7 @@ struct video_mixer
     IMFVideoMixerBitmap IMFVideoMixerBitmap_iface;
     IMFVideoPositionMapper IMFVideoPositionMapper_iface;
     IMFVideoProcessor IMFVideoProcessor_iface;
+    IMFAttributes IMFAttributes_iface;
     IUnknown IUnknown_inner;
     IUnknown *outer_unk;
     LONG refcount;
@@ -73,6 +74,7 @@ struct video_mixer
     IDirect3DDeviceManager9 *device_manager;
     IMediaEventSink *event_sink;
     IMFAttributes *attributes;
+    IMFAttributes *internal_attributes;
     unsigned int mixing_flags;
     CRITICAL_SECTION cs;
 };
@@ -122,6 +124,11 @@ static struct video_mixer *impl_from_IMFVideoProcessor(IMFVideoProcessor *iface)
     return CONTAINING_RECORD(iface, struct video_mixer, IMFVideoProcessor_iface);
 }
 
+static struct video_mixer *impl_from_IMFAttributes(IMFAttributes *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_mixer, IMFAttributes_iface);
+}
+
 static int video_mixer_compare_input_id(const void *a, const void *b)
 {
     const unsigned int *key = a;
@@ -206,6 +213,10 @@ static HRESULT WINAPI video_mixer_inner_QueryInterface(IUnknown *iface, REFIID r
     {
         *obj = &mixer->IMFVideoProcessor_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFAttributes))
+    {
+        *obj = &mixer->IMFAttributes_iface;
+    }
     else
     {
         WARN("Unsupported interface %s.\n", debugstr_guid(riid));
@@ -247,6 +258,8 @@ static ULONG WINAPI video_mixer_inner_Release(IUnknown *iface)
             IDirect3DDeviceManager9_Release(mixer->device_manager);
         if (mixer->attributes)
             IMFAttributes_Release(mixer->attributes);
+        if (mixer->internal_attributes)
+            IMFAttributes_Release(mixer->internal_attributes);
         DeleteCriticalSection(&mixer->cs);
         free(mixer);
     }
@@ -1326,6 +1339,337 @@ static const IMFVideoProcessorVtbl video_mixer_processor_vtbl =
     video_mixer_processor_SetBackgroundColor,
 };
 
+static HRESULT WINAPI video_mixer_attributes_QueryInterface(IMFAttributes *iface, REFIID riid, void **out)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+    return IMFTransform_QueryInterface(&mixer->IMFTransform_iface, riid, out);
+}
+
+static ULONG WINAPI video_mixer_attributes_AddRef(IMFAttributes *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+    return IMFTransform_AddRef(&mixer->IMFTransform_iface);
+}
+
+static ULONG WINAPI video_mixer_attributes_Release(IMFAttributes *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+    return IMFTransform_Release(&mixer->IMFTransform_iface);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetItem(IMFAttributes *iface, REFGUID key, PROPVARIANT *value)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(key), value);
+
+    return IMFAttributes_GetItem(mixer->internal_attributes, key, value);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetItemType(IMFAttributes *iface, REFGUID key, MF_ATTRIBUTE_TYPE *type)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(key), type);
+
+    return IMFAttributes_GetItemType(mixer->internal_attributes, key, type);
+}
+
+static HRESULT WINAPI video_mixer_attributes_CompareItem(IMFAttributes *iface, REFGUID key,
+        REFPROPVARIANT value, BOOL *result)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p, %p.\n", iface, debugstr_guid(key), value, result);
+
+    return IMFAttributes_CompareItem(mixer->internal_attributes, key, value, result);
+}
+
+static HRESULT WINAPI video_mixer_attributes_Compare(IMFAttributes *iface, IMFAttributes *theirs,
+        MF_ATTRIBUTES_MATCH_TYPE match_type, BOOL *ret)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %p, %d, %p.\n", iface, theirs, match_type, ret);
+
+    return IMFAttributes_Compare(mixer->internal_attributes, theirs, match_type, ret);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetUINT32(IMFAttributes *iface, REFGUID key, UINT32 *value)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(key), value);
+
+    return IMFAttributes_GetUINT32(mixer->internal_attributes, key, value);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetUINT64(IMFAttributes *iface, REFGUID key, UINT64 *value)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(key), value);
+
+    return IMFAttributes_GetUINT64(mixer->internal_attributes, key, value);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetDouble(IMFAttributes *iface, REFGUID key, double *value)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(key), value);
+
+    return IMFAttributes_GetDouble(mixer->internal_attributes, key, value);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetGUID(IMFAttributes *iface, REFGUID key, GUID *value)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(key), value);
+
+    return IMFAttributes_GetGUID(mixer->internal_attributes, key, value);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetStringLength(IMFAttributes *iface, REFGUID key, UINT32 *length)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(key), length);
+
+    return IMFAttributes_GetStringLength(mixer->internal_attributes, key, length);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetString(IMFAttributes *iface, REFGUID key, WCHAR *value,
+        UINT32 size, UINT32 *length)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p, %d, %p.\n", iface, debugstr_guid(key), value, size, length);
+
+    return IMFAttributes_GetString(mixer->internal_attributes, key, value, size, length);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetAllocatedString(IMFAttributes *iface, REFGUID key,
+        WCHAR **value, UINT32 *length)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p, %p.\n", iface, debugstr_guid(key), value, length);
+
+    return IMFAttributes_GetAllocatedString(mixer->internal_attributes, key, value, length);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetBlobSize(IMFAttributes *iface, REFGUID key, UINT32 *size)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(key), size);
+
+    return IMFAttributes_GetBlobSize(mixer->internal_attributes, key, size);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetBlob(IMFAttributes *iface, REFGUID key, UINT8 *buf,
+                UINT32 bufsize, UINT32 *blobsize)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p, %d, %p.\n", iface, debugstr_guid(key), buf, bufsize, blobsize);
+
+    return IMFAttributes_GetBlob(mixer->internal_attributes, key, buf, bufsize, blobsize);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetAllocatedBlob(IMFAttributes *iface, REFGUID key, UINT8 **buf, UINT32 *size)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p, %p.\n", iface, debugstr_guid(key), buf, size);
+
+    return IMFAttributes_GetAllocatedBlob(mixer->internal_attributes, key, buf, size);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetUnknown(IMFAttributes *iface, REFGUID key, REFIID riid, void **out)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %s, %p.\n", iface, debugstr_guid(key), debugstr_guid(riid), out);
+
+    return IMFAttributes_GetUnknown(mixer->internal_attributes, key, riid, out);
+}
+
+static HRESULT WINAPI video_mixer_attributes_SetItem(IMFAttributes *iface, REFGUID key, REFPROPVARIANT value)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(key), value);
+
+    return IMFAttributes_SetItem(mixer->internal_attributes, key, value);
+}
+
+static HRESULT WINAPI video_mixer_attributes_DeleteItem(IMFAttributes *iface, REFGUID key)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s.\n", iface, debugstr_guid(key));
+
+    return IMFAttributes_DeleteItem(mixer->internal_attributes, key);
+}
+
+static HRESULT WINAPI video_mixer_attributes_DeleteAllItems(IMFAttributes *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p.\n", iface);
+
+    return IMFAttributes_DeleteAllItems(mixer->internal_attributes);
+}
+
+static HRESULT WINAPI video_mixer_attributes_SetUINT32(IMFAttributes *iface, REFGUID key, UINT32 value)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %u.\n", iface, debugstr_guid(key), value);
+
+    return IMFAttributes_SetUINT32(mixer->internal_attributes, key, value);
+}
+
+static HRESULT WINAPI video_mixer_attributes_SetUINT64(IMFAttributes *iface, REFGUID key, UINT64 value)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %s.\n", iface, debugstr_guid(key), wine_dbgstr_longlong(value));
+
+    return IMFAttributes_SetUINT64(mixer->internal_attributes, key, value);
+}
+
+static HRESULT WINAPI video_mixer_attributes_SetDouble(IMFAttributes *iface, REFGUID key, double value)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %f.\n", iface, debugstr_guid(key), value);
+
+    return IMFAttributes_SetDouble(mixer->internal_attributes, key, value);
+}
+
+static HRESULT WINAPI video_mixer_attributes_SetGUID(IMFAttributes *iface, REFGUID key, REFGUID value)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %s.\n", iface, debugstr_guid(key), debugstr_guid(value));
+
+    return IMFAttributes_SetGUID(mixer->internal_attributes, key, value);
+}
+
+static HRESULT WINAPI video_mixer_attributes_SetString(IMFAttributes *iface, REFGUID key, const WCHAR *value)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %s.\n", iface, debugstr_guid(key), debugstr_w(value));
+
+    return IMFAttributes_SetString(mixer->internal_attributes, key, value);
+}
+
+static HRESULT WINAPI video_mixer_attributes_SetBlob(IMFAttributes *iface, REFGUID key, const UINT8 *buf, UINT32 size)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p, %u.\n", iface, debugstr_guid(key), buf, size);
+
+    return IMFAttributes_SetBlob(mixer->internal_attributes, key, buf, size);
+}
+
+static HRESULT WINAPI video_mixer_attributes_SetUnknown(IMFAttributes *iface, REFGUID key, IUnknown *unknown)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(key), unknown);
+
+    return IMFAttributes_SetUnknown(mixer->internal_attributes, key, unknown);
+}
+
+static HRESULT WINAPI video_mixer_attributes_LockStore(IMFAttributes *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p.\n", iface);
+
+    return IMFAttributes_LockStore(mixer->internal_attributes);
+}
+
+static HRESULT WINAPI video_mixer_attributes_UnlockStore(IMFAttributes *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p.\n", iface);
+
+    return IMFAttributes_UnlockStore(mixer->internal_attributes);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetCount(IMFAttributes *iface, UINT32 *count)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %p.\n", iface, count);
+
+    return IMFAttributes_GetCount(mixer->internal_attributes, count);
+}
+
+static HRESULT WINAPI video_mixer_attributes_GetItemByIndex(IMFAttributes *iface, UINT32 index,
+        GUID *key, PROPVARIANT *value)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %u, %p, %p.\n", iface, index, key, value);
+
+    return IMFAttributes_GetItemByIndex(mixer->internal_attributes, index, key, value);
+}
+
+static HRESULT WINAPI video_mixer_attributes_CopyAllItems(IMFAttributes *iface, IMFAttributes *dest)
+{
+    struct video_mixer *mixer = impl_from_IMFAttributes(iface);
+
+    TRACE("%p, %p.\n", iface, dest);
+
+    return IMFAttributes_CopyAllItems(mixer->internal_attributes, dest);
+}
+
+static const IMFAttributesVtbl video_mixer_attributes_vtbl =
+{
+    video_mixer_attributes_QueryInterface,
+    video_mixer_attributes_AddRef,
+    video_mixer_attributes_Release,
+    video_mixer_attributes_GetItem,
+    video_mixer_attributes_GetItemType,
+    video_mixer_attributes_CompareItem,
+    video_mixer_attributes_Compare,
+    video_mixer_attributes_GetUINT32,
+    video_mixer_attributes_GetUINT64,
+    video_mixer_attributes_GetDouble,
+    video_mixer_attributes_GetGUID,
+    video_mixer_attributes_GetStringLength,
+    video_mixer_attributes_GetString,
+    video_mixer_attributes_GetAllocatedString,
+    video_mixer_attributes_GetBlobSize,
+    video_mixer_attributes_GetBlob,
+    video_mixer_attributes_GetAllocatedBlob,
+    video_mixer_attributes_GetUnknown,
+    video_mixer_attributes_SetItem,
+    video_mixer_attributes_DeleteItem,
+    video_mixer_attributes_DeleteAllItems,
+    video_mixer_attributes_SetUINT32,
+    video_mixer_attributes_SetUINT64,
+    video_mixer_attributes_SetDouble,
+    video_mixer_attributes_SetGUID,
+    video_mixer_attributes_SetString,
+    video_mixer_attributes_SetBlob,
+    video_mixer_attributes_SetUnknown,
+    video_mixer_attributes_LockStore,
+    video_mixer_attributes_UnlockStore,
+    video_mixer_attributes_GetCount,
+    video_mixer_attributes_GetItemByIndex,
+    video_mixer_attributes_CopyAllItems
+};
+
 HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -1355,6 +1699,7 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
     object->IMFVideoMixerBitmap_iface.lpVtbl = &video_mixer_bitmap_vtbl;
     object->IMFVideoPositionMapper_iface.lpVtbl = &video_mixer_position_mapper_vtbl;
     object->IMFVideoProcessor_iface.lpVtbl = &video_mixer_processor_vtbl;
+    object->IMFAttributes_iface.lpVtbl = &video_mixer_attributes_vtbl;
     object->IUnknown_inner.lpVtbl = &video_mixer_inner_vtbl;
     object->outer_unk = outer ? outer : &object->IUnknown_inner;
     object->refcount = 1;
@@ -1366,10 +1711,20 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
         IUnknown_Release(&object->IUnknown_inner);
         return hr;
     }
+    if (FAILED(hr = MFCreateAttributes(&object->internal_attributes, 0)))
+    {
+        IUnknown_Release(&object->IUnknown_inner);
+        return hr;
+    }
+
+    /* Default attributes configuration. */
+
     rect.left = rect.top = 0.0f;
     rect.right = rect.bottom = 1.0f;
     IMFAttributes_SetBlob(object->attributes, &VIDEO_ZOOM_RECT, (const UINT8 *)&rect, sizeof(rect));
 
+    IMFAttributes_SetUINT32(object->internal_attributes, &MF_SA_D3D_AWARE, 1);
+
     *out = &object->IUnknown_inner;
 
     return S_OK;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 92810b516a7..ecf1f850c77 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -424,8 +424,8 @@ static void test_default_mixer(void)
     DWORD input_id, output_id;
     IMFTransform *transform;
     DXVA2_ValueRange range;
-    DXVA2_Fixed32 value;
-    DWORD flags, count;
+    DXVA2_Fixed32 dxva_value;
+    DWORD flags, value, count;
     IMFGetService *gs;
     COLORREF color;
     unsigned int i;
@@ -487,7 +487,7 @@ static void test_default_mixer(void)
 todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
 
-    hr = IMFVideoProcessor_GetFilteringValue(processor, DXVA2_DetailFilterChromaLevel, &value);
+    hr = IMFVideoProcessor_GetFilteringValue(processor, DXVA2_DetailFilterChromaLevel, &dxva_value);
 todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
 
@@ -533,6 +533,25 @@ todo_wine
     ok(attributes == attributes2, "Unexpected attributes instance.\n");
     IMFAttributes_Release(attributes2);
 
+    hr = IMFTransform_QueryInterface(transform, &IID_IMFAttributes, (void **)&attributes2);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(attributes != attributes2, "Unexpected attributes instance.\n");
+
+    hr = IMFAttributes_QueryInterface(attributes2, &IID_IMFTransform, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
+    hr = IMFAttributes_GetCount(attributes2, &count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(count == 1, "Unexpected attribute count %u.\n", count);
+
+    value = 0;
+    hr = IMFAttributes_GetUINT32(attributes2, &MF_SA_D3D_AWARE, &value);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(value == 1, "Unexpected value %d.\n", value);
+
+    IMFAttributes_Release(attributes2);
+
     hr = IMFAttributes_GetCount(attributes, &count);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(count == 1, "Unexpected attribute count %u.\n", count);
From 21d2e68d8e1ab37e47c146af954c267908dd55ad Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 9 Sep 2020 18:00:58 -0500
Subject: [PATCH] winegstreamer: Dereference messages dropped from watch_bus().

From GStreamer documentation: "If the handler returns GST_BUS_DROP, it should
unref the message, else the message should not be unreffed by the sync handler."

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 2c9aafd7a6b..724ac8fd25f 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1280,6 +1280,7 @@ static GstBusSyncReply watch_bus(GstBus *bus, GstMessage *msg, gpointer data)
     default:
         break;
     }
+    gst_message_unref(msg);
     return GST_BUS_DROP;
 }
 
From 8e343024b577892bd4908304ded34b758579698d Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 15 Jul 2020 15:55:45 +0300
Subject: [PATCH] mf/topoloader: Switch to public interface for initial
 topology validation.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/topology.c | 36 ++++++++++++++++++++++++------------
 1 file changed, 24 insertions(+), 12 deletions(-)

diff --git a/dlls/mf/topology.c b/dlls/mf/topology.c
index abe66c45fd4..8522f569691 100644
--- a/dlls/mf/topology.c
+++ b/dlls/mf/topology.c
@@ -1936,38 +1936,50 @@ static ULONG WINAPI topology_loader_Release(IMFTopoLoader *iface)
 static HRESULT WINAPI topology_loader_Load(IMFTopoLoader *iface, IMFTopology *input_topology,
         IMFTopology **output_topology, IMFTopology *current_topology)
 {
-    struct topology *topology = unsafe_impl_from_IMFTopology(input_topology);
+    MF_TOPOLOGY_TYPE node_type;
+    IMFTopologyNode *node;
+    unsigned short i = 0;
     IMFStreamSink *sink;
-    HRESULT hr;
-    size_t i;
+    IUnknown *object;
+    HRESULT hr = E_FAIL;
 
     FIXME("%p, %p, %p, %p.\n", iface, input_topology, output_topology, current_topology);
 
     if (current_topology)
         FIXME("Current topology instance is ignored.\n");
 
-    for (i = 0; i < topology->nodes.count; ++i)
+    /* Basic sanity checks for input topology:
+
+       - source nodes must have stream descriptor set;
+       - sink nodes must be resolved to stream sink objects;
+    */
+    while (SUCCEEDED(IMFTopology_GetNode(input_topology, i++, &node)))
     {
-        struct topology_node *node = topology->nodes.nodes[i];
+        IMFTopologyNode_GetNodeType(node, &node_type);
 
-        switch (node->node_type)
+        switch (node_type)
         {
             case MF_TOPOLOGY_OUTPUT_NODE:
-                if (node->object)
+                if (SUCCEEDED(hr = IMFTopologyNode_GetObject(node, &object)))
                 {
                     /* Sinks must be bound beforehand. */
-                    if (FAILED(IUnknown_QueryInterface(node->object, &IID_IMFStreamSink, (void **)&sink)))
-                        return MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED;
-                    IMFStreamSink_Release(sink);
+                    if (FAILED(IUnknown_QueryInterface(object, &IID_IMFStreamSink, (void **)&sink)))
+                        hr = MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED;
+                    else if (sink)
+                        IMFStreamSink_Release(sink);
+                    IUnknown_Release(object);
                 }
                 break;
             case MF_TOPOLOGY_SOURCESTREAM_NODE:
-                if (FAILED(hr = IMFAttributes_GetItem(node->attributes, &MF_TOPONODE_STREAM_DESCRIPTOR, NULL)))
-                    return hr;
+                hr = IMFTopologyNode_GetItem(node, &MF_TOPONODE_STREAM_DESCRIPTOR, NULL);
                 break;
             default:
                 ;
         }
+
+        IMFTopologyNode_Release(node);
+        if (FAILED(hr))
+            return hr;
     }
 
     if (FAILED(hr = MFCreateTopology(output_topology)))
From 16d44b61d15193905ef40661bc1547cb45e7b019 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 15 Jul 2020 15:55:46 +0300
Subject: [PATCH] mf/topoloader: Clone source nodes as a first layer of
 resulting topology.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/topology.c | 61 +++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 57 insertions(+), 4 deletions(-)

diff --git a/dlls/mf/topology.c b/dlls/mf/topology.c
index 8522f569691..840f1bd25f4 100644
--- a/dlls/mf/topology.c
+++ b/dlls/mf/topology.c
@@ -1933,9 +1933,40 @@ static ULONG WINAPI topology_loader_Release(IMFTopoLoader *iface)
     return refcount;
 }
 
+struct topoloader_context
+{
+    IMFTopology *output_topology;
+    GUID key;
+};
+
+static HRESULT topology_loader_clone_node(struct topoloader_context *context, IMFTopologyNode *node,
+        unsigned int marker)
+{
+    IMFTopologyNode *cloned_node;
+    MF_TOPOLOGY_TYPE node_type;
+    HRESULT hr;
+
+    IMFTopologyNode_GetNodeType(node, &node_type);
+
+    if (FAILED(hr = MFCreateTopologyNode(node_type, &cloned_node)))
+        return hr;
+
+    if (SUCCEEDED(hr = IMFTopologyNode_CloneFrom(cloned_node, node)))
+        hr = IMFTopologyNode_SetUINT32(cloned_node, &context->key, marker);
+
+    if (SUCCEEDED(hr))
+        hr = IMFTopology_AddNode(context->output_topology, cloned_node);
+
+    IMFTopologyNode_Release(cloned_node);
+
+    return hr;
+}
+
 static HRESULT WINAPI topology_loader_Load(IMFTopoLoader *iface, IMFTopology *input_topology,
-        IMFTopology **output_topology, IMFTopology *current_topology)
+        IMFTopology **ret_topology, IMFTopology *current_topology)
 {
+    struct topoloader_context context = { 0 };
+    IMFTopology *output_topology;
     MF_TOPOLOGY_TYPE node_type;
     IMFTopologyNode *node;
     unsigned short i = 0;
@@ -1943,7 +1974,7 @@ static HRESULT WINAPI topology_loader_Load(IMFTopoLoader *iface, IMFTopology *in
     IUnknown *object;
     HRESULT hr = E_FAIL;
 
-    FIXME("%p, %p, %p, %p.\n", iface, input_topology, output_topology, current_topology);
+    FIXME("%p, %p, %p, %p.\n", iface, input_topology, ret_topology, current_topology);
 
     if (current_topology)
         FIXME("Current topology instance is ignored.\n");
@@ -1982,10 +2013,32 @@ static HRESULT WINAPI topology_loader_Load(IMFTopoLoader *iface, IMFTopology *in
             return hr;
     }
 
-    if (FAILED(hr = MFCreateTopology(output_topology)))
+    if (FAILED(hr = MFCreateTopology(&output_topology)))
         return hr;
 
-    return IMFTopology_CloneFrom(*output_topology, input_topology);
+    context.output_topology = output_topology;
+    memset(&context.key, 0xff, sizeof(context.key));
+
+    /* Clone source nodes, use initial marker value. */
+    i = 0;
+    while (SUCCEEDED(IMFTopology_GetNode(input_topology, i++, &node)))
+    {
+        IMFTopologyNode_GetNodeType(node, &node_type);
+
+        if (node_type == MF_TOPOLOGY_SOURCESTREAM_NODE)
+        {
+            if (FAILED(hr = topology_loader_clone_node(&context, node, 0)))
+                WARN("Failed to clone source node, hr %#x.\n", hr);
+        }
+
+        IMFTopologyNode_Release(node);
+    }
+
+    /* For now return original topology. */
+
+    *ret_topology = output_topology;
+
+    return IMFTopology_CloneFrom(output_topology, input_topology);
 }
 
 static const IMFTopoLoaderVtbl topologyloadervtbl =
From e308d81a617632fe0fedd243952f79e8d9ec05b4 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 15 Jul 2020 15:55:47 +0300
Subject: [PATCH] mf/topoloader: Add a structure for iterative branch
 resolution.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/tests/mf.c |   9 ++-
 dlls/mf/topology.c | 138 ++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 143 insertions(+), 4 deletions(-)

diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index aa2c5199b95..f01385cc46c 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -1400,6 +1400,7 @@ static void test_topology_loader(void)
     IMFPresentationDescriptor *pd;
     IMFSourceResolver *resolver;
     IMFActivate *sink_activate;
+    IMFStreamSink *stream_sink;
     unsigned int count, value;
     IMFMediaType *media_type;
     IMFStreamDescriptor *sd;
@@ -1512,15 +1513,19 @@ todo_wine
     hr = IMFActivate_ActivateObject(sink_activate, &IID_IMFMediaSink, (void **)&sink);
     ok(hr == S_OK, "Failed to activate, hr %#x.\n", hr);
 
-    hr = IMFTopologyNode_SetObject(sink_node, (IUnknown *)sink);
+    hr = IMFMediaSink_GetStreamSinkByIndex(sink, 0, &stream_sink);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTopologyNode_SetObject(sink_node, (IUnknown *)stream_sink);
     ok(hr == S_OK, "Failed to set object, hr %#x.\n", hr);
 
+    IMFStreamSink_Release(stream_sink);
+
     hr = IMFTopology_GetCount(topology, &count);
     ok(hr == S_OK, "Failed to get attribute count, hr %#x.\n", hr);
     ok(count == 0, "Unexpected count %u.\n", count);
 
     hr = IMFTopoLoader_Load(loader, topology, &full_topology, NULL);
-todo_wine
     ok(hr == S_OK, "Failed to resolve topology, hr %#x.\n", hr);
     ok(full_topology != topology, "Unexpected instance.\n");
 
diff --git a/dlls/mf/topology.c b/dlls/mf/topology.c
index 840f1bd25f4..8032e438b73 100644
--- a/dlls/mf/topology.c
+++ b/dlls/mf/topology.c
@@ -1935,17 +1935,41 @@ static ULONG WINAPI topology_loader_Release(IMFTopoLoader *iface)
 
 struct topoloader_context
 {
+    IMFTopology *input_topology;
     IMFTopology *output_topology;
+    unsigned int marker;
     GUID key;
 };
 
+static IMFTopologyNode *topology_loader_get_node_for_marker(struct topoloader_context *context, TOPOID *id)
+{
+    IMFTopologyNode *node;
+    unsigned short i = 0;
+    unsigned int value;
+
+    while (SUCCEEDED(IMFTopology_GetNode(context->output_topology, i++, &node)))
+    {
+        if (SUCCEEDED(IMFTopologyNode_GetUINT32(node, &context->key, &value)) && value == context->marker)
+        {
+            IMFTopologyNode_GetTopoNodeID(node, id);
+            return node;
+        }
+        IMFTopologyNode_Release(node);
+    }
+
+    *id = 0;
+    return NULL;
+}
+
 static HRESULT topology_loader_clone_node(struct topoloader_context *context, IMFTopologyNode *node,
-        unsigned int marker)
+        IMFTopologyNode **ret, unsigned int marker)
 {
     IMFTopologyNode *cloned_node;
     MF_TOPOLOGY_TYPE node_type;
     HRESULT hr;
 
+    if (ret) *ret = NULL;
+
     IMFTopologyNode_GetNodeType(node, &node_type);
 
     if (FAILED(hr = MFCreateTopologyNode(node_type, &cloned_node)))
@@ -1957,17 +1981,113 @@ static HRESULT topology_loader_clone_node(struct topoloader_context *context, IM
     if (SUCCEEDED(hr))
         hr = IMFTopology_AddNode(context->output_topology, cloned_node);
 
+    if (SUCCEEDED(hr) && ret)
+    {
+        *ret = cloned_node;
+        IMFTopologyNode_AddRef(*ret);
+    }
+
     IMFTopologyNode_Release(cloned_node);
 
     return hr;
 }
 
+typedef HRESULT (*p_topology_loader_connect_func)(struct topoloader_context *context, IMFTopologyNode *upstream_node,
+        unsigned int output_index, IMFTopologyNode *downstream_node, unsigned int input_index);
+
+static HRESULT topology_loader_connect_source_node(struct topoloader_context *context, IMFTopologyNode *upstream_node,
+        unsigned int output_index, IMFTopologyNode *downstream_node, unsigned int input_index)
+{
+    FIXME("Unimplemented.\n");
+
+    return E_NOTIMPL;
+}
+
+static HRESULT topology_loader_resolve_branch(struct topoloader_context *context, IMFTopologyNode *upstream_node,
+        unsigned int output_index, IMFTopologyNode *downstream_node, unsigned input_index)
+{
+    static const p_topology_loader_connect_func connectors[MF_TOPOLOGY_TEE_NODE+1][MF_TOPOLOGY_TEE_NODE+1] =
+    {
+          /* OUTPUT */ { NULL },
+    /* SOURCESTREAM */ { topology_loader_connect_source_node, NULL, NULL, NULL },
+       /* TRANSFORM */ { NULL },
+             /* TEE */ { NULL },
+    };
+    MF_TOPOLOGY_TYPE u_type, d_type;
+    IMFTopologyNode *node;
+    TOPOID id;
+
+    /* Downstream node might have already been cloned. */
+    IMFTopologyNode_GetTopoNodeID(downstream_node, &id);
+    if (FAILED(IMFTopology_GetNodeByID(context->output_topology, id, &node)))
+        topology_loader_clone_node(context, downstream_node, &node, context->marker + 1);
+
+    IMFTopologyNode_ConnectOutput(upstream_node, output_index, node, input_index);
+
+    IMFTopologyNode_GetNodeType(upstream_node, &u_type);
+    IMFTopologyNode_GetNodeType(downstream_node, &d_type);
+
+    if (!connectors[u_type][d_type])
+    {
+        WARN("Unsupported branch kind %d -> %d.\n", u_type, d_type);
+        return E_FAIL;
+    }
+
+    return connectors[u_type][d_type](context, upstream_node, output_index, downstream_node, input_index);
+}
+
+static HRESULT topology_loader_resolve_nodes(struct topoloader_context *context, unsigned int *layer_size)
+{
+    IMFTopologyNode *downstream_node, *node, *orig_node;
+    unsigned int input_index, size = 0;
+    MF_TOPOLOGY_TYPE node_type;
+    HRESULT hr = S_OK;
+    TOPOID id;
+
+    while ((node = topology_loader_get_node_for_marker(context, &id)))
+    {
+        ++size;
+
+        IMFTopology_GetNodeByID(context->input_topology, id, &orig_node);
+
+        IMFTopologyNode_GetNodeType(node, &node_type);
+        switch (node_type)
+        {
+            case MF_TOPOLOGY_SOURCESTREAM_NODE:
+                if (FAILED(IMFTopologyNode_GetOutput(orig_node, 0, &downstream_node, &input_index)))
+                {
+                    IMFTopology_RemoveNode(context->output_topology, node);
+                    continue;
+                }
+
+                hr = topology_loader_resolve_branch(context, node, 0, downstream_node, input_index);
+                break;
+            case MF_TOPOLOGY_TRANSFORM_NODE:
+            case MF_TOPOLOGY_TEE_NODE:
+                FIXME("Unsupported node type %d.\n", node_type);
+                break;
+            default:
+                WARN("Unexpected node type %d.\n", node_type);
+        }
+
+        IMFTopologyNode_DeleteItem(node, &context->key);
+
+        if (FAILED(hr))
+            break;
+    }
+
+    *layer_size = size;
+
+    return hr;
+}
+
 static HRESULT WINAPI topology_loader_Load(IMFTopoLoader *iface, IMFTopology *input_topology,
         IMFTopology **ret_topology, IMFTopology *current_topology)
 {
     struct topoloader_context context = { 0 };
     IMFTopology *output_topology;
     MF_TOPOLOGY_TYPE node_type;
+    unsigned int layer_size;
     IMFTopologyNode *node;
     unsigned short i = 0;
     IMFStreamSink *sink;
@@ -2016,6 +2136,7 @@ static HRESULT WINAPI topology_loader_Load(IMFTopoLoader *iface, IMFTopology *in
     if (FAILED(hr = MFCreateTopology(&output_topology)))
         return hr;
 
+    context.input_topology = input_topology;
     context.output_topology = output_topology;
     memset(&context.key, 0xff, sizeof(context.key));
 
@@ -2027,13 +2148,26 @@ static HRESULT WINAPI topology_loader_Load(IMFTopoLoader *iface, IMFTopology *in
 
         if (node_type == MF_TOPOLOGY_SOURCESTREAM_NODE)
         {
-            if (FAILED(hr = topology_loader_clone_node(&context, node, 0)))
+            if (FAILED(hr = topology_loader_clone_node(&context, node, NULL, 0)))
                 WARN("Failed to clone source node, hr %#x.\n", hr);
         }
 
         IMFTopologyNode_Release(node);
     }
 
+    for (context.marker = 0;; ++context.marker)
+    {
+        if (FAILED(hr = topology_loader_resolve_nodes(&context, &layer_size)))
+        {
+            WARN("Failed to resolve for marker %u, hr %#x.\n", context.marker, hr);
+            break;
+        }
+
+        /* Reached last marker value. */
+        if (!layer_size)
+            break;
+    }
+
     /* For now return original topology. */
 
     *ret_topology = output_topology;
From deac29d411dccadcd12a815ab0a4a8cb6f5ebdee Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 17 Sep 2020 14:24:38 +0300
Subject: [PATCH] evr/mixer: Handle uninitialized input case in
 GetOutputAvailableType().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 4 +++-
 dlls/evr/tests/evr.c | 3 +++
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 70199f37a1c..710e20815ab 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -533,7 +533,9 @@ static HRESULT WINAPI video_mixer_transform_GetOutputAvailableType(IMFTransform
 
     EnterCriticalSection(&mixer->cs);
 
-    if (index >= mixer->output.type_count)
+    if (!mixer->inputs[0].media_type)
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+    else if (index >= mixer->output.type_count)
         hr = MF_E_NO_MORE_TYPES;
     else
     {
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index ecf1f850c77..a68952c42a0 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -835,6 +835,9 @@ static void test_default_mixer_type_negotiation(void)
     hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type);
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFTransform_GetOutputAvailableType(transform, 0, 0, &media_type);
+    ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
+
     hr = MFCreateMediaType(&media_type);
     ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
 
From 7c1b534a182f74835e84337e5c7ac6617755970a Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 17 Sep 2020 14:24:39 +0300
Subject: [PATCH] evr/tests: Add a test for returned input type instance.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/tests/evr.c | 14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index a68952c42a0..3e2675497a1 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -805,11 +805,11 @@ todo_wine
 
 static void test_default_mixer_type_negotiation(void)
 {
+    IMFMediaType *media_type, *media_type2;
     IDirect3DDeviceManager9 *manager;
     DXVA2_VideoProcessorCaps caps;
     IMFVideoMediaType *video_type;
     IMFVideoProcessor *processor;
-    IMFMediaType *media_type;
     IDirect3DDevice9 *device;
     IMFTransform *transform;
     GUID guid, *guids;
@@ -896,6 +896,18 @@ static void test_default_mixer_type_negotiation(void)
 todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+if (hr == S_OK)
+{
+    ok(media_type != (IMFMediaType *)video_type, "Unexpected media type instance.\n");
+    hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type2);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(media_type == media_type2, "Unexpected media type instance.\n");
+    IMFMediaType_Release(media_type);
+    IMFMediaType_Release(media_type2);
+}
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoProcessor, (void **)&processor);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
From 305aaec8773a7cbd0fdd4d12c5e0210e9cb5f33d Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 18 Sep 2020 17:25:16 +0300
Subject: [PATCH] evr/mixer: Fix error handling in output types collection
 helper.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 6 +++++-
 dlls/evr/tests/evr.c | 1 -
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 710e20815ab..e19520fa7ed 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -604,6 +604,7 @@ static HRESULT video_mixer_collect_output_types(struct video_mixer *mixer, const
             if (!(ptr = heap_realloc(rt_formats, (count + format_count) * sizeof(*rt_formats))))
             {
                 hr = E_OUTOFMEMORY;
+                count = 0;
                 CoTaskMemFree(formats);
                 break;
             }
@@ -641,12 +642,15 @@ static HRESULT video_mixer_collect_output_types(struct video_mixer *mixer, const
             mixer->output.type_count = count;
         }
         else
+        {
             hr = E_OUTOFMEMORY;
+            count = 0;
+        }
     }
 
     heap_free(rt_formats);
 
-    return hr;
+    return count ? S_OK : hr;
 }
 
 static HRESULT WINAPI video_mixer_transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *media_type, DWORD flags)
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 3e2675497a1..bf33051d6e1 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -893,7 +893,6 @@ static void test_default_mixer_type_negotiation(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFTransform_SetInputType(transform, 0, (IMFMediaType *)video_type, 0);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type);
From 622f2ce9915f1089f8e4550d6dbcfb6fb25289a6 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 24 Sep 2020 22:22:54 -0500
Subject: [PATCH] winegstreamer: Don't set the buffer offset in
 request_buffer_src().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 724ac8fd25f..9a9fe01936b 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -906,7 +906,6 @@ static GstFlowReturn request_buffer_src(GstPad *pad, GstObject *parent, guint64
         return GST_FLOW_ERROR;
     }
 
-    GST_BUFFER_OFFSET(*buf) = ofs;
     return GST_FLOW_OK;
 }
 
From 025b3de29c63e5a05f66bd5354d7e90c2ccad417 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 24 Sep 2020 22:22:55 -0500
Subject: [PATCH] winegstreamer: Avoid leaking a newly allocated buffer on
 failure in request_buffer_src().

According to the GStreamer documentation, the contents of "buffer" should be
considered undefined on failure, which means that the caller has no way of
freeing a newly allocated buffer.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 20 ++++++++++++--------
 1 file changed, 12 insertions(+), 8 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 9a9fe01936b..acb15dc9238 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -878,13 +878,14 @@ static GstFlowReturn got_data_sink(GstPad *pad, GstObject *parent, GstBuffer *bu
     return GST_FLOW_OK;
 }
 
-static GstFlowReturn request_buffer_src(GstPad *pad, GstObject *parent, guint64 ofs, guint len, GstBuffer **buf)
+static GstFlowReturn request_buffer_src(GstPad *pad, GstObject *parent, guint64 ofs, guint len, GstBuffer **buffer)
 {
     struct gstdemux *This = gst_pad_get_element_private(pad);
+    GstBuffer *new_buffer = NULL;
     HRESULT hr;
     GstMapInfo info;
 
-    TRACE("pad %p, offset %s, length %u, buffer %p.\n", pad, wine_dbgstr_longlong(ofs), len, *buf);
+    TRACE("pad %p, offset %s, length %u, buffer %p.\n", pad, wine_dbgstr_longlong(ofs), len, *buffer);
 
     if (ofs == GST_BUFFER_OFFSET_NONE)
         ofs = This->nextpullofs;
@@ -896,13 +897,16 @@ static GstFlowReturn request_buffer_src(GstPad *pad, GstObject *parent, guint64
         len = This->filesize - ofs;
     This->nextpullofs = ofs + len;
 
-    if (!*buf)
-        *buf = gst_buffer_new_and_alloc(len);
-    gst_buffer_map(*buf, &info, GST_MAP_WRITE);
+    if (!*buffer)
+        *buffer = new_buffer = gst_buffer_new_and_alloc(len);
+    gst_buffer_map(*buffer, &info, GST_MAP_WRITE);
     hr = IAsyncReader_SyncRead(This->reader, ofs, len, info.data);
-    gst_buffer_unmap(*buf, &info);
-    if (FAILED(hr)) {
-        ERR("Returned %08x\n", hr);
+    gst_buffer_unmap(*buffer, &info);
+    if (FAILED(hr))
+    {
+        ERR("Failed to read data, hr %#x.\n", hr);
+        if (new_buffer)
+            gst_buffer_unref(new_buffer);
         return GST_FLOW_ERROR;
     }
 
From a4d6ad6d493467a4937d43a4c4ada343b0ed4c25 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Mon, 28 Sep 2020 15:59:52 -0500
Subject: [PATCH] winegstreamer: Add a GstPad wrapping the media source's
 bytestream.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gst_cbs.c      |  58 +++++++++
 dlls/winegstreamer/gst_cbs.h      |  12 +-
 dlls/winegstreamer/main.c         |   3 +
 dlls/winegstreamer/media_source.c | 189 +++++++++++++++++++++++++++++-
 4 files changed, 258 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/gst_cbs.c b/dlls/winegstreamer/gst_cbs.c
index bf7103b1606..12b53bc5d68 100644
--- a/dlls/winegstreamer/gst_cbs.c
+++ b/dlls/winegstreamer/gst_cbs.c
@@ -49,6 +49,8 @@ static void CALLBACK perform_cb(TP_CALLBACK_INSTANCE *instance, void *user)
 
     if (cbdata->type < GSTDEMUX_MAX)
         perform_cb_gstdemux(cbdata);
+    else if (cbdata->type < MEDIA_SOURCE_MAX)
+        perform_cb_media_source(cbdata);
 
     pthread_mutex_lock(&cbdata->lock);
     cbdata->finished = 1;
@@ -301,3 +303,59 @@ gboolean query_sink_wrapper(GstPad *pad, GstObject *parent, GstQuery *query)
 
     return cbdata.u.query_sink_data.ret;
 }
+
+GstFlowReturn bytestream_wrapper_pull_wrapper(GstPad *pad, GstObject *parent, guint64 ofs, guint len,
+        GstBuffer **buf)
+{
+    struct cb_data cbdata = { BYTESTREAM_WRAPPER_PULL };
+
+    cbdata.u.getrange_data.pad = pad;
+    cbdata.u.getrange_data.parent = parent;
+    cbdata.u.getrange_data.ofs = ofs;
+    cbdata.u.getrange_data.len = len;
+    cbdata.u.getrange_data.buf = buf;
+
+    call_cb(&cbdata);
+
+    return cbdata.u.getrange_data.ret;
+}
+
+gboolean bytestream_query_wrapper(GstPad *pad, GstObject *parent, GstQuery *query)
+{
+    struct cb_data cbdata = { BYTESTREAM_QUERY };
+
+    cbdata.u.query_function_data.pad = pad;
+    cbdata.u.query_function_data.parent = parent;
+    cbdata.u.query_function_data.query = query;
+
+    call_cb(&cbdata);
+
+    return cbdata.u.query_function_data.ret;
+}
+
+gboolean bytestream_pad_mode_activate_wrapper(GstPad *pad, GstObject *parent, GstPadMode mode, gboolean activate)
+{
+    struct cb_data cbdata = { BYTESTREAM_PAD_MODE_ACTIVATE };
+
+    cbdata.u.activate_mode_data.pad = pad;
+    cbdata.u.activate_mode_data.parent = parent;
+    cbdata.u.activate_mode_data.mode = mode;
+    cbdata.u.activate_mode_data.activate = activate;
+
+    call_cb(&cbdata);
+
+    return cbdata.u.activate_mode_data.ret;
+}
+
+gboolean bytestream_pad_event_process_wrapper(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    struct cb_data cbdata = { BYTESTREAM_PAD_EVENT_PROCESS };
+
+    cbdata.u.event_src_data.pad = pad;
+    cbdata.u.event_src_data.parent = parent;
+    cbdata.u.event_src_data.event = event;
+
+    call_cb(&cbdata);
+
+    return cbdata.u.event_src_data.ret;
+}
diff --git a/dlls/winegstreamer/gst_cbs.h b/dlls/winegstreamer/gst_cbs.h
index 4725f23ad1a..3459a9ef8ee 100644
--- a/dlls/winegstreamer/gst_cbs.h
+++ b/dlls/winegstreamer/gst_cbs.h
@@ -43,7 +43,12 @@ enum CB_TYPE {
     AUTOPLUG_BLACKLIST,
     UNKNOWN_TYPE,
     QUERY_SINK,
-    GSTDEMUX_MAX
+    GSTDEMUX_MAX,
+    BYTESTREAM_WRAPPER_PULL,
+    BYTESTREAM_QUERY,
+    BYTESTREAM_PAD_MODE_ACTIVATE,
+    BYTESTREAM_PAD_EVENT_PROCESS,
+    MEDIA_SOURCE_MAX,
 };
 
 struct cb_data {
@@ -138,6 +143,7 @@ struct cb_data {
 
 void mark_wine_thread(void) DECLSPEC_HIDDEN;
 void perform_cb_gstdemux(struct cb_data *data) DECLSPEC_HIDDEN;
+void perform_cb_media_source(struct cb_data *data) DECLSPEC_HIDDEN;
 
 GstBusSyncReply watch_bus_wrapper(GstBus *bus, GstMessage *msg, gpointer user) DECLSPEC_HIDDEN;
 void existing_new_pad_wrapper(GstElement *bin, GstPad *pad, gpointer user) DECLSPEC_HIDDEN;
@@ -154,5 +160,9 @@ GstAutoplugSelectResult autoplug_blacklist_wrapper(GstElement *bin, GstPad *pad,
 void unknown_type_wrapper(GstElement *bin, GstPad *pad, GstCaps *caps, gpointer user) DECLSPEC_HIDDEN;
 void Gstreamer_transform_pad_added_wrapper(GstElement *filter, GstPad *pad, gpointer user) DECLSPEC_HIDDEN;
 gboolean query_sink_wrapper(GstPad *pad, GstObject *parent, GstQuery *query) DECLSPEC_HIDDEN;
+GstFlowReturn bytestream_wrapper_pull_wrapper(GstPad *pad, GstObject *parent, guint64 ofs, guint len, GstBuffer **buf) DECLSPEC_HIDDEN;
+gboolean bytestream_query_wrapper(GstPad *pad, GstObject *parent, GstQuery *query) DECLSPEC_HIDDEN;
+gboolean bytestream_pad_mode_activate_wrapper(GstPad *pad, GstObject *parent, GstPadMode mode, gboolean activate) DECLSPEC_HIDDEN;
+gboolean bytestream_pad_event_process_wrapper(GstPad *pad, GstObject *parent, GstEvent *event) DECLSPEC_HIDDEN;
 
 #endif
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index 2872710b3e2..4ca371d58bd 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -146,6 +146,9 @@ HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **out)
 
     TRACE("clsid %s, iid %s, out %p.\n", debugstr_guid(clsid), debugstr_guid(iid), out);
 
+    if (!init_gstreamer())
+        return CLASS_E_CLASSNOTAVAILABLE;
+
     if (SUCCEEDED(hr = mfplat_get_class_object(clsid, iid, out)))
         return hr;
 
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index f365c8a1827..1accf55c6a2 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -17,9 +17,15 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+
+#include <gst/gst.h>
+
 #include "gst_private.h"
+#include "gst_cbs.h"
 
 #include <stdarg.h>
+#include <assert.h>
 
 #define COBJMACROS
 #define NONAMELESSUNION
@@ -27,6 +33,7 @@
 #include "mfapi.h"
 #include "mferror.h"
 #include "mfidl.h"
+#include "mfobjects.h"
 
 #include "wine/debug.h"
 #include "wine/heap.h"
@@ -39,6 +46,8 @@ struct media_source
     IMFMediaSource IMFMediaSource_iface;
     LONG ref;
     IMFMediaEventQueue *event_queue;
+    IMFByteStream *byte_stream;
+    GstPad *my_src;
     enum
     {
         SOURCE_OPENING,
@@ -52,6 +61,127 @@ static inline struct media_source *impl_from_IMFMediaSource(IMFMediaSource *ifac
     return CONTAINING_RECORD(iface, struct media_source, IMFMediaSource_iface);
 }
 
+static GstFlowReturn bytestream_wrapper_pull(GstPad *pad, GstObject *parent, guint64 ofs, guint len,
+        GstBuffer **buf)
+{
+    struct media_source *source = gst_pad_get_element_private(pad);
+    IMFByteStream *byte_stream = source->byte_stream;
+    ULONG bytes_read;
+    GstMapInfo info;
+    BOOL is_eof;
+    HRESULT hr;
+
+    TRACE("requesting %u bytes at %s from source %p into buffer %p\n", len, wine_dbgstr_longlong(ofs), source, *buf);
+
+    if (ofs != GST_BUFFER_OFFSET_NONE)
+    {
+        if (FAILED(IMFByteStream_SetCurrentPosition(byte_stream, ofs)))
+            return GST_FLOW_ERROR;
+    }
+
+    if (FAILED(IMFByteStream_IsEndOfStream(byte_stream, &is_eof)))
+        return GST_FLOW_ERROR;
+    if (is_eof)
+        return GST_FLOW_EOS;
+
+    if (!(*buf))
+        *buf = gst_buffer_new_and_alloc(len);
+    gst_buffer_map(*buf, &info, GST_MAP_WRITE);
+    hr = IMFByteStream_Read(byte_stream, info.data, len, &bytes_read);
+    gst_buffer_unmap(*buf, &info);
+
+    gst_buffer_set_size(*buf, bytes_read);
+
+    if (FAILED(hr))
+        return GST_FLOW_ERROR;
+    return GST_FLOW_OK;
+}
+
+static gboolean bytestream_query(GstPad *pad, GstObject *parent, GstQuery *query)
+{
+    struct media_source *source = gst_pad_get_element_private(pad);
+    GstFormat format;
+    QWORD bytestream_len;
+
+    TRACE("GStreamer queries source %p for %s\n", source, GST_QUERY_TYPE_NAME(query));
+
+    if (FAILED(IMFByteStream_GetLength(source->byte_stream, &bytestream_len)))
+        return FALSE;
+
+    switch (GST_QUERY_TYPE(query))
+    {
+        case GST_QUERY_DURATION:
+        {
+            gst_query_parse_duration(query, &format, NULL);
+            if (format == GST_FORMAT_PERCENT)
+            {
+                gst_query_set_duration(query, GST_FORMAT_PERCENT, GST_FORMAT_PERCENT_MAX);
+                return TRUE;
+            }
+            else if (format == GST_FORMAT_BYTES)
+            {
+                QWORD length;
+                IMFByteStream_GetLength(source->byte_stream, &length);
+                gst_query_set_duration(query, GST_FORMAT_BYTES, length);
+                return TRUE;
+            }
+            return FALSE;
+        }
+        case GST_QUERY_SEEKING:
+        {
+            gst_query_parse_seeking (query, &format, NULL, NULL, NULL);
+            if (format != GST_FORMAT_BYTES)
+            {
+                WARN("Cannot seek using format \"%s\".\n", gst_format_get_name(format));
+                return FALSE;
+            }
+            gst_query_set_seeking(query, GST_FORMAT_BYTES, 1, 0, bytestream_len);
+            return TRUE;
+        }
+        case GST_QUERY_SCHEDULING:
+        {
+            gst_query_set_scheduling(query, GST_SCHEDULING_FLAG_SEEKABLE, 1, -1, 0);
+            gst_query_add_scheduling_mode(query, GST_PAD_MODE_PULL);
+            return TRUE;
+        }
+        default:
+        {
+            WARN("Unhandled query type %s\n", GST_QUERY_TYPE_NAME(query));
+            return FALSE;
+        }
+    }
+}
+
+static gboolean bytestream_pad_mode_activate(GstPad *pad, GstObject *parent, GstPadMode mode, gboolean activate)
+{
+    struct media_source *source = gst_pad_get_element_private(pad);
+
+    TRACE("%s source pad for mediasource %p in %s mode.\n",
+            activate ? "Activating" : "Deactivating", source, gst_pad_mode_get_name(mode));
+
+    return mode == GST_PAD_MODE_PULL;
+}
+
+static gboolean bytestream_pad_event_process(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    struct media_source *source = gst_pad_get_element_private(pad);
+
+    TRACE("source %p, type \"%s\".\n", source, GST_EVENT_TYPE_NAME(event));
+
+    switch (event->type) {
+        /* the seek event should fail in pull mode */
+        case GST_EVENT_SEEK:
+            return FALSE;
+        default:
+            WARN("Ignoring \"%s\" event.\n", GST_EVENT_TYPE_NAME(event));
+        case GST_EVENT_TAG:
+        case GST_EVENT_QOS:
+        case GST_EVENT_RECONFIGURE:
+            return gst_pad_event_default(pad, parent, event);
+    }
+    return TRUE;
+}
+
 static HRESULT WINAPI media_source_QueryInterface(IMFMediaSource *iface, REFIID riid, void **out)
 {
     struct media_source *source = impl_from_IMFMediaSource(iface);
@@ -211,8 +341,12 @@ static HRESULT WINAPI media_source_Shutdown(IMFMediaSource *iface)
 
     source->state = SOURCE_SHUTDOWN;
 
+    if (source->my_src)
+        gst_object_unref(GST_OBJECT(source->my_src));
     if (source->event_queue)
         IMFMediaEventQueue_Shutdown(source->event_queue);
+    if (source->byte_stream)
+        IMFByteStream_Release(source->byte_stream);
 
     return S_OK;
 }
@@ -236,19 +370,31 @@ static const IMFMediaSourceVtbl IMFMediaSource_vtbl =
 
 static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_source **out_media_source)
 {
+    GstStaticPadTemplate src_template =
+        GST_STATIC_PAD_TEMPLATE("mf_src", GST_PAD_SRC, GST_PAD_ALWAYS, GST_STATIC_CAPS_ANY);
+
     struct media_source *object = heap_alloc_zero(sizeof(*object));
     HRESULT hr;
 
     if (!object)
         return E_OUTOFMEMORY;
 
+    object->IMFMediaSource_iface.lpVtbl = &IMFMediaSource_vtbl;
+    object->ref = 1;
+    object->byte_stream = bytestream;
+    IMFByteStream_AddRef(bytestream);
+
     if (FAILED(hr = MFCreateEventQueue(&object->event_queue)))
         goto fail;
 
-    object->state = SOURCE_STOPPED;
+    object->my_src = gst_pad_new_from_static_template(&src_template, "mf-src");
+    gst_pad_set_element_private(object->my_src, object);
+    gst_pad_set_getrange_function(object->my_src, bytestream_wrapper_pull_wrapper);
+    gst_pad_set_query_function(object->my_src, bytestream_query_wrapper);
+    gst_pad_set_activatemode_function(object->my_src, bytestream_pad_mode_activate_wrapper);
+    gst_pad_set_event_function(object->my_src, bytestream_pad_event_process_wrapper);
 
-    object->IMFMediaSource_iface.lpVtbl = &IMFMediaSource_vtbl;
-    object->ref = 1;
+    object->state = SOURCE_STOPPED;
 
     *out_media_source = object;
     return S_OK;
@@ -716,3 +862,40 @@ HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj)
 
     return hr;
 }
+
+/* helper for callback forwarding */
+void perform_cb_media_source(struct cb_data *cbdata)
+{
+    switch(cbdata->type)
+    {
+    case BYTESTREAM_WRAPPER_PULL:
+        {
+            struct getrange_data *data = &cbdata->u.getrange_data;
+            cbdata->u.getrange_data.ret = bytestream_wrapper_pull(data->pad, data->parent,
+                    data->ofs, data->len, data->buf);
+            break;
+        }
+    case BYTESTREAM_QUERY:
+        {
+            struct query_function_data *data = &cbdata->u.query_function_data;
+            cbdata->u.query_function_data.ret = bytestream_query(data->pad, data->parent, data->query);
+            break;
+        }
+    case BYTESTREAM_PAD_MODE_ACTIVATE:
+        {
+            struct activate_mode_data *data = &cbdata->u.activate_mode_data;
+            cbdata->u.activate_mode_data.ret = bytestream_pad_mode_activate(data->pad, data->parent, data->mode, data->activate);
+            break;
+        }
+    case BYTESTREAM_PAD_EVENT_PROCESS:
+        {
+            struct event_src_data *data = &cbdata->u.event_src_data;
+            cbdata->u.event_src_data.ret = bytestream_pad_event_process(data->pad, data->parent, data->event);
+            break;
+        }
+    default:
+        {
+            assert(0);
+        }
+    }
+}
From 7d4395a00e6a5222dae859746b61ab68039a8e3e Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Mon, 28 Sep 2020 15:59:53 -0500
Subject: [PATCH] winegstreamer: Use decodebin to initialize media streams.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gst_cbs.c      |  45 ++++
 dlls/winegstreamer/gst_cbs.h      |   8 +
 dlls/winegstreamer/media_source.c | 401 +++++++++++++++++++++++++++++-
 3 files changed, 453 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/gst_cbs.c b/dlls/winegstreamer/gst_cbs.c
index 12b53bc5d68..51aaefa911d 100644
--- a/dlls/winegstreamer/gst_cbs.c
+++ b/dlls/winegstreamer/gst_cbs.c
@@ -359,3 +359,48 @@ gboolean bytestream_pad_event_process_wrapper(GstPad *pad, GstObject *parent, Gs
 
     return cbdata.u.event_src_data.ret;
 }
+
+GstBusSyncReply mf_src_bus_watch_wrapper(GstBus *bus, GstMessage *message, gpointer user)
+{
+    struct cb_data cbdata = { MF_SRC_BUS_WATCH };
+
+    cbdata.u.watch_bus_data.bus = bus;
+    cbdata.u.watch_bus_data.msg = message;
+    cbdata.u.watch_bus_data.user = user;
+
+    call_cb(&cbdata);
+
+    return cbdata.u.watch_bus_data.ret;
+}
+
+void mf_src_stream_added_wrapper(GstElement *bin, GstPad *pad, gpointer user)
+{
+    struct cb_data cbdata = { MF_SRC_STREAM_ADDED };
+
+    cbdata.u.pad_added_data.element = bin;
+    cbdata.u.pad_added_data.pad = pad;
+    cbdata.u.pad_added_data.user = user;
+
+    call_cb(&cbdata);
+}
+
+void mf_src_stream_removed_wrapper(GstElement *element, GstPad *pad, gpointer user)
+{
+    struct cb_data cbdata = { MF_SRC_STREAM_REMOVED };
+
+    cbdata.u.pad_removed_data.element = element;
+    cbdata.u.pad_removed_data.pad = pad;
+    cbdata.u.pad_removed_data.user = user;
+
+    call_cb(&cbdata);
+}
+
+void mf_src_no_more_pads_wrapper(GstElement *element, gpointer user)
+{
+    struct cb_data cbdata = { MF_SRC_NO_MORE_PADS };
+
+    cbdata.u.no_more_pads_data.element = element;
+    cbdata.u.no_more_pads_data.user = user;
+
+    call_cb(&cbdata);
+}
diff --git a/dlls/winegstreamer/gst_cbs.h b/dlls/winegstreamer/gst_cbs.h
index 3459a9ef8ee..a48999bbf71 100644
--- a/dlls/winegstreamer/gst_cbs.h
+++ b/dlls/winegstreamer/gst_cbs.h
@@ -48,6 +48,10 @@ enum CB_TYPE {
     BYTESTREAM_QUERY,
     BYTESTREAM_PAD_MODE_ACTIVATE,
     BYTESTREAM_PAD_EVENT_PROCESS,
+    MF_SRC_BUS_WATCH,
+    MF_SRC_STREAM_ADDED,
+    MF_SRC_STREAM_REMOVED,
+    MF_SRC_NO_MORE_PADS,
     MEDIA_SOURCE_MAX,
 };
 
@@ -164,5 +168,9 @@ GstFlowReturn bytestream_wrapper_pull_wrapper(GstPad *pad, GstObject *parent, gu
 gboolean bytestream_query_wrapper(GstPad *pad, GstObject *parent, GstQuery *query) DECLSPEC_HIDDEN;
 gboolean bytestream_pad_mode_activate_wrapper(GstPad *pad, GstObject *parent, GstPadMode mode, gboolean activate) DECLSPEC_HIDDEN;
 gboolean bytestream_pad_event_process_wrapper(GstPad *pad, GstObject *parent, GstEvent *event) DECLSPEC_HIDDEN;
+GstBusSyncReply mf_src_bus_watch_wrapper(GstBus *bus, GstMessage *message, gpointer user) DECLSPEC_HIDDEN;
+void mf_src_stream_added_wrapper(GstElement *bin, GstPad *pad, gpointer user) DECLSPEC_HIDDEN;
+void mf_src_stream_removed_wrapper(GstElement *element, GstPad *pad, gpointer user) DECLSPEC_HIDDEN;
+void mf_src_no_more_pads_wrapper(GstElement *element, gpointer user) DECLSPEC_HIDDEN;
 
 #endif
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 1accf55c6a2..6a63db4f584 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -24,6 +24,7 @@
 #include "gst_private.h"
 #include "gst_cbs.h"
 
+#include <assert.h>
 #include <stdarg.h>
 #include <assert.h>
 
@@ -41,21 +42,47 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+struct media_stream
+{
+    IMFMediaStream IMFMediaStream_iface;
+    LONG ref;
+    struct media_source *parent_source;
+    IMFMediaEventQueue *event_queue;
+    GstElement *appsink;
+    GstPad *their_src, *my_sink;
+    enum
+    {
+        STREAM_INACTIVE,
+        STREAM_SHUTDOWN,
+    } state;
+};
+
 struct media_source
 {
     IMFMediaSource IMFMediaSource_iface;
     LONG ref;
     IMFMediaEventQueue *event_queue;
     IMFByteStream *byte_stream;
-    GstPad *my_src;
+    struct media_stream **streams;
+    ULONG stream_count;
+    GstBus *bus;
+    GstElement *container;
+    GstElement *decodebin;
+    GstPad *my_src, *their_sink;
     enum
     {
         SOURCE_OPENING,
         SOURCE_STOPPED,
         SOURCE_SHUTDOWN,
     } state;
+    HANDLE no_more_pads_event;
 };
 
+static inline struct media_stream *impl_from_IMFMediaStream(IMFMediaStream *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_stream, IMFMediaStream_iface);
+}
+
 static inline struct media_source *impl_from_IMFMediaSource(IMFMediaSource *iface)
 {
     return CONTAINING_RECORD(iface, struct media_source, IMFMediaSource_iface);
@@ -182,6 +209,224 @@ static gboolean bytestream_pad_event_process(GstPad *pad, GstObject *parent, Gst
     return TRUE;
 }
 
+GstBusSyncReply bus_watch(GstBus *bus, GstMessage *message, gpointer user)
+{
+    struct media_source *source = user;
+    gchar *dbg_info = NULL;
+    GError *err = NULL;
+
+    TRACE("source %p message type %s\n", source, GST_MESSAGE_TYPE_NAME(message));
+
+    switch (message->type)
+    {
+        case GST_MESSAGE_ERROR:
+            gst_message_parse_error(message, &err, &dbg_info);
+            ERR("%s: %s\n", GST_OBJECT_NAME(message->src), err->message);
+            ERR("%s\n", dbg_info);
+            g_error_free(err);
+            g_free(dbg_info);
+            break;
+        case GST_MESSAGE_WARNING:
+            gst_message_parse_warning(message, &err, &dbg_info);
+            WARN("%s: %s\n", GST_OBJECT_NAME(message->src), err->message);
+            WARN("%s\n", dbg_info);
+            g_error_free(err);
+            g_free(dbg_info);
+            break;
+        default:
+            break;
+    }
+
+    gst_message_unref(message);
+    return GST_BUS_DROP;
+}
+
+static HRESULT WINAPI media_stream_QueryInterface(IMFMediaStream *iface, REFIID riid, void **out)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("(%p)->(%s %p)\n", stream, debugstr_guid(riid), out);
+
+    if (IsEqualIID(riid, &IID_IMFMediaStream) ||
+        IsEqualIID(riid, &IID_IMFMediaEventGenerator) ||
+        IsEqualIID(riid, &IID_IUnknown))
+    {
+        *out = &stream->IMFMediaStream_iface;
+    }
+    else
+    {
+        FIXME("(%s, %p)\n", debugstr_guid(riid), out);
+        *out = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI media_stream_AddRef(IMFMediaStream *iface)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+    ULONG ref = InterlockedIncrement(&stream->ref);
+
+    TRACE("(%p) ref=%u\n", stream, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI media_stream_Release(IMFMediaStream *iface)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    ULONG ref = InterlockedDecrement(&stream->ref);
+
+    TRACE("(%p) ref=%u\n", stream, ref);
+
+    if (!ref)
+    {
+        if (stream->event_queue)
+            IMFMediaEventQueue_Release(stream->event_queue);
+        heap_free(stream);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI media_stream_GetEvent(IMFMediaStream *iface, DWORD flags, IMFMediaEvent **event)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("(%p)->(%#x, %p)\n", stream, flags, event);
+
+    return IMFMediaEventQueue_GetEvent(stream->event_queue, flags, event);
+}
+
+static HRESULT WINAPI media_stream_BeginGetEvent(IMFMediaStream *iface, IMFAsyncCallback *callback, IUnknown *state)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("(%p)->(%p, %p)\n", stream, callback, state);
+
+    return IMFMediaEventQueue_BeginGetEvent(stream->event_queue, callback, state);
+}
+
+static HRESULT WINAPI media_stream_EndGetEvent(IMFMediaStream *iface, IMFAsyncResult *result, IMFMediaEvent **event)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("(%p)->(%p, %p)\n", stream, result, event);
+
+    return IMFMediaEventQueue_EndGetEvent(stream->event_queue, result, event);
+}
+
+static HRESULT WINAPI media_stream_QueueEvent(IMFMediaStream *iface, MediaEventType event_type, REFGUID ext_type,
+        HRESULT hr, const PROPVARIANT *value)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("(%p)->(%d, %s, %#x, %p)\n", stream, event_type, debugstr_guid(ext_type), hr, value);
+
+    return IMFMediaEventQueue_QueueEventParamVar(stream->event_queue, event_type, ext_type, hr, value);
+}
+
+static HRESULT WINAPI media_stream_GetMediaSource(IMFMediaStream *iface, IMFMediaSource **source)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    FIXME("stub (%p)->(%p)\n", stream, source);
+
+    if (stream->state == STREAM_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_stream_GetStreamDescriptor(IMFMediaStream* iface, IMFStreamDescriptor **descriptor)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("(%p)->(%p)\n", stream, descriptor);
+
+    if (stream->state == STREAM_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_stream_RequestSample(IMFMediaStream *iface, IUnknown *token)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("(%p)->(%p)\n", iface, token);
+
+    if (stream->state == STREAM_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    return E_NOTIMPL;
+}
+
+static const IMFMediaStreamVtbl media_stream_vtbl =
+{
+    media_stream_QueryInterface,
+    media_stream_AddRef,
+    media_stream_Release,
+    media_stream_GetEvent,
+    media_stream_BeginGetEvent,
+    media_stream_EndGetEvent,
+    media_stream_QueueEvent,
+    media_stream_GetMediaSource,
+    media_stream_GetStreamDescriptor,
+    media_stream_RequestSample
+};
+
+static HRESULT new_media_stream(struct media_source *source, GstPad *pad, struct media_stream **out_stream)
+{
+    struct media_stream *object = heap_alloc_zero(sizeof(*object));
+    HRESULT hr;
+
+    TRACE("(%p %p)->(%p)\n", source, pad, out_stream);
+
+    object->IMFMediaStream_iface.lpVtbl = &media_stream_vtbl;
+    object->ref = 1;
+
+    IMFMediaSource_AddRef(&source->IMFMediaSource_iface);
+    object->parent_source = source;
+    object->their_src = pad;
+
+    object->state = STREAM_INACTIVE;
+
+    if (FAILED(hr = MFCreateEventQueue(&object->event_queue)))
+        goto fail;
+
+    if (!(object->appsink = gst_element_factory_make("appsink", NULL)))
+    {
+        hr = E_OUTOFMEMORY;
+        goto fail;
+    }
+    gst_bin_add(GST_BIN(object->parent_source->container), object->appsink);
+
+    g_object_set(object->appsink, "sync", FALSE, NULL);
+    g_object_set(object->appsink, "max-buffers", 5, NULL);
+
+    object->my_sink = gst_element_get_static_pad(object->appsink, "sink");
+    gst_pad_set_element_private(object->my_sink, object);
+
+    gst_pad_link(object->their_src, object->my_sink);
+
+    gst_element_sync_state_with_parent(object->appsink);
+
+    TRACE("->(%p)\n", object);
+    *out_stream = object;
+
+    return S_OK;
+
+fail:
+    WARN("Failed to construct media stream, hr %#x.\n", hr);
+
+    IMFMediaStream_Release(&object->IMFMediaStream_iface);
+    return hr;
+}
+
 static HRESULT WINAPI media_source_QueryInterface(IMFMediaSource *iface, REFIID riid, void **out)
 {
     struct media_source *source = impl_from_IMFMediaSource(iface);
@@ -333,6 +578,7 @@ static HRESULT WINAPI media_source_Pause(IMFMediaSource *iface)
 static HRESULT WINAPI media_source_Shutdown(IMFMediaSource *iface)
 {
     struct media_source *source = impl_from_IMFMediaSource(iface);
+    unsigned int i;
 
     TRACE("(%p)\n", source);
 
@@ -341,13 +587,44 @@ static HRESULT WINAPI media_source_Shutdown(IMFMediaSource *iface)
 
     source->state = SOURCE_SHUTDOWN;
 
+    if (source->container)
+    {
+        gst_element_set_state(source->container, GST_STATE_NULL);
+        gst_object_unref(GST_OBJECT(source->container));
+    }
+
     if (source->my_src)
         gst_object_unref(GST_OBJECT(source->my_src));
+    if (source->their_sink)
+        gst_object_unref(GST_OBJECT(source->their_sink));
+
     if (source->event_queue)
         IMFMediaEventQueue_Shutdown(source->event_queue);
     if (source->byte_stream)
         IMFByteStream_Release(source->byte_stream);
 
+    for (i = 0; i < source->stream_count; i++)
+    {
+        struct media_stream *stream = source->streams[i];
+
+        stream->state = STREAM_SHUTDOWN;
+
+        if (stream->my_sink)
+            gst_object_unref(GST_OBJECT(stream->my_sink));
+        if (stream->event_queue)
+            IMFMediaEventQueue_Shutdown(stream->event_queue);
+        if (stream->parent_source)
+            IMFMediaSource_Release(&stream->parent_source->IMFMediaSource_iface);
+
+        IMFMediaStream_Release(&stream->IMFMediaStream_iface);
+    }
+
+    if (source->stream_count)
+        heap_free(source->streams);
+
+    if (source->no_more_pads_event)
+        CloseHandle(source->no_more_pads_event);
+
     return S_OK;
 }
 
@@ -368,6 +645,50 @@ static const IMFMediaSourceVtbl IMFMediaSource_vtbl =
     media_source_Shutdown,
 };
 
+static void stream_added(GstElement *element, GstPad *pad, gpointer user)
+{
+    struct media_source *source = user;
+    struct media_stream **new_stream_array;
+    struct media_stream *stream;
+
+    if (gst_pad_get_direction(pad) != GST_PAD_SRC)
+        return;
+
+    if (FAILED(new_media_stream(source, pad, &stream)))
+        return;
+
+    if (!(new_stream_array = heap_realloc(source->streams, (source->stream_count + 1) * (sizeof(*new_stream_array)))))
+    {
+        ERR("Failed to add stream to source\n");
+        IMFMediaStream_Release(&stream->IMFMediaStream_iface);
+        return;
+    }
+
+    source->streams = new_stream_array;
+    source->streams[source->stream_count++] = stream;
+}
+
+static void stream_removed(GstElement *element, GstPad *pad, gpointer user)
+{
+    struct media_source *source = user;
+    unsigned int i;
+
+    for (i = 0; i < source->stream_count; i++)
+    {
+        struct media_stream *stream = source->streams[i];
+        if (stream->their_src != pad)
+            continue;
+        stream->their_src = NULL;
+    }
+}
+
+static void no_more_pads(GstElement *element, gpointer user)
+{
+    struct media_source *source = user;
+
+    SetEvent(source->no_more_pads_event);
+}
+
 static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_source **out_media_source)
 {
     GstStaticPadTemplate src_template =
@@ -375,6 +696,7 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
 
     struct media_source *object = heap_alloc_zero(sizeof(*object));
     HRESULT hr;
+    int ret;
 
     if (!object)
         return E_OUTOFMEMORY;
@@ -383,10 +705,16 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
     object->ref = 1;
     object->byte_stream = bytestream;
     IMFByteStream_AddRef(bytestream);
+    object->no_more_pads_event = CreateEventA(NULL, FALSE, FALSE, NULL);
 
     if (FAILED(hr = MFCreateEventQueue(&object->event_queue)))
         goto fail;
 
+    object->container = gst_bin_new(NULL);
+    object->bus = gst_bus_new();
+    gst_bus_set_sync_handler(object->bus, mf_src_bus_watch_wrapper, object, NULL);
+    gst_element_set_bus(object->container, object->bus);
+
     object->my_src = gst_pad_new_from_static_template(&src_template, "mf-src");
     gst_pad_set_element_private(object->my_src, object);
     gst_pad_set_getrange_function(object->my_src, bytestream_wrapper_pull_wrapper);
@@ -394,6 +722,53 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
     gst_pad_set_activatemode_function(object->my_src, bytestream_pad_mode_activate_wrapper);
     gst_pad_set_event_function(object->my_src, bytestream_pad_event_process_wrapper);
 
+    if (!(object->decodebin = gst_element_factory_make("decodebin", NULL)))
+    {
+        WARN("Failed to create decodebin for source\n");
+        hr = E_OUTOFMEMORY;
+        goto fail;
+    }
+
+    /* In Media Foundation, sources may read from any media source stream
+       without fear of blocking due to buffering limits on another.  Trailmakers,
+       a Unity3D engine game does this by only reading from the audio stream once,
+       and never deselecting this.  These properties replicate that behavior.
+
+       Note that with most elements, this causes excessive memory use, however
+       this is also what occurs on Windows.
+    */
+    g_object_set(object->decodebin, "max-size-buffers", 0, NULL);
+    g_object_set(object->decodebin, "max-size-time", G_GUINT64_CONSTANT(0), NULL);
+    g_object_set(object->decodebin, "max-size-bytes", 0, NULL);
+
+    gst_bin_add(GST_BIN(object->container), object->decodebin);
+
+    g_signal_connect(object->decodebin, "pad-added", G_CALLBACK(mf_src_stream_added_wrapper), object);
+    g_signal_connect(object->decodebin, "pad-removed", G_CALLBACK(mf_src_stream_removed_wrapper), object);
+    g_signal_connect(object->decodebin, "no-more-pads", G_CALLBACK(mf_src_no_more_pads_wrapper), object);
+
+    object->their_sink = gst_element_get_static_pad(object->decodebin, "sink");
+
+    if ((ret = gst_pad_link(object->my_src, object->their_sink)) < 0)
+    {
+        WARN("Failed to link our bytestream pad to the demuxer input, error %d.\n", ret);
+        hr = E_FAIL;
+        goto fail;
+    }
+
+    object->state = SOURCE_OPENING;
+
+    gst_element_set_state(object->container, GST_STATE_PAUSED);
+    ret = gst_element_get_state(object->container, NULL, NULL, -1);
+    if (ret == GST_STATE_CHANGE_FAILURE)
+    {
+        ERR("Failed to play source, error %d.\n", ret);
+        hr = E_FAIL;
+        goto fail;
+    }
+
+    WaitForSingleObject(object->no_more_pads_event, INFINITE);
+
     object->state = SOURCE_STOPPED;
 
     *out_media_source = object;
@@ -893,6 +1268,30 @@ void perform_cb_media_source(struct cb_data *cbdata)
             cbdata->u.event_src_data.ret = bytestream_pad_event_process(data->pad, data->parent, data->event);
             break;
         }
+    case MF_SRC_BUS_WATCH:
+        {
+            struct watch_bus_data *data = &cbdata->u.watch_bus_data;
+            cbdata->u.watch_bus_data.ret = bus_watch(data->bus, data->msg, data->user);
+            break;
+        }
+    case MF_SRC_STREAM_ADDED:
+        {
+            struct pad_added_data *data = &cbdata->u.pad_added_data;
+            stream_added(data->element, data->pad, data->user);
+            break;
+        }
+    case MF_SRC_STREAM_REMOVED:
+        {
+            struct pad_removed_data *data = &cbdata->u.pad_removed_data;
+            stream_removed(data->element, data->pad, data->user);
+            break;
+        }
+    case MF_SRC_NO_MORE_PADS:
+        {
+            struct no_more_pads_data *data = &cbdata->u.no_more_pads_data;
+            no_more_pads(data->element, data->user);
+            break;
+        }
     default:
         {
             assert(0);
From 4228016b0cb79b04e00b34acb6087a6e381fd41c Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Mon, 28 Sep 2020 15:59:54 -0500
Subject: [PATCH] winegstreamer: Implement IMFMediaStream::GetStreamDescriptor.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gst_private.h  |   4 +
 dlls/winegstreamer/media_source.c |  59 ++++++++++-
 dlls/winegstreamer/mfplat.c       | 165 ++++++++++++++++++++++++++++++
 3 files changed, 223 insertions(+), 5 deletions(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index ef07d3591e7..60b38a48f5a 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -36,6 +36,7 @@
 #include "winuser.h"
 #include "dshow.h"
 #include "strmif.h"
+#include "mfobjects.h"
 #include "wine/heap.h"
 #include "wine/strmbase.h"
 
@@ -54,6 +55,9 @@ void start_dispatch_thread(void) DECLSPEC_HIDDEN;
 
 extern HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj) DECLSPEC_HIDDEN;
 
+HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj) DECLSPEC_HIDDEN;
+IMFMediaType *mf_media_type_from_caps(const GstCaps *caps) DECLSPEC_HIDDEN;
+
 HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj) DECLSPEC_HIDDEN;
 
 #endif /* __GST_PRIVATE_INCLUDED__ */
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 6a63db4f584..5f3c43a0204 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -48,6 +48,7 @@ struct media_stream
     LONG ref;
     struct media_source *parent_source;
     IMFMediaEventQueue *event_queue;
+    IMFStreamDescriptor *descriptor;
     GstElement *appsink;
     GstPad *their_src, *my_sink;
     enum
@@ -55,6 +56,7 @@ struct media_stream
         STREAM_INACTIVE,
         STREAM_SHUTDOWN,
     } state;
+    DWORD stream_id;
 };
 
 struct media_source
@@ -350,7 +352,10 @@ static HRESULT WINAPI media_stream_GetStreamDescriptor(IMFMediaStream* iface, IM
     if (stream->state == STREAM_SHUTDOWN)
         return MF_E_SHUTDOWN;
 
-    return E_NOTIMPL;
+    IMFStreamDescriptor_AddRef(stream->descriptor);
+    *descriptor = stream->descriptor;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI media_stream_RequestSample(IMFMediaStream *iface, IUnknown *token)
@@ -379,7 +384,7 @@ static const IMFMediaStreamVtbl media_stream_vtbl =
     media_stream_RequestSample
 };
 
-static HRESULT new_media_stream(struct media_source *source, GstPad *pad, struct media_stream **out_stream)
+static HRESULT new_media_stream(struct media_source *source, GstPad *pad, DWORD stream_id, struct media_stream **out_stream)
 {
     struct media_stream *object = heap_alloc_zero(sizeof(*object));
     HRESULT hr;
@@ -392,6 +397,7 @@ static HRESULT new_media_stream(struct media_source *source, GstPad *pad, struct
     IMFMediaSource_AddRef(&source->IMFMediaSource_iface);
     object->parent_source = source;
     object->their_src = pad;
+    object->stream_id = stream_id;
 
     object->state = STREAM_INACTIVE;
 
@@ -409,8 +415,6 @@ static HRESULT new_media_stream(struct media_source *source, GstPad *pad, struct
     g_object_set(object->appsink, "max-buffers", 5, NULL);
 
     object->my_sink = gst_element_get_static_pad(object->appsink, "sink");
-    gst_pad_set_element_private(object->my_sink, object);
-
     gst_pad_link(object->their_src, object->my_sink);
 
     gst_element_sync_state_with_parent(object->appsink);
@@ -427,6 +431,35 @@ static HRESULT new_media_stream(struct media_source *source, GstPad *pad, struct
     return hr;
 }
 
+static HRESULT media_stream_init_desc(struct media_stream *stream)
+{
+    GstCaps *current_caps = gst_pad_get_current_caps(stream->their_src);
+    IMFMediaTypeHandler *type_handler;
+    IMFMediaType *stream_type = NULL;
+    HRESULT hr;
+
+    stream_type = mf_media_type_from_caps(current_caps);
+    gst_caps_unref(current_caps);
+    if (!stream_type)
+        return E_FAIL;
+
+    hr = MFCreateStreamDescriptor(stream->stream_id, 1, &stream_type, &stream->descriptor);
+
+    IMFMediaType_Release(stream_type);
+
+    if (FAILED(hr))
+        return hr;
+
+    if (FAILED(hr = IMFStreamDescriptor_GetMediaTypeHandler(stream->descriptor, &type_handler)))
+        return hr;
+
+    hr = IMFMediaTypeHandler_SetCurrentMediaType(type_handler, stream_type);
+
+    IMFMediaTypeHandler_Release(type_handler);
+
+    return hr;
+}
+
 static HRESULT WINAPI media_source_QueryInterface(IMFMediaSource *iface, REFIID riid, void **out)
 {
     struct media_source *source = impl_from_IMFMediaSource(iface);
@@ -613,6 +646,8 @@ static HRESULT WINAPI media_source_Shutdown(IMFMediaSource *iface)
             gst_object_unref(GST_OBJECT(stream->my_sink));
         if (stream->event_queue)
             IMFMediaEventQueue_Shutdown(stream->event_queue);
+        if (stream->descriptor)
+            IMFStreamDescriptor_Release(stream->descriptor);
         if (stream->parent_source)
             IMFMediaSource_Release(&stream->parent_source->IMFMediaSource_iface);
 
@@ -654,7 +689,7 @@ static void stream_added(GstElement *element, GstPad *pad, gpointer user)
     if (gst_pad_get_direction(pad) != GST_PAD_SRC)
         return;
 
-    if (FAILED(new_media_stream(source, pad, &stream)))
+    if (FAILED(new_media_stream(source, pad, source->stream_count, &stream)))
         return;
 
     if (!(new_stream_array = heap_realloc(source->streams, (source->stream_count + 1) * (sizeof(*new_stream_array)))))
@@ -679,6 +714,7 @@ static void stream_removed(GstElement *element, GstPad *pad, gpointer user)
         if (stream->their_src != pad)
             continue;
         stream->their_src = NULL;
+        stream->state = STREAM_INACTIVE;
     }
 }
 
@@ -695,6 +731,7 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
         GST_STATIC_PAD_TEMPLATE("mf_src", GST_PAD_SRC, GST_PAD_ALWAYS, GST_STATIC_CAPS_ANY);
 
     struct media_source *object = heap_alloc_zero(sizeof(*object));
+    unsigned int i;
     HRESULT hr;
     int ret;
 
@@ -768,6 +805,18 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
     }
 
     WaitForSingleObject(object->no_more_pads_event, INFINITE);
+    for (i = 0; i < object->stream_count; i++)
+    {
+        GstSample *preroll;
+        g_signal_emit_by_name(object->streams[i]->appsink, "pull-preroll", &preroll);
+        if (FAILED(hr = media_stream_init_desc(object->streams[i])))
+        {
+            ERR("Failed to finish initialization of media stream %p, hr %x.\n", object->streams[i], hr);
+            IMFMediaStream_Release(&object->streams[i]->IMFMediaStream_iface);
+            goto fail;
+        }
+        gst_sample_unref(preroll);
+    }
 
     object->state = SOURCE_STOPPED;
 
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index c996f06211e..2e8b0978648 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -16,6 +16,11 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include <gst/gst.h>
+
+#include "gst_private.h"
+
 #include <stdarg.h>
 
 #include "gst_private.h"
@@ -436,3 +441,163 @@ HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj)
 
     return CLASS_E_CLASSNOTAVAILABLE;
 }
+
+static const struct
+{
+    const GUID *subtype;
+    GstVideoFormat format;
+}
+uncompressed_video_formats[] =
+{
+    {&MFVideoFormat_ARGB32,  GST_VIDEO_FORMAT_BGRA},
+    {&MFVideoFormat_RGB32,   GST_VIDEO_FORMAT_BGRx},
+    {&MFVideoFormat_RGB24,   GST_VIDEO_FORMAT_BGR},
+    {&MFVideoFormat_RGB565,  GST_VIDEO_FORMAT_BGR16},
+    {&MFVideoFormat_RGB555,  GST_VIDEO_FORMAT_BGR15},
+};
+
+/* returns NULL if doesn't match exactly */
+IMFMediaType *mf_media_type_from_caps(const GstCaps *caps)
+{
+    IMFMediaType *media_type;
+    GstStructure *info;
+    const char *mime_type;
+
+    if (TRACE_ON(mfplat))
+    {
+        gchar *human_readable = gst_caps_to_string(caps);
+        TRACE("caps = %s\n", debugstr_a(human_readable));
+        g_free(human_readable);
+    }
+
+    if (FAILED(MFCreateMediaType(&media_type)))
+        return NULL;
+
+    info = gst_caps_get_structure(caps, 0);
+    mime_type = gst_structure_get_name(info);
+
+    if (!strncmp(mime_type, "video", 5))
+    {
+        GstVideoInfo video_info;
+
+        if (!gst_video_info_from_caps(&video_info, caps))
+        {
+            return NULL;
+        }
+
+        IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
+
+        IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_SIZE, ((UINT64)video_info.width << 32) | video_info.height);
+
+        IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_RATE, ((UINT64)video_info.fps_n << 32) | video_info.fps_d);
+
+        if (!strcmp(mime_type, "video/x-raw"))
+        {
+            GUID fourcc_subtype = MFVideoFormat_Base;
+            unsigned int i;
+
+            IMFMediaType_SetUINT32(media_type, &MF_MT_COMPRESSED, FALSE);
+
+            /* First try FOURCC */
+            if ((fourcc_subtype.Data1 = gst_video_format_to_fourcc(video_info.finfo->format)))
+            {
+                IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, &fourcc_subtype);
+            }
+            else
+            {
+                for (i = 0; i < ARRAY_SIZE(uncompressed_video_formats); i++)
+                {
+                    if (uncompressed_video_formats[i].format == video_info.finfo->format)
+                    {
+                        IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, uncompressed_video_formats[i].subtype);
+                        break;
+                    }
+                }
+                if (i == ARRAY_SIZE(uncompressed_video_formats))
+                {
+                    FIXME("Unrecognized uncompressed video format %s\n", gst_video_format_to_string(video_info.finfo->format));
+                    IMFMediaType_Release(media_type);
+                    return NULL;
+                }
+            }
+        }
+        else
+        {
+            FIXME("Unrecognized video format %s\n", mime_type);
+            return NULL;
+        }
+    }
+    else if (!strncmp(mime_type, "audio", 5))
+    {
+        gint rate, channels, bitrate;
+        guint64 channel_mask;
+        IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
+
+        if (gst_structure_get_int(info, "rate", &rate))
+            IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, rate);
+
+        if (gst_structure_get_int(info, "channels", &channels))
+            IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_NUM_CHANNELS, channels);
+
+        if (gst_structure_get(info, "channel-mask", GST_TYPE_BITMASK, &channel_mask, NULL))
+            IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_CHANNEL_MASK, channel_mask);
+
+        if (gst_structure_get_int(info, "bitrate", &bitrate))
+            IMFMediaType_SetUINT32(media_type, &MF_MT_AVG_BITRATE, bitrate);
+
+        if (!strcmp(mime_type, "audio/x-raw"))
+        {
+            GstAudioInfo audio_info;
+            DWORD depth;
+
+            if (!gst_audio_info_from_caps(&audio_info, caps))
+            {
+                ERR("Failed to get caps audio info\n");
+                IMFMediaType_Release(media_type);
+                return NULL;
+            }
+
+            depth = GST_AUDIO_INFO_DEPTH(&audio_info);
+
+            /* validation */
+            if ((audio_info.finfo->flags & GST_AUDIO_FORMAT_FLAG_INTEGER && depth > 8) ||
+                (audio_info.finfo->flags & GST_AUDIO_FORMAT_FLAG_SIGNED && depth <= 8) ||
+                (audio_info.finfo->endianness != G_LITTLE_ENDIAN && depth > 8))
+            {
+                IMFMediaType_Release(media_type);
+                return NULL;
+            }
+
+            /* conversion */
+            switch (audio_info.finfo->flags)
+            {
+                case GST_AUDIO_FORMAT_FLAG_FLOAT:
+                    IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, &MFAudioFormat_Float);
+                    break;
+                case GST_AUDIO_FORMAT_FLAG_INTEGER:
+                case GST_AUDIO_FORMAT_FLAG_SIGNED:
+                    IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, &MFAudioFormat_PCM);
+                    break;
+                default:
+                    FIXME("Unrecognized audio format %x\n", audio_info.finfo->format);
+                    IMFMediaType_Release(media_type);
+                    return NULL;
+            }
+
+            IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, depth);
+        }
+        else
+        {
+            FIXME("Unrecognized audio format %s\n", mime_type);
+            IMFMediaType_Release(media_type);
+            return NULL;
+        }
+    }
+    else
+    {
+        IMFMediaType_Release(media_type);
+        return NULL;
+    }
+
+    return media_type;
+}
From 82584160d42ebf0fd60eefe738d6a9e4fbf0223e Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 30 Sep 2020 13:55:06 +0300
Subject: [PATCH] mfreadwrite/tests: Add return value test (Coverity).

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfreadwrite/tests/mfplat.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/mfreadwrite/tests/mfplat.c b/dlls/mfreadwrite/tests/mfplat.c
index 8ed94289703..84581f9be9a 100644
--- a/dlls/mfreadwrite/tests/mfplat.c
+++ b/dlls/mfreadwrite/tests/mfplat.c
@@ -438,11 +438,13 @@ static struct test_media_stream *create_test_stream(DWORD stream_index, IMFMedia
     struct test_media_stream *stream;
     IMFPresentationDescriptor *pd;
     BOOL selected;
+    HRESULT hr;
 
     stream = heap_alloc_zero(sizeof(*stream));
     stream->IMFMediaStream_iface.lpVtbl = &test_media_stream_vtbl;
     stream->refcount = 1;
-    MFCreateEventQueue(&stream->event_queue);
+    hr = MFCreateEventQueue(&stream->event_queue);
+    ok(hr == S_OK, "Failed to create event queue, hr %#x.\n", hr);
     stream->source = source;
     IMFMediaSource_AddRef(stream->source);
     stream->is_new = TRUE;
From 5542942c8e1d7aee45121601fcdb1d7acfecf587 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 1 Oct 2020 15:59:30 +0300
Subject: [PATCH] evr/mixer: Store input type attributes.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 11 ++++++++++-
 dlls/evr/tests/evr.c | 31 +++++++++++--------------------
 2 files changed, 21 insertions(+), 21 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index e19520fa7ed..9227e6a1777 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -686,7 +686,16 @@ static HRESULT WINAPI video_mixer_transform_SetInputType(IMFTransform *iface, DW
                                 &count, &guids)))
                         {
                             if (SUCCEEDED(hr = video_mixer_collect_output_types(mixer, &video_desc, service, count, guids)))
-                                FIXME("Set input type.\n");
+                            {
+                                GUID subtype = { 0 };
+
+                                if (FAILED(hr = IMFMediaType_GetGUID(media_type, &MF_MT_SUBTYPE, &subtype)))
+                                    WARN("Failed to get subtype %#x.\n", hr);
+
+                                if (SUCCEEDED(hr = MFCreateVideoMediaTypeFromSubtype(&subtype, &mixer->inputs[0].media_type)))
+                                    hr = IMFMediaType_CopyAllItems(media_type, (IMFAttributes *)mixer->inputs[0].media_type);
+
+                            }
                             CoTaskMemFree(guids);
                         }
                     }
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index bf33051d6e1..e6f6251be60 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -896,17 +896,15 @@ static void test_default_mixer_type_negotiation(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-if (hr == S_OK)
-{
     ok(media_type != (IMFMediaType *)video_type, "Unexpected media type instance.\n");
+
     hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type2);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(media_type == media_type2, "Unexpected media type instance.\n");
     IMFMediaType_Release(media_type);
     IMFMediaType_Release(media_type2);
-}
+
     hr = IMFTransform_QueryInterface(transform, &IID_IMFVideoProcessor, (void **)&processor);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
@@ -919,31 +917,24 @@ todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
 
     hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    if (SUCCEEDED(hr))
-    {
-        ok(media_type != (IMFMediaType *)video_type, "Unexpected pointer.\n");
-        hr = IMFMediaType_QueryInterface(media_type, &IID_IMFVideoMediaType, (void **)&unk);
-        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-        IUnknown_Release(unk);
-        IMFMediaType_Release(media_type);
-    }
+    ok(media_type != (IMFMediaType *)video_type, "Unexpected pointer.\n");
+    hr = IMFMediaType_QueryInterface(media_type, &IID_IMFVideoMediaType, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+    IMFMediaType_Release(media_type);
 
     hr = IMFVideoProcessor_GetAvailableVideoProcessorModes(processor, &count, &guids);
 todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
 
     hr = IMFTransform_GetOutputAvailableType(transform, 0, 0, &media_type);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
-    if (SUCCEEDED(hr))
-    {
-        hr = IMFTransform_SetOutputType(transform, 0, media_type, 0);
-        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-        IMFMediaType_Release(media_type);
-    }
+    hr = IMFTransform_SetOutputType(transform, 0, media_type, 0);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IMFMediaType_Release(media_type);
 
     hr = IMFVideoProcessor_GetVideoProcessorMode(processor, &guid);
 todo_wine
From c303b08ba065a6dc85e5e43d1fd1c4c24c3f5881 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 1 Oct 2020 15:59:31 +0300
Subject: [PATCH] evr/mixer: Add IMFQualityAdvise stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 76 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c |  4 +++
 2 files changed, 80 insertions(+)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 9227e6a1777..4ada26d074f 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -61,6 +61,7 @@ struct video_mixer
     IMFVideoPositionMapper IMFVideoPositionMapper_iface;
     IMFVideoProcessor IMFVideoProcessor_iface;
     IMFAttributes IMFAttributes_iface;
+    IMFQualityAdvise IMFQualityAdvise_iface;
     IUnknown IUnknown_inner;
     IUnknown *outer_unk;
     LONG refcount;
@@ -129,6 +130,11 @@ static struct video_mixer *impl_from_IMFAttributes(IMFAttributes *iface)
     return CONTAINING_RECORD(iface, struct video_mixer, IMFAttributes_iface);
 }
 
+static struct video_mixer *impl_from_IMFQualityAdvise(IMFQualityAdvise *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_mixer, IMFQualityAdvise_iface);
+}
+
 static int video_mixer_compare_input_id(const void *a, const void *b)
 {
     const unsigned int *key = a;
@@ -217,6 +223,10 @@ static HRESULT WINAPI video_mixer_inner_QueryInterface(IUnknown *iface, REFIID r
     {
         *obj = &mixer->IMFAttributes_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFQualityAdvise))
+    {
+        *obj = &mixer->IMFQualityAdvise_iface;
+    }
     else
     {
         WARN("Unsupported interface %s.\n", debugstr_guid(riid));
@@ -1685,6 +1695,71 @@ static const IMFAttributesVtbl video_mixer_attributes_vtbl =
     video_mixer_attributes_CopyAllItems
 };
 
+static HRESULT WINAPI video_mixer_quality_advise_QueryInterface(IMFQualityAdvise *iface, REFIID riid, void **out)
+{
+    struct video_mixer *mixer = impl_from_IMFQualityAdvise(iface);
+    return IMFTransform_QueryInterface(&mixer->IMFTransform_iface, riid, out);
+}
+
+static ULONG WINAPI video_mixer_quality_advise_AddRef(IMFQualityAdvise *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFQualityAdvise(iface);
+    return IMFTransform_AddRef(&mixer->IMFTransform_iface);
+}
+
+static ULONG WINAPI video_mixer_quality_Release(IMFQualityAdvise *iface)
+{
+    struct video_mixer *mixer = impl_from_IMFQualityAdvise(iface);
+    return IMFTransform_Release(&mixer->IMFTransform_iface);
+}
+
+static HRESULT WINAPI video_mixer_quality_advise_SetDropMode(IMFQualityAdvise *iface, MF_QUALITY_DROP_MODE mode)
+{
+    FIXME("%p, %u.\n", iface, mode);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_quality_advise_SetQualityLevel(IMFQualityAdvise *iface, MF_QUALITY_LEVEL level)
+{
+    FIXME("%p, %u.\n", iface, level);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_quality_advise_GetDropMode(IMFQualityAdvise *iface, MF_QUALITY_DROP_MODE *mode)
+{
+    FIXME("%p, %p.\n", iface, mode);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_quality_advise_GetQualityLevel(IMFQualityAdvise *iface, MF_QUALITY_LEVEL *level)
+{
+    FIXME("%p, %p.\n", iface, level);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_mixer_quality_advise_DropTime(IMFQualityAdvise *iface, LONGLONG interval)
+{
+    FIXME("%p, %s.\n", iface, wine_dbgstr_longlong(interval));
+
+    return E_NOTIMPL;
+}
+
+static const IMFQualityAdviseVtbl video_mixer_quality_advise_vtbl =
+{
+    video_mixer_quality_advise_QueryInterface,
+    video_mixer_quality_advise_AddRef,
+    video_mixer_quality_Release,
+    video_mixer_quality_advise_SetDropMode,
+    video_mixer_quality_advise_SetQualityLevel,
+    video_mixer_quality_advise_GetDropMode,
+    video_mixer_quality_advise_GetQualityLevel,
+    video_mixer_quality_advise_DropTime,
+};
+
 HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -1715,6 +1790,7 @@ HRESULT evr_mixer_create(IUnknown *outer, void **out)
     object->IMFVideoPositionMapper_iface.lpVtbl = &video_mixer_position_mapper_vtbl;
     object->IMFVideoProcessor_iface.lpVtbl = &video_mixer_processor_vtbl;
     object->IMFAttributes_iface.lpVtbl = &video_mixer_attributes_vtbl;
+    object->IMFQualityAdvise_iface.lpVtbl = &video_mixer_quality_advise_vtbl;
     object->IUnknown_inner.lpVtbl = &video_mixer_inner_vtbl;
     object->outer_unk = outer ? outer : &object->IUnknown_inner;
     object->refcount = 1;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index e6f6251be60..7fa28e75229 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -438,6 +438,10 @@ static void test_default_mixer(void)
     hr = MFCreateVideoMixer(NULL, &IID_IDirect3DDevice9, &IID_IMFTransform, (void **)&transform);
     ok(hr == S_OK, "Failed to create default mixer, hr %#x.\n", hr);
 
+    hr = IMFTransform_QueryInterface(transform, &IID_IMFQualityAdvise, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
     hr = IMFTransform_QueryInterface(transform, &IID_IMFTopologyServiceLookupClient, (void **)&unk);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
From b21d2b7c9cd7ab319ff7781352dff998206bef44 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 1 Oct 2020 15:59:32 +0300
Subject: [PATCH] evr/presenter: Add IMFGetService stub.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 44 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/evr/tests/evr.c |  4 ++++
 2 files changed, 48 insertions(+)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index a7da0704927..5e458f72f11 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -46,6 +46,7 @@ struct video_presenter
     IMFTopologyServiceLookupClient IMFTopologyServiceLookupClient_iface;
     IMFVideoDisplayControl IMFVideoDisplayControl_iface;
     IMFRateSupport IMFRateSupport_iface;
+    IMFGetService IMFGetService_iface;
     IUnknown IUnknown_inner;
     IUnknown *outer_unk;
     LONG refcount;
@@ -88,6 +89,11 @@ static struct video_presenter *impl_from_IMFRateSupport(IMFRateSupport *iface)
     return CONTAINING_RECORD(iface, struct video_presenter, IMFRateSupport_iface);
 }
 
+static struct video_presenter *impl_from_IMFGetService(IMFGetService *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_presenter, IMFGetService_iface);
+}
+
 static HRESULT WINAPI video_presenter_inner_QueryInterface(IUnknown *iface, REFIID riid, void **obj)
 {
     struct video_presenter *presenter = impl_from_IUnknown(iface);
@@ -119,6 +125,10 @@ static HRESULT WINAPI video_presenter_inner_QueryInterface(IUnknown *iface, REFI
     {
         *obj = &presenter->IMFRateSupport_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFGetService))
+    {
+        *obj = &presenter->IMFGetService_iface;
+    }
     else
     {
         WARN("Unimplemented interface %s.\n", debugstr_guid(riid));
@@ -576,6 +586,39 @@ static const IMFRateSupportVtbl video_presenter_rate_support_vtbl =
     video_presenter_rate_support_IsRateSupported,
 };
 
+static HRESULT WINAPI video_presenter_getservice_QueryInterface(IMFGetService *iface, REFIID riid, void **obj)
+{
+    struct video_presenter *presenter = impl_from_IMFGetService(iface);
+    return IMFVideoPresenter_QueryInterface(&presenter->IMFVideoPresenter_iface, riid, obj);
+}
+
+static ULONG WINAPI video_presenter_getservice_AddRef(IMFGetService *iface)
+{
+    struct video_presenter *presenter = impl_from_IMFGetService(iface);
+    return IMFVideoPresenter_AddRef(&presenter->IMFVideoPresenter_iface);
+}
+
+static ULONG WINAPI video_presenter_getservice_Release(IMFGetService *iface)
+{
+    struct video_presenter *presenter = impl_from_IMFGetService(iface);
+    return IMFVideoPresenter_Release(&presenter->IMFVideoPresenter_iface);
+}
+
+static HRESULT WINAPI video_presenter_getservice_GetService(IMFGetService *iface, REFGUID service, REFIID riid, void **obj)
+{
+    FIXME("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+
+    return E_NOTIMPL;
+}
+
+static const IMFGetServiceVtbl video_presenter_getservice_vtbl =
+{
+    video_presenter_getservice_QueryInterface,
+    video_presenter_getservice_AddRef,
+    video_presenter_getservice_Release,
+    video_presenter_getservice_GetService,
+};
+
 HRESULT WINAPI MFCreateVideoPresenter(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj)
 {
     TRACE("%p, %s, %s, %p.\n", owner, debugstr_guid(riid_device), debugstr_guid(riid), obj);
@@ -600,6 +643,7 @@ HRESULT evr_presenter_create(IUnknown *outer, void **out)
     object->IMFTopologyServiceLookupClient_iface.lpVtbl = &video_presenter_service_client_vtbl;
     object->IMFVideoDisplayControl_iface.lpVtbl = &video_presenter_control_vtbl;
     object->IMFRateSupport_iface.lpVtbl = &video_presenter_rate_support_vtbl;
+    object->IMFGetService_iface.lpVtbl = &video_presenter_getservice_vtbl;
     object->IUnknown_inner.lpVtbl = &video_presenter_inner_vtbl;
     object->outer_unk = outer ? outer : &object->IUnknown_inner;
     object->refcount = 1;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 7fa28e75229..b59da51e475 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1002,6 +1002,10 @@ static void test_default_presenter(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
+    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFGetService, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
     /* Rate support. */
     hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFRateSupport, (void **)&rate_support);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
From 2ff55d97d7e86fb80fa4f84a769523add3216ce8 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 1 Oct 2020 15:59:33 +0300
Subject: [PATCH] evr/presenter: Create device manager for the presenter.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/Makefile.in |  2 +-
 dlls/evr/presenter.c | 21 ++++++++++++++++++++-
 dlls/evr/tests/evr.c | 37 +++++++++++++++++++++++++++++++++++--
 3 files changed, 56 insertions(+), 4 deletions(-)

diff --git a/dlls/evr/Makefile.in b/dlls/evr/Makefile.in
index c8178297dab..6d936d65b79 100644
--- a/dlls/evr/Makefile.in
+++ b/dlls/evr/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = evr.dll
 IMPORTLIB = evr
-IMPORTS   = mfuuid strmiids strmbase uuid dxguid ole32 oleaut32
+IMPORTS   = mfuuid strmiids strmbase uuid dxguid ole32 oleaut32 dxva2
 DELAYIMPORTS = mfplat
 
 EXTRADLLFLAGS = -mno-cygwin
diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 5e458f72f11..b60de4b82a1 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -22,6 +22,7 @@
 #include "d3d9.h"
 #include "mfapi.h"
 #include "mferror.h"
+#include "dxva2api.h"
 
 #include "evr_classes.h"
 #include "evr_private.h"
@@ -55,6 +56,8 @@ struct video_presenter
     IMFClock *clock;
     IMediaEventSink *event_sink;
 
+    IDirect3DDeviceManager9 *device_manager;
+    UINT reset_token;
     unsigned int state;
     CRITICAL_SECTION cs;
 };
@@ -174,6 +177,8 @@ static ULONG WINAPI video_presenter_inner_Release(IUnknown *iface)
     {
         video_presenter_clear_container(presenter);
         DeleteCriticalSection(&presenter->cs);
+        if (presenter->device_manager)
+            IDirect3DDeviceManager9_Release(presenter->device_manager);
         heap_free(presenter);
     }
 
@@ -606,7 +611,14 @@ static ULONG WINAPI video_presenter_getservice_Release(IMFGetService *iface)
 
 static HRESULT WINAPI video_presenter_getservice_GetService(IMFGetService *iface, REFGUID service, REFIID riid, void **obj)
 {
-    FIXME("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+    struct video_presenter *presenter = impl_from_IMFGetService(iface);
+
+    TRACE("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(&MR_VIDEO_ACCELERATION_SERVICE, service))
+        return IDirect3DDeviceManager9_QueryInterface(presenter->device_manager, riid, obj);
+
+    FIXME("Unimplemented service %s.\n", debugstr_guid(service));
 
     return E_NOTIMPL;
 }
@@ -634,6 +646,7 @@ HRESULT WINAPI MFCreateVideoPresenter(IUnknown *owner, REFIID riid_device, REFII
 HRESULT evr_presenter_create(IUnknown *outer, void **out)
 {
     struct video_presenter *object;
+    HRESULT hr;
 
     if (!(object = heap_alloc_zero(sizeof(*object))))
         return E_OUTOFMEMORY;
@@ -649,6 +662,12 @@ HRESULT evr_presenter_create(IUnknown *outer, void **out)
     object->refcount = 1;
     InitializeCriticalSection(&object->cs);
 
+    if (FAILED(hr = DXVA2CreateDirect3DDeviceManager9(&object->reset_token, &object->device_manager)))
+    {
+        IUnknown_Release(&object->IUnknown_inner);
+        return hr;
+    }
+
     *out = &object->IUnknown_inner;
 
     return S_OK;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index b59da51e475..0dff691b59f 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -966,9 +966,14 @@ todo_wine
 
 static void test_default_presenter(void)
 {
+    D3DDEVICE_CREATION_PARAMETERS device_params = { 0 };
     IMFVideoPresenter *presenter;
     IMFRateSupport *rate_support;
+    IDirect3DDevice9 *d3d_device;
+    IDirect3DDeviceManager9 *dm;
     IMFVideoDeviceID *deviceid;
+    IMFGetService *gs;
+    HANDLE handle;
     IUnknown *unk;
     float rate;
     HRESULT hr;
@@ -1002,9 +1007,37 @@ static void test_default_presenter(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
-    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFGetService, (void **)&unk);
+    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFGetService, (void **)&gs);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    IUnknown_Release(unk);
+
+    hr = IMFGetService_GetService(gs, &MR_VIDEO_ACCELERATION_SERVICE, &IID_IDirect3DDeviceManager9, (void **)&dm);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(dm, &handle);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_LockDevice(dm, handle, &d3d_device, FALSE);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+if (SUCCEEDED(hr))
+{
+    hr = IDirect3DDevice9_GetCreationParameters(d3d_device, &device_params);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(device_params.hFocusWindow == GetDesktopWindow(), "Unexpected window %p.\n", device_params.hFocusWindow);
+
+    IDirect3DDevice9_Release(d3d_device);
+
+    hr = IDirect3DDeviceManager9_UnlockDevice(dm, handle, FALSE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DDeviceManager9_CloseDeviceHandle(dm, handle);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+}
+    IDirect3DDeviceManager9_Release(dm);
+
+    IMFGetService_Release(gs);
 
     /* Rate support. */
     hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFRateSupport, (void **)&rate_support);
From 164c3b7f2ba5e98a3096ef9de37fc7cede9e7e68 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 2 Oct 2020 14:01:09 +0300
Subject: [PATCH] evr/presenter: Create d3d device on presenter creation.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/Makefile.in |  2 +-
 dlls/evr/presenter.c | 47 +++++++++++++++++++++++++++++++++----
 dlls/evr/tests/evr.c | 55 +++++++++++++++++++++++++++++++++++++++-----
 3 files changed, 92 insertions(+), 12 deletions(-)

diff --git a/dlls/evr/Makefile.in b/dlls/evr/Makefile.in
index 6d936d65b79..02cdb9b820a 100644
--- a/dlls/evr/Makefile.in
+++ b/dlls/evr/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = evr.dll
 IMPORTLIB = evr
-IMPORTS   = mfuuid strmiids strmbase uuid dxguid ole32 oleaut32 dxva2
+IMPORTS   = mfuuid strmiids strmbase uuid dxguid ole32 oleaut32 user32 d3d9 dxva2
 DELAYIMPORTS = mfplat
 
 EXTRADLLFLAGS = -mno-cygwin
diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index b60de4b82a1..04653ff67ad 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -643,11 +643,47 @@ HRESULT WINAPI MFCreateVideoPresenter(IUnknown *owner, REFIID riid_device, REFII
     return CoCreateInstance(&CLSID_MFVideoPresenter9, owner, CLSCTX_INPROC_SERVER, riid, obj);
 }
 
+static HRESULT video_presenter_init_d3d(struct video_presenter *presenter)
+{
+    D3DPRESENT_PARAMETERS present_params = { 0 };
+    IDirect3DDevice9 *device;
+    IDirect3D9 *d3d;
+    HRESULT hr;
+
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+
+    present_params.BackBufferCount = 1;
+    present_params.SwapEffect = D3DSWAPEFFECT_COPY;
+    present_params.hDeviceWindow = GetDesktopWindow();
+    present_params.Windowed = TRUE;
+    present_params.Flags = D3DPRESENTFLAG_VIDEO;
+    present_params.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
+    hr = IDirect3D9_CreateDevice(d3d, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, GetDesktopWindow(),
+            0, &present_params, &device);
+
+    IDirect3D9_Release(d3d);
+
+    if (FAILED(hr))
+    {
+        WARN("Failed to create d3d device, hr %#x.\n", hr);
+        return hr;
+    }
+
+    hr = IDirect3DDeviceManager9_ResetDevice(presenter->device_manager, device, presenter->reset_token);
+    IDirect3DDevice9_Release(device);
+    if (FAILED(hr))
+        WARN("Failed to set new device for the manager, hr %#x.\n", hr);
+
+    return hr;
+}
+
 HRESULT evr_presenter_create(IUnknown *outer, void **out)
 {
     struct video_presenter *object;
     HRESULT hr;
 
+    *out = NULL;
+
     if (!(object = heap_alloc_zero(sizeof(*object))))
         return E_OUTOFMEMORY;
 
@@ -663,12 +699,13 @@ HRESULT evr_presenter_create(IUnknown *outer, void **out)
     InitializeCriticalSection(&object->cs);
 
     if (FAILED(hr = DXVA2CreateDirect3DDeviceManager9(&object->reset_token, &object->device_manager)))
-    {
         IUnknown_Release(&object->IUnknown_inner);
-        return hr;
-    }
 
-    *out = &object->IUnknown_inner;
+    if (FAILED(hr = video_presenter_init_d3d(object)))
+        IUnknown_Release(&object->IUnknown_inner);
 
-    return S_OK;
+    if (SUCCEEDED(hr))
+        *out = &object->IUnknown_inner;
+
+    return hr;
 }
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 0dff691b59f..c2e17595559 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -39,7 +39,7 @@ static HWND create_window(void)
 
     AdjustWindowRect(&r, WS_OVERLAPPEDWINDOW | WS_VISIBLE, FALSE);
 
-    return CreateWindowA("static", "d3d9_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+    return CreateWindowA("static", "evr_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
             0, 0, r.right - r.left, r.bottom - r.top, NULL, NULL, NULL, NULL);
 }
 
@@ -967,12 +967,16 @@ todo_wine
 static void test_default_presenter(void)
 {
     D3DDEVICE_CREATION_PARAMETERS device_params = { 0 };
+    D3DPRESENT_PARAMETERS present_params = { 0 };
+    IMFVideoDisplayControl *display_control;
+    IDirect3DSwapChain9 *swapchain;
     IMFVideoPresenter *presenter;
     IMFRateSupport *rate_support;
     IDirect3DDevice9 *d3d_device;
     IDirect3DDeviceManager9 *dm;
     IMFVideoDeviceID *deviceid;
     IMFGetService *gs;
+    HWND hwnd, hwnd2;
     HANDLE handle;
     IUnknown *unk;
     float rate;
@@ -1010,33 +1014,70 @@ static void test_default_presenter(void)
     hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFGetService, (void **)&gs);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFGetService_GetService(gs, &MR_VIDEO_RENDER_SERVICE, &IID_IMFVideoDisplayControl, (void **)&display_control);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    if (SUCCEEDED(hr))
+        IMFVideoDisplayControl_Release(display_control);
+
     hr = IMFGetService_GetService(gs, &MR_VIDEO_ACCELERATION_SERVICE, &IID_IDirect3DDeviceManager9, (void **)&dm);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFVideoDisplayControl, (void **)&display_control);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
     hr = IDirect3DDeviceManager9_OpenDeviceHandle(dm, &handle);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IDirect3DDeviceManager9_LockDevice(dm, handle, &d3d_device, FALSE);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
-if (SUCCEEDED(hr))
-{
     hr = IDirect3DDevice9_GetCreationParameters(d3d_device, &device_params);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(device_params.hFocusWindow == GetDesktopWindow(), "Unexpected window %p.\n", device_params.hFocusWindow);
 
+    hr = IDirect3DDevice9_GetSwapChain(d3d_device, 0, &swapchain);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IDirect3DSwapChain9_GetPresentParameters(swapchain, &present_params);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    ok(present_params.hDeviceWindow == GetDesktopWindow(), "Unexpected device window.\n");
+    ok(present_params.Windowed, "Unexpected windowed mode.\n");
+    ok(present_params.SwapEffect == D3DSWAPEFFECT_COPY, "Unexpected swap effect.\n");
+    ok(present_params.Flags == D3DPRESENTFLAG_VIDEO, "Unexpected flags.\n");
+    ok(present_params.PresentationInterval == D3DPRESENT_INTERVAL_IMMEDIATE, "Unexpected present interval.\n");
+
     IDirect3DDevice9_Release(d3d_device);
 
     hr = IDirect3DDeviceManager9_UnlockDevice(dm, handle, FALSE);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
-    hr = IDirect3DDeviceManager9_CloseDeviceHandle(dm, handle);
+    hwnd = create_window();
+    ok(!!hwnd, "Failed to create a test window.\n");
+
+    hwnd2 = hwnd;
+    hr = IMFVideoDisplayControl_GetVideoWindow(display_control, &hwnd2);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(hwnd2 == NULL, "Unexpected window %p.\n", hwnd2);
+}
+    hr = IMFVideoDisplayControl_SetVideoWindow(display_control, hwnd);
+todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hwnd2 = NULL;
+    hr = IMFVideoDisplayControl_GetVideoWindow(display_control, &hwnd2);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(hwnd2 == hwnd, "Unexpected window %p.\n", hwnd2);
 }
+    hr = IDirect3DDeviceManager9_CloseDeviceHandle(dm, handle);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
     IDirect3DDeviceManager9_Release(dm);
 
+    IMFVideoDisplayControl_Release(display_control);
     IMFGetService_Release(gs);
 
     /* Rate support. */
@@ -1066,6 +1107,8 @@ if (SUCCEEDED(hr))
     IMFRateSupport_Release(rate_support);
 
     IMFVideoPresenter_Release(presenter);
+
+    DestroyWindow(hwnd);
 }
 
 static void test_MFCreateVideoMixerAndPresenter(void)
From 69e777c804e9803bef3e151fc20a363f699692ab Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 2 Oct 2020 14:01:10 +0300
Subject: [PATCH] evr/presenter: Expose IMFVideoDisplayControl as a service.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 11 +++++++++++
 dlls/evr/tests/evr.c |  4 +---
 2 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 04653ff67ad..8b5a7dd46ab 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -618,6 +618,17 @@ static HRESULT WINAPI video_presenter_getservice_GetService(IMFGetService *iface
     if (IsEqualGUID(&MR_VIDEO_ACCELERATION_SERVICE, service))
         return IDirect3DDeviceManager9_QueryInterface(presenter->device_manager, riid, obj);
 
+    if (IsEqualGUID(&MR_VIDEO_RENDER_SERVICE, service))
+    {
+        if (IsEqualIID(riid, &IID_IMFVideoDisplayControl))
+            return IMFVideoPresenter_QueryInterface(&presenter->IMFVideoPresenter_iface, riid, obj);
+        else
+        {
+            FIXME("Unsupported interface %s.\n", debugstr_guid(riid));
+            return E_NOTIMPL;
+        }
+    }
+
     FIXME("Unimplemented service %s.\n", debugstr_guid(service));
 
     return E_NOTIMPL;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index c2e17595559..9665e2683dd 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1015,10 +1015,8 @@ static void test_default_presenter(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFGetService_GetService(gs, &MR_VIDEO_RENDER_SERVICE, &IID_IMFVideoDisplayControl, (void **)&display_control);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    if (SUCCEEDED(hr))
-        IMFVideoDisplayControl_Release(display_control);
+    IMFVideoDisplayControl_Release(display_control);
 
     hr = IMFGetService_GetService(gs, &MR_VIDEO_ACCELERATION_SERVICE, &IID_IDirect3DDeviceManager9, (void **)&dm);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
From 77e04e221a609cb4b45625ccbc743d322a14189e Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 2 Oct 2020 14:01:11 +0300
Subject: [PATCH] evr/presenter: Keep video window handle.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 19 +++++++++++++++----
 dlls/evr/tests/evr.c |  7 ++-----
 2 files changed, 17 insertions(+), 9 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 8b5a7dd46ab..a8e9a507924 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -58,6 +58,7 @@ struct video_presenter
 
     IDirect3DDeviceManager9 *device_manager;
     UINT reset_token;
+    HWND video_window;
     unsigned int state;
     CRITICAL_SECTION cs;
 };
@@ -497,16 +498,26 @@ static HRESULT WINAPI video_presenter_control_GetAspectRatioMode(IMFVideoDisplay
 
 static HRESULT WINAPI video_presenter_control_SetVideoWindow(IMFVideoDisplayControl *iface, HWND window)
 {
-    FIXME("%p, %p.\n", iface, window);
+    struct video_presenter *presenter = impl_from_IMFVideoDisplayControl(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, window);
+
+    EnterCriticalSection(&presenter->cs);
+    presenter->video_window = window;
+    LeaveCriticalSection(&presenter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_presenter_control_GetVideoWindow(IMFVideoDisplayControl *iface, HWND *window)
 {
-    FIXME("%p, %p.\n", iface, window);
+    struct video_presenter *presenter = impl_from_IMFVideoDisplayControl(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, window);
+
+    *window = presenter->video_window;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_presenter_control_RepaintVideo(IMFVideoDisplayControl *iface)
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 9665e2683dd..d77703b6c1f 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1056,20 +1056,17 @@ static void test_default_presenter(void)
 
     hwnd2 = hwnd;
     hr = IMFVideoDisplayControl_GetVideoWindow(display_control, &hwnd2);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(hwnd2 == NULL, "Unexpected window %p.\n", hwnd2);
-}
+
     hr = IMFVideoDisplayControl_SetVideoWindow(display_control, hwnd);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hwnd2 = NULL;
     hr = IMFVideoDisplayControl_GetVideoWindow(display_control, &hwnd2);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(hwnd2 == hwnd, "Unexpected window %p.\n", hwnd2);
-}
+
     hr = IDirect3DDeviceManager9_CloseDeviceHandle(dm, handle);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
From 3981be41287c799e43693d80a9c0f4d34d2c0135 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 2 Oct 2020 14:01:12 +0300
Subject: [PATCH] evr/presenter: Maintain video position rectangles.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 43 ++++++++++++++++++++++++-----
 dlls/evr/tests/evr.c | 66 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 102 insertions(+), 7 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index a8e9a507924..0663383b14f 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -59,6 +59,8 @@ struct video_presenter
     IDirect3DDeviceManager9 *device_manager;
     UINT reset_token;
     HWND video_window;
+    MFVideoNormalizedRect src_rect;
+    RECT dst_rect;
     unsigned int state;
     CRITICAL_SECTION cs;
 };
@@ -467,19 +469,45 @@ static HRESULT WINAPI video_presenter_control_GetIdealVideoSize(IMFVideoDisplayC
 }
 
 static HRESULT WINAPI video_presenter_control_SetVideoPosition(IMFVideoDisplayControl *iface,
-        const MFVideoNormalizedRect *source, const RECT *dest)
+        const MFVideoNormalizedRect *src_rect, const RECT *dst_rect)
 {
-    FIXME("%p, %p, %p.\n", iface, source, dest);
+    struct video_presenter *presenter = impl_from_IMFVideoDisplayControl(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %s.\n", iface, src_rect, wine_dbgstr_rect(dst_rect));
+
+    if (!src_rect && !dst_rect)
+        return E_POINTER;
+
+    if (src_rect && (src_rect->left < 0.0f || src_rect->top < 0.0f ||
+                src_rect->right > 1.0f || src_rect->bottom > 1.0f))
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&presenter->cs);
+    if (src_rect)
+        presenter->src_rect = *src_rect;
+    if (dst_rect)
+        presenter->dst_rect = *dst_rect;
+    LeaveCriticalSection(&presenter->cs);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI video_presenter_control_GetVideoPosition(IMFVideoDisplayControl *iface, MFVideoNormalizedRect *source,
-        RECT *dest)
+static HRESULT WINAPI video_presenter_control_GetVideoPosition(IMFVideoDisplayControl *iface, MFVideoNormalizedRect *src_rect,
+        RECT *dst_rect)
 {
-    FIXME("%p, %p, %p.\n", iface, source, dest);
+    struct video_presenter *presenter = impl_from_IMFVideoDisplayControl(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %p.\n", iface, src_rect, dst_rect);
+
+    if (!src_rect || !dst_rect)
+        return E_POINTER;
+
+    EnterCriticalSection(&presenter->cs);
+    *src_rect = presenter->src_rect;
+    *dst_rect = presenter->dst_rect;
+    LeaveCriticalSection(&presenter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_presenter_control_SetAspectRatioMode(IMFVideoDisplayControl *iface, DWORD mode)
@@ -718,6 +746,7 @@ HRESULT evr_presenter_create(IUnknown *outer, void **out)
     object->IUnknown_inner.lpVtbl = &video_presenter_inner_vtbl;
     object->outer_unk = outer ? outer : &object->IUnknown_inner;
     object->refcount = 1;
+    object->src_rect.right = object->src_rect.bottom = 1.0f;
     InitializeCriticalSection(&object->cs);
 
     if (FAILED(hr = DXVA2CreateDirect3DDeviceManager9(&object->reset_token, &object->device_manager)))
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index d77703b6c1f..48bf01a2ef5 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -970,6 +970,7 @@ static void test_default_presenter(void)
     D3DPRESENT_PARAMETERS present_params = { 0 };
     IMFVideoDisplayControl *display_control;
     IDirect3DSwapChain9 *swapchain;
+    MFVideoNormalizedRect src_rect;
     IMFVideoPresenter *presenter;
     IMFRateSupport *rate_support;
     IDirect3DDevice9 *d3d_device;
@@ -977,6 +978,7 @@ static void test_default_presenter(void)
     IMFVideoDeviceID *deviceid;
     IMFGetService *gs;
     HWND hwnd, hwnd2;
+    RECT dst_rect;
     HANDLE handle;
     IUnknown *unk;
     float rate;
@@ -1051,6 +1053,7 @@ static void test_default_presenter(void)
     hr = IDirect3DDeviceManager9_UnlockDevice(dm, handle, FALSE);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    /* Video window */
     hwnd = create_window();
     ok(!!hwnd, "Failed to create a test window.\n");
 
@@ -1067,6 +1070,69 @@ static void test_default_presenter(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(hwnd2 == hwnd, "Unexpected window %p.\n", hwnd2);
 
+    /* Video position */
+    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, NULL, &dst_rect);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    SetRect(&dst_rect, 1, 2, 3, 4);
+    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(src_rect.left == 0.0f && src_rect.top == 0.0f && src_rect.right == 1.0f &&
+            src_rect.bottom == 1.0f, "Unexpected source rectangle.\n");
+    ok(dst_rect.left == 0 && dst_rect.right == 0 && dst_rect.top == 0 && dst_rect.bottom == 0,
+            "Unexpected destination rectangle %s.\n", wine_dbgstr_rect(&dst_rect));
+
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    SetRect(&dst_rect, 0, 0, 10, 10);
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    SetRect(&dst_rect, 1, 2, 3, 4);
+    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(dst_rect.left == 0 && dst_rect.right == 10 && dst_rect.top == 0 && dst_rect.bottom == 10,
+            "Unexpected destination rectangle %s.\n", wine_dbgstr_rect(&dst_rect));
+
+    src_rect.left = src_rect.top = 0.0f;
+    src_rect.right = 2.0f;
+    src_rect.bottom = 1.0f;
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    src_rect.left = -0.1f;
+    src_rect.top = 0.0f;
+    src_rect.right = 0.9f;
+    src_rect.bottom = 1.0f;
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    src_rect.left = 0.1f;
+    src_rect.top = 0.2f;
+    src_rect.right = 0.8f;
+    src_rect.bottom = 0.9f;
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(src_rect.left == 0.1f && src_rect.top == 0.2f && src_rect.right == 0.8f &&
+            src_rect.bottom == 0.9f, "Unexpected source rectangle.\n");
+
+    SetRect(&dst_rect, 1, 2, 999, 1000);
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    SetRect(&dst_rect, 0, 1, 3, 4);
+    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(dst_rect.left == 1 && dst_rect.right == 999 && dst_rect.top == 2 && dst_rect.bottom == 1000,
+            "Unexpected destination rectangle %s.\n", wine_dbgstr_rect(&dst_rect));
+
     hr = IDirect3DDeviceManager9_CloseDeviceHandle(dm, handle);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
From 82c64b9c951777b0143e3125f4b95a3ac6e091c3 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 2 Oct 2020 14:01:13 +0300
Subject: [PATCH] evr/presenter: Add missing method stubs.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 48 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 48 insertions(+)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 0663383b14f..04e9a556840 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -563,6 +563,48 @@ static HRESULT WINAPI video_presenter_control_GetCurrentImage(IMFVideoDisplayCon
     return E_NOTIMPL;
 }
 
+static HRESULT WINAPI video_presenter_control_SetBorderColor(IMFVideoDisplayControl *iface, COLORREF color)
+{
+    FIXME("%p, %#x.\n", iface, color);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_GetBorderColor(IMFVideoDisplayControl *iface, COLORREF *color)
+{
+    FIXME("%p, %p.\n", iface, color);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_SetRenderingPrefs(IMFVideoDisplayControl *iface, DWORD flags)
+{
+    FIXME("%p, %#x.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_GetRenderingPrefs(IMFVideoDisplayControl *iface, DWORD *flags)
+{
+    FIXME("%p, %p.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_SetFullscreen(IMFVideoDisplayControl *iface, BOOL fullscreen)
+{
+    FIXME("%p, %d.\n", iface, fullscreen);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_presenter_control_GetFullscreen(IMFVideoDisplayControl *iface, BOOL *fullscreen)
+{
+    FIXME("%p, %p.\n", iface, fullscreen);
+
+    return E_NOTIMPL;
+}
+
 static const IMFVideoDisplayControlVtbl video_presenter_control_vtbl =
 {
     video_presenter_control_QueryInterface,
@@ -578,6 +620,12 @@ static const IMFVideoDisplayControlVtbl video_presenter_control_vtbl =
     video_presenter_control_GetVideoWindow,
     video_presenter_control_RepaintVideo,
     video_presenter_control_GetCurrentImage,
+    video_presenter_control_SetBorderColor,
+    video_presenter_control_GetBorderColor,
+    video_presenter_control_SetRenderingPrefs,
+    video_presenter_control_GetRenderingPrefs,
+    video_presenter_control_SetFullscreen,
+    video_presenter_control_GetFullscreen,
 };
 
 static HRESULT WINAPI video_presenter_rate_support_QueryInterface(IMFRateSupport *iface, REFIID riid, void **obj)
From 1d7469d9a6e82e3a4c6a170e542f48fd4a342ef3 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 5 Oct 2020 15:02:56 +0300
Subject: [PATCH] rtworkq: Add remaining queue management stubs.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/mfplat.spec   |  6 +++---
 dlls/rtworkq/queue.c      | 21 +++++++++++++++++++++
 dlls/rtworkq/rtworkq.spec |  6 +++---
 include/mfapi.h           |  3 +++
 include/rtworkq.idl       |  2 ++
 5 files changed, 32 insertions(+), 6 deletions(-)

diff --git a/dlls/mfplat/mfplat.spec b/dlls/mfplat/mfplat.spec
index f55a8237d35..8f5e7db6aee 100644
--- a/dlls/mfplat/mfplat.spec
+++ b/dlls/mfplat/mfplat.spec
@@ -25,7 +25,7 @@
 @ stub MFBeginGetHostByName
 @ stub MFBeginRegisterWorkQueueWithMMCSS
 @ stdcall MFBeginRegisterWorkQueueWithMMCSSEx(long wstr long long ptr ptr) rtworkq.RtwqBeginRegisterWorkQueueWithMMCSS
-@ stub MFBeginUnregisterWorkQueueWithMMCSS
+@ stdcall MFBeginUnregisterWorkQueueWithMMCSS(long ptr ptr) rtworkq.RtwqBeginUnregisterWorkQueueWithMMCSS
 @ stub MFBlockThread
 @ stub MFCalculateBitmapImageSize
 @ stdcall MFCalculateImageSize(ptr long long ptr)
@@ -87,8 +87,8 @@
 @ stub MFDeserializePresentationDescriptor
 @ stdcall MFEndCreateFile(ptr ptr)
 @ stub MFEndGetHostByName
-@ stub MFEndRegisterWorkQueueWithMMCSS
-@ stub MFEndUnregisterWorkQueueWithMMCSS
+@ stdcall MFEndRegisterWorkQueueWithMMCSS(ptr ptr) rtworkq.RtwqEndRegisterWorkQueueWithMMCSS
+@ stdcall MFEndUnregisterWorkQueueWithMMCSS(ptr) rtworkq.RtwqEndUnregisterWorkQueueWithMMCSS
 @ stub MFFrameRateToAverageTimePerFrame
 @ stub MFFreeAdaptersAddresses
 @ stub MFGetAdaptersAddresses
diff --git a/dlls/rtworkq/queue.c b/dlls/rtworkq/queue.c
index 07d124cfb73..f4e9f10d3f0 100644
--- a/dlls/rtworkq/queue.c
+++ b/dlls/rtworkq/queue.c
@@ -1533,6 +1533,27 @@ HRESULT WINAPI RtwqBeginRegisterWorkQueueWithMMCSS(DWORD queue, const WCHAR *cla
     return E_NOTIMPL;
 }
 
+HRESULT WINAPI RtwqEndRegisterWorkQueueWithMMCSS(IRtwqAsyncResult *result, DWORD *taskid)
+{
+    FIXME("%p, %p.\n", result, taskid);
+
+    return E_NOTIMPL;
+}
+
+HRESULT WINAPI RtwqBeginUnregisterWorkQueueWithMMCSS(DWORD queue, IRtwqAsyncCallback *callback, IUnknown *state)
+{
+    FIXME("%#x, %p, %p.\n", queue, callback, state);
+
+    return E_NOTIMPL;
+}
+
+HRESULT WINAPI RtwqEndUnregisterWorkQueueWithMMCSS(IRtwqAsyncResult *result)
+{
+    FIXME("%p.\n", result);
+
+    return E_NOTIMPL;
+}
+
 HRESULT WINAPI RtwqRegisterPlatformEvents(IRtwqPlatformEvents *events)
 {
     FIXME("%p.\n", events);
diff --git a/dlls/rtworkq/rtworkq.spec b/dlls/rtworkq/rtworkq.spec
index 09d877790d5..2200b0863bd 100644
--- a/dlls/rtworkq/rtworkq.spec
+++ b/dlls/rtworkq/rtworkq.spec
@@ -2,13 +2,13 @@
 @ stdcall RtwqAllocateSerialWorkQueue(long ptr)
 @ stdcall RtwqAllocateWorkQueue(long ptr)
 @ stdcall RtwqBeginRegisterWorkQueueWithMMCSS(long wstr long long ptr ptr)
-@ stub RtwqBeginUnregisterWorkQueueWithMMCSS
+@ stdcall RtwqBeginUnregisterWorkQueueWithMMCSS(long ptr ptr)
 @ stdcall RtwqCancelDeadline(long)
 @ stub RtwqCancelMultipleWaitingWorkItem
 @ stdcall RtwqCancelWorkItem(int64)
 @ stdcall RtwqCreateAsyncResult(ptr ptr ptr ptr)
-@ stub RtwqEndRegisterWorkQueueWithMMCSS
-@ stub RtwqEndUnregisterWorkQueueWithMMCSS
+@ stdcall RtwqEndRegisterWorkQueueWithMMCSS(ptr ptr)
+@ stdcall RtwqEndUnregisterWorkQueueWithMMCSS(ptr)
 @ stub RtwqGetPlatform
 @ stdcall RtwqGetWorkQueueMMCSSClass(long ptr ptr)
 @ stdcall RtwqGetWorkQueueMMCSSPriority(long ptr)
diff --git a/include/mfapi.h b/include/mfapi.h
index b1edeac02f6..e9b26f322c3 100644
--- a/include/mfapi.h
+++ b/include/mfapi.h
@@ -490,6 +490,7 @@ HRESULT WINAPI MFBeginCreateFile(MF_FILE_ACCESSMODE access_mode, MF_FILE_OPENMOD
         const WCHAR *path, IMFAsyncCallback *callback, IUnknown *state, IUnknown **cancel_cookie);
 HRESULT WINAPI MFBeginRegisterWorkQueueWithMMCSSEx(DWORD queue, const WCHAR *usage_class, DWORD taskid, LONG priority,
         IMFAsyncCallback *callback, IUnknown *state);
+HRESULT WINAPI MFBeginUnregisterWorkQueueWithMMCSS(DWORD queue, IMFAsyncCallback *callback, IUnknown *state);
 HRESULT WINAPI MFCalculateImageSize(REFGUID subtype, UINT32 width, UINT32 height, UINT32 *size);
 HRESULT WINAPI MFCancelCreateFile(IUnknown *cancel_cookie);
 HRESULT WINAPI MFCancelWorkItem(MFWORKITEM_KEY key);
@@ -517,6 +518,8 @@ HRESULT WINAPI MFCreateVideoMediaTypeFromSubtype(const GUID *subtype, IMFVideoMe
 HRESULT WINAPI MFCreateMemoryBuffer(DWORD max_length, IMFMediaBuffer **buffer);
 HRESULT WINAPI MFCreateWaveFormatExFromMFMediaType(IMFMediaType *type, WAVEFORMATEX **format, UINT32 *size, UINT32 flags);
 HRESULT WINAPI MFEndCreateFile(IMFAsyncResult *result, IMFByteStream **stream);
+HRESULT WINAPI MFEndRegisterWorkQueueWithMMCSS(IMFAsyncResult *result, DWORD *taskid);
+HRESULT WINAPI MFEndUnregisterWorkQueueWithMMCSS(IMFAsyncResult *result);
 void *  WINAPI MFHeapAlloc(SIZE_T size, ULONG flags, char *file, int line, EAllocationType type);
 void    WINAPI MFHeapFree(void *ptr);
 HRESULT WINAPI MFGetAttributesAsBlob(IMFAttributes *attributes, UINT8 *buffer, UINT size);
diff --git a/include/rtworkq.idl b/include/rtworkq.idl
index ed32df1c3bf..e7ff768074c 100644
--- a/include/rtworkq.idl
+++ b/include/rtworkq.idl
@@ -93,9 +93,11 @@ cpp_quote("HRESULT WINAPI RtwqAddPeriodicCallback(RTWQPERIODICCALLBACK callback,
 cpp_quote("HRESULT WINAPI RtwqAllocateSerialWorkQueue(DWORD target_queue, DWORD *queue);")
 cpp_quote("HRESULT WINAPI RtwqAllocateWorkQueue(RTWQ_WORKQUEUE_TYPE queue_type, DWORD *queue);")
 cpp_quote("HRESULT WINAPI RtwqBeginRegisterWorkQueueWithMMCSS(DWORD queue, const WCHAR *class, DWORD taskid, LONG priority, IRtwqAsyncCallback *callback, IUnknown *state);")
+cpp_quote("HRESULT WINAPI RtwqBeginUnregisterWorkQueueWithMMCSS(DWORD queue, IRtwqAsyncCallback *callback, IUnknown *state);")
 cpp_quote("HRESULT WINAPI RtwqCancelDeadline(HANDLE request);")
 cpp_quote("HRESULT WINAPI RtwqCancelWorkItem(RTWQWORKITEM_KEY key);")
 cpp_quote("HRESULT WINAPI RtwqCreateAsyncResult(IUnknown *object, IRtwqAsyncCallback *callback, IUnknown *state, IRtwqAsyncResult **result);")
+cpp_quote("HRESULT WINAPI RtwqEndRegisterWorkQueueWithMMCSS(IRtwqAsyncResult *result, DWORD *taskid);")
 cpp_quote("HRESULT WINAPI RtwqGetWorkQueueMMCSSClass(DWORD queue, WCHAR *class, DWORD *length);")
 cpp_quote("HRESULT WINAPI RtwqGetWorkQueueMMCSSPriority(DWORD queue, LONG *priority);")
 cpp_quote("HRESULT WINAPI RtwqGetWorkQueueMMCSSTaskId(DWORD queue, DWORD *taskid);")
From 93de829b13c6ff93bcdce510e1a90f17f5d88f94 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 5 Oct 2020 15:26:40 +0300
Subject: [PATCH] evr/presenter: Validate mixer's device id.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 55 ++++++++++++++++++++++++++++++++++----------
 1 file changed, 43 insertions(+), 12 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 04e9a556840..4a7a4021c28 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -357,6 +357,41 @@ static ULONG WINAPI video_presenter_service_client_Release(IMFTopologyServiceLoo
     return IMFVideoPresenter_Release(&presenter->IMFVideoPresenter_iface);
 }
 
+static HRESULT video_presenter_attach_mixer(struct video_presenter *presenter, IMFTopologyServiceLookup *service_lookup)
+{
+    IMFVideoDeviceID *device_id;
+    unsigned int count;
+    GUID id = { 0 };
+    HRESULT hr;
+
+    count = 1;
+    if (FAILED(hr = IMFTopologyServiceLookup_LookupService(service_lookup, MF_SERVICE_LOOKUP_GLOBAL, 0,
+            &MR_VIDEO_MIXER_SERVICE, &IID_IMFTransform, (void **)&presenter->mixer, &count)))
+    {
+        WARN("Failed to get mixer interface, hr %#x.\n", hr);
+        return hr;
+    }
+
+    if (SUCCEEDED(hr = IMFTransform_QueryInterface(presenter->mixer, &IID_IMFVideoDeviceID, (void **)&device_id)))
+    {
+        if (SUCCEEDED(hr = IMFVideoDeviceID_GetDeviceID(device_id, &id)))
+        {
+            if (!IsEqualGUID(&id, &IID_IDirect3DDevice9))
+                hr = MF_E_INVALIDREQUEST;
+        }
+
+        IMFVideoDeviceID_Release(device_id);
+    }
+
+    if (FAILED(hr))
+    {
+        IMFTransform_Release(presenter->mixer);
+        presenter->mixer = NULL;
+    }
+
+    return hr;
+}
+
 static HRESULT WINAPI video_presenter_service_client_InitServicePointers(IMFTopologyServiceLookupClient *iface,
         IMFTopologyServiceLookup *service_lookup)
 {
@@ -384,20 +419,16 @@ static HRESULT WINAPI video_presenter_service_client_InitServicePointers(IMFTopo
         IMFTopologyServiceLookup_LookupService(service_lookup, MF_SERVICE_LOOKUP_GLOBAL, 0,
                 &MR_VIDEO_RENDER_SERVICE, &IID_IMFClock, (void **)&presenter->clock, &count);
 
-        count = 1;
-        if (SUCCEEDED(hr = IMFTopologyServiceLookup_LookupService(service_lookup, MF_SERVICE_LOOKUP_GLOBAL, 0,
-                &MR_VIDEO_MIXER_SERVICE, &IID_IMFTransform, (void **)&presenter->mixer, &count)))
-        {
-            /* FIXME: presumably should validate mixer's device id. */
-        }
-        else
-            WARN("Failed to get mixer interface, hr %#x.\n", hr);
+        hr = video_presenter_attach_mixer(presenter, service_lookup);
 
-        count = 1;
-        if (FAILED(hr = IMFTopologyServiceLookup_LookupService(service_lookup, MF_SERVICE_LOOKUP_GLOBAL, 0,
-                &MR_VIDEO_RENDER_SERVICE, &IID_IMediaEventSink, (void **)&presenter->event_sink, &count)))
+        if (SUCCEEDED(hr))
         {
-            WARN("Failed to get renderer event sink, hr %#x.\n", hr);
+            count = 1;
+            if (FAILED(hr = IMFTopologyServiceLookup_LookupService(service_lookup, MF_SERVICE_LOOKUP_GLOBAL, 0,
+                    &MR_VIDEO_RENDER_SERVICE, &IID_IMediaEventSink, (void **)&presenter->event_sink, &count)))
+            {
+                WARN("Failed to get renderer event sink, hr %#x.\n", hr);
+            }
         }
 
         if (SUCCEEDED(hr))
From 6019f3c17989085ed0349edaade0c1c44e007e68 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 5 Oct 2020 15:26:41 +0300
Subject: [PATCH] mf: Implement MFCreateVideoRenderer().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c      | 28 ++++++++++++++++++++++++++++
 dlls/mf/mf.spec    |  2 +-
 dlls/mf/tests/mf.c |  4 ++++
 include/evr.idl    |  1 +
 4 files changed, 34 insertions(+), 1 deletion(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 31bc110ea48..c5b2ceecd67 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -1388,3 +1388,31 @@ HRESULT WINAPI MFCreateVideoRendererActivate(HWND hwnd, IMFActivate **activate)
 
     return hr;
 }
+
+/***********************************************************************
+ *      MFCreateVideoRenderer (mf.@)
+ */
+HRESULT WINAPI MFCreateVideoRenderer(REFIID riid, void **renderer)
+{
+    IMFAttributes *attributes;
+    IUnknown *obj;
+    HRESULT hr;
+
+    TRACE("%s, %p.\n", debugstr_guid(riid), renderer);
+
+    *renderer = NULL;
+
+    if (FAILED(hr = MFCreateAttributes(&attributes, 0)))
+        return hr;
+
+    hr = evr_create_object(attributes, NULL, &obj);
+    IMFAttributes_Release(attributes);
+
+    if (SUCCEEDED(hr))
+    {
+        hr = IUnknown_QueryInterface(obj, riid, renderer);
+        IUnknown_Release(obj);
+    }
+
+    return hr;
+}
diff --git a/dlls/mf/mf.spec b/dlls/mf/mf.spec
index 4b5b085d082..2927d9f8a88 100644
--- a/dlls/mf/mf.spec
+++ b/dlls/mf/mf.spec
@@ -66,7 +66,7 @@
 @ stub MFCreateTranscodeSinkActivate
 @ stub MFCreateTranscodeTopology
 @ stub MFCreateUrlmonSchemePlugin
-@ stub MFCreateVideoRenderer
+@ stdcall MFCreateVideoRenderer(ptr ptr)
 @ stdcall MFCreateVideoRendererActivate(long ptr)
 @ stub MFCreateWMAEncoderActivate
 @ stub MFCreateWMVEncoderActivate
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 2c02b1d8e54..0bc297cc69c 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3253,6 +3253,10 @@ static void test_evr(void)
     hr = CoInitialize(NULL);
     ok(hr == S_OK, "Failed to initialize, hr %#x.\n", hr);
 
+    hr = MFCreateVideoRenderer(&IID_IUnknown, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+
     hr = MFCreateVideoRendererActivate(NULL, NULL);
     ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
diff --git a/include/evr.idl b/include/evr.idl
index 77c46a075f1..c2178835383 100644
--- a/include/evr.idl
+++ b/include/evr.idl
@@ -313,5 +313,6 @@ cpp_quote("HRESULT WINAPI MFCreateVideoMixer(IUnknown *owner, REFIID riid_device
 cpp_quote("HRESULT WINAPI MFCreateVideoMixerAndPresenter(IUnknown *mixer_outer, IUnknown *presenter_outer, ")
 cpp_quote("        REFIID riid_mixer, void **mixer, REFIID riid_presenter, void **presenter);")
 cpp_quote("HRESULT WINAPI MFCreateVideoPresenter(IUnknown *owner, REFIID riid_device, REFIID riid, void **obj);")
+cpp_quote("HRESULT WINAPI MFCreateVideoRenderer(REFIID riid, void **renderer);")
 cpp_quote("HRESULT WINAPI MFCreateVideoSampleAllocator(REFIID riid, void **allocator);")
 cpp_quote("HRESULT WINAPI MFCreateVideoSampleFromSurface(IUnknown *surface, IMFSample **sample);")
From a419b3eb79741adc9f6f22f84b71ed3e8ae19025 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 5 Oct 2020 15:26:42 +0300
Subject: [PATCH] evr/presenter: Better validate input rectangles in
 SetVideoPosition().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 10 +++++++++-
 dlls/evr/tests/evr.c | 24 ++++++++++++++++++++++++
 2 files changed, 33 insertions(+), 1 deletion(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 4a7a4021c28..babaca6885c 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -510,7 +510,15 @@ static HRESULT WINAPI video_presenter_control_SetVideoPosition(IMFVideoDisplayCo
         return E_POINTER;
 
     if (src_rect && (src_rect->left < 0.0f || src_rect->top < 0.0f ||
-                src_rect->right > 1.0f || src_rect->bottom > 1.0f))
+            src_rect->right > 1.0f || src_rect->bottom > 1.0f ||
+            src_rect->left > src_rect->right ||
+            src_rect->top > src_rect->bottom))
+    {
+        return E_INVALIDARG;
+    }
+
+    if (dst_rect && (dst_rect->left > dst_rect->right ||
+            dst_rect->top > dst_rect->bottom))
         return E_INVALIDARG;
 
     EnterCriticalSection(&presenter->cs);
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 48bf01a2ef5..0436836963f 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1111,6 +1111,21 @@ static void test_default_presenter(void)
     hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
     ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
+    /* Flipped source rectangle. */
+    src_rect.left = 0.5f;
+    src_rect.top = 0.0f;
+    src_rect.right = 0.4f;
+    src_rect.bottom = 1.0f;
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    src_rect.left = 0.0f;
+    src_rect.top = 0.5f;
+    src_rect.right = 0.4f;
+    src_rect.bottom = 0.1f;
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
     src_rect.left = 0.1f;
     src_rect.top = 0.2f;
     src_rect.right = 0.8f;
@@ -1123,6 +1138,15 @@ static void test_default_presenter(void)
     ok(src_rect.left == 0.1f && src_rect.top == 0.2f && src_rect.right == 0.8f &&
             src_rect.bottom == 0.9f, "Unexpected source rectangle.\n");
 
+    /* Flipped destination rectangle. */
+    SetRect(&dst_rect, 100, 1, 50, 1000);
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    SetRect(&dst_rect, 1, 100, 100, 50);
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
     SetRect(&dst_rect, 1, 2, 999, 1000);
     hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
From f859a4d0482aeb5dc1a2831ba4795b46184315e5 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 5 Oct 2020 15:26:43 +0300
Subject: [PATCH] evr/presenter: Check video window in SetVideoPosition().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c |  16 +-
 dlls/evr/tests/evr.c | 385 +++++++++++++++++++++++++++++++++----------
 2 files changed, 308 insertions(+), 93 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index babaca6885c..37f4e675938 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -503,6 +503,7 @@ static HRESULT WINAPI video_presenter_control_SetVideoPosition(IMFVideoDisplayCo
         const MFVideoNormalizedRect *src_rect, const RECT *dst_rect)
 {
     struct video_presenter *presenter = impl_from_IMFVideoDisplayControl(iface);
+    HRESULT hr = S_OK;
 
     TRACE("%p, %p, %s.\n", iface, src_rect, wine_dbgstr_rect(dst_rect));
 
@@ -522,13 +523,18 @@ static HRESULT WINAPI video_presenter_control_SetVideoPosition(IMFVideoDisplayCo
         return E_INVALIDARG;
 
     EnterCriticalSection(&presenter->cs);
-    if (src_rect)
-        presenter->src_rect = *src_rect;
-    if (dst_rect)
-        presenter->dst_rect = *dst_rect;
+    if (!presenter->video_window)
+        hr = E_POINTER;
+    else
+    {
+        if (src_rect)
+            presenter->src_rect = *src_rect;
+        if (dst_rect)
+            presenter->dst_rect = *dst_rect;
+    }
     LeaveCriticalSection(&presenter->cs);
 
-    return S_OK;
+    return hr;
 }
 
 static HRESULT WINAPI video_presenter_control_GetVideoPosition(IMFVideoDisplayControl *iface, MFVideoNormalizedRect *src_rect,
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 0436836963f..869af10b221 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -970,7 +970,6 @@ static void test_default_presenter(void)
     D3DPRESENT_PARAMETERS present_params = { 0 };
     IMFVideoDisplayControl *display_control;
     IDirect3DSwapChain9 *swapchain;
-    MFVideoNormalizedRect src_rect;
     IMFVideoPresenter *presenter;
     IMFRateSupport *rate_support;
     IDirect3DDevice9 *d3d_device;
@@ -978,7 +977,6 @@ static void test_default_presenter(void)
     IMFVideoDeviceID *deviceid;
     IMFGetService *gs;
     HWND hwnd, hwnd2;
-    RECT dst_rect;
     HANDLE handle;
     IUnknown *unk;
     float rate;
@@ -1071,92 +1069,6 @@ static void test_default_presenter(void)
     ok(hwnd2 == hwnd, "Unexpected window %p.\n", hwnd2);
 
     /* Video position */
-    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, NULL, &dst_rect);
-    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
-
-    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
-
-    SetRect(&dst_rect, 1, 2, 3, 4);
-    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
-    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    ok(src_rect.left == 0.0f && src_rect.top == 0.0f && src_rect.right == 1.0f &&
-            src_rect.bottom == 1.0f, "Unexpected source rectangle.\n");
-    ok(dst_rect.left == 0 && dst_rect.right == 0 && dst_rect.top == 0 && dst_rect.bottom == 0,
-            "Unexpected destination rectangle %s.\n", wine_dbgstr_rect(&dst_rect));
-
-    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
-
-    SetRect(&dst_rect, 0, 0, 10, 10);
-    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
-    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-
-    SetRect(&dst_rect, 1, 2, 3, 4);
-    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
-    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    ok(dst_rect.left == 0 && dst_rect.right == 10 && dst_rect.top == 0 && dst_rect.bottom == 10,
-            "Unexpected destination rectangle %s.\n", wine_dbgstr_rect(&dst_rect));
-
-    src_rect.left = src_rect.top = 0.0f;
-    src_rect.right = 2.0f;
-    src_rect.bottom = 1.0f;
-    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
-
-    src_rect.left = -0.1f;
-    src_rect.top = 0.0f;
-    src_rect.right = 0.9f;
-    src_rect.bottom = 1.0f;
-    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
-
-    /* Flipped source rectangle. */
-    src_rect.left = 0.5f;
-    src_rect.top = 0.0f;
-    src_rect.right = 0.4f;
-    src_rect.bottom = 1.0f;
-    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
-
-    src_rect.left = 0.0f;
-    src_rect.top = 0.5f;
-    src_rect.right = 0.4f;
-    src_rect.bottom = 0.1f;
-    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
-
-    src_rect.left = 0.1f;
-    src_rect.top = 0.2f;
-    src_rect.right = 0.8f;
-    src_rect.bottom = 0.9f;
-    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
-    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-
-    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
-    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    ok(src_rect.left == 0.1f && src_rect.top == 0.2f && src_rect.right == 0.8f &&
-            src_rect.bottom == 0.9f, "Unexpected source rectangle.\n");
-
-    /* Flipped destination rectangle. */
-    SetRect(&dst_rect, 100, 1, 50, 1000);
-    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
-
-    SetRect(&dst_rect, 1, 100, 100, 50);
-    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
-
-    SetRect(&dst_rect, 1, 2, 999, 1000);
-    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
-    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-
-    SetRect(&dst_rect, 0, 1, 3, 4);
-    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
-    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    ok(dst_rect.left == 1 && dst_rect.right == 999 && dst_rect.top == 2 && dst_rect.bottom == 1000,
-            "Unexpected destination rectangle %s.\n", wine_dbgstr_rect(&dst_rect));
-
     hr = IDirect3DDeviceManager9_CloseDeviceHandle(dm, handle);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
@@ -1336,6 +1248,302 @@ todo_wine {
     IUnknown_Release(unk);
 }
 
+struct test_host
+{
+    IMFTopologyServiceLookup IMFTopologyServiceLookup_iface;
+    IMediaEventSink IMediaEventSink_iface;
+    IMFTransform *mixer;
+    IMFVideoPresenter *presenter;
+};
+
+static struct test_host *impl_from_test_host(IMFTopologyServiceLookup *iface)
+{
+    return CONTAINING_RECORD(iface, struct test_host, IMFTopologyServiceLookup_iface);
+}
+
+static struct test_host *impl_from_test_host_events(IMediaEventSink *iface)
+{
+    return CONTAINING_RECORD(iface, struct test_host, IMediaEventSink_iface);
+}
+
+static HRESULT WINAPI test_host_QueryInterface(IMFTopologyServiceLookup *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(riid, &IID_IMFTopologyServiceLookup) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFTopologyServiceLookup_AddRef(iface);
+        return S_OK;
+    }
+
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI test_host_AddRef(IMFTopologyServiceLookup *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI test_host_Release(IMFTopologyServiceLookup *iface)
+{
+    return 1;
+}
+
+static HRESULT WINAPI test_host_LookupService(IMFTopologyServiceLookup *iface,
+        MF_SERVICE_LOOKUP_TYPE lookup_type, DWORD index, REFGUID service,
+        REFIID riid, void **objects, DWORD *num_objects)
+{
+    struct test_host *host = impl_from_test_host(iface);
+
+    ok(*num_objects == 1, "Unexpected number of requested objects %u\n", *num_objects);
+
+    memset(objects, 0, *num_objects * sizeof(*objects));
+
+    if (IsEqualGUID(service, &MR_VIDEO_RENDER_SERVICE))
+    {
+        if (IsEqualIID(riid, &IID_IMFClock)) return E_FAIL;
+        if (IsEqualIID(riid, &IID_IMediaEventSink))
+        {
+            *objects = &host->IMediaEventSink_iface;
+            IMediaEventSink_AddRef(&host->IMediaEventSink_iface);
+            return S_OK;
+        }
+
+        ok(0, "Unexpected interface %s.\n", wine_dbgstr_guid(riid));
+        return E_UNEXPECTED;
+    }
+
+    if (IsEqualGUID(service, &MR_VIDEO_MIXER_SERVICE))
+    {
+        if (IsEqualIID(riid, &IID_IMFTransform))
+        {
+            *objects = host->mixer;
+            IMFTransform_AddRef(host->mixer);
+            return S_OK;
+        }
+        ok(0, "Unexpected interface %s.\n", wine_dbgstr_guid(riid));
+        return E_UNEXPECTED;
+    }
+
+    return E_NOTIMPL;
+}
+
+static const IMFTopologyServiceLookupVtbl test_host_vtbl =
+{
+    test_host_QueryInterface,
+    test_host_AddRef,
+    test_host_Release,
+    test_host_LookupService,
+};
+
+static HRESULT WINAPI test_host_events_QueryInterface(IMediaEventSink *iface, REFIID riid, void **obj)
+{
+    struct test_host *host = impl_from_test_host_events(iface);
+    return IMFTopologyServiceLookup_QueryInterface(&host->IMFTopologyServiceLookup_iface, riid, obj);
+}
+
+static ULONG WINAPI test_host_events_AddRef(IMediaEventSink *iface)
+{
+    struct test_host *host = impl_from_test_host_events(iface);
+    return IMFTopologyServiceLookup_AddRef(&host->IMFTopologyServiceLookup_iface);
+}
+
+static ULONG WINAPI test_host_events_Release(IMediaEventSink *iface)
+{
+    struct test_host *host = impl_from_test_host_events(iface);
+    return IMFTopologyServiceLookup_Release(&host->IMFTopologyServiceLookup_iface);
+}
+
+static HRESULT WINAPI test_host_events_Notify(IMediaEventSink *iface, LONG code, LONG_PTR param1, LONG_PTR param2)
+{
+    return S_OK;
+}
+
+static const IMediaEventSinkVtbl test_host_events_vtbl =
+{
+    test_host_events_QueryInterface,
+    test_host_events_AddRef,
+    test_host_events_Release,
+    test_host_events_Notify,
+};
+
+static void init_test_host(struct test_host *host, IMFTransform *mixer, IMFVideoPresenter *presenter)
+{
+    host->IMFTopologyServiceLookup_iface.lpVtbl = &test_host_vtbl;
+    host->IMediaEventSink_iface.lpVtbl = &test_host_events_vtbl;
+    /* No need to keep references. */
+    host->mixer = mixer;
+    host->presenter = presenter;
+}
+
+static void test_presenter_video_position(void)
+{
+    IMFTopologyServiceLookupClient *lookup_client;
+    IMFVideoDisplayControl *display_control;
+    IMFAttributes *mixer_attributes;
+    MFVideoNormalizedRect src_rect;
+    IMFVideoPresenter *presenter;
+    struct test_host host;
+    IMFTransform *mixer;
+    RECT dst_rect;
+    HRESULT hr;
+    DWORD count;
+    HWND hwnd;
+
+    hr = MFCreateVideoMixer(NULL, &IID_IDirect3DDevice9, &IID_IMFTransform, (void **)&mixer);
+    ok(hr == S_OK, "Failed to create a mixer, hr %#x.\n", hr);
+
+    hr = MFCreateVideoPresenter(NULL, &IID_IDirect3DDevice9, &IID_IMFVideoPresenter, (void **)&presenter);
+    ok(hr == S_OK, "Failed to create default presenter, hr %#x.\n", hr);
+
+    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFTopologyServiceLookupClient, (void **)&lookup_client);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    init_test_host(&host, mixer, presenter);
+
+    /* Clear default mixer attributes, then attach presenter. */
+    hr = IMFTransform_GetAttributes(mixer, &mixer_attributes);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFAttributes_DeleteAllItems(mixer_attributes);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTopologyServiceLookupClient_InitServicePointers(lookup_client, &host.IMFTopologyServiceLookup_iface);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFAttributes_GetCount(mixer_attributes, &count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+todo_wine
+    ok(count == 1, "Unexpected count %u.\n", count);
+
+    memset(&src_rect, 0, sizeof(src_rect));
+    hr = IMFAttributes_GetBlob(mixer_attributes, &VIDEO_ZOOM_RECT, (UINT8 *)&src_rect, sizeof(src_rect), NULL);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(src_rect.left == 0.0f && src_rect.top == 0.0f && src_rect.right == 1.0f &&
+            src_rect.bottom == 1.0f, "Unexpected source rectangle.\n");
+}
+
+    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFVideoDisplayControl, (void **)&display_control);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, NULL, &dst_rect);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    SetRect(&dst_rect, 1, 2, 3, 4);
+    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(src_rect.left == 0.0f && src_rect.top == 0.0f && src_rect.right == 1.0f &&
+            src_rect.bottom == 1.0f, "Unexpected source rectangle.\n");
+    ok(dst_rect.left == 0 && dst_rect.right == 0 && dst_rect.top == 0 && dst_rect.bottom == 0,
+            "Unexpected destination rectangle %s.\n", wine_dbgstr_rect(&dst_rect));
+
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    /* Setting position requires a window. */
+    hwnd = create_window();
+    ok(!!hwnd, "Failed to create a test window.\n");
+
+    SetRect(&dst_rect, 0, 0, 10, 10);
+    memset(&src_rect, 0, sizeof(src_rect));
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, &dst_rect);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_SetVideoWindow(display_control, hwnd);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    SetRect(&dst_rect, 0, 0, 10, 10);
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    SetRect(&dst_rect, 1, 2, 3, 4);
+    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(dst_rect.left == 0 && dst_rect.right == 10 && dst_rect.top == 0 && dst_rect.bottom == 10,
+            "Unexpected destination rectangle %s.\n", wine_dbgstr_rect(&dst_rect));
+
+    src_rect.left = src_rect.top = 0.0f;
+    src_rect.right = 2.0f;
+    src_rect.bottom = 1.0f;
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    src_rect.left = -0.1f;
+    src_rect.top = 0.0f;
+    src_rect.right = 0.9f;
+    src_rect.bottom = 1.0f;
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    /* Flipped source rectangle. */
+    src_rect.left = 0.5f;
+    src_rect.top = 0.0f;
+    src_rect.right = 0.4f;
+    src_rect.bottom = 1.0f;
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    src_rect.left = 0.0f;
+    src_rect.top = 0.5f;
+    src_rect.right = 0.4f;
+    src_rect.bottom = 0.1f;
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    src_rect.left = 0.1f;
+    src_rect.top = 0.2f;
+    src_rect.right = 0.8f;
+    src_rect.bottom = 0.9f;
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* Presenter updates mixer attribute. */
+    memset(&src_rect, 0, sizeof(src_rect));
+    hr = IMFAttributes_GetBlob(mixer_attributes, &VIDEO_ZOOM_RECT, (UINT8 *)&src_rect, sizeof(src_rect), NULL);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(src_rect.left == 0.1f && src_rect.top == 0.2f && src_rect.right == 0.8f &&
+            src_rect.bottom == 0.9f, "Unexpected source rectangle.\n");
+}
+    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(src_rect.left == 0.1f && src_rect.top == 0.2f && src_rect.right == 0.8f &&
+            src_rect.bottom == 0.9f, "Unexpected source rectangle.\n");
+
+    SetRect(&dst_rect, 1, 2, 999, 1000);
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    SetRect(&dst_rect, 0, 1, 3, 4);
+    hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(dst_rect.left == 1 && dst_rect.right == 999 && dst_rect.top == 2 && dst_rect.bottom == 1000,
+            "Unexpected destination rectangle %s.\n", wine_dbgstr_rect(&dst_rect));
+
+    /* Flipped destination rectangle. */
+    SetRect(&dst_rect, 100, 1, 50, 1000);
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    SetRect(&dst_rect, 1, 100, 100, 50);
+    hr = IMFVideoDisplayControl_SetVideoPosition(display_control, NULL, &dst_rect);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    IMFVideoDisplayControl_Release(display_control);
+
+    IMFTopologyServiceLookupClient_Release(lookup_client);
+    IMFVideoPresenter_Release(presenter);
+    IMFAttributes_Release(mixer_attributes);
+    IMFTransform_Release(mixer);
+
+    DestroyWindow(hwnd);
+}
+
 START_TEST(evr)
 {
     CoInitialize(NULL);
@@ -1353,6 +1561,7 @@ START_TEST(evr)
     test_default_presenter();
     test_MFCreateVideoMixerAndPresenter();
     test_MFCreateVideoSampleAllocator();
+    test_presenter_video_position();
 
     CoUninitialize();
 }
From 94b2db85b6ae695c91f2a7c872549bc6ebca19f4 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 5 Oct 2020 15:26:44 +0300
Subject: [PATCH] evr/presenter: Set VIDEO_ZOOM_RECT on SetVideoPosition().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 29 ++++++++++++++++++++++++++++-
 dlls/evr/tests/evr.c |  6 +-----
 2 files changed, 29 insertions(+), 6 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 37f4e675938..eceabfd381d 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -357,6 +357,25 @@ static ULONG WINAPI video_presenter_service_client_Release(IMFTopologyServiceLoo
     return IMFVideoPresenter_Release(&presenter->IMFVideoPresenter_iface);
 }
 
+static void video_presenter_set_mixer_rect(struct video_presenter *presenter)
+{
+    IMFAttributes *attributes;
+    HRESULT hr;
+
+    if (!presenter->mixer)
+        return;
+
+    if (SUCCEEDED(IMFTransform_GetAttributes(presenter->mixer, &attributes)))
+    {
+        if (FAILED(hr = IMFAttributes_SetBlob(attributes, &VIDEO_ZOOM_RECT, (const UINT8 *)&presenter->src_rect,
+                sizeof(presenter->src_rect))))
+        {
+            WARN("Failed to set zoom rectangle attribute, hr %#x.\n", hr);
+        }
+        IMFAttributes_Release(attributes);
+    }
+}
+
 static HRESULT video_presenter_attach_mixer(struct video_presenter *presenter, IMFTopologyServiceLookup *service_lookup)
 {
     IMFVideoDeviceID *device_id;
@@ -389,6 +408,8 @@ static HRESULT video_presenter_attach_mixer(struct video_presenter *presenter, I
         presenter->mixer = NULL;
     }
 
+    video_presenter_set_mixer_rect(presenter);
+
     return hr;
 }
 
@@ -528,7 +549,13 @@ static HRESULT WINAPI video_presenter_control_SetVideoPosition(IMFVideoDisplayCo
     else
     {
         if (src_rect)
-            presenter->src_rect = *src_rect;
+        {
+            if (memcmp(&presenter->src_rect, src_rect, sizeof(*src_rect)))
+            {
+                presenter->src_rect = *src_rect;
+                video_presenter_set_mixer_rect(presenter);
+            }
+        }
         if (dst_rect)
             presenter->dst_rect = *dst_rect;
     }
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 869af10b221..db9546a945b 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1414,16 +1414,13 @@ static void test_presenter_video_position(void)
 
     hr = IMFAttributes_GetCount(mixer_attributes, &count);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-todo_wine
     ok(count == 1, "Unexpected count %u.\n", count);
 
     memset(&src_rect, 0, sizeof(src_rect));
     hr = IMFAttributes_GetBlob(mixer_attributes, &VIDEO_ZOOM_RECT, (UINT8 *)&src_rect, sizeof(src_rect), NULL);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(src_rect.left == 0.0f && src_rect.top == 0.0f && src_rect.right == 1.0f &&
             src_rect.bottom == 1.0f, "Unexpected source rectangle.\n");
-}
 
     hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFVideoDisplayControl, (void **)&display_control);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
@@ -1505,11 +1502,10 @@ todo_wine {
     /* Presenter updates mixer attribute. */
     memset(&src_rect, 0, sizeof(src_rect));
     hr = IMFAttributes_GetBlob(mixer_attributes, &VIDEO_ZOOM_RECT, (UINT8 *)&src_rect, sizeof(src_rect), NULL);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(src_rect.left == 0.1f && src_rect.top == 0.2f && src_rect.right == 0.8f &&
             src_rect.bottom == 0.9f, "Unexpected source rectangle.\n");
-}
+
     hr = IMFVideoDisplayControl_GetVideoPosition(display_control, &src_rect, &dst_rect);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(src_rect.left == 0.1f && src_rect.top == 0.2f && src_rect.right == 0.8f &&
From 9b1bd73188ca47b718a46718ae8f269f9d0e212d Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 6 Oct 2020 14:48:57 +0300
Subject: [PATCH] evr/presenter: Return default flags for GetRenderingPrefs().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 14 ++++++++++++--
 dlls/evr/tests/evr.c | 10 ++++++++++
 2 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index eceabfd381d..8c455778d77 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -61,6 +61,7 @@ struct video_presenter
     HWND video_window;
     MFVideoNormalizedRect src_rect;
     RECT dst_rect;
+    DWORD rendering_prefs;
     unsigned int state;
     CRITICAL_SECTION cs;
 };
@@ -658,9 +659,18 @@ static HRESULT WINAPI video_presenter_control_SetRenderingPrefs(IMFVideoDisplayC
 
 static HRESULT WINAPI video_presenter_control_GetRenderingPrefs(IMFVideoDisplayControl *iface, DWORD *flags)
 {
-    FIXME("%p, %p.\n", iface, flags);
+    struct video_presenter *presenter = impl_from_IMFVideoDisplayControl(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, flags);
+
+    if (!flags)
+        return E_POINTER;
+
+    EnterCriticalSection(&presenter->cs);
+    *flags = presenter->rendering_prefs;
+    LeaveCriticalSection(&presenter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_presenter_control_SetFullscreen(IMFVideoDisplayControl *iface, BOOL fullscreen)
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index db9546a945b..85eedbe6643 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -979,6 +979,7 @@ static void test_default_presenter(void)
     HWND hwnd, hwnd2;
     HANDLE handle;
     IUnknown *unk;
+    DWORD flags;
     float rate;
     HRESULT hr;
     GUID iid;
@@ -1016,6 +1017,15 @@ static void test_default_presenter(void)
 
     hr = IMFGetService_GetService(gs, &MR_VIDEO_RENDER_SERVICE, &IID_IMFVideoDisplayControl, (void **)&display_control);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_GetRenderingPrefs(display_control, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    flags = 123;
+    hr = IMFVideoDisplayControl_GetRenderingPrefs(display_control, &flags);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!flags, "Unexpected rendering flags %#x.\n", flags);
+
     IMFVideoDisplayControl_Release(display_control);
 
     hr = IMFGetService_GetService(gs, &MR_VIDEO_ACCELERATION_SERVICE, &IID_IDirect3DDeviceManager9, (void **)&dm);
From c01a9bae61618eca9a551108994b374b05e865ed Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 6 Oct 2020 14:48:58 +0300
Subject: [PATCH] evr/presenter: Check for null argument in GetVideoWindow().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 5 +++++
 dlls/evr/tests/evr.c | 3 +++
 2 files changed, 8 insertions(+)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 8c455778d77..9acbead7287 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -616,7 +616,12 @@ static HRESULT WINAPI video_presenter_control_GetVideoWindow(IMFVideoDisplayCont
 
     TRACE("%p, %p.\n", iface, window);
 
+    if (!window)
+        return E_POINTER;
+
+    EnterCriticalSection(&presenter->cs);
     *window = presenter->video_window;
+    LeaveCriticalSection(&presenter->cs);
 
     return S_OK;
 }
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 85eedbe6643..53f1b02724d 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1065,6 +1065,9 @@ static void test_default_presenter(void)
     hwnd = create_window();
     ok(!!hwnd, "Failed to create a test window.\n");
 
+    hr = IMFVideoDisplayControl_GetVideoWindow(display_control, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
     hwnd2 = hwnd;
     hr = IMFVideoDisplayControl_GetVideoWindow(display_control, &hwnd2);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
From adc4dd674a28b71586511d466ac505aea86680fe Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 6 Oct 2020 14:48:59 +0300
Subject: [PATCH] evr/presenter: Validate passed handle on SetVideoWindow().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 3 +++
 dlls/evr/tests/evr.c | 6 ++++++
 2 files changed, 9 insertions(+)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 9acbead7287..15ebcd80acc 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -603,6 +603,9 @@ static HRESULT WINAPI video_presenter_control_SetVideoWindow(IMFVideoDisplayCont
 
     TRACE("%p, %p.\n", iface, window);
 
+    if (!IsWindow(window))
+        return E_INVALIDARG;
+
     EnterCriticalSection(&presenter->cs);
     presenter->video_window = window;
     LeaveCriticalSection(&presenter->cs);
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 53f1b02724d..79020e1ec49 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1073,6 +1073,12 @@ static void test_default_presenter(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(hwnd2 == NULL, "Unexpected window %p.\n", hwnd2);
 
+    hr = IMFVideoDisplayControl_SetVideoWindow(display_control, NULL);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_SetVideoWindow(display_control, (HWND)0x1);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
     hr = IMFVideoDisplayControl_SetVideoWindow(display_control, hwnd);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
From 0b8b00216fa269657f06a54803c731966e173829 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 6 Oct 2020 14:49:00 +0300
Subject: [PATCH] evr/mixer: Keep per-stream output rectangles.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     |  83 +++++++++++++++++-------
 dlls/evr/tests/evr.c | 150 +++++++++++++++++++++++++++++++++++++------
 2 files changed, 190 insertions(+), 43 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 4ada26d074f..da0bcb0a2db 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -41,6 +41,7 @@ struct input_stream
     unsigned int id;
     IMFAttributes *attributes;
     IMFVideoMediaType *media_type;
+    MFVideoNormalizedRect rect;
 };
 
 struct output_stream
@@ -145,15 +146,18 @@ static int video_mixer_compare_input_id(const void *a, const void *b)
     return 0;
 }
 
-static struct input_stream * video_mixer_get_input(const struct video_mixer *mixer, unsigned int id)
+static HRESULT video_mixer_get_input(const struct video_mixer *mixer, unsigned int id, struct input_stream **stream)
 {
-    return bsearch(&id, mixer->inputs, mixer->input_count, sizeof(*mixer->inputs), video_mixer_compare_input_id);
+    *stream = bsearch(&id, mixer->inputs, mixer->input_count, sizeof(*mixer->inputs), video_mixer_compare_input_id);
+    return *stream ? S_OK : MF_E_INVALIDSTREAMNUMBER;
 }
 
 static void video_mixer_init_input(struct input_stream *stream)
 {
     if (SUCCEEDED(MFCreateAttributes(&stream->attributes, 1)))
         IMFAttributes_SetUINT32(stream->attributes, &MF_SA_REQUIRED_SAMPLE_COUNT, 1);
+    stream->rect.left = stream->rect.top = 0.0f;
+    stream->rect.right = stream->rect.bottom = 1.0f;
 }
 
 static void video_mixer_clear_types(struct video_mixer *mixer)
@@ -352,19 +356,19 @@ static HRESULT WINAPI video_mixer_transform_GetInputStreamInfo(IMFTransform *ifa
 {
     struct video_mixer *mixer = impl_from_IMFTransform(iface);
     struct input_stream *input;
-    HRESULT hr = S_OK;
+    HRESULT hr;
 
     TRACE("%p, %u, %p.\n", iface, id, info);
 
     EnterCriticalSection(&mixer->cs);
-    if (!(input = video_mixer_get_input(mixer, id)))
-        hr = MF_E_INVALIDSTREAMNUMBER;
-    else
+
+    if (SUCCEEDED(hr = video_mixer_get_input(mixer, id, &input)))
     {
         memset(info, 0, sizeof(*info));
         if (id)
             info->dwFlags |= MFT_INPUT_STREAM_REMOVABLE | MFT_INPUT_STREAM_OPTIONAL;
     }
+
     LeaveCriticalSection(&mixer->cs);
 
     return hr;
@@ -402,15 +406,13 @@ static HRESULT WINAPI video_mixer_transform_GetInputStreamAttributes(IMFTransfor
 {
     struct video_mixer *mixer = impl_from_IMFTransform(iface);
     struct input_stream *input;
-    HRESULT hr = S_OK;
+    HRESULT hr;
 
     TRACE("%p, %u, %p.\n", iface, id, attributes);
 
     EnterCriticalSection(&mixer->cs);
 
-    if (!(input = video_mixer_get_input(mixer, id)))
-        hr = MF_E_INVALIDSTREAMNUMBER;
-    else
+    if (SUCCEEDED(hr = video_mixer_get_input(mixer, id, &input)))
     {
         *attributes = input->attributes;
         if (*attributes)
@@ -434,17 +436,18 @@ static HRESULT WINAPI video_mixer_transform_DeleteInputStream(IMFTransform *ifac
 {
     struct video_mixer *mixer = impl_from_IMFTransform(iface);
     struct input_stream *input;
-    HRESULT hr = S_OK;
     unsigned int idx;
+    HRESULT hr;
 
     TRACE("%p, %u.\n", iface, id);
 
+    if (!id)
+        return MF_E_INVALIDSTREAMNUMBER;
+
     EnterCriticalSection(&mixer->cs);
 
     /* Can't delete reference stream. */
-    if (!id || !(input = video_mixer_get_input(mixer, id)))
-        hr = MF_E_INVALIDSTREAMNUMBER;
-    else
+    if (SUCCEEDED(hr = video_mixer_get_input(mixer, id, &input)))
     {
         mixer->input_count--;
         idx = input - mixer->inputs;
@@ -736,13 +739,13 @@ static HRESULT WINAPI video_mixer_transform_GetInputCurrentType(IMFTransform *if
 {
     struct video_mixer *mixer = impl_from_IMFTransform(iface);
     struct input_stream *stream;
-    HRESULT hr = S_OK;
+    HRESULT hr;
 
     TRACE("%p, %u, %p.\n", iface, id, type);
 
     EnterCriticalSection(&mixer->cs);
 
-    if ((stream = video_mixer_get_input(mixer, id)))
+    if (SUCCEEDED(hr = video_mixer_get_input(mixer, id, &stream)))
     {
         if (!stream->media_type)
             hr = MF_E_TRANSFORM_TYPE_NOT_SET;
@@ -752,8 +755,6 @@ static HRESULT WINAPI video_mixer_transform_GetInputCurrentType(IMFTransform *if
             IMFMediaType_AddRef(*type);
         }
     }
-    else
-        hr = MF_E_INVALIDSTREAMNUMBER;
 
     LeaveCriticalSection(&mixer->cs);
 
@@ -1029,20 +1030,54 @@ static HRESULT WINAPI video_mixer_control_GetStreamZOrder(IMFVideoMixerControl2
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI video_mixer_control_SetStreamOutputRect(IMFVideoMixerControl2 *iface, DWORD stream_id,
+static HRESULT WINAPI video_mixer_control_SetStreamOutputRect(IMFVideoMixerControl2 *iface, DWORD id,
         const MFVideoNormalizedRect *rect)
 {
-    FIXME("%p, %u, %p.\n", iface, stream_id, rect);
+    struct video_mixer *mixer = impl_from_IMFVideoMixerControl2(iface);
+    struct input_stream *stream;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p.\n", iface, id, rect);
+
+    if (!rect)
+        return E_POINTER;
+
+    if (rect->left > rect->right || rect->top > rect->bottom ||
+            rect->left < 0.0f || rect->top < 0.0f || rect->right > 1.0f || rect->bottom > 1.0f)
+    {
+        return E_INVALIDARG;
+    }
+
+    EnterCriticalSection(&mixer->cs);
+
+    if (SUCCEEDED(hr = video_mixer_get_input(mixer, id, &stream)))
+        stream->rect = *rect;
+
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
-static HRESULT WINAPI video_mixer_control_GetStreamOutputRect(IMFVideoMixerControl2 *iface, DWORD stream_id,
+static HRESULT WINAPI video_mixer_control_GetStreamOutputRect(IMFVideoMixerControl2 *iface, DWORD id,
         MFVideoNormalizedRect *rect)
 {
-    FIXME("%p, %u, %p.\n", iface, stream_id, rect);
+    struct video_mixer *mixer = impl_from_IMFVideoMixerControl2(iface);
+    struct input_stream *stream;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p.\n", iface, id, rect);
+
+    if (!rect)
+        return E_POINTER;
+
+    EnterCriticalSection(&mixer->cs);
+
+    if (SUCCEEDED(hr = video_mixer_get_input(mixer, id, &stream)))
+        *rect = stream->rect;
+
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_mixer_control_SetMixingPrefs(IMFVideoMixerControl2 *iface, DWORD flags)
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 79020e1ec49..fbefe5e02f4 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -33,6 +33,14 @@ static const WCHAR sink_id[] = {'E','V','R',' ','I','n','p','u','t','0',0};
 
 static HRESULT (WINAPI *pMFCreateVideoMediaTypeFromSubtype)(const GUID *subtype, IMFVideoMediaType **video_type);
 
+static void set_rect(MFVideoNormalizedRect *rect, float left, float top, float right, float bottom)
+{
+    rect->left = left;
+    rect->top = top;
+    rect->right = right;
+    rect->bottom = bottom;
+}
+
 static HWND create_window(void)
 {
     RECT r = {0, 0, 640, 480};
@@ -1483,38 +1491,24 @@ static void test_presenter_video_position(void)
     ok(dst_rect.left == 0 && dst_rect.right == 10 && dst_rect.top == 0 && dst_rect.bottom == 10,
             "Unexpected destination rectangle %s.\n", wine_dbgstr_rect(&dst_rect));
 
-    src_rect.left = src_rect.top = 0.0f;
-    src_rect.right = 2.0f;
-    src_rect.bottom = 1.0f;
+    set_rect(&src_rect, 0.0f, 0.0f, 2.0f, 1.0f);
     hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
     ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
-    src_rect.left = -0.1f;
-    src_rect.top = 0.0f;
-    src_rect.right = 0.9f;
-    src_rect.bottom = 1.0f;
+    set_rect(&src_rect, -0.1f, 0.0f, 0.9f, 1.0f);
     hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
     ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     /* Flipped source rectangle. */
-    src_rect.left = 0.5f;
-    src_rect.top = 0.0f;
-    src_rect.right = 0.4f;
-    src_rect.bottom = 1.0f;
+    set_rect(&src_rect, 0.5f, 0.0f, 0.4f, 1.0f);
     hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
     ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
-    src_rect.left = 0.0f;
-    src_rect.top = 0.5f;
-    src_rect.right = 0.4f;
-    src_rect.bottom = 0.1f;
+    set_rect(&src_rect, 0.0f, 0.5f, 0.4f, 0.1f);
     hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
     ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
-    src_rect.left = 0.1f;
-    src_rect.top = 0.2f;
-    src_rect.right = 0.8f;
-    src_rect.bottom = 0.9f;
+    set_rect(&src_rect, 0.1f, 0.2f, 0.8f, 0.9f);
     hr = IMFVideoDisplayControl_SetVideoPosition(display_control, &src_rect, NULL);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
@@ -1559,6 +1553,122 @@ static void test_presenter_video_position(void)
     DestroyWindow(hwnd);
 }
 
+static void test_presenter_native_video_size(void)
+{
+    IMFTopologyServiceLookupClient *lookup_client;
+    IMFVideoDisplayControl *display_control;
+    IMFVideoPresenter *presenter;
+    struct test_host host;
+    IMFTransform *mixer;
+    SIZE size, ratio;
+    HRESULT hr;
+
+    hr = MFCreateVideoMixer(NULL, &IID_IDirect3DDevice9, &IID_IMFTransform, (void **)&mixer);
+    ok(hr == S_OK, "Failed to create a mixer, hr %#x.\n", hr);
+
+    hr = MFCreateVideoPresenter(NULL, &IID_IDirect3DDevice9, &IID_IMFVideoPresenter, (void **)&presenter);
+    ok(hr == S_OK, "Failed to create default presenter, hr %#x.\n", hr);
+
+    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFTopologyServiceLookupClient, (void **)&lookup_client);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFVideoDisplayControl, (void **)&display_control);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, NULL, NULL);
+todo_wine
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    memset(&size, 0xcc, sizeof(size));
+    hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, &size, NULL);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(size.cx == 0 && size.cy == 0, "Unexpected size.\n");
+}
+    memset(&ratio, 0xcc, sizeof(ratio));
+    hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, NULL, &ratio);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(ratio.cx == 0 && ratio.cy == 0, "Unexpected ratio.\n");
+}
+    hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFTopologyServiceLookupClient, (void **)&lookup_client);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    init_test_host(&host, mixer, presenter);
+
+    hr = IMFTopologyServiceLookupClient_InitServicePointers(lookup_client, &host.IMFTopologyServiceLookup_iface);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, &size, &ratio);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(size.cx == 0 && size.cy == 0, "Unexpected size.\n");
+    ok(ratio.cx == 0 && ratio.cy == 0, "Unexpected ratio.\n");
+}
+    IMFVideoDisplayControl_Release(display_control);
+    IMFVideoPresenter_Release(presenter);
+    IMFTransform_Release(mixer);
+}
+
+static void test_mixer_output_rectangle(void)
+{
+    IMFVideoMixerControl *mixer_control;
+    MFVideoNormalizedRect rect;
+    IMFTransform *mixer;
+    HRESULT hr;
+
+    hr = MFCreateVideoMixer(NULL, &IID_IDirect3DDevice9, &IID_IMFTransform, (void **)&mixer);
+    ok(hr == S_OK, "Failed to create a mixer, hr %#x.\n", hr);
+
+    hr = IMFTransform_QueryInterface(mixer, &IID_IMFVideoMixerControl, (void **)&mixer_control);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoMixerControl_GetStreamOutputRect(mixer_control, 0, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    set_rect(&rect, 0.0f, 0.0f, 0.0f, 0.0f);
+    hr = IMFVideoMixerControl_GetStreamOutputRect(mixer_control, 0, &rect);
+    ok(hr == S_OK, "Failed to get output rect, hr %#x.\n", hr);
+    ok(rect.left == 0.0f && rect.top == 0.0f && rect.right == 1.0f && rect.bottom == 1.0f,
+            "Unexpected rectangle.\n");
+
+    hr = IMFVideoMixerControl_GetStreamOutputRect(mixer_control, 1, &rect);
+    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoMixerControl_GetStreamOutputRect(mixer_control, 1, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoMixerControl_SetStreamOutputRect(mixer_control, 1, &rect);
+    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoMixerControl_SetStreamOutputRect(mixer_control, 1, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    /* Wrong bounds. */
+    set_rect(&rect, 0.0f, 0.0f, 1.1f, 1.0f);
+    hr = IMFVideoMixerControl_SetStreamOutputRect(mixer_control, 0, &rect);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    set_rect(&rect, -0.1f, 0.0f, 0.5f, 1.0f);
+    hr = IMFVideoMixerControl_SetStreamOutputRect(mixer_control, 0, &rect);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    /* Flipped. */
+    set_rect(&rect, 1.0f, 0.0f, 0.0f, 1.0f);
+    hr = IMFVideoMixerControl_SetStreamOutputRect(mixer_control, 0, &rect);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    set_rect(&rect, 0.0f, 1.0f, 1.0f, 0.5f);
+    hr = IMFVideoMixerControl_SetStreamOutputRect(mixer_control, 0, &rect);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoMixerControl_SetStreamOutputRect(mixer_control, 0, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    IMFVideoMixerControl_Release(mixer_control);
+    IMFTransform_Release(mixer);
+}
+
 START_TEST(evr)
 {
     CoInitialize(NULL);
@@ -1577,6 +1687,8 @@ START_TEST(evr)
     test_MFCreateVideoMixerAndPresenter();
     test_MFCreateVideoSampleAllocator();
     test_presenter_video_position();
+    test_presenter_native_video_size();
+    test_mixer_output_rectangle();
 
     CoUninitialize();
 }
From 9cb5077096b72c2668fdf6d8f7e59179f6bf39a6 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 6 Oct 2020 14:49:01 +0300
Subject: [PATCH] evr/mixer: Keep per-stream zorder configuration.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     |  59 +++++++++++++++++++++---
 dlls/evr/tests/evr.c | 105 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 158 insertions(+), 6 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index da0bcb0a2db..107438b1f17 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -42,6 +42,7 @@ struct input_stream
     IMFAttributes *attributes;
     IMFVideoMediaType *media_type;
     MFVideoNormalizedRect rect;
+    unsigned int zorder;
 };
 
 struct output_stream
@@ -510,6 +511,8 @@ static HRESULT WINAPI video_mixer_transform_AddInputStreams(IMFTransform *iface,
 
         if (SUCCEEDED(hr))
         {
+            unsigned int zorder = mixer->input_count;
+
             for (i = 0; i < count; ++i)
             {
                 if ((input = bsearch(&ids[i], inputs, len, sizeof(*inputs), video_mixer_compare_input_id)))
@@ -518,6 +521,13 @@ static HRESULT WINAPI video_mixer_transform_AddInputStreams(IMFTransform *iface,
             memcpy(&mixer->input_ids[mixer->input_count], ids, count * sizeof(*ids));
             memcpy(mixer->inputs, inputs, len * sizeof(*inputs));
             mixer->input_count += count;
+
+            for (i = 0; i < count; ++i)
+            {
+                if (SUCCEEDED(video_mixer_get_input(mixer, ids[i], &input)))
+                    input->zorder = zorder;
+                zorder++;
+            }
         }
     }
     LeaveCriticalSection(&mixer->cs);
@@ -1016,18 +1026,55 @@ static ULONG WINAPI video_mixer_control_Release(IMFVideoMixerControl2 *iface)
     return IMFTransform_Release(&mixer->IMFTransform_iface);
 }
 
-static HRESULT WINAPI video_mixer_control_SetStreamZOrder(IMFVideoMixerControl2 *iface, DWORD stream_id, DWORD zorder)
+static HRESULT WINAPI video_mixer_control_SetStreamZOrder(IMFVideoMixerControl2 *iface, DWORD id, DWORD zorder)
 {
-    FIXME("%p, %u, %u.\n", iface, stream_id, zorder);
+    struct video_mixer *mixer = impl_from_IMFVideoMixerControl2(iface);
+    struct input_stream *stream;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %u.\n", iface, id, zorder);
+
+    /* Can't change reference stream. */
+    if (!id && zorder)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&mixer->cs);
+
+    if (zorder >= mixer->input_count)
+        hr = E_INVALIDARG;
+    else if (SUCCEEDED(hr = video_mixer_get_input(mixer, id, &stream)))
+    {
+        /* Lowest zorder only applies to reference stream. */
+        if (id && !zorder)
+            hr = MF_E_INVALIDREQUEST;
+        else
+            stream->zorder = zorder;
+    }
+
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
-static HRESULT WINAPI video_mixer_control_GetStreamZOrder(IMFVideoMixerControl2 *iface, DWORD stream_id, DWORD *zorder)
+static HRESULT WINAPI video_mixer_control_GetStreamZOrder(IMFVideoMixerControl2 *iface, DWORD id, DWORD *zorder)
 {
-    FIXME("%p, %u, %p.\n", iface, stream_id, zorder);
+    struct video_mixer *mixer = impl_from_IMFVideoMixerControl2(iface);
+    struct input_stream *stream;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p.\n", iface, id, zorder);
+
+    if (!zorder)
+        return E_POINTER;
+
+    EnterCriticalSection(&mixer->cs);
+
+    if (SUCCEEDED(hr = video_mixer_get_input(mixer, id, &stream)))
+        *zorder = stream->zorder;
+
+    LeaveCriticalSection(&mixer->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_mixer_control_SetStreamOutputRect(IMFVideoMixerControl2 *iface, DWORD id,
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index fbefe5e02f4..70c7053efdf 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1669,6 +1669,110 @@ static void test_mixer_output_rectangle(void)
     IMFTransform_Release(mixer);
 }
 
+static void test_mixer_zorder(void)
+{
+    IMFVideoMixerControl *mixer_control;
+    IMFTransform *mixer;
+    DWORD ids[2];
+    DWORD value;
+    HRESULT hr;
+
+    hr = MFCreateVideoMixer(NULL, &IID_IDirect3DDevice9, &IID_IMFTransform, (void **)&mixer);
+    ok(hr == S_OK, "Failed to create a mixer, hr %#x.\n", hr);
+
+    hr = IMFTransform_QueryInterface(mixer, &IID_IMFVideoMixerControl, (void **)&mixer_control);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoMixerControl_GetStreamZOrder(mixer_control, 0, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoMixerControl_GetStreamZOrder(mixer_control, 1, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    value = 1;
+    hr = IMFVideoMixerControl_GetStreamZOrder(mixer_control, 0, &value);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!value, "Unexpected value %u.\n", value);
+
+    value = 1;
+    hr = IMFVideoMixerControl_GetStreamZOrder(mixer_control, 1, &value);
+    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoMixerControl_SetStreamZOrder(mixer_control, 0, 1);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoMixerControl_SetStreamZOrder(mixer_control, 1, 1);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    /* Exceeds maximum stream number. */
+    hr = IMFVideoMixerControl_SetStreamZOrder(mixer_control, 0, 20);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    value = 1;
+    hr = IMFTransform_AddInputStreams(mixer, 1, &value);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    value = 0;
+    hr = IMFVideoMixerControl_GetStreamZOrder(mixer_control, 1, &value);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(value == 1, "Unexpected zorder %u.\n", value);
+
+    hr = IMFVideoMixerControl_SetStreamZOrder(mixer_control, 1, 0);
+    ok(hr == MF_E_INVALIDREQUEST, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoMixerControl_SetStreamZOrder(mixer_control, 1, 2);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoMixerControl_SetStreamZOrder(mixer_control, 0, 0);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    value = 2;
+    hr = IMFTransform_AddInputStreams(mixer, 1, &value);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    value = 0;
+    hr = IMFVideoMixerControl_GetStreamZOrder(mixer_control, 2, &value);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(value == 2, "Unexpected zorder %u.\n", value);
+
+    hr = IMFVideoMixerControl_SetStreamZOrder(mixer_control, 2, 1);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    value = 3;
+    hr = IMFTransform_AddInputStreams(mixer, 1, &value);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    value = 0;
+    hr = IMFVideoMixerControl_GetStreamZOrder(mixer_control, 3, &value);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(value == 3, "Unexpected zorder %u.\n", value);
+
+    hr = IMFTransform_DeleteInputStream(mixer, 1);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    hr = IMFTransform_DeleteInputStream(mixer, 2);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    hr = IMFTransform_DeleteInputStream(mixer, 3);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    ids[0] = 2;
+    ids[1] = 1;
+    hr = IMFTransform_AddInputStreams(mixer, 2, ids);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    value = 0;
+    hr = IMFVideoMixerControl_GetStreamZOrder(mixer_control, 1, &value);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(value == 2, "Unexpected zorder %u.\n", value);
+
+    value = 0;
+    hr = IMFVideoMixerControl_GetStreamZOrder(mixer_control, 2, &value);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(value == 1, "Unexpected zorder %u.\n", value);
+
+    IMFVideoMixerControl_Release(mixer_control);
+    IMFTransform_Release(mixer);
+}
+
 START_TEST(evr)
 {
     CoInitialize(NULL);
@@ -1689,6 +1793,7 @@ START_TEST(evr)
     test_presenter_video_position();
     test_presenter_native_video_size();
     test_mixer_output_rectangle();
+    test_mixer_zorder();
 
     CoUninitialize();
 }
From e47b45e2f55ea33790aa60fdf207cafa53c9adb0 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 7 Oct 2020 01:04:56 +0700
Subject: [PATCH] winegstreamer: Use RGB15/16 formats instead of BGR15/16.

Gstreamer stores the first component in the most significant bits, same as DirectShow.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index acb15dc9238..5b5add409c7 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -194,11 +194,11 @@ static gboolean amt_from_gst_video_info(const GstVideoInfo *info, AM_MEDIA_TYPE
             amt->subtype = MEDIASUBTYPE_RGB24;
             bih->biBitCount = 24;
             break;
-        case GST_VIDEO_FORMAT_BGR16:
+        case GST_VIDEO_FORMAT_RGB16:
             amt->subtype = MEDIASUBTYPE_RGB565;
             bih->biBitCount = 16;
             break;
-        case GST_VIDEO_FORMAT_BGR15:
+        case GST_VIDEO_FORMAT_RGB15:
             amt->subtype = MEDIASUBTYPE_RGB555;
             bih->biBitCount = 16;
             break;
@@ -380,8 +380,8 @@ static GstCaps *amt_to_gst_caps_video(const AM_MEDIA_TYPE *mt)
         {&MEDIASUBTYPE_ARGB32,  GST_VIDEO_FORMAT_BGRA},
         {&MEDIASUBTYPE_RGB32,   GST_VIDEO_FORMAT_BGRx},
         {&MEDIASUBTYPE_RGB24,   GST_VIDEO_FORMAT_BGR},
-        {&MEDIASUBTYPE_RGB565,  GST_VIDEO_FORMAT_BGR16},
-        {&MEDIASUBTYPE_RGB555,  GST_VIDEO_FORMAT_BGR15},
+        {&MEDIASUBTYPE_RGB565,  GST_VIDEO_FORMAT_RGB16},
+        {&MEDIASUBTYPE_RGB555,  GST_VIDEO_FORMAT_RGB15},
     };
 
     const VIDEOINFOHEADER *vih = (VIDEOINFOHEADER *)mt->pbFormat;
From 9afc5ed72eaf109726be8f558294a1a21502c496 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 7 Oct 2020 01:04:57 +0700
Subject: [PATCH] winegstreamer: Fix RGB565 conversion in
 amt_from_gst_video_info().

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 5b5add409c7..e95205ca44a 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -158,7 +158,7 @@ static gboolean amt_from_gst_audio_info(const GstAudioInfo *info, AM_MEDIA_TYPE
 
 static gboolean amt_from_gst_video_info(const GstVideoInfo *info, AM_MEDIA_TYPE *amt)
 {
-    VIDEOINFOHEADER *vih;
+    VIDEOINFO *vih;
     BITMAPINFOHEADER *bih;
     gint32 width, height;
 
@@ -170,7 +170,7 @@ static gboolean amt_from_gst_video_info(const GstVideoInfo *info, AM_MEDIA_TYPE
 
     amt->formattype = FORMAT_VideoInfo;
     amt->pbFormat = (BYTE*)vih;
-    amt->cbFormat = sizeof(*vih);
+    amt->cbFormat = sizeof(VIDEOINFOHEADER);
     amt->bFixedSizeSamples = FALSE;
     amt->bTemporalCompression = TRUE;
     amt->lSampleSize = 1;
@@ -180,6 +180,7 @@ static gboolean amt_from_gst_video_info(const GstVideoInfo *info, AM_MEDIA_TYPE
 
     if (GST_VIDEO_INFO_IS_RGB(info))
     {
+        bih->biCompression = BI_RGB;
         switch (GST_VIDEO_INFO_FORMAT(info))
         {
         case GST_VIDEO_FORMAT_BGRA:
@@ -196,7 +197,12 @@ static gboolean amt_from_gst_video_info(const GstVideoInfo *info, AM_MEDIA_TYPE
             break;
         case GST_VIDEO_FORMAT_RGB16:
             amt->subtype = MEDIASUBTYPE_RGB565;
+            amt->cbFormat = offsetof(VIDEOINFO, u.dwBitMasks[3]);
+            vih->u.dwBitMasks[iRED] = 0xf800;
+            vih->u.dwBitMasks[iGREEN] = 0x07e0;
+            vih->u.dwBitMasks[iBLUE] = 0x001f;
             bih->biBitCount = 16;
+            bih->biCompression = BI_BITFIELDS;
             break;
         case GST_VIDEO_FORMAT_RGB15:
             amt->subtype = MEDIASUBTYPE_RGB555;
@@ -207,7 +213,6 @@ static gboolean amt_from_gst_video_info(const GstVideoInfo *info, AM_MEDIA_TYPE
             CoTaskMemFree(vih);
             return FALSE;
         }
-        bih->biCompression = BI_RGB;
     } else {
         amt->subtype = MEDIATYPE_Video;
         if (!(amt->subtype.Data1 = gst_video_format_to_fourcc(GST_VIDEO_INFO_FORMAT(info))))
@@ -2116,7 +2121,8 @@ static HRESULT WINAPI GSTOutPin_DecideBufferSize(struct strmbase_source *iface,
         buffer_size = format->bmiHeader.biSizeImage;
 
         gst_util_set_object_arg(G_OBJECT(pin->flip), "method",
-                format->bmiHeader.biCompression == BI_RGB ? "vertical-flip" : "none");
+                (format->bmiHeader.biCompression == BI_RGB
+                || format->bmiHeader.biCompression == BI_BITFIELDS) ? "vertical-flip" : "none");
     }
     else if (IsEqualGUID(&pin->pin.pin.mt.formattype, &FORMAT_WaveFormatEx)
             && (IsEqualGUID(&pin->pin.pin.mt.subtype, &MEDIASUBTYPE_PCM)
From e484056171bfd57473660243bc75935409320f37 Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 7 Oct 2020 01:04:58 +0700
Subject: [PATCH] winegstreamer: Add a second videoconvert to handle 15/16-bit
 RGB formats.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 19 +++++++++++++++++--
 1 file changed, 17 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index e95205ca44a..90a129f29a4 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1003,7 +1003,7 @@ static void init_new_decoded_pad(GstElement *bin, GstPad *pad, struct gstdemux *
 
     if (!strcmp(typename, "video/x-raw"))
     {
-        GstElement *vconv, *flip, *deinterlace;
+        GstElement *deinterlace, *vconv, *flip, *vconv2;
 
         /* DirectShow can express interlaced video, but downstream filters can't
          * necessarily consume it. In particular, the video renderer can't. */
@@ -1035,6 +1035,18 @@ static void init_new_decoded_pad(GstElement *bin, GstPad *pad, struct gstdemux *
             goto out;
         }
 
+        /* videoflip does not support 15 and 16-bit RGB so add a second videoconvert
+         * to do the final conversion. */
+        if (!(vconv2 = gst_element_factory_make("videoconvert", NULL)))
+        {
+            ERR("Failed to create videoconvert, are %u-bit GStreamer \"base\" plugins installed?\n",
+                    8 * (int)sizeof(void *));
+            goto out;
+        }
+
+        /* Avoid expensive color matrix conversions. */
+        gst_util_set_object_arg(G_OBJECT(vconv2), "matrix-mode", "none");
+
         /* The bin takes ownership of these elements. */
         gst_bin_add(GST_BIN(This->container), deinterlace);
         gst_element_sync_state_with_parent(deinterlace);
@@ -1042,12 +1054,15 @@ static void init_new_decoded_pad(GstElement *bin, GstPad *pad, struct gstdemux *
         gst_element_sync_state_with_parent(vconv);
         gst_bin_add(GST_BIN(This->container), flip);
         gst_element_sync_state_with_parent(flip);
+        gst_bin_add(GST_BIN(This->container), vconv2);
+        gst_element_sync_state_with_parent(vconv2);
 
         gst_element_link(deinterlace, vconv);
         gst_element_link(vconv, flip);
+        gst_element_link(flip, vconv2);
 
         pin->post_sink = gst_element_get_static_pad(deinterlace, "sink");
-        pin->post_src = gst_element_get_static_pad(flip, "src");
+        pin->post_src = gst_element_get_static_pad(vconv2, "src");
         pin->flip = flip;
     }
     else if (!strcmp(typename, "audio/x-raw"))
From 0542a34c247f029a0394f308f9f44c5c41d904fc Mon Sep 17 00:00:00 2001
From: Anton Baskanov <baskanov@gmail.com>
Date: Wed, 7 Oct 2020 01:04:59 +0700
Subject: [PATCH] winegstreamer: Expose 15/16-bit RGB formats.

Signed-off-by: Anton Baskanov <baskanov@gmail.com>
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winegstreamer/gstdemux.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 90a129f29a4..6279c2c28c0 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -1722,6 +1722,8 @@ static HRESULT gstdecoder_source_get_media_type(struct gstdemux_source *pin,
         GST_VIDEO_FORMAT_BGRA,
         GST_VIDEO_FORMAT_BGRx,
         GST_VIDEO_FORMAT_BGR,
+        GST_VIDEO_FORMAT_RGB16,
+        GST_VIDEO_FORMAT_RGB15,
     };
 
     assert(caps); /* We shouldn't be able to get here if caps haven't been set. */
From d2beff26236258a9c8853d0a54534a79d595ae7a Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 7 Oct 2020 11:40:19 +0300
Subject: [PATCH] evr/tests: Add some tests for presenter's
 GetNativeVideoSize().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/tests/Makefile.in |  2 +-
 dlls/evr/tests/evr.c       | 55 ++++++++++++++++++++++++++++++++++++--
 2 files changed, 54 insertions(+), 3 deletions(-)

diff --git a/dlls/evr/tests/Makefile.in b/dlls/evr/tests/Makefile.in
index 5bd82277d1b..c5db2226ebc 100644
--- a/dlls/evr/tests/Makefile.in
+++ b/dlls/evr/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = evr.dll
-IMPORTS   = dxva2 mfplat mfuuid strmiids uuid dxguid ole32 oleaut32 evr d3d9 user32
+IMPORTS   = dxva2 mfplat mfuuid mf strmiids uuid dxguid ole32 oleaut32 evr d3d9 user32
 
 C_SRCS = \
 	evr.c
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 70c7053efdf..ce2803bcb34 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1562,6 +1562,8 @@ static void test_presenter_native_video_size(void)
     IMFTransform *mixer;
     SIZE size, ratio;
     HRESULT hr;
+    IMFVideoMediaType *video_type;
+    IDirect3DDeviceManager9 *dm;
 
     hr = MFCreateVideoMixer(NULL, &IID_IDirect3DDevice9, &IID_IMFTransform, (void **)&mixer);
     ok(hr == S_OK, "Failed to create a mixer, hr %#x.\n", hr);
@@ -1594,6 +1596,27 @@ todo_wine {
     hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFTopologyServiceLookupClient, (void **)&lookup_client);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    /* Configure mixer primary stream. */
+    hr = MFGetService((IUnknown *)presenter, &MR_VIDEO_ACCELERATION_SERVICE, &IID_IDirect3DDeviceManager9, (void **)&dm);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_ProcessMessage(mixer, MFT_MESSAGE_SET_D3D_MANAGER, (ULONG_PTR)dm);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    IDirect3DDeviceManager9_Release(dm);
+
+    hr = pMFCreateVideoMediaTypeFromSubtype(&MFVideoFormat_RGB32, &video_type);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoMediaType_SetUINT64(video_type, &MF_MT_FRAME_SIZE, (UINT64)640 << 32 | 480);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    hr = IMFVideoMediaType_SetUINT32(video_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_SetInputType(mixer, 0, (IMFMediaType *)video_type, 0);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    /* Native video size is cached on initialization. */
     init_test_host(&host, mixer, presenter);
 
     hr = IMFTopologyServiceLookupClient_InitServicePointers(lookup_client, &host.IMFTopologyServiceLookup_iface);
@@ -1602,9 +1625,37 @@ todo_wine {
     hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, &size, &ratio);
 todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    ok(size.cx == 0 && size.cy == 0, "Unexpected size.\n");
-    ok(ratio.cx == 0 && ratio.cy == 0, "Unexpected ratio.\n");
+    ok(size.cx == 640 && size.cy == 480, "Unexpected size %u x %u.\n", size.cx, size.cy);
+    ok((ratio.cx == 4 && ratio.cy == 3) || broken(!memcmp(&ratio, &size, sizeof(ratio))) /* < Win10 */,
+            "Unexpected ratio %u x %u.\n", ratio.cx, ratio.cy);
+}
+    /* Update input type. */
+    hr = IMFVideoMediaType_SetUINT64(video_type, &MF_MT_FRAME_SIZE, (UINT64)320 << 32 | 240);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_SetInputType(mixer, 0, (IMFMediaType *)video_type, 0);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, &size, &ratio);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(size.cx == 640 && size.cy == 480, "Unexpected size %u x %u.\n", size.cx, size.cy);
+    ok((ratio.cx == 4 && ratio.cy == 3) || broken(!memcmp(&ratio, &size, sizeof(ratio))) /* < Win10 */,
+            "Unexpected ratio %u x %u.\n", ratio.cx, ratio.cy);
 }
+    /* Negotiating types updates native video size. */
+    hr = IMFVideoPresenter_ProcessMessage(presenter, MFVP_MESSAGE_INVALIDATEMEDIATYPE, 0);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, &size, &ratio);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(size.cx == 320 && size.cy == 240, "Unexpected size %u x %u.\n", size.cx, size.cy);
+    ok((ratio.cx == 4 && ratio.cy == 3) || broken(!memcmp(&ratio, &size, sizeof(ratio))) /* < Win10 */,
+            "Unexpected ratio %u x %u.\n", ratio.cx, ratio.cy);
+}
+    IMFVideoMediaType_Release(video_type);
     IMFVideoDisplayControl_Release(display_control);
     IMFVideoPresenter_Release(presenter);
     IMFTransform_Release(mixer);
From 95dcc559fcd9b5f7e6a492e51781c95a257d2dc3 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 7 Oct 2020 11:40:20 +0300
Subject: [PATCH] evr/presenter: Request original reference frame size when
 attaching the mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 64 ++++++++++++++++++++++++++++++++++++++++++--
 dlls/evr/tests/evr.c | 17 +++++-------
 2 files changed, 68 insertions(+), 13 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index 15ebcd80acc..ba9e09c4e3e 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -62,6 +62,8 @@ struct video_presenter
     MFVideoNormalizedRect src_rect;
     RECT dst_rect;
     DWORD rendering_prefs;
+    SIZE native_size;
+    SIZE native_ratio;
     unsigned int state;
     CRITICAL_SECTION cs;
 };
@@ -377,6 +379,51 @@ static void video_presenter_set_mixer_rect(struct video_presenter *presenter)
     }
 }
 
+static unsigned int get_gcd(unsigned int a, unsigned int b)
+{
+    unsigned int m;
+
+    while (b)
+    {
+        m = a % b;
+        a = b;
+        b = m;
+    }
+
+    return a;
+}
+
+static void video_presenter_get_native_video_size(struct video_presenter *presenter)
+{
+    IMFMediaType *media_type;
+    UINT64 frame_size = 0;
+
+    memset(&presenter->native_size, 0, sizeof(presenter->native_size));
+    memset(&presenter->native_ratio, 0, sizeof(presenter->native_ratio));
+
+    if (!presenter->mixer)
+        return;
+
+    if (FAILED(IMFTransform_GetInputCurrentType(presenter->mixer, 0, &media_type)))
+        return;
+
+    if (SUCCEEDED(IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &frame_size)))
+    {
+        unsigned int gcd;
+
+        presenter->native_size.cx = frame_size >> 32;
+        presenter->native_size.cy = frame_size;
+
+        if ((gcd = get_gcd(presenter->native_size.cx, presenter->native_size.cy)))
+        {
+            presenter->native_ratio.cx = presenter->native_size.cx / gcd;
+            presenter->native_ratio.cy = presenter->native_size.cy / gcd;
+        }
+    }
+
+    IMFMediaType_Release(media_type);
+}
+
 static HRESULT video_presenter_attach_mixer(struct video_presenter *presenter, IMFTopologyServiceLookup *service_lookup)
 {
     IMFVideoDeviceID *device_id;
@@ -410,6 +457,7 @@ static HRESULT video_presenter_attach_mixer(struct video_presenter *presenter, I
     }
 
     video_presenter_set_mixer_rect(presenter);
+    video_presenter_get_native_video_size(presenter);
 
     return hr;
 }
@@ -508,9 +556,21 @@ static ULONG WINAPI video_presenter_control_Release(IMFVideoDisplayControl *ifac
 static HRESULT WINAPI video_presenter_control_GetNativeVideoSize(IMFVideoDisplayControl *iface, SIZE *video_size,
         SIZE *aspect_ratio)
 {
-    FIXME("%p, %p, %p.\n", iface, video_size, aspect_ratio);
+    struct video_presenter *presenter = impl_from_IMFVideoDisplayControl(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %p.\n", iface, video_size, aspect_ratio);
+
+    if (!video_size && !aspect_ratio)
+        return E_POINTER;
+
+    EnterCriticalSection(&presenter->cs);
+    if (video_size)
+        *video_size = presenter->native_size;
+    if (aspect_ratio)
+        *aspect_ratio = presenter->native_ratio;
+    LeaveCriticalSection(&presenter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_presenter_control_GetIdealVideoSize(IMFVideoDisplayControl *iface, SIZE *min_size,
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index ce2803bcb34..39d2ed72a06 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1578,21 +1578,18 @@ static void test_presenter_native_video_size(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, NULL, NULL);
-todo_wine
     ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     memset(&size, 0xcc, sizeof(size));
     hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, &size, NULL);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(size.cx == 0 && size.cy == 0, "Unexpected size.\n");
-}
+
     memset(&ratio, 0xcc, sizeof(ratio));
     hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, NULL, &ratio);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(ratio.cx == 0 && ratio.cy == 0, "Unexpected ratio.\n");
-}
+
     hr = IMFVideoPresenter_QueryInterface(presenter, &IID_IMFTopologyServiceLookupClient, (void **)&lookup_client);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
@@ -1623,12 +1620,11 @@ todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, &size, &ratio);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(size.cx == 640 && size.cy == 480, "Unexpected size %u x %u.\n", size.cx, size.cy);
     ok((ratio.cx == 4 && ratio.cy == 3) || broken(!memcmp(&ratio, &size, sizeof(ratio))) /* < Win10 */,
             "Unexpected ratio %u x %u.\n", ratio.cx, ratio.cy);
-}
+
     /* Update input type. */
     hr = IMFVideoMediaType_SetUINT64(video_type, &MF_MT_FRAME_SIZE, (UINT64)320 << 32 | 240);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
@@ -1637,24 +1633,23 @@ todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, &size, &ratio);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(size.cx == 640 && size.cy == 480, "Unexpected size %u x %u.\n", size.cx, size.cy);
     ok((ratio.cx == 4 && ratio.cy == 3) || broken(!memcmp(&ratio, &size, sizeof(ratio))) /* < Win10 */,
             "Unexpected ratio %u x %u.\n", ratio.cx, ratio.cy);
-}
+
     /* Negotiating types updates native video size. */
     hr = IMFVideoPresenter_ProcessMessage(presenter, MFVP_MESSAGE_INVALIDATEMEDIATYPE, 0);
 todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, &size, &ratio);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+todo_wine
     ok(size.cx == 320 && size.cy == 240, "Unexpected size %u x %u.\n", size.cx, size.cy);
     ok((ratio.cx == 4 && ratio.cy == 3) || broken(!memcmp(&ratio, &size, sizeof(ratio))) /* < Win10 */,
             "Unexpected ratio %u x %u.\n", ratio.cx, ratio.cy);
-}
+
     IMFVideoMediaType_Release(video_type);
     IMFVideoDisplayControl_Release(display_control);
     IMFVideoPresenter_Release(presenter);
From 59f3337a394271cf729977a77fefb9950cf460d7 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 7 Oct 2020 11:40:21 +0300
Subject: [PATCH] evr/presenter: Update cached native size on format
 negotiation.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 118 ++++++++++++++++++++++++++-----------------
 dlls/evr/tests/evr.c |   2 -
 2 files changed, 71 insertions(+), 49 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index ba9e09c4e3e..ecfa9234426 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -103,6 +103,58 @@ static struct video_presenter *impl_from_IMFGetService(IMFGetService *iface)
     return CONTAINING_RECORD(iface, struct video_presenter, IMFGetService_iface);
 }
 
+static unsigned int get_gcd(unsigned int a, unsigned int b)
+{
+    unsigned int m;
+
+    while (b)
+    {
+        m = a % b;
+        a = b;
+        b = m;
+    }
+
+    return a;
+}
+
+static void video_presenter_get_native_video_size(struct video_presenter *presenter)
+{
+    IMFMediaType *media_type;
+    UINT64 frame_size = 0;
+
+    memset(&presenter->native_size, 0, sizeof(presenter->native_size));
+    memset(&presenter->native_ratio, 0, sizeof(presenter->native_ratio));
+
+    if (!presenter->mixer)
+        return;
+
+    if (FAILED(IMFTransform_GetInputCurrentType(presenter->mixer, 0, &media_type)))
+        return;
+
+    if (SUCCEEDED(IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &frame_size)))
+    {
+        unsigned int gcd;
+
+        presenter->native_size.cx = frame_size >> 32;
+        presenter->native_size.cy = frame_size;
+
+        if ((gcd = get_gcd(presenter->native_size.cx, presenter->native_size.cy)))
+        {
+            presenter->native_ratio.cx = presenter->native_size.cx / gcd;
+            presenter->native_ratio.cy = presenter->native_size.cy / gcd;
+        }
+    }
+
+    IMFMediaType_Release(media_type);
+}
+
+static HRESULT video_presenter_invalidate_media_type(struct video_presenter *presenter)
+{
+    video_presenter_get_native_video_size(presenter);
+
+    return S_OK;
+}
+
 static HRESULT WINAPI video_presenter_inner_QueryInterface(IUnknown *iface, REFIID riid, void **obj)
 {
     struct video_presenter *presenter = impl_from_IUnknown(iface);
@@ -277,9 +329,26 @@ static HRESULT WINAPI video_presenter_OnClockSetRate(IMFVideoPresenter *iface, M
 
 static HRESULT WINAPI video_presenter_ProcessMessage(IMFVideoPresenter *iface, MFVP_MESSAGE_TYPE message, ULONG_PTR param)
 {
-    FIXME("%p, %d, %lu.\n", iface, message, param);
+    struct video_presenter *presenter = impl_from_IMFVideoPresenter(iface);
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %d, %lu.\n", iface, message, param);
+
+    EnterCriticalSection(&presenter->cs);
+
+    switch (message)
+    {
+        case MFVP_MESSAGE_INVALIDATEMEDIATYPE:
+            hr = video_presenter_invalidate_media_type(presenter);
+            break;
+        default:
+            FIXME("Unsupported message %u.\n", message);
+            hr = E_NOTIMPL;
+    }
+
+    LeaveCriticalSection(&presenter->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_presenter_GetCurrentMediaType(IMFVideoPresenter *iface, IMFVideoMediaType **media_type)
@@ -379,51 +448,6 @@ static void video_presenter_set_mixer_rect(struct video_presenter *presenter)
     }
 }
 
-static unsigned int get_gcd(unsigned int a, unsigned int b)
-{
-    unsigned int m;
-
-    while (b)
-    {
-        m = a % b;
-        a = b;
-        b = m;
-    }
-
-    return a;
-}
-
-static void video_presenter_get_native_video_size(struct video_presenter *presenter)
-{
-    IMFMediaType *media_type;
-    UINT64 frame_size = 0;
-
-    memset(&presenter->native_size, 0, sizeof(presenter->native_size));
-    memset(&presenter->native_ratio, 0, sizeof(presenter->native_ratio));
-
-    if (!presenter->mixer)
-        return;
-
-    if (FAILED(IMFTransform_GetInputCurrentType(presenter->mixer, 0, &media_type)))
-        return;
-
-    if (SUCCEEDED(IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &frame_size)))
-    {
-        unsigned int gcd;
-
-        presenter->native_size.cx = frame_size >> 32;
-        presenter->native_size.cy = frame_size;
-
-        if ((gcd = get_gcd(presenter->native_size.cx, presenter->native_size.cy)))
-        {
-            presenter->native_ratio.cx = presenter->native_size.cx / gcd;
-            presenter->native_ratio.cy = presenter->native_size.cy / gcd;
-        }
-    }
-
-    IMFMediaType_Release(media_type);
-}
-
 static HRESULT video_presenter_attach_mixer(struct video_presenter *presenter, IMFTopologyServiceLookup *service_lookup)
 {
     IMFVideoDeviceID *device_id;
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 39d2ed72a06..e7eabc5971a 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1640,12 +1640,10 @@ static void test_presenter_native_video_size(void)
 
     /* Negotiating types updates native video size. */
     hr = IMFVideoPresenter_ProcessMessage(presenter, MFVP_MESSAGE_INVALIDATEMEDIATYPE, 0);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoDisplayControl_GetNativeVideoSize(display_control, &size, &ratio);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-todo_wine
     ok(size.cx == 320 && size.cy == 240, "Unexpected size %u x %u.\n", size.cx, size.cy);
     ok((ratio.cx == 4 && ratio.cy == 3) || broken(!memcmp(&ratio, &size, sizeof(ratio))) /* < Win10 */,
             "Unexpected ratio %u x %u.\n", ratio.cx, ratio.cy);
From 6163b3331fbca57af1ff8ba530927086d360589b Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 7 Oct 2020 11:40:22 +0300
Subject: [PATCH] evr/presenter: Initialize aspect ratio mode.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/presenter.c | 28 ++++++++++++++++++++++++----
 dlls/evr/tests/evr.c | 32 ++++++++++++++++++++++++++++++++
 include/evr.idl      |  9 +++++++++
 3 files changed, 65 insertions(+), 4 deletions(-)

diff --git a/dlls/evr/presenter.c b/dlls/evr/presenter.c
index ecfa9234426..8fcd6d58b3c 100644
--- a/dlls/evr/presenter.c
+++ b/dlls/evr/presenter.c
@@ -64,6 +64,7 @@ struct video_presenter
     DWORD rendering_prefs;
     SIZE native_size;
     SIZE native_ratio;
+    unsigned int ar_mode;
     unsigned int state;
     CRITICAL_SECTION cs;
 };
@@ -669,16 +670,34 @@ static HRESULT WINAPI video_presenter_control_GetVideoPosition(IMFVideoDisplayCo
 
 static HRESULT WINAPI video_presenter_control_SetAspectRatioMode(IMFVideoDisplayControl *iface, DWORD mode)
 {
-    FIXME("%p, %d.\n", iface, mode);
+    struct video_presenter *presenter = impl_from_IMFVideoDisplayControl(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x.\n", iface, mode);
+
+    if (mode & ~MFVideoARMode_Mask)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&presenter->cs);
+    presenter->ar_mode = mode;
+    LeaveCriticalSection(&presenter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_presenter_control_GetAspectRatioMode(IMFVideoDisplayControl *iface, DWORD *mode)
 {
-    FIXME("%p, %p.\n", iface, mode);
+    struct video_presenter *presenter = impl_from_IMFVideoDisplayControl(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, mode);
+
+    if (!mode)
+        return E_POINTER;
+
+    EnterCriticalSection(&presenter->cs);
+    *mode = presenter->ar_mode;
+    LeaveCriticalSection(&presenter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_presenter_control_SetVideoWindow(IMFVideoDisplayControl *iface, HWND window)
@@ -969,6 +988,7 @@ HRESULT evr_presenter_create(IUnknown *outer, void **out)
     object->outer_unk = outer ? outer : &object->IUnknown_inner;
     object->refcount = 1;
     object->src_rect.right = object->src_rect.bottom = 1.0f;
+    object->ar_mode = MFVideoARMode_PreservePicture | MFVideoARMode_PreservePixel;
     InitializeCriticalSection(&object->cs);
 
     if (FAILED(hr = DXVA2CreateDirect3DDeviceManager9(&object->reset_token, &object->device_manager)))
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index e7eabc5971a..3ae36d9b5df 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1654,6 +1654,37 @@ static void test_presenter_native_video_size(void)
     IMFTransform_Release(mixer);
 }
 
+static void test_presenter_ar_mode(void)
+{
+    IMFVideoDisplayControl *display_control;
+    HRESULT hr;
+    DWORD mode;
+
+    hr = MFCreateVideoPresenter(NULL, &IID_IDirect3DDevice9, &IID_IMFVideoDisplayControl, (void **)&display_control);
+    ok(hr == S_OK, "Failed to create default presenter, hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_GetAspectRatioMode(display_control, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    mode = 0;
+    hr = IMFVideoDisplayControl_GetAspectRatioMode(display_control, &mode);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(mode == (MFVideoARMode_PreservePicture | MFVideoARMode_PreservePixel), "Unexpected mode %#x.\n", mode);
+
+    hr = IMFVideoDisplayControl_SetAspectRatioMode(display_control, 0x100);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoDisplayControl_SetAspectRatioMode(display_control, MFVideoARMode_Mask);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    mode = 0;
+    hr = IMFVideoDisplayControl_GetAspectRatioMode(display_control, &mode);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(mode == MFVideoARMode_Mask, "Unexpected mode %#x.\n", mode);
+
+    IMFVideoDisplayControl_Release(display_control);
+}
+
 static void test_mixer_output_rectangle(void)
 {
     IMFVideoMixerControl *mixer_control;
@@ -1836,6 +1867,7 @@ START_TEST(evr)
     test_MFCreateVideoSampleAllocator();
     test_presenter_video_position();
     test_presenter_native_video_size();
+    test_presenter_ar_mode();
     test_mixer_output_rectangle();
     test_mixer_zorder();
 
diff --git a/include/evr.idl b/include/evr.idl
index c2178835383..413f5af1d47 100644
--- a/include/evr.idl
+++ b/include/evr.idl
@@ -228,6 +228,15 @@ interface IMFDesiredSample : IUnknown
     void Clear();
 }
 
+typedef enum MFVideoAspectRatioMode
+{
+    MFVideoARMode_None             = 0x00000000,
+    MFVideoARMode_PreservePicture  = 0x00000001,
+    MFVideoARMode_PreservePixel    = 0x00000002,
+    MFVideoARMode_NonLinearStretch = 0x00000004,
+    MFVideoARMode_Mask             = 0x00000007,
+} MFVideoAspectRatioMode;
+
 [
     object,
     uuid(a490b1e4-ab84-4d31-a1b2-181e03b1077a),
From eb9556bd608300064ba938d90a50edfc4c584de0 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 7 Oct 2020 11:40:23 +0300
Subject: [PATCH] mfplat: Added MFBeginRegisterWorkQueueWithMMCSS().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mfplat/mfplat.spec |  2 +-
 dlls/mfplat/queue.c     | 10 ++++++++++
 include/mfapi.h         |  2 ++
 3 files changed, 13 insertions(+), 1 deletion(-)

diff --git a/dlls/mfplat/mfplat.spec b/dlls/mfplat/mfplat.spec
index 8f5e7db6aee..5f4735cd6f7 100644
--- a/dlls/mfplat/mfplat.spec
+++ b/dlls/mfplat/mfplat.spec
@@ -23,7 +23,7 @@
 @ stub MFAverageTimePerFrameToFrameRate
 @ stdcall MFBeginCreateFile(long long long wstr ptr ptr ptr)
 @ stub MFBeginGetHostByName
-@ stub MFBeginRegisterWorkQueueWithMMCSS
+@ stdcall MFBeginRegisterWorkQueueWithMMCSS(long wstr long ptr ptr)
 @ stdcall MFBeginRegisterWorkQueueWithMMCSSEx(long wstr long long ptr ptr) rtworkq.RtwqBeginRegisterWorkQueueWithMMCSS
 @ stdcall MFBeginUnregisterWorkQueueWithMMCSS(long ptr ptr) rtworkq.RtwqBeginUnregisterWorkQueueWithMMCSS
 @ stub MFBlockThread
diff --git a/dlls/mfplat/queue.c b/dlls/mfplat/queue.c
index 2080a79f848..8279929b46e 100644
--- a/dlls/mfplat/queue.c
+++ b/dlls/mfplat/queue.c
@@ -140,3 +140,13 @@ HRESULT WINAPI MFGetTimerPeriodicity(DWORD *period)
 
     return S_OK;
 }
+
+/***********************************************************************
+ *      MFBeginRegisterWorkQueueWithMMCSS (mfplat.@)
+ */
+HRESULT WINAPI MFBeginRegisterWorkQueueWithMMCSS(DWORD queue, const WCHAR *usage_class, DWORD taskid,
+        IMFAsyncCallback *callback, IUnknown *state)
+{
+    return RtwqBeginRegisterWorkQueueWithMMCSS(queue, usage_class, taskid, 0,
+            (IRtwqAsyncCallback *)callback, state);
+}
diff --git a/include/mfapi.h b/include/mfapi.h
index e9b26f322c3..499c77ab337 100644
--- a/include/mfapi.h
+++ b/include/mfapi.h
@@ -488,6 +488,8 @@ HRESULT WINAPI MFAllocateWorkQueue(DWORD *queue);
 HRESULT WINAPI MFAllocateWorkQueueEx(MFASYNC_WORKQUEUE_TYPE queue_type, DWORD *queue);
 HRESULT WINAPI MFBeginCreateFile(MF_FILE_ACCESSMODE access_mode, MF_FILE_OPENMODE open_mode, MF_FILE_FLAGS flags,
         const WCHAR *path, IMFAsyncCallback *callback, IUnknown *state, IUnknown **cancel_cookie);
+HRESULT WINAPI MFBeginRegisterWorkQueueWithMMCSS(DWORD queue, const WCHAR *usage_class, DWORD taskid,
+        IMFAsyncCallback *callback, IUnknown *state);
 HRESULT WINAPI MFBeginRegisterWorkQueueWithMMCSSEx(DWORD queue, const WCHAR *usage_class, DWORD taskid, LONG priority,
         IMFAsyncCallback *callback, IUnknown *state);
 HRESULT WINAPI MFBeginUnregisterWorkQueueWithMMCSS(DWORD queue, IMFAsyncCallback *callback, IUnknown *state);
From bdbae2ff5a9db01fc109fa0a8ad5500124bf6242 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 8 Oct 2020 14:44:13 +0300
Subject: [PATCH] mf/evr: Partially implement InitializeRenderer().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c      | 333 +++++++++++++++++++++++++++------------------
 dlls/mf/tests/mf.c |   8 +-
 2 files changed, 208 insertions(+), 133 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index c5b2ceecd67..e90cf686f26 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -854,12 +854,195 @@ static ULONG WINAPI video_renderer_Release(IMFVideoRenderer *iface)
     return IMFMediaSink_Release(&renderer->IMFMediaSink_iface);
 }
 
+static HRESULT video_renderer_create_mixer(IMFAttributes *attributes, IMFTransform **out)
+{
+    unsigned int flags = 0;
+    IMFActivate *activate;
+    CLSID clsid;
+    HRESULT hr;
+
+    if (attributes && SUCCEEDED(hr = IMFAttributes_GetUnknown(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE,
+            &IID_IMFActivate, (void **)&activate)))
+    {
+        IMFAttributes_GetUINT32(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_FLAGS, &flags);
+        hr = IMFActivate_ActivateObject(activate, &IID_IMFTransform, (void **)out);
+        IMFActivate_Release(activate);
+        if (SUCCEEDED(hr) || !(flags & MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL))
+            return hr;
+    }
+
+    if (!attributes || FAILED(IMFAttributes_GetGUID(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID, &clsid)))
+        memcpy(&clsid, &CLSID_MFVideoMixer9, sizeof(clsid));
+
+    return CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFTransform, (void **)out);
+}
+
+static HRESULT video_renderer_create_presenter(IMFAttributes *attributes, IMFVideoPresenter **out)
+{
+    unsigned int flags = 0;
+    IMFActivate *activate;
+    CLSID clsid;
+    HRESULT hr;
+
+    if (attributes && SUCCEEDED(IMFAttributes_GetUnknown(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_ACTIVATE,
+            &IID_IMFActivate, (void **)&activate)))
+    {
+        IMFAttributes_GetUINT32(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS, &flags);
+        hr = IMFActivate_ActivateObject(activate, &IID_IMFVideoPresenter, (void **)out);
+        IMFActivate_Release(activate);
+        if (SUCCEEDED(hr) || !(flags & MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL))
+            return hr;
+    }
+
+    if (!attributes || FAILED(IMFAttributes_GetGUID(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_CLSID, &clsid)))
+        memcpy(&clsid, &CLSID_MFVideoPresenter9, sizeof(clsid));
+
+    return CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFVideoPresenter, (void **)out);
+}
+
+static HRESULT video_renderer_configure_mixer(struct video_renderer *renderer)
+{
+    IMFTopologyServiceLookupClient *lookup_client;
+    HRESULT hr;
+
+    if (SUCCEEDED(hr = IMFTransform_QueryInterface(renderer->mixer, &IID_IMFTopologyServiceLookupClient,
+            (void **)&lookup_client)))
+    {
+        renderer->flags |= EVR_INIT_SERVICES;
+        if (SUCCEEDED(hr = IMFTopologyServiceLookupClient_InitServicePointers(lookup_client,
+                &renderer->IMFTopologyServiceLookup_iface)))
+        {
+            renderer->flags |= EVR_MIXER_INITED_SERVICES;
+        }
+        renderer->flags &= ~EVR_INIT_SERVICES;
+        IMFTopologyServiceLookupClient_Release(lookup_client);
+    }
+
+    if (SUCCEEDED(hr))
+    {
+        unsigned int input_count, output_count;
+        unsigned int *ids, *oids;
+        size_t i;
+
+        /* Create stream sinks for inputs that mixer already has by default. */
+        if (SUCCEEDED(IMFTransform_GetStreamCount(renderer->mixer, &input_count, &output_count)))
+        {
+            ids = heap_calloc(input_count, sizeof(*ids));
+            oids = heap_calloc(output_count, sizeof(*oids));
+
+            if (ids && oids)
+            {
+                if (SUCCEEDED(IMFTransform_GetStreamIDs(renderer->mixer, input_count, ids, output_count, oids)))
+                {
+                    for (i = 0; i < input_count; ++i)
+                    {
+                        video_renderer_add_stream(renderer, ids[i], NULL);
+                    }
+                }
+
+            }
+
+            heap_free(ids);
+            heap_free(oids);
+        }
+    }
+
+    return hr;
+}
+
+static HRESULT video_renderer_configure_presenter(struct video_renderer *renderer)
+{
+    IMFTopologyServiceLookupClient *lookup_client;
+    HRESULT hr;
+
+    if (SUCCEEDED(hr = IMFVideoPresenter_QueryInterface(renderer->presenter, &IID_IMFTopologyServiceLookupClient,
+            (void **)&lookup_client)))
+    {
+        renderer->flags |= EVR_INIT_SERVICES;
+        if (SUCCEEDED(hr = IMFTopologyServiceLookupClient_InitServicePointers(lookup_client,
+                &renderer->IMFTopologyServiceLookup_iface)))
+        {
+            renderer->flags |= EVR_PRESENTER_INITED_SERVICES;
+        }
+        renderer->flags &= ~EVR_INIT_SERVICES;
+        IMFTopologyServiceLookupClient_Release(lookup_client);
+    }
+
+    return hr;
+}
+
+static HRESULT video_renderer_initialize(struct video_renderer *renderer, IMFTransform *mixer,
+        IMFVideoPresenter *presenter)
+{
+    HRESULT hr;
+
+    if (renderer->mixer)
+    {
+        IMFTransform_Release(renderer->mixer);
+        renderer->mixer = NULL;
+    }
+
+    if (renderer->presenter)
+    {
+        IMFVideoPresenter_Release(renderer->presenter);
+        renderer->presenter = NULL;
+    }
+
+    renderer->mixer = mixer;
+    IMFTransform_AddRef(renderer->mixer);
+
+    renderer->presenter = presenter;
+    IMFVideoPresenter_AddRef(renderer->presenter);
+
+    if (SUCCEEDED(hr = video_renderer_configure_mixer(renderer)))
+        hr = video_renderer_configure_presenter(renderer);
+
+    return hr;
+}
+
 static HRESULT WINAPI video_renderer_InitializeRenderer(IMFVideoRenderer *iface, IMFTransform *mixer,
         IMFVideoPresenter *presenter)
 {
-    FIXME("%p, %p, %p.\n", iface, mixer, presenter);
+    struct video_renderer *renderer = impl_from_IMFVideoRenderer(iface);
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %p.\n", iface, mixer, presenter);
+
+    if (mixer)
+        IMFTransform_AddRef(mixer);
+    else if (FAILED(hr = video_renderer_create_mixer(NULL, &mixer)))
+    {
+        WARN("Failed to create default mixer object, hr %#x.\n", hr);
+        return hr;
+    }
+
+    if (presenter)
+        IMFVideoPresenter_AddRef(presenter);
+    else if (FAILED(hr = video_renderer_create_presenter(NULL, &presenter)))
+    {
+        WARN("Failed to create default presenter, hr %#x.\n", hr);
+        IMFTransform_Release(mixer);
+        return hr;
+    }
+
+    EnterCriticalSection(&renderer->cs);
+
+    if (renderer->flags & EVR_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else
+    {
+        /* FIXME: check clock state */
+        /* FIXME: check that streams are not initialized */
+
+        hr = video_renderer_initialize(renderer, mixer, presenter);
+    }
+
+    LeaveCriticalSection(&renderer->cs);
+
+    IMFTransform_Release(mixer);
+    IMFVideoPresenter_Release(presenter);
+
+    return hr;
 }
 
 static const IMFVideoRendererVtbl video_renderer_vtbl =
@@ -1191,128 +1374,11 @@ static const IMediaEventSinkVtbl media_event_sink_vtbl =
     video_renderer_event_sink_Notify,
 };
 
-static HRESULT video_renderer_create_mixer(struct video_renderer *renderer, IMFAttributes *attributes,
-        IMFTransform **out)
-{
-    IMFTopologyServiceLookupClient *lookup_client;
-    unsigned int flags = 0;
-    IMFActivate *activate;
-    CLSID clsid;
-    HRESULT hr;
-
-    if (SUCCEEDED(hr = IMFAttributes_GetUnknown(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE,
-            &IID_IMFActivate, (void **)&activate)))
-    {
-        IMFAttributes_GetUINT32(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_FLAGS, &flags);
-        hr = IMFActivate_ActivateObject(activate, &IID_IMFTransform, (void **)out);
-        IMFActivate_Release(activate);
-        if (FAILED(hr) && !(flags & MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL))
-            return hr;
-    }
-
-    /* Activation object failed, use class activation. */
-    if (FAILED(hr))
-    {
-        if (FAILED(IMFAttributes_GetGUID(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID, &clsid)))
-            memcpy(&clsid, &CLSID_MFVideoMixer9, sizeof(clsid));
-        hr = CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFTransform, (void **)out);
-    }
-
-    if (FAILED(hr))
-    {
-        WARN("Failed to create a mixer object, hr %#x.\n", hr);
-        return hr;
-    }
-
-    if (SUCCEEDED(hr = IMFTransform_QueryInterface(*out, &IID_IMFTopologyServiceLookupClient,
-            (void **)&lookup_client)))
-    {
-        renderer->flags |= EVR_INIT_SERVICES;
-        if (SUCCEEDED(hr = IMFTopologyServiceLookupClient_InitServicePointers(lookup_client,
-                &renderer->IMFTopologyServiceLookup_iface)))
-        {
-            renderer->flags |= EVR_MIXER_INITED_SERVICES;
-        }
-        renderer->flags &= ~EVR_INIT_SERVICES;
-        IMFTopologyServiceLookupClient_Release(lookup_client);
-    }
-
-    if (SUCCEEDED(hr))
-    {
-        unsigned int input_count, output_count;
-        unsigned int *ids, *oids;
-        size_t i;
-
-        /* Create stream sinks for inputs that mixer already has by default. */
-        if (SUCCEEDED(IMFTransform_GetStreamCount(*out, &input_count, &output_count)))
-        {
-            ids = heap_calloc(input_count, sizeof(*ids));
-            oids = heap_calloc(output_count, sizeof(*oids));
-
-            if (ids && oids)
-            {
-                if (SUCCEEDED(IMFTransform_GetStreamIDs(*out, input_count, ids, output_count, oids)))
-                {
-                    for (i = 0; i < input_count; ++i)
-                    {
-                        video_renderer_add_stream(renderer, ids[i], NULL);
-                    }
-                }
-
-            }
-
-            heap_free(ids);
-            heap_free(oids);
-        }
-    }
-
-    return hr;
-}
-
-static HRESULT video_renderer_create_presenter(struct video_renderer *renderer, IMFAttributes *attributes,
-        IMFVideoPresenter **out)
-{
-    IMFTopologyServiceLookupClient *lookup_client;
-    unsigned int flags = 0;
-    IMFActivate *activate;
-    CLSID clsid;
-    HRESULT hr;
-
-    if (SUCCEEDED(IMFAttributes_GetUnknown(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_ACTIVATE,
-            &IID_IMFActivate, (void **)&activate)))
-    {
-        IMFAttributes_GetUINT32(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS, &flags);
-        hr = IMFActivate_ActivateObject(activate, &IID_IMFVideoPresenter, (void **)out);
-        IMFActivate_Release(activate);
-        if (FAILED(hr) && !(flags & MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL))
-            return hr;
-    }
-
-    if (FAILED(IMFAttributes_GetGUID(attributes, &MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_CLSID, &clsid)))
-        memcpy(&clsid, &CLSID_MFVideoPresenter9, sizeof(clsid));
-
-    if (SUCCEEDED(hr = CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IMFVideoPresenter, (void **)out)))
-    {
-        if (SUCCEEDED(hr = IMFVideoPresenter_QueryInterface(*out, &IID_IMFTopologyServiceLookupClient,
-                (void **)&lookup_client)))
-        {
-            renderer->flags |= EVR_INIT_SERVICES;
-            if (SUCCEEDED(hr = IMFTopologyServiceLookupClient_InitServicePointers(lookup_client,
-                    &renderer->IMFTopologyServiceLookup_iface)))
-            {
-                renderer->flags |= EVR_PRESENTER_INITED_SERVICES;
-            }
-            renderer->flags &= ~EVR_INIT_SERVICES;
-            IMFTopologyServiceLookupClient_Release(lookup_client);
-        }
-    }
-
-    return hr;
-}
-
 static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context, IUnknown **obj)
 {
     struct video_renderer *object;
+    IMFVideoPresenter *presenter;
+    IMFTransform *mixer;
     HRESULT hr;
 
     TRACE("%p, %p, %p.\n", attributes, user_context, obj);
@@ -1335,18 +1401,30 @@ static HRESULT evr_create_object(IMFAttributes *attributes, void *user_context,
         goto failed;
 
     /* Create mixer and presenter. */
-    if (FAILED(hr = video_renderer_create_mixer(object, attributes, &object->mixer)))
+    if (FAILED(hr = video_renderer_create_mixer(attributes, &mixer)))
+        goto failed;
+
+    if (FAILED(hr = video_renderer_create_presenter(attributes, &presenter)))
         goto failed;
 
-    if (FAILED(hr = video_renderer_create_presenter(object, attributes, &object->presenter)))
+    if (FAILED(hr = video_renderer_initialize(object, mixer, presenter)))
         goto failed;
 
+    IMFTransform_Release(mixer);
+    IMFVideoPresenter_Release(presenter);
+
     *obj = (IUnknown *)&object->IMFMediaSink_iface;
 
     return S_OK;
 
 failed:
 
+    if (mixer)
+        IMFTransform_Release(mixer);
+
+    if (presenter)
+        IMFVideoPresenter_Release(presenter);
+
     video_renderer_release_services(object);
     IMFMediaSink_Release(&object->IMFMediaSink_iface);
 
@@ -1394,7 +1472,6 @@ HRESULT WINAPI MFCreateVideoRendererActivate(HWND hwnd, IMFActivate **activate)
  */
 HRESULT WINAPI MFCreateVideoRenderer(REFIID riid, void **renderer)
 {
-    IMFAttributes *attributes;
     IUnknown *obj;
     HRESULT hr;
 
@@ -1402,13 +1479,7 @@ HRESULT WINAPI MFCreateVideoRenderer(REFIID riid, void **renderer)
 
     *renderer = NULL;
 
-    if (FAILED(hr = MFCreateAttributes(&attributes, 0)))
-        return hr;
-
-    hr = evr_create_object(attributes, NULL, &obj);
-    IMFAttributes_Release(attributes);
-
-    if (SUCCEEDED(hr))
+    if (SUCCEEDED(hr = evr_create_object(NULL, NULL, &obj)))
     {
         hr = IUnknown_QueryInterface(obj, riid, renderer);
         IUnknown_Release(obj);
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 0bc297cc69c..88cfa8d7625 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3253,9 +3253,13 @@ static void test_evr(void)
     hr = CoInitialize(NULL);
     ok(hr == S_OK, "Failed to initialize, hr %#x.\n", hr);
 
-    hr = MFCreateVideoRenderer(&IID_IUnknown, (void **)&unk);
+    hr = MFCreateVideoRenderer(&IID_IMFVideoRenderer, (void **)&video_renderer);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
-    IUnknown_Release(unk);
+
+    hr = IMFVideoRenderer_InitializeRenderer(video_renderer, NULL, NULL);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    IMFVideoRenderer_Release(video_renderer);
 
     hr = MFCreateVideoRendererActivate(NULL, NULL);
     ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
From 29aecbef64b19bf8faee163d7a30fb414a730874 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 8 Oct 2020 14:44:14 +0300
Subject: [PATCH] mf/evr: Provide device manager to the mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index e90cf686f26..dc2b20ddf76 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -21,6 +21,9 @@
 #include "mf_private.h"
 #include "uuids.h"
 #include "evr.h"
+#include "d3d9.h"
+#include "initguid.h"
+#include "dxva2api.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
@@ -903,6 +906,7 @@ static HRESULT video_renderer_create_presenter(IMFAttributes *attributes, IMFVid
 static HRESULT video_renderer_configure_mixer(struct video_renderer *renderer)
 {
     IMFTopologyServiceLookupClient *lookup_client;
+    IMFAttributes *attributes;
     HRESULT hr;
 
     if (SUCCEEDED(hr = IMFTransform_QueryInterface(renderer->mixer, &IID_IMFTopologyServiceLookupClient,
@@ -947,6 +951,24 @@ static HRESULT video_renderer_configure_mixer(struct video_renderer *renderer)
         }
     }
 
+    /* Set device manager that presenter should have created. */
+    if (SUCCEEDED(IMFTransform_QueryInterface(renderer->mixer, &IID_IMFAttributes, (void **)&attributes)))
+    {
+        IDirect3DDeviceManager9 *device_manager;
+        unsigned int value;
+
+        if (SUCCEEDED(IMFAttributes_GetUINT32(attributes, &MF_SA_D3D_AWARE, &value)) && value)
+        {
+            if (SUCCEEDED(MFGetService((IUnknown *)renderer->presenter, &MR_VIDEO_ACCELERATION_SERVICE,
+                    &IID_IDirect3DDeviceManager9, (void **)&device_manager)))
+            {
+                IMFTransform_ProcessMessage(renderer->mixer, MFT_MESSAGE_SET_D3D_MANAGER, (ULONG_PTR)device_manager);
+                IDirect3DDeviceManager9_Release(device_manager);
+            }
+        }
+        IMFAttributes_Release(attributes);
+    }
+
     return hr;
 }
 
From bcee4fbb9486dbc511e458f262f87cfdbfa0234e Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 8 Oct 2020 14:44:15 +0300
Subject: [PATCH] mf/evr: Add IMFGetService stub for the streams.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 44 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 44 insertions(+)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index dc2b20ddf76..af5c5d31038 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -41,6 +41,7 @@ struct video_stream
 {
     IMFStreamSink IMFStreamSink_iface;
     IMFMediaTypeHandler IMFMediaTypeHandler_iface;
+    IMFGetService IMFGetService_iface;
     LONG refcount;
     unsigned int id;
     struct video_renderer *parent;
@@ -123,6 +124,11 @@ static struct video_stream *impl_from_IMFMediaTypeHandler(IMFMediaTypeHandler *i
     return CONTAINING_RECORD(iface, struct video_stream, IMFMediaTypeHandler_iface);
 }
 
+static struct video_stream *impl_from_stream_IMFGetService(IMFGetService *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_stream, IMFGetService_iface);
+}
+
 static void video_renderer_release_services(struct video_renderer *renderer)
 {
     IMFTopologyServiceLookupClient *lookup_client;
@@ -162,6 +168,10 @@ static HRESULT WINAPI video_stream_sink_QueryInterface(IMFStreamSink *iface, REF
     {
         *obj = &stream->IMFMediaTypeHandler_iface;
     }
+    else if (IsEqualIID(riid, &IID_IMFGetService))
+    {
+        *obj = &stream->IMFGetService_iface;
+    }
 
     if (*obj)
     {
@@ -415,6 +425,39 @@ static const IMFMediaTypeHandlerVtbl video_stream_type_handler_vtbl =
     video_stream_typehandler_GetMajorType,
 };
 
+static HRESULT WINAPI video_stream_get_service_QueryInterface(IMFGetService *iface, REFIID riid, void **obj)
+{
+    struct video_stream *stream = impl_from_stream_IMFGetService(iface);
+    return IMFStreamSink_QueryInterface(&stream->IMFStreamSink_iface, riid, obj);
+}
+
+static ULONG WINAPI video_stream_get_service_AddRef(IMFGetService *iface)
+{
+    struct video_stream *stream = impl_from_stream_IMFGetService(iface);
+    return IMFStreamSink_AddRef(&stream->IMFStreamSink_iface);
+}
+
+static ULONG WINAPI video_stream_get_service_Release(IMFGetService *iface)
+{
+    struct video_stream *stream = impl_from_stream_IMFGetService(iface);
+    return IMFStreamSink_Release(&stream->IMFStreamSink_iface);
+}
+
+static HRESULT WINAPI video_stream_get_service_GetService(IMFGetService *iface, REFGUID service, REFIID riid, void **obj)
+{
+    FIXME("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+
+    return E_NOTIMPL;
+}
+
+static const IMFGetServiceVtbl video_stream_get_service_vtbl =
+{
+    video_stream_get_service_QueryInterface,
+    video_stream_get_service_AddRef,
+    video_stream_get_service_Release,
+    video_stream_get_service_GetService,
+};
+
 static HRESULT video_renderer_stream_create(struct video_renderer *renderer, unsigned int id,
         struct video_stream **ret)
 {
@@ -426,6 +469,7 @@ static HRESULT video_renderer_stream_create(struct video_renderer *renderer, uns
 
     stream->IMFStreamSink_iface.lpVtbl = &video_stream_sink_vtbl;
     stream->IMFMediaTypeHandler_iface.lpVtbl = &video_stream_type_handler_vtbl;
+    stream->IMFGetService_iface.lpVtbl = &video_stream_get_service_vtbl;
     stream->refcount = 1;
 
     if (FAILED(hr = MFCreateEventQueue(&stream->event_queue)))
From 30e5405acac8eacb3ca1c009f751be41eee84c49 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 8 Oct 2020 14:44:16 +0300
Subject: [PATCH] mf/evr: Create sample allocator for each stream.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/Makefile.in |  1 +
 dlls/mf/evr.c       | 27 +++++++++++++++++++++++++--
 dlls/mf/tests/mf.c  | 42 ++++++++++++++++++++++++++++++++++++++++--
 3 files changed, 66 insertions(+), 4 deletions(-)

diff --git a/dlls/mf/Makefile.in b/dlls/mf/Makefile.in
index b64cdb4a64d..f1d0571d143 100644
--- a/dlls/mf/Makefile.in
+++ b/dlls/mf/Makefile.in
@@ -1,6 +1,7 @@
 MODULE    = mf.dll
 IMPORTLIB = mf
 IMPORTS   = advapi32 mfplat ole32 uuid mfuuid strmiids
+DELAYIMPORTS = evr
 
 EXTRADLLFLAGS = -mno-cygwin
 
diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index af5c5d31038..ac3f17fa585 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -46,6 +46,7 @@ struct video_stream
     unsigned int id;
     struct video_renderer *parent;
     IMFMediaEventQueue *event_queue;
+    IMFVideoSampleAllocator *allocator;
 };
 
 struct video_renderer
@@ -203,6 +204,8 @@ static ULONG WINAPI video_stream_sink_Release(IMFStreamSink *iface)
     {
         if (stream->event_queue)
             IMFMediaEventQueue_Release(stream->event_queue);
+        if (stream->allocator)
+            IMFVideoSampleAllocator_Release(stream->allocator);
         heap_free(stream);
     }
 
@@ -445,7 +448,18 @@ static ULONG WINAPI video_stream_get_service_Release(IMFGetService *iface)
 
 static HRESULT WINAPI video_stream_get_service_GetService(IMFGetService *iface, REFGUID service, REFIID riid, void **obj)
 {
-    FIXME("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+    struct video_stream *stream = impl_from_stream_IMFGetService(iface);
+
+    TRACE("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(service, &MR_VIDEO_ACCELERATION_SERVICE))
+    {
+        if (IsEqualIID(riid, &IID_IMFVideoSampleAllocator))
+            return IMFVideoSampleAllocator_QueryInterface(stream->allocator, riid, obj);
+        return E_NOINTERFACE;
+    }
+
+    FIXME("Unsupported service %s.\n", debugstr_guid(service));
 
     return E_NOTIMPL;
 }
@@ -473,7 +487,10 @@ static HRESULT video_renderer_stream_create(struct video_renderer *renderer, uns
     stream->refcount = 1;
 
     if (FAILED(hr = MFCreateEventQueue(&stream->event_queue)))
-        return hr;
+        goto failed;
+
+    if (FAILED(hr = MFCreateVideoSampleAllocator(&IID_IMFVideoSampleAllocator, (void **)&stream->allocator)))
+        goto failed;
 
     stream->parent = renderer;
     IMFMediaSink_AddRef(&stream->parent->IMFMediaSink_iface);
@@ -482,6 +499,12 @@ static HRESULT video_renderer_stream_create(struct video_renderer *renderer, uns
     *ret = stream;
 
     return S_OK;
+
+failed:
+
+    IMFStreamSink_Release(&stream->IMFStreamSink_iface);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_renderer_sink_QueryInterface(IMFMediaSink *iface, REFIID riid, void **obj)
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 88cfa8d7625..bd6e66a5132 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3235,16 +3235,20 @@ todo_wine
 
 static void test_evr(void)
 {
+    IMFVideoSampleAllocatorCallback *allocator_callback;
+    IMFStreamSink *stream_sink, *stream_sink2;
     IMFMediaEventGenerator *ev_generator;
+    IMFVideoSampleAllocator *allocator;
     IMFMediaTypeHandler *type_handler;
     IMFVideoRenderer *video_renderer;
     IMFClockStateSink *clock_sink;
     IMFMediaSinkPreroll *preroll;
     IMFMediaSink *sink, *sink2;
-    IMFStreamSink *stream_sink;
     IMFActivate *activate;
     DWORD flags, count;
+    LONG sample_count;
     IMFGetService *gs;
+    IMFSample *sample;
     IUnknown *unk;
     UINT64 value;
     HRESULT hr;
@@ -3292,9 +3296,43 @@ static void test_evr(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(IsEqualGUID(&guid, &MFMediaType_Video), "Unexpected type %s.\n", wine_dbgstr_guid(&guid));
 
-    IMFStreamSink_Release(stream_sink);
     IMFMediaTypeHandler_Release(type_handler);
 
+    /* Stream uses an allocator. */
+    hr = MFGetService((IUnknown *)stream_sink, &MR_VIDEO_ACCELERATION_SERVICE, &IID_IMFVideoSampleAllocator,
+            (void **)&allocator);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoSampleAllocator_QueryInterface(allocator, &IID_IMFVideoSampleAllocatorCallback, (void **)&allocator_callback);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    sample_count = 0;
+    hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_callback, &sample_count);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!sample_count, "Unexpected sample count %d.\n", sample_count);
+
+    hr = IMFVideoSampleAllocator_AllocateSample(allocator, &sample);
+todo_wine
+    ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
+
+    IMFVideoSampleAllocatorCallback_Release(allocator_callback);
+    IMFVideoSampleAllocator_Release(allocator);
+
+    /* Same test for a substream. */
+    hr = IMFMediaSink_AddStreamSink(sink, 1, NULL, &stream_sink2);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = MFGetService((IUnknown *)stream_sink2, &MR_VIDEO_ACCELERATION_SERVICE, &IID_IMFVideoSampleAllocator,
+            (void **)&allocator);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IMFVideoSampleAllocator_Release(allocator);
+
+    hr = IMFMediaSink_RemoveStreamSink(sink, 1);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    IMFStreamSink_Release(stream_sink2);
+
     hr = IMFMediaSink_GetCharacteristics(sink, &flags);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(flags == (MEDIASINK_CAN_PREROLL | MEDIASINK_CLOCK_REQUIRED), "Unexpected flags %#x.\n", flags);
From 4fa62d40dcde49557b306c731fb534673ec1036f Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 8 Oct 2020 14:44:17 +0300
Subject: [PATCH] evr/allocator: Implement SetCallback().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/sample.c    | 21 +++++++++++++++++--
 dlls/evr/tests/evr.c | 48 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 67 insertions(+), 2 deletions(-)

diff --git a/dlls/evr/sample.c b/dlls/evr/sample.c
index f371d920762..31e3ff43334 100644
--- a/dlls/evr/sample.c
+++ b/dlls/evr/sample.c
@@ -30,6 +30,9 @@ struct sample_allocator
     IMFVideoSampleAllocator IMFVideoSampleAllocator_iface;
     IMFVideoSampleAllocatorCallback IMFVideoSampleAllocatorCallback_iface;
     LONG refcount;
+
+    IMFVideoSampleAllocatorNotify *callback;
+    CRITICAL_SECTION cs;
 };
 
 static struct sample_allocator *impl_from_IMFVideoSampleAllocator(IMFVideoSampleAllocator *iface)
@@ -87,6 +90,9 @@ static ULONG WINAPI sample_allocator_Release(IMFVideoSampleAllocator *iface)
 
     if (!refcount)
     {
+        if (allocator->callback)
+            IMFVideoSampleAllocatorNotify_Release(allocator->callback);
+        DeleteCriticalSection(&allocator->cs);
         heap_free(allocator);
     }
 
@@ -156,9 +162,19 @@ static ULONG WINAPI sample_allocator_callback_Release(IMFVideoSampleAllocatorCal
 static HRESULT WINAPI sample_allocator_callback_SetCallback(IMFVideoSampleAllocatorCallback *iface,
         IMFVideoSampleAllocatorNotify *callback)
 {
-    FIXME("%p, %p.\n", iface, callback);
+    struct sample_allocator *allocator = impl_from_IMFVideoSampleAllocatorCallback(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, callback);
+
+    EnterCriticalSection(&allocator->cs);
+    if (allocator->callback)
+        IMFVideoSampleAllocatorNotify_Release(allocator->callback);
+    allocator->callback = callback;
+    if (allocator->callback)
+        IMFVideoSampleAllocatorNotify_AddRef(allocator->callback);
+    LeaveCriticalSection(&allocator->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI sample_allocator_callback_GetFreeSampleCount(IMFVideoSampleAllocatorCallback *iface,
@@ -191,6 +207,7 @@ HRESULT WINAPI MFCreateVideoSampleAllocator(REFIID riid, void **obj)
     object->IMFVideoSampleAllocator_iface.lpVtbl = &sample_allocator_vtbl;
     object->IMFVideoSampleAllocatorCallback_iface.lpVtbl = &sample_allocator_callback_vtbl;
     object->refcount = 1;
+    InitializeCriticalSection(&object->cs);
 
     hr = IMFVideoSampleAllocator_QueryInterface(&object->IMFVideoSampleAllocator_iface, riid, obj);
     IMFVideoSampleAllocator_Release(&object->IMFVideoSampleAllocator_iface);
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 3ae36d9b5df..3951b813a02 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1147,8 +1147,47 @@ static void test_MFCreateVideoMixerAndPresenter(void)
     IUnknown_Release(presenter);
 }
 
+static HRESULT WINAPI test_notify_callback_QueryInterface(IMFVideoSampleAllocatorNotify *iface,
+        REFIID riid, void **obj)
+{
+    if (IsEqualIID(riid, &IID_IMFVideoSampleAllocatorNotify) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFVideoSampleAllocatorNotify_AddRef(iface);
+        return S_OK;
+    }
+
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI test_notify_callback_AddRef(IMFVideoSampleAllocatorNotify *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI test_notify_callback_Release(IMFVideoSampleAllocatorNotify *iface)
+{
+    return 1;
+}
+
+static HRESULT WINAPI test_notify_callback_NotifyRelease(IMFVideoSampleAllocatorNotify *iface)
+{
+    return E_NOTIMPL;
+}
+
+static const IMFVideoSampleAllocatorNotifyVtbl test_notify_callback_vtbl =
+{
+    test_notify_callback_QueryInterface,
+    test_notify_callback_AddRef,
+    test_notify_callback_Release,
+    test_notify_callback_NotifyRelease,
+};
+
 static void test_MFCreateVideoSampleAllocator(void)
 {
+    IMFVideoSampleAllocatorNotify test_notify = { &test_notify_callback_vtbl };
     IMFVideoSampleAllocatorCallback *allocator_cb;
     IMFVideoSampleAllocator *allocator;
     IMFVideoMediaType *video_type;
@@ -1171,6 +1210,15 @@ static void test_MFCreateVideoSampleAllocator(void)
     hr = IMFVideoSampleAllocator_QueryInterface(allocator, &IID_IMFVideoSampleAllocatorCallback, (void **)&allocator_cb);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFVideoSampleAllocatorCallback_SetCallback(allocator_cb, NULL);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoSampleAllocatorCallback_SetCallback(allocator_cb, &test_notify);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFVideoSampleAllocatorCallback_SetCallback(allocator_cb, NULL);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
     count = 10;
     hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
 todo_wine {
From d136c7554cc5f78bfefb5da9559bcec78030247d Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 8 Oct 2020 14:44:18 +0300
Subject: [PATCH] evr/allocator: Implement GetFreeSampleCount().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/sample.c    | 12 ++++++++++--
 dlls/evr/tests/evr.c | 14 ++++++++------
 dlls/mf/tests/mf.c   |  1 -
 3 files changed, 18 insertions(+), 9 deletions(-)

diff --git a/dlls/evr/sample.c b/dlls/evr/sample.c
index 31e3ff43334..2887a37e8d9 100644
--- a/dlls/evr/sample.c
+++ b/dlls/evr/sample.c
@@ -32,6 +32,7 @@ struct sample_allocator
     LONG refcount;
 
     IMFVideoSampleAllocatorNotify *callback;
+    unsigned int free_samples;
     CRITICAL_SECTION cs;
 };
 
@@ -180,9 +181,16 @@ static HRESULT WINAPI sample_allocator_callback_SetCallback(IMFVideoSampleAlloca
 static HRESULT WINAPI sample_allocator_callback_GetFreeSampleCount(IMFVideoSampleAllocatorCallback *iface,
         LONG *count)
 {
-    FIXME("%p, %p.\n", iface, count);
+    struct sample_allocator *allocator = impl_from_IMFVideoSampleAllocatorCallback(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, count);
+
+    EnterCriticalSection(&allocator->cs);
+    if (count)
+        *count = allocator->free_samples;
+    LeaveCriticalSection(&allocator->cs);
+
+    return S_OK;
 }
 
 static const IMFVideoSampleAllocatorCallbackVtbl sample_allocator_callback_vtbl =
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 3951b813a02..7ad011d2a09 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -1219,12 +1219,14 @@ static void test_MFCreateVideoSampleAllocator(void)
     hr = IMFVideoSampleAllocatorCallback_SetCallback(allocator_cb, NULL);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, NULL);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
     count = 10;
     hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!count, "Unexpected count %d.\n", count);
-}
+
     hr = IMFVideoSampleAllocator_UninitializeSampleAllocator(allocator);
 todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
@@ -1256,10 +1258,10 @@ todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+todo_wine
     ok(count == 1, "Unexpected count %d.\n", count);
-}
+
     sample = NULL;
     hr = IMFVideoSampleAllocator_AllocateSample(allocator, &sample);
 todo_wine
@@ -1279,10 +1281,10 @@ todo_wine
         ok(get_refcount(sample) == 3, "Unexpected refcount %u.\n", get_refcount(sample));
 
     hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
-todo_wine {
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+todo_wine
     ok(count == 4, "Unexpected count %d.\n", count);
-}
+
     if (sample)
     {
         hr = IMFSample_QueryInterface(sample, &IID_IMFDesiredSample, (void **)&unk);
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index bd6e66a5132..a63c353a4b5 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3308,7 +3308,6 @@ static void test_evr(void)
 
     sample_count = 0;
     hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_callback, &sample_count);
-todo_wine
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!sample_count, "Unexpected sample count %d.\n", sample_count);
 
From 6408aa3ab74d4740f276c0b8cc444dd6a9e6842e Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 9 Oct 2020 13:54:36 +0300
Subject: [PATCH] mf/evr: Implement GetMediaTypeCount().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c      | 9 +++++++--
 dlls/mf/tests/mf.c | 9 +++++++++
 2 files changed, 16 insertions(+), 2 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index ac3f17fa585..7567b1a7098 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -372,9 +372,14 @@ static HRESULT WINAPI video_stream_typehandler_IsMediaTypeSupported(IMFMediaType
 
 static HRESULT WINAPI video_stream_typehandler_GetMediaTypeCount(IMFMediaTypeHandler *iface, DWORD *count)
 {
-    FIXME("%p, %p.\n", iface, count);
+    TRACE("%p, %p.\n", iface, count);
 
-    return E_NOTIMPL;
+    if (!count)
+        return E_POINTER;
+
+    *count = 0;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI video_stream_typehandler_GetMediaTypeByIndex(IMFMediaTypeHandler *iface, DWORD index,
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index a63c353a4b5..db442453d6d 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3296,6 +3296,15 @@ static void test_evr(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(IsEqualGUID(&guid, &MFMediaType_Video), "Unexpected type %s.\n", wine_dbgstr_guid(&guid));
 
+    /* Supported types are not advertised. */
+    hr = IMFMediaTypeHandler_GetMediaTypeCount(type_handler, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    count = 1;
+    hr = IMFMediaTypeHandler_GetMediaTypeCount(type_handler, &count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!count, "Unexpected count %u.\n", count);
+
     IMFMediaTypeHandler_Release(type_handler);
 
     /* Stream uses an allocator. */
From 7b54ce1e07fe09b0734407db012c754c48aee4d9 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 9 Oct 2020 13:54:37 +0300
Subject: [PATCH] mf/evr: Implement GetMediaTypeByIndex().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 7567b1a7098..ebeb8899eea 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -385,9 +385,9 @@ static HRESULT WINAPI video_stream_typehandler_GetMediaTypeCount(IMFMediaTypeHan
 static HRESULT WINAPI video_stream_typehandler_GetMediaTypeByIndex(IMFMediaTypeHandler *iface, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("%p, %u, %p.\n", iface, index, type);
+    TRACE("%p, %u, %p.\n", iface, index, type);
 
-    return E_NOTIMPL;
+    return MF_E_NO_MORE_TYPES;
 }
 
 static HRESULT WINAPI video_stream_typehandler_SetCurrentMediaType(IMFMediaTypeHandler *iface, IMFMediaType *type)
From 430c179fe86dd7f9b3ddfb6ef30f6359633ef0b8 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 9 Oct 2020 13:54:38 +0300
Subject: [PATCH] mf/evr: Set stream media type to the mixer.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c      | 39 +++++++++++++++++++++++++++++++++++----
 dlls/mf/tests/mf.c | 42 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 77 insertions(+), 4 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index ebeb8899eea..087ac2a88e3 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -392,16 +392,47 @@ static HRESULT WINAPI video_stream_typehandler_GetMediaTypeByIndex(IMFMediaTypeH
 
 static HRESULT WINAPI video_stream_typehandler_SetCurrentMediaType(IMFMediaTypeHandler *iface, IMFMediaType *type)
 {
-    FIXME("%p, %p.\n", iface, type);
+    struct video_stream *stream = impl_from_IMFMediaTypeHandler(iface);
+    IMFVideoMediaType *video_type;
+    GUID subtype;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, type);
+
+    if (!type)
+        return E_POINTER;
+
+    if (!stream->parent)
+        return MF_E_STREAMSINK_REMOVED;
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    /* Mixer expects special video media type instance. */
+    if (FAILED(hr = MFCreateVideoMediaTypeFromSubtype(&subtype, &video_type)))
+        return hr;
+
+    if (SUCCEEDED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *)video_type)))
+        hr = IMFTransform_SetInputType(stream->parent->mixer, stream->id, (IMFMediaType *)video_type, 0);
+
+    IMFVideoMediaType_Release(video_type);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_stream_typehandler_GetCurrentMediaType(IMFMediaTypeHandler *iface, IMFMediaType **type)
 {
-    FIXME("%p, %p.\n", iface, type);
+    struct video_stream *stream = impl_from_IMFMediaTypeHandler(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, type);
+
+    if (!type)
+        return E_POINTER;
+
+    if (!stream->parent)
+        return MF_E_STREAMSINK_REMOVED;
+
+    return IMFTransform_GetInputCurrentType(stream->parent->mixer, stream->id, type);
 }
 
 static HRESULT WINAPI video_stream_typehandler_GetMajorType(IMFMediaTypeHandler *iface, GUID *type)
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index db442453d6d..5ffc191667b 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3237,6 +3237,7 @@ static void test_evr(void)
 {
     IMFVideoSampleAllocatorCallback *allocator_callback;
     IMFStreamSink *stream_sink, *stream_sink2;
+    IMFMediaType *media_type, *media_type2;
     IMFMediaEventGenerator *ev_generator;
     IMFVideoSampleAllocator *allocator;
     IMFMediaTypeHandler *type_handler;
@@ -3305,6 +3306,47 @@ static void test_evr(void)
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!count, "Unexpected count %u.\n", count);
 
+    hr = IMFMediaTypeHandler_GetMediaTypeByIndex(type_handler, 0, NULL);
+    ok(hr == MF_E_NO_MORE_TYPES, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaTypeHandler_GetMediaTypeByIndex(type_handler, 0, &media_type);
+    ok(hr == MF_E_NO_MORE_TYPES, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaTypeHandler_GetCurrentMediaType(type_handler, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaTypeHandler_GetCurrentMediaType(type_handler, &media_type);
+    ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaTypeHandler_SetCurrentMediaType(type_handler, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = MFCreateMediaType(&media_type);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, &MFVideoFormat_RGB32);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_SIZE, (UINT64)640 << 32 | 480);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    hr = IMFMediaType_SetUINT32(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaTypeHandler_SetCurrentMediaType(type_handler, media_type);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaTypeHandler_GetCurrentMediaType(type_handler, &media_type2);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    hr = IMFMediaType_QueryInterface(media_type2, &IID_IMFVideoMediaType, (void **)&unk);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    IUnknown_Release(unk);
+    IMFMediaType_Release(media_type2);
+
+    IMFMediaType_Release(media_type);
+
     IMFMediaTypeHandler_Release(type_handler);
 
     /* Stream uses an allocator. */
From 24c9d77cee95a778c95a03c6083739cc31989e50 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 9 Oct 2020 13:54:39 +0300
Subject: [PATCH] evr/mixer: Add support for MFT_SET_TYPE_TEST_ONLY for inputs.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/evr/mixer.c     | 12 +++++++-----
 dlls/evr/tests/evr.c | 12 ++++++++++++
 2 files changed, 19 insertions(+), 5 deletions(-)

diff --git a/dlls/evr/mixer.c b/dlls/evr/mixer.c
index 107438b1f17..54da3a9ce1c 100644
--- a/dlls/evr/mixer.c
+++ b/dlls/evr/mixer.c
@@ -611,12 +611,12 @@ static int rt_formats_sort_compare(const void *left, const void *right)
 }
 
 static HRESULT video_mixer_collect_output_types(struct video_mixer *mixer, const DXVA2_VideoDesc *video_desc,
-        IDirectXVideoProcessorService *service, unsigned int device_count, const GUID *devices)
+        IDirectXVideoProcessorService *service, unsigned int device_count, const GUID *devices, unsigned int flags)
 {
     unsigned int i, j, format_count, count;
     D3DFORMAT *rt_formats = NULL, *formats, *ptr;
+    HRESULT hr = MF_E_INVALIDMEDIATYPE;
     GUID subtype;
-    HRESULT hr;
 
     count = 0;
     for (i = 0; i < device_count; ++i)
@@ -640,7 +640,7 @@ static HRESULT video_mixer_collect_output_types(struct video_mixer *mixer, const
         }
     }
 
-    if (count)
+    if (count && !(flags & MFT_SET_TYPE_TEST_ONLY))
     {
         qsort(rt_formats, count, sizeof(*rt_formats), rt_formats_sort_compare);
 
@@ -690,7 +690,8 @@ static HRESULT WINAPI video_mixer_transform_SetInputType(IMFTransform *iface, DW
 
     EnterCriticalSection(&mixer->cs);
 
-    video_mixer_clear_types(mixer);
+    if (!(flags & MFT_SET_TYPE_TEST_ONLY))
+        video_mixer_clear_types(mixer);
 
     if (!mixer->device_manager)
         hr = MF_E_NOT_INITIALIZED;
@@ -708,7 +709,8 @@ static HRESULT WINAPI video_mixer_transform_SetInputType(IMFTransform *iface, DW
                         if (SUCCEEDED(hr = IDirectXVideoProcessorService_GetVideoProcessorDeviceGuids(service, &video_desc,
                                 &count, &guids)))
                         {
-                            if (SUCCEEDED(hr = video_mixer_collect_output_types(mixer, &video_desc, service, count, guids)))
+                            if (SUCCEEDED(hr = video_mixer_collect_output_types(mixer, &video_desc, service, count,
+                                    guids, flags)) && !(flags & MFT_SET_TYPE_TEST_ONLY))
                             {
                                 GUID subtype = { 0 };
 
diff --git a/dlls/evr/tests/evr.c b/dlls/evr/tests/evr.c
index 7ad011d2a09..175c30e8188 100644
--- a/dlls/evr/tests/evr.c
+++ b/dlls/evr/tests/evr.c
@@ -862,6 +862,9 @@ static void test_default_mixer_type_negotiation(void)
     hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
     ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFTransform_SetInputType(transform, 0, media_type, MFT_SET_TYPE_TEST_ONLY);
+    ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
+
     /* Now try with device manager. */
 
     window = create_window();
@@ -883,6 +886,9 @@ static void test_default_mixer_type_negotiation(void)
     hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
     ok(hr == DXVA2_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFTransform_SetInputType(transform, 0, media_type, MFT_SET_TYPE_TEST_ONLY);
+    ok(hr == DXVA2_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
+
     hr = IDirect3DDeviceManager9_ResetDevice(manager, device, token);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
@@ -904,6 +910,12 @@ static void test_default_mixer_type_negotiation(void)
     hr = IMFVideoMediaType_SetUINT32(video_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    hr = IMFTransform_SetInputType(transform, 0, (IMFMediaType *)video_type, MFT_SET_TYPE_TEST_ONLY);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type);
+    ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Unexpected hr %#x.\n", hr);
+
     hr = IMFTransform_SetInputType(transform, 0, (IMFMediaType *)video_type, 0);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
From e2bcf44080070436bfae9888c8e6001d511192e3 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Fri, 9 Oct 2020 13:54:40 +0300
Subject: [PATCH] mf/evr: Implement IsMediaTypeSupported().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/mf/evr.c      | 60 +++++++++++++++++++++++++++++++++++++---------
 dlls/mf/tests/mf.c | 12 ++++++++++
 2 files changed, 61 insertions(+), 11 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index 087ac2a88e3..c3548170afb 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -362,12 +362,57 @@ static ULONG WINAPI video_stream_typehandler_Release(IMFMediaTypeHandler *iface)
     return IMFStreamSink_Release(&stream->IMFStreamSink_iface);
 }
 
+/* Mixer expects special video media type instance. */
+static HRESULT video_renderer_create_video_type(IMFMediaType *media_type, IMFVideoMediaType **video_type)
+{
+    GUID subtype;
+    HRESULT hr;
+
+    *video_type = NULL;
+
+    if (FAILED(hr = IMFMediaType_GetGUID(media_type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (FAILED(hr = MFCreateVideoMediaTypeFromSubtype(&subtype, video_type)))
+        return hr;
+
+    hr = IMFMediaType_CopyAllItems(media_type, (IMFAttributes *)*video_type);
+    if (FAILED(hr))
+    {
+        IMFVideoMediaType_Release(*video_type);
+        *video_type = NULL;
+    }
+
+    return hr;
+}
+
 static HRESULT WINAPI video_stream_typehandler_IsMediaTypeSupported(IMFMediaTypeHandler *iface,
         IMFMediaType *in_type, IMFMediaType **out_type)
 {
-    FIXME("%p, %p, %p.\n", iface, in_type, out_type);
+    struct video_stream *stream = impl_from_IMFMediaTypeHandler(iface);
+    IMFVideoMediaType *video_type;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %p, %p.\n", iface, in_type, out_type);
+
+    if (!in_type)
+        return E_POINTER;
+
+    if (!stream->parent)
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(hr = video_renderer_create_video_type(in_type, &video_type)))
+        return hr;
+
+    if (SUCCEEDED(hr = IMFTransform_SetInputType(stream->parent->mixer, stream->id, (IMFMediaType *)video_type,
+            MFT_SET_TYPE_TEST_ONLY)))
+    {
+        if (out_type) *out_type = NULL;
+    }
+
+    IMFVideoMediaType_Release(video_type);
+
+    return hr;
 }
 
 static HRESULT WINAPI video_stream_typehandler_GetMediaTypeCount(IMFMediaTypeHandler *iface, DWORD *count)
@@ -394,7 +439,6 @@ static HRESULT WINAPI video_stream_typehandler_SetCurrentMediaType(IMFMediaTypeH
 {
     struct video_stream *stream = impl_from_IMFMediaTypeHandler(iface);
     IMFVideoMediaType *video_type;
-    GUID subtype;
     HRESULT hr;
 
     TRACE("%p, %p.\n", iface, type);
@@ -405,16 +449,10 @@ static HRESULT WINAPI video_stream_typehandler_SetCurrentMediaType(IMFMediaTypeH
     if (!stream->parent)
         return MF_E_STREAMSINK_REMOVED;
 
-    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
-        return hr;
-
-    /* Mixer expects special video media type instance. */
-    if (FAILED(hr = MFCreateVideoMediaTypeFromSubtype(&subtype, &video_type)))
+    if (FAILED(hr = video_renderer_create_video_type(type, &video_type)))
         return hr;
 
-    if (SUCCEEDED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *)video_type)))
-        hr = IMFTransform_SetInputType(stream->parent->mixer, stream->id, (IMFMediaType *)video_type, 0);
-
+    hr = IMFTransform_SetInputType(stream->parent->mixer, stream->id, (IMFMediaType *)video_type, 0);
     IMFVideoMediaType_Release(video_type);
 
     return hr;
diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 5ffc191667b..351a6e1edab 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -3332,9 +3332,21 @@ static void test_evr(void)
 
     hr = IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_SIZE, (UINT64)640 << 32 | 480);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, NULL, NULL);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
+
+    hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type, &media_type2);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
+
     hr = IMFMediaType_SetUINT32(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
+    media_type2 = (void *)0x1;
+    hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type, &media_type2);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!media_type2, "Unexpected media type %p.\n", media_type2);
+
     hr = IMFMediaTypeHandler_SetCurrentMediaType(type_handler, media_type);
     ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
From: Akihiro Sagawa <sagawa.aki@gmail.com>
Subject: [PATCH] winegstreamer: Color matrix conversions are needed for YUV -> RGB conversion and vice versa.
Message-Id: <20201011235026.9015.375B48EC@gmail.com>
Date: Sun, 11 Oct 2020 23:52:21 +0900


Otherwise, for instance, we get a strange color image when viewing an MPEG
movie with RGB32 video renderer.
Fixes a regression introduced by fd25ba65e0eb9fedfb2cdfa2b7a4b16e0401dfdf.

Signed-off-by: Akihiro Sagawa <sagawa.aki@gmail.com>
---
 dlls/winegstreamer/gstdemux.c | 30 ++++++++++++++++++++++++++----
 1 file changed, 26 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/gstdemux.c b/dlls/winegstreamer/gstdemux.c
index 6279c2c28c..734767f281 100644
--- a/dlls/winegstreamer/gstdemux.c
+++ b/dlls/winegstreamer/gstdemux.c
@@ -77,7 +77,7 @@ struct gstdemux_source
     IQualityControl IQualityControl_iface;
 
     GstPad *their_src, *post_sink, *post_src, *my_sink;
-    GstElement *flip;
+    GstElement *flip, *vconv;
     HANDLE caps_event, eos_event;
     GstSegment *segment;
     SourceSeeking seek;
@@ -1044,9 +1044,6 @@ static void init_new_decoded_pad(GstElement *bin, GstPad *pad, struct gstdemux *
             goto out;
         }
 
-        /* Avoid expensive color matrix conversions. */
-        gst_util_set_object_arg(G_OBJECT(vconv2), "matrix-mode", "none");
-
         /* The bin takes ownership of these elements. */
         gst_bin_add(GST_BIN(This->container), deinterlace);
         gst_element_sync_state_with_parent(deinterlace);
@@ -1064,6 +1061,7 @@ static void init_new_decoded_pad(GstElement *bin, GstPad *pad, struct gstdemux *
         pin->post_sink = gst_element_get_static_pad(deinterlace, "sink");
         pin->post_src = gst_element_get_static_pad(vconv2, "src");
         pin->flip = flip;
+        pin->vconv = vconv2;
     }
     else if (!strcmp(typename, "audio/x-raw"))
     {
@@ -2125,6 +2123,25 @@ static HRESULT source_get_media_type(struct strmbase_pin *iface, unsigned int in
     return filter->source_get_media_type(pin, index, mt);
 }
 
+static BOOL is_compatible_video_color_space(GstPad *pad1, GstPad *pad2)
+{
+    GstCaps *caps1, *caps2;
+    BOOL ret = FALSE;
+
+    caps1 = gst_pad_get_current_caps(pad1);
+    caps2 = gst_pad_get_current_caps(pad2);
+    if (caps1 && caps2)
+    {
+        GstVideoInfo vinfo1, vinfo2;
+        if (gst_video_info_from_caps(&vinfo1, caps1) && gst_video_info_from_caps(&vinfo2, caps2))
+            ret = (((GST_VIDEO_FORMAT_INFO_IS_YUV(&vinfo1) && GST_VIDEO_FORMAT_INFO_IS_YUV(&vinfo2)))
+                   || (GST_VIDEO_FORMAT_INFO_IS_RGB(&vinfo1) && GST_VIDEO_FORMAT_INFO_IS_RGB(&vinfo2)));
+    }
+    gst_caps_unref(caps1);
+    gst_caps_unref(caps2);
+    return ret;
+}
+
 static HRESULT WINAPI GSTOutPin_DecideBufferSize(struct strmbase_source *iface,
         IMemAllocator *allocator, ALLOCATOR_PROPERTIES *props)
 {
@@ -2140,6 +2157,11 @@ static HRESULT WINAPI GSTOutPin_DecideBufferSize(struct strmbase_source *iface,
         gst_util_set_object_arg(G_OBJECT(pin->flip), "method",
                 (format->bmiHeader.biCompression == BI_RGB
                 || format->bmiHeader.biCompression == BI_BITFIELDS) ? "vertical-flip" : "none");
+
+        /* Avoid expensive color matrix conversions if we can. */
+        if (pin->vconv && is_compatible_video_color_space(pin->their_src, pin->my_sink))
+            gst_util_set_object_arg(G_OBJECT(pin->vconv), "matrix-mode", "none");
+
     }
     else if (IsEqualGUID(&pin->pin.pin.mt.formattype, &FORMAT_WaveFormatEx)
             && (IsEqualGUID(&pin->pin.pin.mt.subtype, &MEDIASUBTYPE_PCM)
